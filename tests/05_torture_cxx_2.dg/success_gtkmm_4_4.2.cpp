/*
<testinfo>
test_generator=05_torture_cxx_2.dg/mercurium
</testinfo>
*/

extern const int gtkmm_major_version;
extern const int gtkmm_minor_version;
extern const int gtkmm_micro_version;
typedef int ptrdiff_t;
typedef unsigned int size_t;
namespace std
{
  using ::ptrdiff_t;
  using ::size_t;
}
namespace __gnu_debug_def { }
namespace __gnu_debug
{
  using namespace __gnu_debug_def;
}
extern "C" {
extern void *memcpy (void *__restrict __dest,
       __const void *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern void *memmove (void *__dest, __const void *__src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern void *memccpy (void *__restrict __dest, __const void *__restrict __src,
        int __c, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern void *memset (void *__s, int __c, size_t __n) throw () __attribute__ ((__nonnull__ (1)));
extern int memcmp (__const void *__s1, __const void *__s2, size_t __n)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
extern void *memchr (__const void *__s, int __c, size_t __n)
      throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern void *rawmemchr (__const void *__s, int __c)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern void *memrchr (__const void *__s, int __c, size_t __n)
      throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern char *strcpy (char *__restrict __dest, __const char *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern char *strncpy (char *__restrict __dest,
        __const char *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern char *strcat (char *__restrict __dest, __const char *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern char *strncat (char *__restrict __dest, __const char *__restrict __src,
        size_t __n) throw () __attribute__ ((__nonnull__ (1, 2)));
extern int strcmp (__const char *__s1, __const char *__s2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
extern int strncmp (__const char *__s1, __const char *__s2, size_t __n)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
extern int strcoll (__const char *__s1, __const char *__s2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
extern size_t strxfrm (char *__restrict __dest,
         __const char *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (2)));
typedef struct __locale_struct
{
  struct locale_data *__locales[13];
  const unsigned short int *__ctype_b;
  const int *__ctype_tolower;
  const int *__ctype_toupper;
  const char *__names[13];
} *__locale_t;
extern int strcoll_l (__const char *__s1, __const char *__s2, __locale_t __l)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));
extern size_t strxfrm_l (char *__dest, __const char *__src, size_t __n,
    __locale_t __l) throw () __attribute__ ((__nonnull__ (2, 4)));
extern char *strdup (__const char *__s)
     throw () __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));
extern char *strndup (__const char *__string, size_t __n)
     throw () __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));
extern char *strchr (__const char *__s, int __c)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern char *strrchr (__const char *__s, int __c)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern char *strchrnul (__const char *__s, int __c)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern size_t strcspn (__const char *__s, __const char *__reject)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
extern size_t strspn (__const char *__s, __const char *__accept)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
extern char *strpbrk (__const char *__s, __const char *__accept)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
extern char *strstr (__const char *__haystack, __const char *__needle)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
extern char *strtok (char *__restrict __s, __const char *__restrict __delim)
     throw () __attribute__ ((__nonnull__ (2)));
extern char *__strtok_r (char *__restrict __s,
    __const char *__restrict __delim,
    char **__restrict __save_ptr)
     throw () __attribute__ ((__nonnull__ (2, 3)));
extern char *strtok_r (char *__restrict __s, __const char *__restrict __delim,
         char **__restrict __save_ptr)
     throw () __attribute__ ((__nonnull__ (2, 3)));
extern char *strcasestr (__const char *__haystack, __const char *__needle)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
extern void *memmem (__const void *__haystack, size_t __haystacklen,
       __const void *__needle, size_t __needlelen)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 3)));
extern void *__mempcpy (void *__restrict __dest,
   __const void *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern void *mempcpy (void *__restrict __dest,
        __const void *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern size_t strlen (__const char *__s)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern size_t strnlen (__const char *__string, size_t __maxlen)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern char *strerror (int __errnum) throw ();
extern char *strerror_r (int __errnum, char *__buf, size_t __buflen)
     throw () __attribute__ ((__nonnull__ (2)));
extern char *strerror_l (int __errnum, __locale_t __l) throw ();
extern void __bzero (void *__s, size_t __n) throw () __attribute__ ((__nonnull__ (1)));
extern void bcopy (__const void *__src, void *__dest, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern void bzero (void *__s, size_t __n) throw () __attribute__ ((__nonnull__ (1)));
extern int bcmp (__const void *__s1, __const void *__s2, size_t __n)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
extern char *index (__const char *__s, int __c)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern char *rindex (__const char *__s, int __c)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern int ffs (int __i) throw () __attribute__ ((__const__));
extern int ffsl (long int __l) throw () __attribute__ ((__const__));
__extension__ extern int ffsll (long long int __ll)
     throw () __attribute__ ((__const__));
extern int strcasecmp (__const char *__s1, __const char *__s2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
extern int strncasecmp (__const char *__s1, __const char *__s2, size_t __n)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
extern int strcasecmp_l (__const char *__s1, __const char *__s2,
    __locale_t __loc)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));
extern int strncasecmp_l (__const char *__s1, __const char *__s2,
     size_t __n, __locale_t __loc)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 4)));
extern char *strsep (char **__restrict __stringp,
       __const char *__restrict __delim)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern int strverscmp (__const char *__s1, __const char *__s2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
extern char *strsignal (int __sig) throw ();
extern char *__stpcpy (char *__restrict __dest, __const char *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern char *stpcpy (char *__restrict __dest, __const char *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern char *__stpncpy (char *__restrict __dest,
   __const char *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern char *stpncpy (char *__restrict __dest,
        __const char *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern char *strfry (char *__string) throw () __attribute__ ((__nonnull__ (1)));
extern void *memfrob (void *__s, size_t __n) throw () __attribute__ ((__nonnull__ (1)));
extern char *basename (__const char *__filename) throw () __attribute__ ((__nonnull__ (1)));
}
namespace std
{
  using ::memcpy;
  using ::memmove;
  using ::strcpy;
  using ::strncpy;
  using ::strcat;
  using ::strncat;
  using ::memcmp;
  using ::strcmp;
  using ::strcoll;
  using ::strncmp;
  using ::strxfrm;
  using ::strcspn;
  using ::strspn;
  using ::strtok;
  using ::memset;
  using ::strerror;
  using ::strlen;
  using ::memchr;
  inline void*
  memchr(void* __p, int __c, size_t __n)
  { return memchr(const_cast<const void*>(__p), __c, __n); }
  using ::strchr;
  inline char*
  strchr(char* __s1, int __n)
  { return __builtin_strchr(const_cast<const char*>(__s1), __n); }
  using ::strpbrk;
  inline char*
  strpbrk(char* __s1, const char* __s2)
  { return __builtin_strpbrk(const_cast<const char*>(__s1), __s2); }
  using ::strrchr;
  inline char*
  strrchr(char* __s1, int __n)
  { return __builtin_strrchr(const_cast<const char*>(__s1), __n); }
  using ::strstr;
  inline char*
  strstr(char* __s1, const char* __s2)
  { return __builtin_strstr(const_cast<const char*>(__s1), __s2); }
}
extern "C" {
union wait
  {
    int w_status;
    struct
      {
 unsigned int __w_termsig:7;
 unsigned int __w_coredump:1;
 unsigned int __w_retcode:8;
 unsigned int:16;
      } __wait_terminated;
    struct
      {
 unsigned int __w_stopval:8;
 unsigned int __w_stopsig:8;
 unsigned int:16;
      } __wait_stopped;
  };
typedef struct
  {
    int quot;
    int rem;
  } div_t;
typedef struct
  {
    long int quot;
    long int rem;
  } ldiv_t;
__extension__ typedef struct
  {
    long long int quot;
    long long int rem;
  } lldiv_t;
extern size_t __ctype_get_mb_cur_max (void) throw () ;
extern double atof (__const char *__nptr)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;
extern int atoi (__const char *__nptr)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;
extern long int atol (__const char *__nptr)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;
__extension__ extern long long int atoll (__const char *__nptr)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;
extern double strtod (__const char *__restrict __nptr,
        char **__restrict __endptr)
     throw () __attribute__ ((__nonnull__ (1))) ;
extern float strtof (__const char *__restrict __nptr,
       char **__restrict __endptr) throw () __attribute__ ((__nonnull__ (1))) ;
extern long double strtold (__const char *__restrict __nptr,
       char **__restrict __endptr)
     throw () __attribute__ ((__nonnull__ (1))) ;
extern long int strtol (__const char *__restrict __nptr,
   char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1))) ;
extern unsigned long int strtoul (__const char *__restrict __nptr,
      char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1))) ;
__extension__
extern long long int strtoq (__const char *__restrict __nptr,
        char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1))) ;
__extension__
extern unsigned long long int strtouq (__const char *__restrict __nptr,
           char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1))) ;
__extension__
extern long long int strtoll (__const char *__restrict __nptr,
         char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1))) ;
__extension__
extern unsigned long long int strtoull (__const char *__restrict __nptr,
     char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1))) ;
extern long int strtol_l (__const char *__restrict __nptr,
     char **__restrict __endptr, int __base,
     __locale_t __loc) throw () __attribute__ ((__nonnull__ (1, 4))) ;
extern unsigned long int strtoul_l (__const char *__restrict __nptr,
        char **__restrict __endptr,
        int __base, __locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 4))) ;
__extension__
extern long long int strtoll_l (__const char *__restrict __nptr,
    char **__restrict __endptr, int __base,
    __locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 4))) ;
__extension__
extern unsigned long long int strtoull_l (__const char *__restrict __nptr,
       char **__restrict __endptr,
       int __base, __locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 4))) ;
extern double strtod_l (__const char *__restrict __nptr,
   char **__restrict __endptr, __locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3))) ;
extern float strtof_l (__const char *__restrict __nptr,
         char **__restrict __endptr, __locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3))) ;
extern long double strtold_l (__const char *__restrict __nptr,
         char **__restrict __endptr,
         __locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3))) ;
extern char *l64a (long int __n) throw () ;
extern long int a64l (__const char *__s)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;
extern "C" {
typedef unsigned char __u_char;
typedef unsigned short int __u_short;
typedef unsigned int __u_int;
typedef unsigned long int __u_long;
typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef signed short int __int16_t;
typedef unsigned short int __uint16_t;
typedef signed int __int32_t;
typedef unsigned int __uint32_t;
__extension__ typedef signed long long int __int64_t;
__extension__ typedef unsigned long long int __uint64_t;
__extension__ typedef long long int __quad_t;
__extension__ typedef unsigned long long int __u_quad_t;
__extension__ typedef __u_quad_t __dev_t;
__extension__ typedef unsigned int __uid_t;
__extension__ typedef unsigned int __gid_t;
__extension__ typedef unsigned long int __ino_t;
__extension__ typedef __u_quad_t __ino64_t;
__extension__ typedef unsigned int __mode_t;
__extension__ typedef unsigned int __nlink_t;
__extension__ typedef long int __off_t;
__extension__ typedef __quad_t __off64_t;
__extension__ typedef int __pid_t;
__extension__ typedef struct { int __val[2]; } __fsid_t;
__extension__ typedef long int __clock_t;
__extension__ typedef unsigned long int __rlim_t;
__extension__ typedef __u_quad_t __rlim64_t;
__extension__ typedef unsigned int __id_t;
__extension__ typedef long int __time_t;
__extension__ typedef unsigned int __useconds_t;
__extension__ typedef long int __suseconds_t;
__extension__ typedef int __daddr_t;
__extension__ typedef long int __swblk_t;
__extension__ typedef int __key_t;
__extension__ typedef int __clockid_t;
__extension__ typedef void * __timer_t;
__extension__ typedef long int __blksize_t;
__extension__ typedef long int __blkcnt_t;
__extension__ typedef __quad_t __blkcnt64_t;
__extension__ typedef unsigned long int __fsblkcnt_t;
__extension__ typedef __u_quad_t __fsblkcnt64_t;
__extension__ typedef unsigned long int __fsfilcnt_t;
__extension__ typedef __u_quad_t __fsfilcnt64_t;
__extension__ typedef int __ssize_t;
typedef __off64_t __loff_t;
typedef __quad_t *__qaddr_t;
typedef char *__caddr_t;
__extension__ typedef int __intptr_t;
__extension__ typedef unsigned int __socklen_t;
typedef __u_char u_char;
typedef __u_short u_short;
typedef __u_int u_int;
typedef __u_long u_long;
typedef __quad_t quad_t;
typedef __u_quad_t u_quad_t;
typedef __fsid_t fsid_t;
typedef __loff_t loff_t;
typedef __ino_t ino_t;
typedef __ino64_t ino64_t;
typedef __dev_t dev_t;
typedef __gid_t gid_t;
typedef __mode_t mode_t;
typedef __nlink_t nlink_t;
typedef __uid_t uid_t;
typedef __off_t off_t;
typedef __off64_t off64_t;
typedef __pid_t pid_t;
typedef __id_t id_t;
typedef __ssize_t ssize_t;
typedef __daddr_t daddr_t;
typedef __caddr_t caddr_t;
typedef __key_t key_t;
typedef __clock_t clock_t;
typedef __time_t time_t;
typedef __clockid_t clockid_t;
typedef __timer_t timer_t;
typedef __useconds_t useconds_t;
typedef __suseconds_t suseconds_t;
typedef unsigned long int ulong;
typedef unsigned short int ushort;
typedef unsigned int uint;
typedef int int8_t __attribute__ ((__mode__ (__QI__)));
typedef int int16_t __attribute__ ((__mode__ (__HI__)));
typedef int int32_t __attribute__ ((__mode__ (__SI__)));
typedef int int64_t __attribute__ ((__mode__ (__DI__)));
typedef unsigned int u_int8_t __attribute__ ((__mode__ (__QI__)));
typedef unsigned int u_int16_t __attribute__ ((__mode__ (__HI__)));
typedef unsigned int u_int32_t __attribute__ ((__mode__ (__SI__)));
typedef unsigned int u_int64_t __attribute__ ((__mode__ (__DI__)));
typedef int register_t __attribute__ ((__mode__ (__word__)));
typedef int __sig_atomic_t;
typedef struct
  {
    unsigned long int __val[(1024 / (8 * sizeof (unsigned long int)))];
  } __sigset_t;
typedef __sigset_t sigset_t;
struct timespec
  {
    __time_t tv_sec;
    long int tv_nsec;
  };
struct timeval
  {
    __time_t tv_sec;
    __suseconds_t tv_usec;
  };
typedef long int __fd_mask;
typedef struct
  {
    __fd_mask fds_bits[1024 / (8 * sizeof (__fd_mask))];
  } fd_set;
typedef __fd_mask fd_mask;
extern "C" {
extern int select (int __nfds, fd_set *__restrict __readfds,
     fd_set *__restrict __writefds,
     fd_set *__restrict __exceptfds,
     struct timeval *__restrict __timeout);
extern int pselect (int __nfds, fd_set *__restrict __readfds,
      fd_set *__restrict __writefds,
      fd_set *__restrict __exceptfds,
      const struct timespec *__restrict __timeout,
      const __sigset_t *__restrict __sigmask);
}
__extension__
extern unsigned int gnu_dev_major (unsigned long long int __dev)
     throw ();
__extension__
extern unsigned int gnu_dev_minor (unsigned long long int __dev)
     throw ();
__extension__
extern unsigned long long int gnu_dev_makedev (unsigned int __major,
            unsigned int __minor)
     throw ();
typedef __blksize_t blksize_t;
typedef __blkcnt_t blkcnt_t;
typedef __fsblkcnt_t fsblkcnt_t;
typedef __fsfilcnt_t fsfilcnt_t;
typedef __blkcnt64_t blkcnt64_t;
typedef __fsblkcnt64_t fsblkcnt64_t;
typedef __fsfilcnt64_t fsfilcnt64_t;
typedef unsigned long int pthread_t;
typedef union
{
  char __size[36];
  long int __align;
} pthread_attr_t;
typedef struct __pthread_internal_slist
{
  struct __pthread_internal_slist *__next;
} __pthread_slist_t;
typedef union
{
  struct __pthread_mutex_s
  {
    int __lock;
    unsigned int __count;
    int __owner;
    int __kind;
    unsigned int __nusers;
    __extension__ union
    {
      int __spins;
      __pthread_slist_t __list;
    };
  } __data;
  char __size[24];
  long int __align;
} pthread_mutex_t;
typedef union
{
  char __size[4];
  long int __align;
} pthread_mutexattr_t;
typedef union
{
  struct
  {
    int __lock;
    unsigned int __futex;
    __extension__ unsigned long long int __total_seq;
    __extension__ unsigned long long int __wakeup_seq;
    __extension__ unsigned long long int __woken_seq;
    void *__mutex;
    unsigned int __nwaiters;
    unsigned int __broadcast_seq;
  } __data;
  char __size[48];
  __extension__ long long int __align;
} pthread_cond_t;
typedef union
{
  char __size[4];
  long int __align;
} pthread_condattr_t;
typedef unsigned int pthread_key_t;
typedef int pthread_once_t;
typedef union
{
  struct
  {
    int __lock;
    unsigned int __nr_readers;
    unsigned int __readers_wakeup;
    unsigned int __writer_wakeup;
    unsigned int __nr_readers_queued;
    unsigned int __nr_writers_queued;
    unsigned char __flags;
    unsigned char __shared;
    unsigned char __pad1;
    unsigned char __pad2;
    int __writer;
  } __data;
  char __size[32];
  long int __align;
} pthread_rwlock_t;
typedef union
{
  char __size[8];
  long int __align;
} pthread_rwlockattr_t;
typedef volatile int pthread_spinlock_t;
typedef union
{
  char __size[20];
  long int __align;
} pthread_barrier_t;
typedef union
{
  char __size[4];
  int __align;
} pthread_barrierattr_t;
}
extern long int random (void) throw ();
extern void srandom (unsigned int __seed) throw ();
extern char *initstate (unsigned int __seed, char *__statebuf,
   size_t __statelen) throw () __attribute__ ((__nonnull__ (2)));
extern char *setstate (char *__statebuf) throw () __attribute__ ((__nonnull__ (1)));
struct random_data
  {
    int32_t *fptr;
    int32_t *rptr;
    int32_t *state;
    int rand_type;
    int rand_deg;
    int rand_sep;
    int32_t *end_ptr;
  };
extern int random_r (struct random_data *__restrict __buf,
       int32_t *__restrict __result) throw () __attribute__ ((__nonnull__ (1, 2)));
extern int srandom_r (unsigned int __seed, struct random_data *__buf)
     throw () __attribute__ ((__nonnull__ (2)));
extern int initstate_r (unsigned int __seed, char *__restrict __statebuf,
   size_t __statelen,
   struct random_data *__restrict __buf)
     throw () __attribute__ ((__nonnull__ (2, 4)));
extern int setstate_r (char *__restrict __statebuf,
         struct random_data *__restrict __buf)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern int rand (void) throw ();
extern void srand (unsigned int __seed) throw ();
extern int rand_r (unsigned int *__seed) throw ();
extern double drand48 (void) throw ();
extern double erand48 (unsigned short int __xsubi[3]) throw () __attribute__ ((__nonnull__ (1)));
extern long int lrand48 (void) throw ();
extern long int nrand48 (unsigned short int __xsubi[3])
     throw () __attribute__ ((__nonnull__ (1)));
extern long int mrand48 (void) throw ();
extern long int jrand48 (unsigned short int __xsubi[3])
     throw () __attribute__ ((__nonnull__ (1)));
extern void srand48 (long int __seedval) throw ();
extern unsigned short int *seed48 (unsigned short int __seed16v[3])
     throw () __attribute__ ((__nonnull__ (1)));
extern void lcong48 (unsigned short int __param[7]) throw () __attribute__ ((__nonnull__ (1)));
struct drand48_data
  {
    unsigned short int __x[3];
    unsigned short int __old_x[3];
    unsigned short int __c;
    unsigned short int __init;
    unsigned long long int __a;
  };
extern int drand48_r (struct drand48_data *__restrict __buffer,
        double *__restrict __result) throw () __attribute__ ((__nonnull__ (1, 2)));
extern int erand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        double *__restrict __result) throw () __attribute__ ((__nonnull__ (1, 2)));
extern int lrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern int nrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern int mrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern int jrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern int srand48_r (long int __seedval, struct drand48_data *__buffer)
     throw () __attribute__ ((__nonnull__ (2)));
extern int seed48_r (unsigned short int __seed16v[3],
       struct drand48_data *__buffer) throw () __attribute__ ((__nonnull__ (1, 2)));
extern int lcong48_r (unsigned short int __param[7],
        struct drand48_data *__buffer)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern void *malloc (size_t __size) throw () __attribute__ ((__malloc__)) ;
extern void *calloc (size_t __nmemb, size_t __size)
     throw () __attribute__ ((__malloc__)) ;
extern void *realloc (void *__ptr, size_t __size)
     throw () __attribute__ ((__warn_unused_result__));
extern void free (void *__ptr) throw ();
extern void cfree (void *__ptr) throw ();
extern "C" {
extern void *alloca (size_t __size) throw ();
}
extern void *valloc (size_t __size) throw () __attribute__ ((__malloc__)) ;
extern int posix_memalign (void **__memptr, size_t __alignment, size_t __size)
     throw () __attribute__ ((__nonnull__ (1))) ;
extern void abort (void) throw () __attribute__ ((__noreturn__));
extern int atexit (void (*__func) (void)) throw () __attribute__ ((__nonnull__ (1)));
extern int on_exit (void (*__func) (int __status, void *__arg), void *__arg)
     throw () __attribute__ ((__nonnull__ (1)));
extern void exit (int __status) throw () __attribute__ ((__noreturn__));
extern void _Exit (int __status) throw () __attribute__ ((__noreturn__));
extern char *getenv (__const char *__name) throw () __attribute__ ((__nonnull__ (1))) ;
extern char *__secure_getenv (__const char *__name)
     throw () __attribute__ ((__nonnull__ (1))) ;
extern int putenv (char *__string) throw () __attribute__ ((__nonnull__ (1)));
extern int setenv (__const char *__name, __const char *__value, int __replace)
     throw () __attribute__ ((__nonnull__ (2)));
extern int unsetenv (__const char *__name) throw ();
extern int clearenv (void) throw ();
extern char *mktemp (char *__template) throw () __attribute__ ((__nonnull__ (1))) ;
extern int mkstemp (char *__template) __attribute__ ((__nonnull__ (1))) ;
extern int mkstemp64 (char *__template) __attribute__ ((__nonnull__ (1))) ;
extern char *mkdtemp (char *__template) throw () __attribute__ ((__nonnull__ (1))) ;
extern int mkostemp (char *__template, int __flags) __attribute__ ((__nonnull__ (1))) ;
extern int mkostemp64 (char *__template, int __flags) __attribute__ ((__nonnull__ (1))) ;
extern int system (__const char *__command) ;
extern char *canonicalize_file_name (__const char *__name)
     throw () __attribute__ ((__nonnull__ (1))) ;
extern char *realpath (__const char *__restrict __name,
         char *__restrict __resolved) throw () ;
typedef int (*__compar_fn_t) (__const void *, __const void *);
typedef __compar_fn_t comparison_fn_t;
extern void *bsearch (__const void *__key, __const void *__base,
        size_t __nmemb, size_t __size, __compar_fn_t __compar)
     __attribute__ ((__nonnull__ (1, 2, 5))) ;
extern void qsort (void *__base, size_t __nmemb, size_t __size,
     __compar_fn_t __compar) __attribute__ ((__nonnull__ (1, 4)));
extern int abs (int __x) throw () __attribute__ ((__const__)) ;
extern long int labs (long int __x) throw () __attribute__ ((__const__)) ;
__extension__ extern long long int llabs (long long int __x)
     throw () __attribute__ ((__const__)) ;
extern div_t div (int __numer, int __denom)
     throw () __attribute__ ((__const__)) ;
extern ldiv_t ldiv (long int __numer, long int __denom)
     throw () __attribute__ ((__const__)) ;
__extension__ extern lldiv_t lldiv (long long int __numer,
        long long int __denom)
     throw () __attribute__ ((__const__)) ;
extern char *ecvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) throw () __attribute__ ((__nonnull__ (3, 4))) ;
extern char *fcvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) throw () __attribute__ ((__nonnull__ (3, 4))) ;
extern char *gcvt (double __value, int __ndigit, char *__buf)
     throw () __attribute__ ((__nonnull__ (3))) ;
extern char *qecvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     throw () __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qfcvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     throw () __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qgcvt (long double __value, int __ndigit, char *__buf)
     throw () __attribute__ ((__nonnull__ (3))) ;
extern int ecvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) throw () __attribute__ ((__nonnull__ (3, 4, 5)));
extern int fcvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) throw () __attribute__ ((__nonnull__ (3, 4, 5)));
extern int qecvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     throw () __attribute__ ((__nonnull__ (3, 4, 5)));
extern int qfcvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     throw () __attribute__ ((__nonnull__ (3, 4, 5)));
extern int mblen (__const char *__s, size_t __n) throw () ;
extern int mbtowc (wchar_t *__restrict __pwc,
     __const char *__restrict __s, size_t __n) throw () ;
extern int wctomb (char *__s, wchar_t __wchar) throw () ;
extern size_t mbstowcs (wchar_t *__restrict __pwcs,
   __const char *__restrict __s, size_t __n) throw ();
extern size_t wcstombs (char *__restrict __s,
   __const wchar_t *__restrict __pwcs, size_t __n)
     throw ();
extern int rpmatch (__const char *__response) throw () __attribute__ ((__nonnull__ (1))) ;
extern int getsubopt (char **__restrict __optionp,
        char *__const *__restrict __tokens,
        char **__restrict __valuep)
     throw () __attribute__ ((__nonnull__ (1, 2, 3))) ;
extern void setkey (__const char *__key) throw () __attribute__ ((__nonnull__ (1)));
extern int posix_openpt (int __oflag) ;
extern int grantpt (int __fd) throw ();
extern int unlockpt (int __fd) throw ();
extern char *ptsname (int __fd) throw () ;
extern int ptsname_r (int __fd, char *__buf, size_t __buflen)
     throw () __attribute__ ((__nonnull__ (2)));
extern int getpt (void);
extern int getloadavg (double __loadavg[], int __nelem)
     throw () __attribute__ ((__nonnull__ (1)));
}
namespace std
{
  using ::div_t;
  using ::ldiv_t;
  using ::abort;
  using ::abs;
  using ::atexit;
  using ::atof;
  using ::atoi;
  using ::atol;
  using ::bsearch;
  using ::calloc;
  using ::div;
  using ::exit;
  using ::free;
  using ::getenv;
  using ::labs;
  using ::ldiv;
  using ::malloc;
  using ::mblen;
  using ::mbstowcs;
  using ::mbtowc;
  using ::qsort;
  using ::rand;
  using ::realloc;
  using ::srand;
  using ::strtod;
  using ::strtol;
  using ::strtoul;
  using ::system;
  using ::wcstombs;
  using ::wctomb;
  inline long
  abs(long __i) { return labs(__i); }
  inline ldiv_t
  div(long __i, long __j) { return ldiv(__i, __j); }
}
namespace __gnu_cxx
{
  using ::lldiv_t;
  using ::_Exit;
  inline long long
  abs(long long __x) { return __x >= 0 ? __x : -__x; }
  using ::llabs;
  inline lldiv_t
  div(long long __n, long long __d)
  { lldiv_t __q; __q.quot = __n / __d; __q.rem = __n % __d; return __q; }
  using ::lldiv;
  using ::atoll;
  using ::strtoll;
  using ::strtoull;
  using ::strtof;
  using ::strtold;
}
namespace std
{
  using ::__gnu_cxx::lldiv_t;
  using ::__gnu_cxx::_Exit;
  using ::__gnu_cxx::abs;
  using ::__gnu_cxx::llabs;
  using ::__gnu_cxx::div;
  using ::__gnu_cxx::lldiv;
  using ::__gnu_cxx::atoll;
  using ::__gnu_cxx::strtof;
  using ::__gnu_cxx::strtoll;
  using ::__gnu_cxx::strtoull;
  using ::__gnu_cxx::strtold;
}
extern "C" {
struct _IO_FILE;
typedef struct _IO_FILE FILE;
typedef struct _IO_FILE __FILE;
typedef struct
{
  int __count;
  union
  {
    unsigned int __wch;
    char __wchb[4];
  } __value;
} __mbstate_t;
typedef struct
{
  __off_t __pos;
  __mbstate_t __state;
} _G_fpos_t;
typedef struct
{
  __off64_t __pos;
  __mbstate_t __state;
} _G_fpos64_t;
typedef int _G_int16_t __attribute__ ((__mode__ (__HI__)));
typedef int _G_int32_t __attribute__ ((__mode__ (__SI__)));
typedef unsigned int _G_uint16_t __attribute__ ((__mode__ (__HI__)));
typedef unsigned int _G_uint32_t __attribute__ ((__mode__ (__SI__)));
typedef __builtin_va_list __gnuc_va_list;
struct _IO_jump_t; struct _IO_FILE;
typedef void _IO_lock_t;
struct _IO_marker {
  struct _IO_marker *_next;
  struct _IO_FILE *_sbuf;
  int _pos;
};
enum __codecvt_result
{
  __codecvt_ok,
  __codecvt_partial,
  __codecvt_error,
  __codecvt_noconv
};
struct _IO_FILE {
  int _flags;
  char* _IO_read_ptr;
  char* _IO_read_end;
  char* _IO_read_base;
  char* _IO_write_base;
  char* _IO_write_ptr;
  char* _IO_write_end;
  char* _IO_buf_base;
  char* _IO_buf_end;
  char *_IO_save_base;
  char *_IO_backup_base;
  char *_IO_save_end;
  struct _IO_marker *_markers;
  struct _IO_FILE *_chain;
  int _fileno;
  int _flags2;
  __off_t _old_offset;
  unsigned short _cur_column;
  signed char _vtable_offset;
  char _shortbuf[1];
  _IO_lock_t *_lock;
  __off64_t _offset;
  void *__pad1;
  void *__pad2;
  void *__pad3;
  void *__pad4;
  size_t __pad5;
  int _mode;
  char _unused2[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (size_t)];
};
struct _IO_FILE_plus;
extern struct _IO_FILE_plus _IO_2_1_stdin_;
extern struct _IO_FILE_plus _IO_2_1_stdout_;
extern struct _IO_FILE_plus _IO_2_1_stderr_;
typedef __ssize_t __io_read_fn (void *__cookie, char *__buf, size_t __nbytes);
typedef __ssize_t __io_write_fn (void *__cookie, __const char *__buf,
     size_t __n);
typedef int __io_seek_fn (void *__cookie, __off64_t *__pos, int __w);
typedef int __io_close_fn (void *__cookie);
typedef __io_read_fn cookie_read_function_t;
typedef __io_write_fn cookie_write_function_t;
typedef __io_seek_fn cookie_seek_function_t;
typedef __io_close_fn cookie_close_function_t;
typedef struct
{
  __io_read_fn *read;
  __io_write_fn *write;
  __io_seek_fn *seek;
  __io_close_fn *close;
} _IO_cookie_io_functions_t;
typedef _IO_cookie_io_functions_t cookie_io_functions_t;
struct _IO_cookie_file;
extern void _IO_cookie_init (struct _IO_cookie_file *__cfile, int __read_write,
        void *__cookie, _IO_cookie_io_functions_t __fns);
extern "C" {
extern int __underflow (_IO_FILE *);
extern int __uflow (_IO_FILE *);
extern int __overflow (_IO_FILE *, int);
extern int _IO_getc (_IO_FILE *__fp);
extern int _IO_putc (int __c, _IO_FILE *__fp);
extern int _IO_feof (_IO_FILE *__fp) throw ();
extern int _IO_ferror (_IO_FILE *__fp) throw ();
extern int _IO_peekc_locked (_IO_FILE *__fp);
extern void _IO_flockfile (_IO_FILE *) throw ();
extern void _IO_funlockfile (_IO_FILE *) throw ();
extern int _IO_ftrylockfile (_IO_FILE *) throw ();
extern int _IO_vfscanf (_IO_FILE * __restrict, const char * __restrict,
   __gnuc_va_list, int *__restrict);
extern int _IO_vfprintf (_IO_FILE *__restrict, const char *__restrict,
    __gnuc_va_list);
extern __ssize_t _IO_padn (_IO_FILE *, int, __ssize_t);
extern size_t _IO_sgetn (_IO_FILE *, void *, size_t);
extern __off64_t _IO_seekoff (_IO_FILE *, __off64_t, int, int);
extern __off64_t _IO_seekpos (_IO_FILE *, __off64_t, int);
extern void _IO_free_backup_area (_IO_FILE *) throw ();
}
typedef __gnuc_va_list va_list;
typedef _G_fpos_t fpos_t;
typedef _G_fpos64_t fpos64_t;
extern struct _IO_FILE *stdin;
extern struct _IO_FILE *stdout;
extern struct _IO_FILE *stderr;
extern int remove (__const char *__filename) throw ();
extern int rename (__const char *__old, __const char *__new) throw ();
extern int renameat (int __oldfd, __const char *__old, int __newfd,
       __const char *__new) throw ();
extern FILE *tmpfile (void) ;
extern FILE *tmpfile64 (void) ;
extern char *tmpnam (char *__s) throw () ;
extern char *tmpnam_r (char *__s) throw () ;
extern char *tempnam (__const char *__dir, __const char *__pfx)
     throw () __attribute__ ((__malloc__)) ;
extern int fclose (FILE *__stream);
extern int fflush (FILE *__stream);
extern int fflush_unlocked (FILE *__stream);
extern int fcloseall (void);
extern FILE *fopen (__const char *__restrict __filename,
      __const char *__restrict __modes) ;
extern FILE *freopen (__const char *__restrict __filename,
        __const char *__restrict __modes,
        FILE *__restrict __stream) ;
extern FILE *fopen64 (__const char *__restrict __filename,
        __const char *__restrict __modes) ;
extern FILE *freopen64 (__const char *__restrict __filename,
   __const char *__restrict __modes,
   FILE *__restrict __stream) ;
extern FILE *fdopen (int __fd, __const char *__modes) throw () ;
extern FILE *fopencookie (void *__restrict __magic_cookie,
     __const char *__restrict __modes,
     _IO_cookie_io_functions_t __io_funcs) throw () ;
extern FILE *fmemopen (void *__s, size_t __len, __const char *__modes)
  throw () ;
extern FILE *open_memstream (char **__bufloc, size_t *__sizeloc) throw () ;
extern void setbuf (FILE *__restrict __stream, char *__restrict __buf) throw ();
extern int setvbuf (FILE *__restrict __stream, char *__restrict __buf,
      int __modes, size_t __n) throw ();
extern void setbuffer (FILE *__restrict __stream, char *__restrict __buf,
         size_t __size) throw ();
extern void setlinebuf (FILE *__stream) throw ();
extern int fprintf (FILE *__restrict __stream,
      __const char *__restrict __format, ...);
extern int printf (__const char *__restrict __format, ...);
extern int sprintf (char *__restrict __s,
      __const char *__restrict __format, ...) throw ();
extern int vfprintf (FILE *__restrict __s, __const char *__restrict __format,
       __gnuc_va_list __arg);
extern int vprintf (__const char *__restrict __format, __gnuc_va_list __arg);
extern int vsprintf (char *__restrict __s, __const char *__restrict __format,
       __gnuc_va_list __arg) throw ();
extern int snprintf (char *__restrict __s, size_t __maxlen,
       __const char *__restrict __format, ...)
     throw () __attribute__ ((__format__ (__printf__, 3, 4)));
extern int vsnprintf (char *__restrict __s, size_t __maxlen,
        __const char *__restrict __format, __gnuc_va_list __arg)
     throw () __attribute__ ((__format__ (__printf__, 3, 0)));
extern int vasprintf (char **__restrict __ptr, __const char *__restrict __f,
        __gnuc_va_list __arg)
     throw () __attribute__ ((__format__ (__printf__, 2, 0))) ;
extern int __asprintf (char **__restrict __ptr,
         __const char *__restrict __fmt, ...)
     throw () __attribute__ ((__format__ (__printf__, 2, 3))) ;
extern int asprintf (char **__restrict __ptr,
       __const char *__restrict __fmt, ...)
     throw () __attribute__ ((__format__ (__printf__, 2, 3))) ;
extern int vdprintf (int __fd, __const char *__restrict __fmt,
       __gnuc_va_list __arg)
     __attribute__ ((__format__ (__printf__, 2, 0)));
extern int dprintf (int __fd, __const char *__restrict __fmt, ...)
     __attribute__ ((__format__ (__printf__, 2, 3)));
extern int fscanf (FILE *__restrict __stream,
     __const char *__restrict __format, ...) ;
extern int scanf (__const char *__restrict __format, ...) ;
extern int sscanf (__const char *__restrict __s,
     __const char *__restrict __format, ...) throw ();
extern int vfscanf (FILE *__restrict __s, __const char *__restrict __format,
      __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 2, 0))) ;
extern int vscanf (__const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 1, 0))) ;
extern int vsscanf (__const char *__restrict __s,
      __const char *__restrict __format, __gnuc_va_list __arg)
     throw () __attribute__ ((__format__ (__scanf__, 2, 0)));
extern int fgetc (FILE *__stream);
extern int getc (FILE *__stream);
extern int getchar (void);
extern int getc_unlocked (FILE *__stream);
extern int getchar_unlocked (void);
extern int fgetc_unlocked (FILE *__stream);
extern int fputc (int __c, FILE *__stream);
extern int putc (int __c, FILE *__stream);
extern int putchar (int __c);
extern int fputc_unlocked (int __c, FILE *__stream);
extern int putc_unlocked (int __c, FILE *__stream);
extern int putchar_unlocked (int __c);
extern int getw (FILE *__stream);
extern int putw (int __w, FILE *__stream);
extern char *fgets (char *__restrict __s, int __n, FILE *__restrict __stream)
     ;
extern char *gets (char *__s) ;
extern char *fgets_unlocked (char *__restrict __s, int __n,
        FILE *__restrict __stream) ;
extern __ssize_t __getdelim (char **__restrict __lineptr,
          size_t *__restrict __n, int __delimiter,
          FILE *__restrict __stream) ;
extern __ssize_t getdelim (char **__restrict __lineptr,
        size_t *__restrict __n, int __delimiter,
        FILE *__restrict __stream) ;
extern __ssize_t getline (char **__restrict __lineptr,
       size_t *__restrict __n,
       FILE *__restrict __stream) ;
extern int fputs (__const char *__restrict __s, FILE *__restrict __stream);
extern int puts (__const char *__s);
extern int ungetc (int __c, FILE *__stream);
extern size_t fread (void *__restrict __ptr, size_t __size,
       size_t __n, FILE *__restrict __stream) ;
extern size_t fwrite (__const void *__restrict __ptr, size_t __size,
        size_t __n, FILE *__restrict __s) ;
extern int fputs_unlocked (__const char *__restrict __s,
      FILE *__restrict __stream);
extern size_t fread_unlocked (void *__restrict __ptr, size_t __size,
         size_t __n, FILE *__restrict __stream) ;
extern size_t fwrite_unlocked (__const void *__restrict __ptr, size_t __size,
          size_t __n, FILE *__restrict __stream) ;
extern int fseek (FILE *__stream, long int __off, int __whence);
extern long int ftell (FILE *__stream) ;
extern void rewind (FILE *__stream);
extern int fseeko (FILE *__stream, __off_t __off, int __whence);
extern __off_t ftello (FILE *__stream) ;
extern int fgetpos (FILE *__restrict __stream, fpos_t *__restrict __pos);
extern int fsetpos (FILE *__stream, __const fpos_t *__pos);
extern int fseeko64 (FILE *__stream, __off64_t __off, int __whence);
extern __off64_t ftello64 (FILE *__stream) ;
extern int fgetpos64 (FILE *__restrict __stream, fpos64_t *__restrict __pos);
extern int fsetpos64 (FILE *__stream, __const fpos64_t *__pos);
extern void clearerr (FILE *__stream) throw ();
extern int feof (FILE *__stream) throw () ;
extern int ferror (FILE *__stream) throw () ;
extern void clearerr_unlocked (FILE *__stream) throw ();
extern int feof_unlocked (FILE *__stream) throw () ;
extern int ferror_unlocked (FILE *__stream) throw () ;
extern void perror (__const char *__s);
extern int sys_nerr;
extern __const char *__const sys_errlist[];
extern int _sys_nerr;
extern __const char *__const _sys_errlist[];
extern int fileno (FILE *__stream) throw () ;
extern int fileno_unlocked (FILE *__stream) throw () ;
extern FILE *popen (__const char *__command, __const char *__modes) ;
extern int pclose (FILE *__stream);
extern char *ctermid (char *__s) throw ();
extern char *cuserid (char *__s);
struct obstack;
extern int obstack_printf (struct obstack *__restrict __obstack,
      __const char *__restrict __format, ...)
     throw () __attribute__ ((__format__ (__printf__, 2, 3)));
extern int obstack_vprintf (struct obstack *__restrict __obstack,
       __const char *__restrict __format,
       __gnuc_va_list __args)
     throw () __attribute__ ((__format__ (__printf__, 2, 0)));
extern void flockfile (FILE *__stream) throw ();
extern int ftrylockfile (FILE *__stream) throw () ;
extern void funlockfile (FILE *__stream) throw ();
}
namespace std
{
  using ::FILE;
  using ::fpos_t;
  using ::clearerr;
  using ::fclose;
  using ::feof;
  using ::ferror;
  using ::fflush;
  using ::fgetc;
  using ::fgetpos;
  using ::fgets;
  using ::fopen;
  using ::fprintf;
  using ::fputc;
  using ::fputs;
  using ::fread;
  using ::freopen;
  using ::fscanf;
  using ::fseek;
  using ::fsetpos;
  using ::ftell;
  using ::fwrite;
  using ::getc;
  using ::getchar;
  using ::gets;
  using ::perror;
  using ::printf;
  using ::putc;
  using ::putchar;
  using ::puts;
  using ::remove;
  using ::rename;
  using ::rewind;
  using ::scanf;
  using ::setbuf;
  using ::setvbuf;
  using ::sprintf;
  using ::sscanf;
  using ::tmpfile;
  using ::tmpnam;
  using ::ungetc;
  using ::vfprintf;
  using ::vprintf;
  using ::vsprintf;
}
namespace __gnu_cxx
{
  using ::snprintf;
  using ::vfscanf;
  using ::vscanf;
  using ::vsnprintf;
  using ::vsscanf;
}
namespace std
{
  using __gnu_cxx::snprintf;
  using __gnu_cxx::vfscanf;
  using __gnu_cxx::vscanf;
  using __gnu_cxx::vsnprintf;
  using __gnu_cxx::vsscanf;
}
enum
{
  __LC_CTYPE = 0,
  __LC_NUMERIC = 1,
  __LC_TIME = 2,
  __LC_COLLATE = 3,
  __LC_MONETARY = 4,
  __LC_MESSAGES = 5,
  __LC_ALL = 6,
  __LC_PAPER = 7,
  __LC_NAME = 8,
  __LC_ADDRESS = 9,
  __LC_TELEPHONE = 10,
  __LC_MEASUREMENT = 11,
  __LC_IDENTIFICATION = 12
};
extern "C" {
struct lconv
{
  char *decimal_point;
  char *thousands_sep;
  char *grouping;
  char *int_curr_symbol;
  char *currency_symbol;
  char *mon_decimal_point;
  char *mon_thousands_sep;
  char *mon_grouping;
  char *positive_sign;
  char *negative_sign;
  char int_frac_digits;
  char frac_digits;
  char p_cs_precedes;
  char p_sep_by_space;
  char n_cs_precedes;
  char n_sep_by_space;
  char p_sign_posn;
  char n_sign_posn;
  char int_p_cs_precedes;
  char int_p_sep_by_space;
  char int_n_cs_precedes;
  char int_n_sep_by_space;
  char int_p_sign_posn;
  char int_n_sign_posn;
};
extern char *setlocale (int __category, __const char *__locale) throw ();
extern struct lconv *localeconv (void) throw ();
typedef __locale_t locale_t;
extern __locale_t newlocale (int __category_mask, __const char *__locale,
        __locale_t __base) throw ();
extern __locale_t duplocale (__locale_t __dataset) throw ();
extern void freelocale (__locale_t __dataset) throw ();
extern __locale_t uselocale (__locale_t __dataset) throw ();
}
namespace std
{
  using ::lconv;
  using ::setlocale;
  using ::localeconv;
}
extern "C" {
typedef void *nl_catd;
typedef int nl_item;
extern nl_catd catopen (__const char *__cat_name, int __flag) __attribute__ ((__nonnull__ (1)));
extern char *catgets (nl_catd __catalog, int __set, int __number,
        __const char *__string) throw () __attribute__ ((__nonnull__ (1)));
extern int catclose (nl_catd __catalog) throw () __attribute__ ((__nonnull__ (1)));
}
extern "C" {
enum
{
  ABDAY_1 = (((__LC_TIME) << 16) | (0)),
  ABDAY_2,
  ABDAY_3,
  ABDAY_4,
  ABDAY_5,
  ABDAY_6,
  ABDAY_7,
  DAY_1,
  DAY_2,
  DAY_3,
  DAY_4,
  DAY_5,
  DAY_6,
  DAY_7,
  ABMON_1,
  ABMON_2,
  ABMON_3,
  ABMON_4,
  ABMON_5,
  ABMON_6,
  ABMON_7,
  ABMON_8,
  ABMON_9,
  ABMON_10,
  ABMON_11,
  ABMON_12,
  MON_1,
  MON_2,
  MON_3,
  MON_4,
  MON_5,
  MON_6,
  MON_7,
  MON_8,
  MON_9,
  MON_10,
  MON_11,
  MON_12,
  AM_STR,
  PM_STR,
  D_T_FMT,
  D_FMT,
  T_FMT,
  T_FMT_AMPM,
  ERA,
  __ERA_YEAR,
  ERA_D_FMT,
  ALT_DIGITS,
  ERA_D_T_FMT,
  ERA_T_FMT,
  _NL_TIME_ERA_NUM_ENTRIES,
  _NL_TIME_ERA_ENTRIES,
  _NL_WABDAY_1,
  _NL_WABDAY_2,
  _NL_WABDAY_3,
  _NL_WABDAY_4,
  _NL_WABDAY_5,
  _NL_WABDAY_6,
  _NL_WABDAY_7,
  _NL_WDAY_1,
  _NL_WDAY_2,
  _NL_WDAY_3,
  _NL_WDAY_4,
  _NL_WDAY_5,
  _NL_WDAY_6,
  _NL_WDAY_7,
  _NL_WABMON_1,
  _NL_WABMON_2,
  _NL_WABMON_3,
  _NL_WABMON_4,
  _NL_WABMON_5,
  _NL_WABMON_6,
  _NL_WABMON_7,
  _NL_WABMON_8,
  _NL_WABMON_9,
  _NL_WABMON_10,
  _NL_WABMON_11,
  _NL_WABMON_12,
  _NL_WMON_1,
  _NL_WMON_2,
  _NL_WMON_3,
  _NL_WMON_4,
  _NL_WMON_5,
  _NL_WMON_6,
  _NL_WMON_7,
  _NL_WMON_8,
  _NL_WMON_9,
  _NL_WMON_10,
  _NL_WMON_11,
  _NL_WMON_12,
  _NL_WAM_STR,
  _NL_WPM_STR,
  _NL_WD_T_FMT,
  _NL_WD_FMT,
  _NL_WT_FMT,
  _NL_WT_FMT_AMPM,
  _NL_WERA_YEAR,
  _NL_WERA_D_FMT,
  _NL_WALT_DIGITS,
  _NL_WERA_D_T_FMT,
  _NL_WERA_T_FMT,
  _NL_TIME_WEEK_NDAYS,
  _NL_TIME_WEEK_1STDAY,
  _NL_TIME_WEEK_1STWEEK,
  _NL_TIME_FIRST_WEEKDAY,
  _NL_TIME_FIRST_WORKDAY,
  _NL_TIME_CAL_DIRECTION,
  _NL_TIME_TIMEZONE,
  _DATE_FMT,
  _NL_W_DATE_FMT,
  _NL_TIME_CODESET,
  _NL_NUM_LC_TIME,
  _NL_COLLATE_NRULES = (((__LC_COLLATE) << 16) | (0)),
  _NL_COLLATE_RULESETS,
  _NL_COLLATE_TABLEMB,
  _NL_COLLATE_WEIGHTMB,
  _NL_COLLATE_EXTRAMB,
  _NL_COLLATE_INDIRECTMB,
  _NL_COLLATE_GAP1,
  _NL_COLLATE_GAP2,
  _NL_COLLATE_GAP3,
  _NL_COLLATE_TABLEWC,
  _NL_COLLATE_WEIGHTWC,
  _NL_COLLATE_EXTRAWC,
  _NL_COLLATE_INDIRECTWC,
  _NL_COLLATE_SYMB_HASH_SIZEMB,
  _NL_COLLATE_SYMB_TABLEMB,
  _NL_COLLATE_SYMB_EXTRAMB,
  _NL_COLLATE_COLLSEQMB,
  _NL_COLLATE_COLLSEQWC,
  _NL_COLLATE_CODESET,
  _NL_NUM_LC_COLLATE,
  _NL_CTYPE_CLASS = (((__LC_CTYPE) << 16) | (0)),
  _NL_CTYPE_TOUPPER,
  _NL_CTYPE_GAP1,
  _NL_CTYPE_TOLOWER,
  _NL_CTYPE_GAP2,
  _NL_CTYPE_CLASS32,
  _NL_CTYPE_GAP3,
  _NL_CTYPE_GAP4,
  _NL_CTYPE_GAP5,
  _NL_CTYPE_GAP6,
  _NL_CTYPE_CLASS_NAMES,
  _NL_CTYPE_MAP_NAMES,
  _NL_CTYPE_WIDTH,
  _NL_CTYPE_MB_CUR_MAX,
  _NL_CTYPE_CODESET_NAME,
  CODESET = _NL_CTYPE_CODESET_NAME,
  _NL_CTYPE_TOUPPER32,
  _NL_CTYPE_TOLOWER32,
  _NL_CTYPE_CLASS_OFFSET,
  _NL_CTYPE_MAP_OFFSET,
  _NL_CTYPE_INDIGITS_MB_LEN,
  _NL_CTYPE_INDIGITS0_MB,
  _NL_CTYPE_INDIGITS1_MB,
  _NL_CTYPE_INDIGITS2_MB,
  _NL_CTYPE_INDIGITS3_MB,
  _NL_CTYPE_INDIGITS4_MB,
  _NL_CTYPE_INDIGITS5_MB,
  _NL_CTYPE_INDIGITS6_MB,
  _NL_CTYPE_INDIGITS7_MB,
  _NL_CTYPE_INDIGITS8_MB,
  _NL_CTYPE_INDIGITS9_MB,
  _NL_CTYPE_INDIGITS_WC_LEN,
  _NL_CTYPE_INDIGITS0_WC,
  _NL_CTYPE_INDIGITS1_WC,
  _NL_CTYPE_INDIGITS2_WC,
  _NL_CTYPE_INDIGITS3_WC,
  _NL_CTYPE_INDIGITS4_WC,
  _NL_CTYPE_INDIGITS5_WC,
  _NL_CTYPE_INDIGITS6_WC,
  _NL_CTYPE_INDIGITS7_WC,
  _NL_CTYPE_INDIGITS8_WC,
  _NL_CTYPE_INDIGITS9_WC,
  _NL_CTYPE_OUTDIGIT0_MB,
  _NL_CTYPE_OUTDIGIT1_MB,
  _NL_CTYPE_OUTDIGIT2_MB,
  _NL_CTYPE_OUTDIGIT3_MB,
  _NL_CTYPE_OUTDIGIT4_MB,
  _NL_CTYPE_OUTDIGIT5_MB,
  _NL_CTYPE_OUTDIGIT6_MB,
  _NL_CTYPE_OUTDIGIT7_MB,
  _NL_CTYPE_OUTDIGIT8_MB,
  _NL_CTYPE_OUTDIGIT9_MB,
  _NL_CTYPE_OUTDIGIT0_WC,
  _NL_CTYPE_OUTDIGIT1_WC,
  _NL_CTYPE_OUTDIGIT2_WC,
  _NL_CTYPE_OUTDIGIT3_WC,
  _NL_CTYPE_OUTDIGIT4_WC,
  _NL_CTYPE_OUTDIGIT5_WC,
  _NL_CTYPE_OUTDIGIT6_WC,
  _NL_CTYPE_OUTDIGIT7_WC,
  _NL_CTYPE_OUTDIGIT8_WC,
  _NL_CTYPE_OUTDIGIT9_WC,
  _NL_CTYPE_TRANSLIT_TAB_SIZE,
  _NL_CTYPE_TRANSLIT_FROM_IDX,
  _NL_CTYPE_TRANSLIT_FROM_TBL,
  _NL_CTYPE_TRANSLIT_TO_IDX,
  _NL_CTYPE_TRANSLIT_TO_TBL,
  _NL_CTYPE_TRANSLIT_DEFAULT_MISSING_LEN,
  _NL_CTYPE_TRANSLIT_DEFAULT_MISSING,
  _NL_CTYPE_TRANSLIT_IGNORE_LEN,
  _NL_CTYPE_TRANSLIT_IGNORE,
  _NL_CTYPE_MAP_TO_NONASCII,
  _NL_CTYPE_EXTRA_MAP_1,
  _NL_CTYPE_EXTRA_MAP_2,
  _NL_CTYPE_EXTRA_MAP_3,
  _NL_CTYPE_EXTRA_MAP_4,
  _NL_CTYPE_EXTRA_MAP_5,
  _NL_CTYPE_EXTRA_MAP_6,
  _NL_CTYPE_EXTRA_MAP_7,
  _NL_CTYPE_EXTRA_MAP_8,
  _NL_CTYPE_EXTRA_MAP_9,
  _NL_CTYPE_EXTRA_MAP_10,
  _NL_CTYPE_EXTRA_MAP_11,
  _NL_CTYPE_EXTRA_MAP_12,
  _NL_CTYPE_EXTRA_MAP_13,
  _NL_CTYPE_EXTRA_MAP_14,
  _NL_NUM_LC_CTYPE,
  __INT_CURR_SYMBOL = (((__LC_MONETARY) << 16) | (0)),
  __CURRENCY_SYMBOL,
  __MON_DECIMAL_POINT,
  __MON_THOUSANDS_SEP,
  __MON_GROUPING,
  __POSITIVE_SIGN,
  __NEGATIVE_SIGN,
  __INT_FRAC_DIGITS,
  __FRAC_DIGITS,
  __P_CS_PRECEDES,
  __P_SEP_BY_SPACE,
  __N_CS_PRECEDES,
  __N_SEP_BY_SPACE,
  __P_SIGN_POSN,
  __N_SIGN_POSN,
  _NL_MONETARY_CRNCYSTR,
  __INT_P_CS_PRECEDES,
  __INT_P_SEP_BY_SPACE,
  __INT_N_CS_PRECEDES,
  __INT_N_SEP_BY_SPACE,
  __INT_P_SIGN_POSN,
  __INT_N_SIGN_POSN,
  _NL_MONETARY_DUO_INT_CURR_SYMBOL,
  _NL_MONETARY_DUO_CURRENCY_SYMBOL,
  _NL_MONETARY_DUO_INT_FRAC_DIGITS,
  _NL_MONETARY_DUO_FRAC_DIGITS,
  _NL_MONETARY_DUO_P_CS_PRECEDES,
  _NL_MONETARY_DUO_P_SEP_BY_SPACE,
  _NL_MONETARY_DUO_N_CS_PRECEDES,
  _NL_MONETARY_DUO_N_SEP_BY_SPACE,
  _NL_MONETARY_DUO_INT_P_CS_PRECEDES,
  _NL_MONETARY_DUO_INT_P_SEP_BY_SPACE,
  _NL_MONETARY_DUO_INT_N_CS_PRECEDES,
  _NL_MONETARY_DUO_INT_N_SEP_BY_SPACE,
  _NL_MONETARY_DUO_P_SIGN_POSN,
  _NL_MONETARY_DUO_N_SIGN_POSN,
  _NL_MONETARY_DUO_INT_P_SIGN_POSN,
  _NL_MONETARY_DUO_INT_N_SIGN_POSN,
  _NL_MONETARY_UNO_VALID_FROM,
  _NL_MONETARY_UNO_VALID_TO,
  _NL_MONETARY_DUO_VALID_FROM,
  _NL_MONETARY_DUO_VALID_TO,
  _NL_MONETARY_CONVERSION_RATE,
  _NL_MONETARY_DECIMAL_POINT_WC,
  _NL_MONETARY_THOUSANDS_SEP_WC,
  _NL_MONETARY_CODESET,
  _NL_NUM_LC_MONETARY,
  __DECIMAL_POINT = (((__LC_NUMERIC) << 16) | (0)),
  RADIXCHAR = __DECIMAL_POINT,
  __THOUSANDS_SEP,
  THOUSEP = __THOUSANDS_SEP,
  __GROUPING,
  _NL_NUMERIC_DECIMAL_POINT_WC,
  _NL_NUMERIC_THOUSANDS_SEP_WC,
  _NL_NUMERIC_CODESET,
  _NL_NUM_LC_NUMERIC,
  __YESEXPR = (((__LC_MESSAGES) << 16) | (0)),
  __NOEXPR,
  __YESSTR,
  __NOSTR,
  _NL_MESSAGES_CODESET,
  _NL_NUM_LC_MESSAGES,
  _NL_PAPER_HEIGHT = (((__LC_PAPER) << 16) | (0)),
  _NL_PAPER_WIDTH,
  _NL_PAPER_CODESET,
  _NL_NUM_LC_PAPER,
  _NL_NAME_NAME_FMT = (((__LC_NAME) << 16) | (0)),
  _NL_NAME_NAME_GEN,
  _NL_NAME_NAME_MR,
  _NL_NAME_NAME_MRS,
  _NL_NAME_NAME_MISS,
  _NL_NAME_NAME_MS,
  _NL_NAME_CODESET,
  _NL_NUM_LC_NAME,
  _NL_ADDRESS_POSTAL_FMT = (((__LC_ADDRESS) << 16) | (0)),
  _NL_ADDRESS_COUNTRY_NAME,
  _NL_ADDRESS_COUNTRY_POST,
  _NL_ADDRESS_COUNTRY_AB2,
  _NL_ADDRESS_COUNTRY_AB3,
  _NL_ADDRESS_COUNTRY_CAR,
  _NL_ADDRESS_COUNTRY_NUM,
  _NL_ADDRESS_COUNTRY_ISBN,
  _NL_ADDRESS_LANG_NAME,
  _NL_ADDRESS_LANG_AB,
  _NL_ADDRESS_LANG_TERM,
  _NL_ADDRESS_LANG_LIB,
  _NL_ADDRESS_CODESET,
  _NL_NUM_LC_ADDRESS,
  _NL_TELEPHONE_TEL_INT_FMT = (((__LC_TELEPHONE) << 16) | (0)),
  _NL_TELEPHONE_TEL_DOM_FMT,
  _NL_TELEPHONE_INT_SELECT,
  _NL_TELEPHONE_INT_PREFIX,
  _NL_TELEPHONE_CODESET,
  _NL_NUM_LC_TELEPHONE,
  _NL_MEASUREMENT_MEASUREMENT = (((__LC_MEASUREMENT) << 16) | (0)),
  _NL_MEASUREMENT_CODESET,
  _NL_NUM_LC_MEASUREMENT,
  _NL_IDENTIFICATION_TITLE = (((__LC_IDENTIFICATION) << 16) | (0)),
  _NL_IDENTIFICATION_SOURCE,
  _NL_IDENTIFICATION_ADDRESS,
  _NL_IDENTIFICATION_CONTACT,
  _NL_IDENTIFICATION_EMAIL,
  _NL_IDENTIFICATION_TEL,
  _NL_IDENTIFICATION_FAX,
  _NL_IDENTIFICATION_LANGUAGE,
  _NL_IDENTIFICATION_TERRITORY,
  _NL_IDENTIFICATION_AUDIENCE,
  _NL_IDENTIFICATION_APPLICATION,
  _NL_IDENTIFICATION_ABBREVIATION,
  _NL_IDENTIFICATION_REVISION,
  _NL_IDENTIFICATION_DATE,
  _NL_IDENTIFICATION_CATEGORY,
  _NL_IDENTIFICATION_CODESET,
  _NL_NUM_LC_IDENTIFICATION,
  _NL_NUM
};
extern char *nl_langinfo (nl_item __item) throw ();
extern char *nl_langinfo_l (nl_item __item, __locale_t l);
}
extern "C" {
typedef void *iconv_t;
extern iconv_t iconv_open (__const char *__tocode, __const char *__fromcode);
extern size_t iconv (iconv_t __cd, char **__restrict __inbuf,
       size_t *__restrict __inbytesleft,
       char **__restrict __outbuf,
       size_t *__restrict __outbytesleft);
extern int iconv_close (iconv_t __cd);
}
extern "C" {
extern char *gettext (__const char *__msgid)
     throw () __attribute__ ((__format_arg__ (1)));
extern char *dgettext (__const char *__domainname, __const char *__msgid)
     throw () __attribute__ ((__format_arg__ (2)));
extern char *__dgettext (__const char *__domainname, __const char *__msgid)
     throw () __attribute__ ((__format_arg__ (2)));
extern char *dcgettext (__const char *__domainname,
   __const char *__msgid, int __category)
     throw () __attribute__ ((__format_arg__ (2)));
extern char *__dcgettext (__const char *__domainname,
     __const char *__msgid, int __category)
     throw () __attribute__ ((__format_arg__ (2)));
extern char *ngettext (__const char *__msgid1, __const char *__msgid2,
         unsigned long int __n)
     throw () __attribute__ ((__format_arg__ (1))) __attribute__ ((__format_arg__ (2)));
extern char *dngettext (__const char *__domainname, __const char *__msgid1,
   __const char *__msgid2, unsigned long int __n)
     throw () __attribute__ ((__format_arg__ (2))) __attribute__ ((__format_arg__ (3)));
extern char *dcngettext (__const char *__domainname, __const char *__msgid1,
    __const char *__msgid2, unsigned long int __n,
    int __category)
     throw () __attribute__ ((__format_arg__ (2))) __attribute__ ((__format_arg__ (3)));
extern char *textdomain (__const char *__domainname) throw ();
extern char *bindtextdomain (__const char *__domainname,
        __const char *__dirname) throw ();
extern char *bind_textdomain_codeset (__const char *__domainname,
          __const char *__codeset) throw ();
}
namespace __gnu_cxx
{
  extern "C" __typeof(uselocale) __uselocale;
}
namespace std
{
  typedef __locale_t __c_locale;
  template<typename _Tv>
    int
    __convert_from_v(char* __out,
       const int __size __attribute__ ((__unused__)),
       const char* __fmt,
       _Tv __v, const __c_locale& __cloc, int __prec)
    {
      __c_locale __old = __gnu_cxx::__uselocale(__cloc);
      const int __ret = std::snprintf(__out, __size, __fmt, __prec, __v);
      __gnu_cxx::__uselocale(__old);
      return __ret;
    }
}
struct sched_param
  {
    int __sched_priority;
  };
extern "C" {
extern int clone (int (*__fn) (void *__arg), void *__child_stack,
    int __flags, void *__arg, ...) throw ();
extern int unshare (int __flags) throw ();
extern int sched_getcpu (void) throw ();
}
struct __sched_param
  {
    int __sched_priority;
  };
typedef unsigned long int __cpu_mask;
typedef struct
{
  __cpu_mask __bits[1024 / (8 * sizeof (__cpu_mask))];
} cpu_set_t;
extern "C" {
extern int __sched_cpucount (size_t __setsize, const cpu_set_t *__setp)
  throw ();
extern cpu_set_t *__sched_cpualloc (size_t __count) throw () ;
extern void __sched_cpufree (cpu_set_t *__set) throw ();
}
extern "C" {
extern int sched_setparam (__pid_t __pid, __const struct sched_param *__param)
     throw ();
extern int sched_getparam (__pid_t __pid, struct sched_param *__param) throw ();
extern int sched_setscheduler (__pid_t __pid, int __policy,
          __const struct sched_param *__param) throw ();
extern int sched_getscheduler (__pid_t __pid) throw ();
extern int sched_yield (void) throw ();
extern int sched_get_priority_max (int __algorithm) throw ();
extern int sched_get_priority_min (int __algorithm) throw ();
extern int sched_rr_get_interval (__pid_t __pid, struct timespec *__t) throw ();
extern int sched_setaffinity (__pid_t __pid, size_t __cpusetsize,
         __const cpu_set_t *__cpuset) throw ();
extern int sched_getaffinity (__pid_t __pid, size_t __cpusetsize,
         cpu_set_t *__cpuset) throw ();
}
extern "C" {
struct tm
{
  int tm_sec;
  int tm_min;
  int tm_hour;
  int tm_mday;
  int tm_mon;
  int tm_year;
  int tm_wday;
  int tm_yday;
  int tm_isdst;
  long int tm_gmtoff;
  __const char *tm_zone;
};
struct itimerspec
  {
    struct timespec it_interval;
    struct timespec it_value;
  };
struct sigevent;
extern clock_t clock (void) throw ();
extern time_t time (time_t *__timer) throw ();
extern double difftime (time_t __time1, time_t __time0)
     throw () __attribute__ ((__const__));
extern time_t mktime (struct tm *__tp) throw ();
extern size_t strftime (char *__restrict __s, size_t __maxsize,
   __const char *__restrict __format,
   __const struct tm *__restrict __tp) throw ();
extern char *strptime (__const char *__restrict __s,
         __const char *__restrict __fmt, struct tm *__tp)
     throw ();
extern size_t strftime_l (char *__restrict __s, size_t __maxsize,
     __const char *__restrict __format,
     __const struct tm *__restrict __tp,
     __locale_t __loc) throw ();
extern char *strptime_l (__const char *__restrict __s,
    __const char *__restrict __fmt, struct tm *__tp,
    __locale_t __loc) throw ();
extern struct tm *gmtime (__const time_t *__timer) throw ();
extern struct tm *localtime (__const time_t *__timer) throw ();
extern struct tm *gmtime_r (__const time_t *__restrict __timer,
       struct tm *__restrict __tp) throw ();
extern struct tm *localtime_r (__const time_t *__restrict __timer,
          struct tm *__restrict __tp) throw ();
extern char *asctime (__const struct tm *__tp) throw ();
extern char *ctime (__const time_t *__timer) throw ();
extern char *asctime_r (__const struct tm *__restrict __tp,
   char *__restrict __buf) throw ();
extern char *ctime_r (__const time_t *__restrict __timer,
        char *__restrict __buf) throw ();
extern char *__tzname[2];
extern int __daylight;
extern long int __timezone;
extern char *tzname[2];
extern void tzset (void) throw ();
extern int daylight;
extern long int timezone;
extern int stime (__const time_t *__when) throw ();
extern time_t timegm (struct tm *__tp) throw ();
extern time_t timelocal (struct tm *__tp) throw ();
extern int dysize (int __year) throw () __attribute__ ((__const__));
extern int nanosleep (__const struct timespec *__requested_time,
        struct timespec *__remaining);
extern int clock_getres (clockid_t __clock_id, struct timespec *__res) throw ();
extern int clock_gettime (clockid_t __clock_id, struct timespec *__tp) throw ();
extern int clock_settime (clockid_t __clock_id, __const struct timespec *__tp)
     throw ();
extern int clock_nanosleep (clockid_t __clock_id, int __flags,
       __const struct timespec *__req,
       struct timespec *__rem);
extern int clock_getcpuclockid (pid_t __pid, clockid_t *__clock_id) throw ();
extern int timer_create (clockid_t __clock_id,
    struct sigevent *__restrict __evp,
    timer_t *__restrict __timerid) throw ();
extern int timer_delete (timer_t __timerid) throw ();
extern int timer_settime (timer_t __timerid, int __flags,
     __const struct itimerspec *__restrict __value,
     struct itimerspec *__restrict __ovalue) throw ();
extern int timer_gettime (timer_t __timerid, struct itimerspec *__value)
     throw ();
extern int timer_getoverrun (timer_t __timerid) throw ();
extern int getdate_err;
extern struct tm *getdate (__const char *__string);
extern int getdate_r (__const char *__restrict __string,
        struct tm *__restrict __resbufp);
}
extern "C" {
}
typedef int __jmp_buf[6];
enum
{
  PTHREAD_CREATE_JOINABLE,
  PTHREAD_CREATE_DETACHED
};
enum
{
  PTHREAD_MUTEX_TIMED_NP,
  PTHREAD_MUTEX_RECURSIVE_NP,
  PTHREAD_MUTEX_ERRORCHECK_NP,
  PTHREAD_MUTEX_ADAPTIVE_NP
  ,
  PTHREAD_MUTEX_NORMAL = PTHREAD_MUTEX_TIMED_NP,
  PTHREAD_MUTEX_RECURSIVE = PTHREAD_MUTEX_RECURSIVE_NP,
  PTHREAD_MUTEX_ERRORCHECK = PTHREAD_MUTEX_ERRORCHECK_NP,
  PTHREAD_MUTEX_DEFAULT = PTHREAD_MUTEX_NORMAL
  , PTHREAD_MUTEX_FAST_NP = PTHREAD_MUTEX_TIMED_NP
};
enum
{
  PTHREAD_MUTEX_STALLED_NP,
  PTHREAD_MUTEX_ROBUST_NP
};
enum
{
  PTHREAD_PRIO_NONE,
  PTHREAD_PRIO_INHERIT,
  PTHREAD_PRIO_PROTECT
};
enum
{
  PTHREAD_RWLOCK_PREFER_READER_NP,
  PTHREAD_RWLOCK_PREFER_WRITER_NP,
  PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP,
  PTHREAD_RWLOCK_DEFAULT_NP = PTHREAD_RWLOCK_PREFER_READER_NP
};
enum
{
  PTHREAD_INHERIT_SCHED,
  PTHREAD_EXPLICIT_SCHED
};
enum
{
  PTHREAD_SCOPE_SYSTEM,
  PTHREAD_SCOPE_PROCESS
};
enum
{
  PTHREAD_PROCESS_PRIVATE,
  PTHREAD_PROCESS_SHARED
};
struct _pthread_cleanup_buffer
{
  void (*__routine) (void *);
  void *__arg;
  int __canceltype;
  struct _pthread_cleanup_buffer *__prev;
};
enum
{
  PTHREAD_CANCEL_ENABLE,
  PTHREAD_CANCEL_DISABLE
};
enum
{
  PTHREAD_CANCEL_DEFERRED,
  PTHREAD_CANCEL_ASYNCHRONOUS
};
extern "C" {
extern int pthread_create (pthread_t *__restrict __newthread,
      __const pthread_attr_t *__restrict __attr,
      void *(*__start_routine) (void *),
      void *__restrict __arg) throw () __attribute__ ((__nonnull__ (1, 3)));
extern void pthread_exit (void *__retval) __attribute__ ((__noreturn__));
extern int pthread_join (pthread_t __th, void **__thread_return);
extern int pthread_tryjoin_np (pthread_t __th, void **__thread_return) throw ();
extern int pthread_timedjoin_np (pthread_t __th, void **__thread_return,
     __const struct timespec *__abstime);
extern int pthread_detach (pthread_t __th) throw ();
extern pthread_t pthread_self (void) throw () __attribute__ ((__const__));
extern int pthread_equal (pthread_t __thread1, pthread_t __thread2) throw ();
extern int pthread_attr_init (pthread_attr_t *__attr) throw () __attribute__ ((__nonnull__ (1)));
extern int pthread_attr_destroy (pthread_attr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));
extern int pthread_attr_getdetachstate (__const pthread_attr_t *__attr,
     int *__detachstate)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern int pthread_attr_setdetachstate (pthread_attr_t *__attr,
     int __detachstate)
     throw () __attribute__ ((__nonnull__ (1)));
extern int pthread_attr_getguardsize (__const pthread_attr_t *__attr,
          size_t *__guardsize)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern int pthread_attr_setguardsize (pthread_attr_t *__attr,
          size_t __guardsize)
     throw () __attribute__ ((__nonnull__ (1)));
extern int pthread_attr_getschedparam (__const pthread_attr_t *__restrict
           __attr,
           struct sched_param *__restrict __param)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern int pthread_attr_setschedparam (pthread_attr_t *__restrict __attr,
           __const struct sched_param *__restrict
           __param) throw () __attribute__ ((__nonnull__ (1, 2)));
extern int pthread_attr_getschedpolicy (__const pthread_attr_t *__restrict
     __attr, int *__restrict __policy)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern int pthread_attr_setschedpolicy (pthread_attr_t *__attr, int __policy)
     throw () __attribute__ ((__nonnull__ (1)));
extern int pthread_attr_getinheritsched (__const pthread_attr_t *__restrict
      __attr, int *__restrict __inherit)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern int pthread_attr_setinheritsched (pthread_attr_t *__attr,
      int __inherit)
     throw () __attribute__ ((__nonnull__ (1)));
extern int pthread_attr_getscope (__const pthread_attr_t *__restrict __attr,
      int *__restrict __scope)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern int pthread_attr_setscope (pthread_attr_t *__attr, int __scope)
     throw () __attribute__ ((__nonnull__ (1)));
extern int pthread_attr_getstackaddr (__const pthread_attr_t *__restrict
          __attr, void **__restrict __stackaddr)
     throw () __attribute__ ((__nonnull__ (1, 2))) __attribute__ ((__deprecated__));
extern int pthread_attr_setstackaddr (pthread_attr_t *__attr,
          void *__stackaddr)
     throw () __attribute__ ((__nonnull__ (1))) __attribute__ ((__deprecated__));
extern int pthread_attr_getstacksize (__const pthread_attr_t *__restrict
          __attr, size_t *__restrict __stacksize)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern int pthread_attr_setstacksize (pthread_attr_t *__attr,
          size_t __stacksize)
     throw () __attribute__ ((__nonnull__ (1)));
extern int pthread_attr_getstack (__const pthread_attr_t *__restrict __attr,
      void **__restrict __stackaddr,
      size_t *__restrict __stacksize)
     throw () __attribute__ ((__nonnull__ (1, 2, 3)));
extern int pthread_attr_setstack (pthread_attr_t *__attr, void *__stackaddr,
      size_t __stacksize) throw () __attribute__ ((__nonnull__ (1)));
extern int pthread_attr_setaffinity_np (pthread_attr_t *__attr,
     size_t __cpusetsize,
     __const cpu_set_t *__cpuset)
     throw () __attribute__ ((__nonnull__ (1, 3)));
extern int pthread_attr_getaffinity_np (__const pthread_attr_t *__attr,
     size_t __cpusetsize,
     cpu_set_t *__cpuset)
     throw () __attribute__ ((__nonnull__ (1, 3)));
extern int pthread_getattr_np (pthread_t __th, pthread_attr_t *__attr)
     throw () __attribute__ ((__nonnull__ (2)));
extern int pthread_setschedparam (pthread_t __target_thread, int __policy,
      __const struct sched_param *__param)
     throw () __attribute__ ((__nonnull__ (3)));
extern int pthread_getschedparam (pthread_t __target_thread,
      int *__restrict __policy,
      struct sched_param *__restrict __param)
     throw () __attribute__ ((__nonnull__ (2, 3)));
extern int pthread_setschedprio (pthread_t __target_thread, int __prio)
     throw ();
extern int pthread_getconcurrency (void) throw ();
extern int pthread_setconcurrency (int __level) throw ();
extern int pthread_yield (void) throw ();
extern int pthread_setaffinity_np (pthread_t __th, size_t __cpusetsize,
       __const cpu_set_t *__cpuset)
     throw () __attribute__ ((__nonnull__ (3)));
extern int pthread_getaffinity_np (pthread_t __th, size_t __cpusetsize,
       cpu_set_t *__cpuset)
     throw () __attribute__ ((__nonnull__ (3)));
extern int pthread_once (pthread_once_t *__once_control,
    void (*__init_routine) (void)) __attribute__ ((__nonnull__ (1, 2)));
extern int pthread_setcancelstate (int __state, int *__oldstate);
extern int pthread_setcanceltype (int __type, int *__oldtype);
extern int pthread_cancel (pthread_t __th);
extern void pthread_testcancel (void);
typedef struct
{
  struct
  {
    __jmp_buf __cancel_jmp_buf;
    int __mask_was_saved;
  } __cancel_jmp_buf[1];
  void *__pad[4];
} __pthread_unwind_buf_t __attribute__ ((__aligned__));
struct __pthread_cleanup_frame
{
  void (*__cancel_routine) (void *);
  void *__cancel_arg;
  int __do_it;
  int __cancel_type;
};
class __pthread_cleanup_class
{
  void (*__cancel_routine) (void *);
  void *__cancel_arg;
  int __do_it;
  int __cancel_type;
 public:
  __pthread_cleanup_class (void (*__fct) (void *), void *__arg)
    : __cancel_routine (__fct), __cancel_arg (__arg), __do_it (1) { }
  ~__pthread_cleanup_class () { if (__do_it) __cancel_routine (__cancel_arg); }
  void __setdoit (int __newval) { __do_it = __newval; }
  void __defer () { pthread_setcanceltype (PTHREAD_CANCEL_DEFERRED,
        &__cancel_type); }
  void __restore () const { pthread_setcanceltype (__cancel_type, 0); }
};
struct __jmp_buf_tag;
extern int __sigsetjmp (struct __jmp_buf_tag *__env, int __savemask) throw ();
extern int pthread_mutex_init (pthread_mutex_t *__mutex,
          __const pthread_mutexattr_t *__mutexattr)
     throw () __attribute__ ((__nonnull__ (1)));
extern int pthread_mutex_destroy (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));
extern int pthread_mutex_trylock (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));
extern int pthread_mutex_lock (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));
extern int pthread_mutex_timedlock (pthread_mutex_t *__restrict __mutex,
                                    __const struct timespec *__restrict
                                    __abstime) throw () __attribute__ ((__nonnull__ (1, 2)));
extern int pthread_mutex_unlock (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));
extern int pthread_mutex_getprioceiling (__const pthread_mutex_t *
      __restrict __mutex,
      int *__restrict __prioceiling)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern int pthread_mutex_setprioceiling (pthread_mutex_t *__restrict __mutex,
      int __prioceiling,
      int *__restrict __old_ceiling)
     throw () __attribute__ ((__nonnull__ (1, 3)));
extern int pthread_mutex_consistent_np (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));
extern int pthread_mutexattr_init (pthread_mutexattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));
extern int pthread_mutexattr_destroy (pthread_mutexattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));
extern int pthread_mutexattr_getpshared (__const pthread_mutexattr_t *
      __restrict __attr,
      int *__restrict __pshared)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern int pthread_mutexattr_setpshared (pthread_mutexattr_t *__attr,
      int __pshared)
     throw () __attribute__ ((__nonnull__ (1)));
extern int pthread_mutexattr_gettype (__const pthread_mutexattr_t *__restrict
          __attr, int *__restrict __kind)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern int pthread_mutexattr_settype (pthread_mutexattr_t *__attr, int __kind)
     throw () __attribute__ ((__nonnull__ (1)));
extern int pthread_mutexattr_getprotocol (__const pthread_mutexattr_t *
       __restrict __attr,
       int *__restrict __protocol)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern int pthread_mutexattr_setprotocol (pthread_mutexattr_t *__attr,
       int __protocol)
     throw () __attribute__ ((__nonnull__ (1)));
extern int pthread_mutexattr_getprioceiling (__const pthread_mutexattr_t *
          __restrict __attr,
          int *__restrict __prioceiling)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern int pthread_mutexattr_setprioceiling (pthread_mutexattr_t *__attr,
          int __prioceiling)
     throw () __attribute__ ((__nonnull__ (1)));
extern int pthread_mutexattr_getrobust_np (__const pthread_mutexattr_t *__attr,
        int *__robustness)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern int pthread_mutexattr_setrobust_np (pthread_mutexattr_t *__attr,
        int __robustness)
     throw () __attribute__ ((__nonnull__ (1)));
extern int pthread_rwlock_init (pthread_rwlock_t *__restrict __rwlock,
    __const pthread_rwlockattr_t *__restrict
    __attr) throw () __attribute__ ((__nonnull__ (1)));
extern int pthread_rwlock_destroy (pthread_rwlock_t *__rwlock)
     throw () __attribute__ ((__nonnull__ (1)));
extern int pthread_rwlock_rdlock (pthread_rwlock_t *__rwlock)
     throw () __attribute__ ((__nonnull__ (1)));
extern int pthread_rwlock_tryrdlock (pthread_rwlock_t *__rwlock)
  throw () __attribute__ ((__nonnull__ (1)));
extern int pthread_rwlock_timedrdlock (pthread_rwlock_t *__restrict __rwlock,
           __const struct timespec *__restrict
           __abstime) throw () __attribute__ ((__nonnull__ (1, 2)));
extern int pthread_rwlock_wrlock (pthread_rwlock_t *__rwlock)
     throw () __attribute__ ((__nonnull__ (1)));
extern int pthread_rwlock_trywrlock (pthread_rwlock_t *__rwlock)
     throw () __attribute__ ((__nonnull__ (1)));
extern int pthread_rwlock_timedwrlock (pthread_rwlock_t *__restrict __rwlock,
           __const struct timespec *__restrict
           __abstime) throw () __attribute__ ((__nonnull__ (1, 2)));
extern int pthread_rwlock_unlock (pthread_rwlock_t *__rwlock)
     throw () __attribute__ ((__nonnull__ (1)));
extern int pthread_rwlockattr_init (pthread_rwlockattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));
extern int pthread_rwlockattr_destroy (pthread_rwlockattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));
extern int pthread_rwlockattr_getpshared (__const pthread_rwlockattr_t *
       __restrict __attr,
       int *__restrict __pshared)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern int pthread_rwlockattr_setpshared (pthread_rwlockattr_t *__attr,
       int __pshared)
     throw () __attribute__ ((__nonnull__ (1)));
extern int pthread_rwlockattr_getkind_np (__const pthread_rwlockattr_t *
       __restrict __attr,
       int *__restrict __pref)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern int pthread_rwlockattr_setkind_np (pthread_rwlockattr_t *__attr,
       int __pref) throw () __attribute__ ((__nonnull__ (1)));
extern int pthread_cond_init (pthread_cond_t *__restrict __cond,
         __const pthread_condattr_t *__restrict
         __cond_attr) throw () __attribute__ ((__nonnull__ (1)));
extern int pthread_cond_destroy (pthread_cond_t *__cond)
     throw () __attribute__ ((__nonnull__ (1)));
extern int pthread_cond_signal (pthread_cond_t *__cond)
     throw () __attribute__ ((__nonnull__ (1)));
extern int pthread_cond_broadcast (pthread_cond_t *__cond)
     throw () __attribute__ ((__nonnull__ (1)));
extern int pthread_cond_wait (pthread_cond_t *__restrict __cond,
         pthread_mutex_t *__restrict __mutex)
     __attribute__ ((__nonnull__ (1, 2)));
extern int pthread_cond_timedwait (pthread_cond_t *__restrict __cond,
       pthread_mutex_t *__restrict __mutex,
       __const struct timespec *__restrict
       __abstime) __attribute__ ((__nonnull__ (1, 2, 3)));
extern int pthread_condattr_init (pthread_condattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));
extern int pthread_condattr_destroy (pthread_condattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));
extern int pthread_condattr_getpshared (__const pthread_condattr_t *
                                        __restrict __attr,
                                        int *__restrict __pshared)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern int pthread_condattr_setpshared (pthread_condattr_t *__attr,
                                        int __pshared) throw () __attribute__ ((__nonnull__ (1)));
extern int pthread_condattr_getclock (__const pthread_condattr_t *
          __restrict __attr,
          __clockid_t *__restrict __clock_id)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern int pthread_condattr_setclock (pthread_condattr_t *__attr,
          __clockid_t __clock_id)
     throw () __attribute__ ((__nonnull__ (1)));
extern int pthread_spin_init (pthread_spinlock_t *__lock, int __pshared)
     throw () __attribute__ ((__nonnull__ (1)));
extern int pthread_spin_destroy (pthread_spinlock_t *__lock)
     throw () __attribute__ ((__nonnull__ (1)));
extern int pthread_spin_lock (pthread_spinlock_t *__lock)
     throw () __attribute__ ((__nonnull__ (1)));
extern int pthread_spin_trylock (pthread_spinlock_t *__lock)
     throw () __attribute__ ((__nonnull__ (1)));
extern int pthread_spin_unlock (pthread_spinlock_t *__lock)
     throw () __attribute__ ((__nonnull__ (1)));
extern int pthread_barrier_init (pthread_barrier_t *__restrict __barrier,
     __const pthread_barrierattr_t *__restrict
     __attr, unsigned int __count)
     throw () __attribute__ ((__nonnull__ (1)));
extern int pthread_barrier_destroy (pthread_barrier_t *__barrier)
     throw () __attribute__ ((__nonnull__ (1)));
extern int pthread_barrier_wait (pthread_barrier_t *__barrier)
     throw () __attribute__ ((__nonnull__ (1)));
extern int pthread_barrierattr_init (pthread_barrierattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));
extern int pthread_barrierattr_destroy (pthread_barrierattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));
extern int pthread_barrierattr_getpshared (__const pthread_barrierattr_t *
        __restrict __attr,
        int *__restrict __pshared)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern int pthread_barrierattr_setpshared (pthread_barrierattr_t *__attr,
                                           int __pshared)
     throw () __attribute__ ((__nonnull__ (1)));
extern int pthread_key_create (pthread_key_t *__key,
          void (*__destr_function) (void *))
     throw () __attribute__ ((__nonnull__ (1)));
extern int pthread_key_delete (pthread_key_t __key) throw ();
extern void *pthread_getspecific (pthread_key_t __key) throw ();
extern int pthread_setspecific (pthread_key_t __key,
    __const void *__pointer) throw () ;
extern int pthread_getcpuclockid (pthread_t __thread_id,
      __clockid_t *__clock_id)
     throw () __attribute__ ((__nonnull__ (2)));
extern int pthread_atfork (void (*__prepare) (void),
      void (*__parent) (void),
      void (*__child) (void)) throw ();
}
extern "C" {
typedef __intptr_t intptr_t;
typedef __socklen_t socklen_t;
extern int access (__const char *__name, int __type) throw () __attribute__ ((__nonnull__ (1)));
extern int euidaccess (__const char *__name, int __type)
     throw () __attribute__ ((__nonnull__ (1)));
extern int eaccess (__const char *__name, int __type)
     throw () __attribute__ ((__nonnull__ (1)));
extern int faccessat (int __fd, __const char *__file, int __type, int __flag)
     throw () __attribute__ ((__nonnull__ (2))) ;
extern __off_t lseek (int __fd, __off_t __offset, int __whence) throw ();
extern __off64_t lseek64 (int __fd, __off64_t __offset, int __whence)
     throw ();
extern int close (int __fd);
extern ssize_t read (int __fd, void *__buf, size_t __nbytes) ;
extern ssize_t write (int __fd, __const void *__buf, size_t __n) ;
extern ssize_t pread (int __fd, void *__buf, size_t __nbytes,
        __off_t __offset) ;
extern ssize_t pwrite (int __fd, __const void *__buf, size_t __n,
         __off_t __offset) ;
extern ssize_t pread64 (int __fd, void *__buf, size_t __nbytes,
   __off64_t __offset) ;
extern ssize_t pwrite64 (int __fd, __const void *__buf, size_t __n,
    __off64_t __offset) ;
extern int pipe (int __pipedes[2]) throw () ;
extern unsigned int alarm (unsigned int __seconds) throw ();
extern unsigned int sleep (unsigned int __seconds);
extern __useconds_t ualarm (__useconds_t __value, __useconds_t __interval)
     throw ();
extern int usleep (__useconds_t __useconds);
extern int pause (void);
extern int chown (__const char *__file, __uid_t __owner, __gid_t __group)
     throw () __attribute__ ((__nonnull__ (1))) ;
extern int fchown (int __fd, __uid_t __owner, __gid_t __group) throw () ;
extern int lchown (__const char *__file, __uid_t __owner, __gid_t __group)
     throw () __attribute__ ((__nonnull__ (1))) ;
extern int fchownat (int __fd, __const char *__file, __uid_t __owner,
       __gid_t __group, int __flag)
     throw () __attribute__ ((__nonnull__ (2))) ;
extern int chdir (__const char *__path) throw () __attribute__ ((__nonnull__ (1))) ;
extern int fchdir (int __fd) throw () ;
extern char *getcwd (char *__buf, size_t __size) throw () ;
extern char *get_current_dir_name (void) throw ();
extern char *getwd (char *__buf)
     throw () __attribute__ ((__nonnull__ (1))) __attribute__ ((__deprecated__)) ;
extern int dup (int __fd) throw () ;
extern int dup2 (int __fd, int __fd2) throw ();
extern char **__environ;
extern char **environ;
extern int execve (__const char *__path, char *__const __argv[],
     char *__const __envp[]) throw () __attribute__ ((__nonnull__ (1)));
extern int fexecve (int __fd, char *__const __argv[], char *__const __envp[])
     throw ();
extern int execv (__const char *__path, char *__const __argv[])
     throw () __attribute__ ((__nonnull__ (1)));
extern int execle (__const char *__path, __const char *__arg, ...)
     throw () __attribute__ ((__nonnull__ (1)));
extern int execl (__const char *__path, __const char *__arg, ...)
     throw () __attribute__ ((__nonnull__ (1)));
extern int execvp (__const char *__file, char *__const __argv[])
     throw () __attribute__ ((__nonnull__ (1)));
extern int execlp (__const char *__file, __const char *__arg, ...)
     throw () __attribute__ ((__nonnull__ (1)));
extern int nice (int __inc) throw () ;
extern void _exit (int __status) __attribute__ ((__noreturn__));
enum
  {
    _PC_LINK_MAX,
    _PC_MAX_CANON,
    _PC_MAX_INPUT,
    _PC_NAME_MAX,
    _PC_PATH_MAX,
    _PC_PIPE_BUF,
    _PC_CHOWN_RESTRICTED,
    _PC_NO_TRUNC,
    _PC_VDISABLE,
    _PC_SYNC_IO,
    _PC_ASYNC_IO,
    _PC_PRIO_IO,
    _PC_SOCK_MAXBUF,
    _PC_FILESIZEBITS,
    _PC_REC_INCR_XFER_SIZE,
    _PC_REC_MAX_XFER_SIZE,
    _PC_REC_MIN_XFER_SIZE,
    _PC_REC_XFER_ALIGN,
    _PC_ALLOC_SIZE_MIN,
    _PC_SYMLINK_MAX,
    _PC_2_SYMLINKS
  };
enum
  {
    _SC_ARG_MAX,
    _SC_CHILD_MAX,
    _SC_CLK_TCK,
    _SC_NGROUPS_MAX,
    _SC_OPEN_MAX,
    _SC_STREAM_MAX,
    _SC_TZNAME_MAX,
    _SC_JOB_CONTROL,
    _SC_SAVED_IDS,
    _SC_REALTIME_SIGNALS,
    _SC_PRIORITY_SCHEDULING,
    _SC_TIMERS,
    _SC_ASYNCHRONOUS_IO,
    _SC_PRIORITIZED_IO,
    _SC_SYNCHRONIZED_IO,
    _SC_FSYNC,
    _SC_MAPPED_FILES,
    _SC_MEMLOCK,
    _SC_MEMLOCK_RANGE,
    _SC_MEMORY_PROTECTION,
    _SC_MESSAGE_PASSING,
    _SC_SEMAPHORES,
    _SC_SHARED_MEMORY_OBJECTS,
    _SC_AIO_LISTIO_MAX,
    _SC_AIO_MAX,
    _SC_AIO_PRIO_DELTA_MAX,
    _SC_DELAYTIMER_MAX,
    _SC_MQ_OPEN_MAX,
    _SC_MQ_PRIO_MAX,
    _SC_VERSION,
    _SC_PAGESIZE,
    _SC_RTSIG_MAX,
    _SC_SEM_NSEMS_MAX,
    _SC_SEM_VALUE_MAX,
    _SC_SIGQUEUE_MAX,
    _SC_TIMER_MAX,
    _SC_BC_BASE_MAX,
    _SC_BC_DIM_MAX,
    _SC_BC_SCALE_MAX,
    _SC_BC_STRING_MAX,
    _SC_COLL_WEIGHTS_MAX,
    _SC_EQUIV_CLASS_MAX,
    _SC_EXPR_NEST_MAX,
    _SC_LINE_MAX,
    _SC_RE_DUP_MAX,
    _SC_CHARCLASS_NAME_MAX,
    _SC_2_VERSION,
    _SC_2_C_BIND,
    _SC_2_C_DEV,
    _SC_2_FORT_DEV,
    _SC_2_FORT_RUN,
    _SC_2_SW_DEV,
    _SC_2_LOCALEDEF,
    _SC_PII,
    _SC_PII_XTI,
    _SC_PII_SOCKET,
    _SC_PII_INTERNET,
    _SC_PII_OSI,
    _SC_POLL,
    _SC_SELECT,
    _SC_UIO_MAXIOV,
    _SC_IOV_MAX = _SC_UIO_MAXIOV,
    _SC_PII_INTERNET_STREAM,
    _SC_PII_INTERNET_DGRAM,
    _SC_PII_OSI_COTS,
    _SC_PII_OSI_CLTS,
    _SC_PII_OSI_M,
    _SC_T_IOV_MAX,
    _SC_THREADS,
    _SC_THREAD_SAFE_FUNCTIONS,
    _SC_GETGR_R_SIZE_MAX,
    _SC_GETPW_R_SIZE_MAX,
    _SC_LOGIN_NAME_MAX,
    _SC_TTY_NAME_MAX,
    _SC_THREAD_DESTRUCTOR_ITERATIONS,
    _SC_THREAD_KEYS_MAX,
    _SC_THREAD_STACK_MIN,
    _SC_THREAD_THREADS_MAX,
    _SC_THREAD_ATTR_STACKADDR,
    _SC_THREAD_ATTR_STACKSIZE,
    _SC_THREAD_PRIORITY_SCHEDULING,
    _SC_THREAD_PRIO_INHERIT,
    _SC_THREAD_PRIO_PROTECT,
    _SC_THREAD_PROCESS_SHARED,
    _SC_NPROCESSORS_CONF,
    _SC_NPROCESSORS_ONLN,
    _SC_PHYS_PAGES,
    _SC_AVPHYS_PAGES,
    _SC_ATEXIT_MAX,
    _SC_PASS_MAX,
    _SC_XOPEN_VERSION,
    _SC_XOPEN_XCU_VERSION,
    _SC_XOPEN_UNIX,
    _SC_XOPEN_CRYPT,
    _SC_XOPEN_ENH_I18N,
    _SC_XOPEN_SHM,
    _SC_2_CHAR_TERM,
    _SC_2_C_VERSION,
    _SC_2_UPE,
    _SC_XOPEN_XPG2,
    _SC_XOPEN_XPG3,
    _SC_XOPEN_XPG4,
    _SC_CHAR_BIT,
    _SC_CHAR_MAX,
    _SC_CHAR_MIN,
    _SC_INT_MAX,
    _SC_INT_MIN,
    _SC_LONG_BIT,
    _SC_WORD_BIT,
    _SC_MB_LEN_MAX,
    _SC_NZERO,
    _SC_SSIZE_MAX,
    _SC_SCHAR_MAX,
    _SC_SCHAR_MIN,
    _SC_SHRT_MAX,
    _SC_SHRT_MIN,
    _SC_UCHAR_MAX,
    _SC_UINT_MAX,
    _SC_ULONG_MAX,
    _SC_USHRT_MAX,
    _SC_NL_ARGMAX,
    _SC_NL_LANGMAX,
    _SC_NL_MSGMAX,
    _SC_NL_NMAX,
    _SC_NL_SETMAX,
    _SC_NL_TEXTMAX,
    _SC_XBS5_ILP32_OFF32,
    _SC_XBS5_ILP32_OFFBIG,
    _SC_XBS5_LP64_OFF64,
    _SC_XBS5_LPBIG_OFFBIG,
    _SC_XOPEN_LEGACY,
    _SC_XOPEN_REALTIME,
    _SC_XOPEN_REALTIME_THREADS,
    _SC_ADVISORY_INFO,
    _SC_BARRIERS,
    _SC_BASE,
    _SC_C_LANG_SUPPORT,
    _SC_C_LANG_SUPPORT_R,
    _SC_CLOCK_SELECTION,
    _SC_CPUTIME,
    _SC_THREAD_CPUTIME,
    _SC_DEVICE_IO,
    _SC_DEVICE_SPECIFIC,
    _SC_DEVICE_SPECIFIC_R,
    _SC_FD_MGMT,
    _SC_FIFO,
    _SC_PIPE,
    _SC_FILE_ATTRIBUTES,
    _SC_FILE_LOCKING,
    _SC_FILE_SYSTEM,
    _SC_MONOTONIC_CLOCK,
    _SC_MULTI_PROCESS,
    _SC_SINGLE_PROCESS,
    _SC_NETWORKING,
    _SC_READER_WRITER_LOCKS,
    _SC_SPIN_LOCKS,
    _SC_REGEXP,
    _SC_REGEX_VERSION,
    _SC_SHELL,
    _SC_SIGNALS,
    _SC_SPAWN,
    _SC_SPORADIC_SERVER,
    _SC_THREAD_SPORADIC_SERVER,
    _SC_SYSTEM_DATABASE,
    _SC_SYSTEM_DATABASE_R,
    _SC_TIMEOUTS,
    _SC_TYPED_MEMORY_OBJECTS,
    _SC_USER_GROUPS,
    _SC_USER_GROUPS_R,
    _SC_2_PBS,
    _SC_2_PBS_ACCOUNTING,
    _SC_2_PBS_LOCATE,
    _SC_2_PBS_MESSAGE,
    _SC_2_PBS_TRACK,
    _SC_SYMLOOP_MAX,
    _SC_STREAMS,
    _SC_2_PBS_CHECKPOINT,
    _SC_V6_ILP32_OFF32,
    _SC_V6_ILP32_OFFBIG,
    _SC_V6_LP64_OFF64,
    _SC_V6_LPBIG_OFFBIG,
    _SC_HOST_NAME_MAX,
    _SC_TRACE,
    _SC_TRACE_EVENT_FILTER,
    _SC_TRACE_INHERIT,
    _SC_TRACE_LOG,
    _SC_LEVEL1_ICACHE_SIZE,
    _SC_LEVEL1_ICACHE_ASSOC,
    _SC_LEVEL1_ICACHE_LINESIZE,
    _SC_LEVEL1_DCACHE_SIZE,
    _SC_LEVEL1_DCACHE_ASSOC,
    _SC_LEVEL1_DCACHE_LINESIZE,
    _SC_LEVEL2_CACHE_SIZE,
    _SC_LEVEL2_CACHE_ASSOC,
    _SC_LEVEL2_CACHE_LINESIZE,
    _SC_LEVEL3_CACHE_SIZE,
    _SC_LEVEL3_CACHE_ASSOC,
    _SC_LEVEL3_CACHE_LINESIZE,
    _SC_LEVEL4_CACHE_SIZE,
    _SC_LEVEL4_CACHE_ASSOC,
    _SC_LEVEL4_CACHE_LINESIZE,
    _SC_IPV6 = _SC_LEVEL1_ICACHE_SIZE + 50,
    _SC_RAW_SOCKETS
  };
enum
  {
    _CS_PATH,
    _CS_V6_WIDTH_RESTRICTED_ENVS,
    _CS_GNU_LIBC_VERSION,
    _CS_GNU_LIBPTHREAD_VERSION,
    _CS_LFS_CFLAGS = 1000,
    _CS_LFS_LDFLAGS,
    _CS_LFS_LIBS,
    _CS_LFS_LINTFLAGS,
    _CS_LFS64_CFLAGS,
    _CS_LFS64_LDFLAGS,
    _CS_LFS64_LIBS,
    _CS_LFS64_LINTFLAGS,
    _CS_XBS5_ILP32_OFF32_CFLAGS = 1100,
    _CS_XBS5_ILP32_OFF32_LDFLAGS,
    _CS_XBS5_ILP32_OFF32_LIBS,
    _CS_XBS5_ILP32_OFF32_LINTFLAGS,
    _CS_XBS5_ILP32_OFFBIG_CFLAGS,
    _CS_XBS5_ILP32_OFFBIG_LDFLAGS,
    _CS_XBS5_ILP32_OFFBIG_LIBS,
    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS,
    _CS_XBS5_LP64_OFF64_CFLAGS,
    _CS_XBS5_LP64_OFF64_LDFLAGS,
    _CS_XBS5_LP64_OFF64_LIBS,
    _CS_XBS5_LP64_OFF64_LINTFLAGS,
    _CS_XBS5_LPBIG_OFFBIG_CFLAGS,
    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS,
    _CS_XBS5_LPBIG_OFFBIG_LIBS,
    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS,
    _CS_POSIX_V6_ILP32_OFF32_CFLAGS,
    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS,
    _CS_POSIX_V6_ILP32_OFF32_LIBS,
    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS,
    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS,
    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS,
    _CS_POSIX_V6_ILP32_OFFBIG_LIBS,
    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS,
    _CS_POSIX_V6_LP64_OFF64_CFLAGS,
    _CS_POSIX_V6_LP64_OFF64_LDFLAGS,
    _CS_POSIX_V6_LP64_OFF64_LIBS,
    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS,
    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS,
    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS,
    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS,
    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS
  };
extern long int pathconf (__const char *__path, int __name)
     throw () __attribute__ ((__nonnull__ (1)));
extern long int fpathconf (int __fd, int __name) throw ();
extern long int sysconf (int __name) throw ();
extern size_t confstr (int __name, char *__buf, size_t __len) throw ();
extern __pid_t getpid (void) throw ();
extern __pid_t getppid (void) throw ();
extern __pid_t getpgrp (void) throw ();
extern __pid_t __getpgid (__pid_t __pid) throw ();
extern __pid_t getpgid (__pid_t __pid) throw ();
extern int setpgid (__pid_t __pid, __pid_t __pgid) throw ();
extern int setpgrp (void) throw ();
extern __pid_t setsid (void) throw ();
extern __pid_t getsid (__pid_t __pid) throw ();
extern __uid_t getuid (void) throw ();
extern __uid_t geteuid (void) throw ();
extern __gid_t getgid (void) throw ();
extern __gid_t getegid (void) throw ();
extern int getgroups (int __size, __gid_t __list[]) throw () ;
extern int group_member (__gid_t __gid) throw ();
extern int setuid (__uid_t __uid) throw ();
extern int setreuid (__uid_t __ruid, __uid_t __euid) throw ();
extern int seteuid (__uid_t __uid) throw ();
extern int setgid (__gid_t __gid) throw ();
extern int setregid (__gid_t __rgid, __gid_t __egid) throw ();
extern int setegid (__gid_t __gid) throw ();
extern int getresuid (__uid_t *__ruid, __uid_t *__euid, __uid_t *__suid)
     throw ();
extern int getresgid (__gid_t *__rgid, __gid_t *__egid, __gid_t *__sgid)
     throw ();
extern int setresuid (__uid_t __ruid, __uid_t __euid, __uid_t __suid)
     throw ();
extern int setresgid (__gid_t __rgid, __gid_t __egid, __gid_t __sgid)
     throw ();
extern __pid_t fork (void) throw ();
extern __pid_t vfork (void) throw ();
extern char *ttyname (int __fd) throw ();
extern int ttyname_r (int __fd, char *__buf, size_t __buflen)
     throw () __attribute__ ((__nonnull__ (2))) ;
extern int isatty (int __fd) throw ();
extern int ttyslot (void) throw ();
extern int link (__const char *__from, __const char *__to)
     throw () __attribute__ ((__nonnull__ (1, 2))) ;
extern int linkat (int __fromfd, __const char *__from, int __tofd,
     __const char *__to, int __flags)
     throw () __attribute__ ((__nonnull__ (2, 4))) ;
extern int symlink (__const char *__from, __const char *__to)
     throw () __attribute__ ((__nonnull__ (1, 2))) ;
extern ssize_t readlink (__const char *__restrict __path,
    char *__restrict __buf, size_t __len)
     throw () __attribute__ ((__nonnull__ (1, 2))) ;
extern int symlinkat (__const char *__from, int __tofd,
        __const char *__to) throw () __attribute__ ((__nonnull__ (1, 3))) ;
extern ssize_t readlinkat (int __fd, __const char *__restrict __path,
      char *__restrict __buf, size_t __len)
     throw () __attribute__ ((__nonnull__ (2, 3))) ;
extern int unlink (__const char *__name) throw () __attribute__ ((__nonnull__ (1)));
extern int unlinkat (int __fd, __const char *__name, int __flag)
     throw () __attribute__ ((__nonnull__ (2)));
extern int rmdir (__const char *__path) throw () __attribute__ ((__nonnull__ (1)));
extern __pid_t tcgetpgrp (int __fd) throw ();
extern int tcsetpgrp (int __fd, __pid_t __pgrp_id) throw ();
extern char *getlogin (void);
extern int getlogin_r (char *__name, size_t __name_len) __attribute__ ((__nonnull__ (1)));
extern int setlogin (__const char *__name) throw () __attribute__ ((__nonnull__ (1)));
extern "C" {
extern char *optarg;
extern int optind;
extern int opterr;
extern int optopt;
extern int getopt (int ___argc, char *const *___argv, const char *__shortopts)
       throw ();
}
extern int gethostname (char *__name, size_t __len) throw () __attribute__ ((__nonnull__ (1)));
extern int sethostname (__const char *__name, size_t __len)
     throw () __attribute__ ((__nonnull__ (1))) ;
extern int sethostid (long int __id) throw () ;
extern int getdomainname (char *__name, size_t __len)
     throw () __attribute__ ((__nonnull__ (1))) ;
extern int setdomainname (__const char *__name, size_t __len)
     throw () __attribute__ ((__nonnull__ (1))) ;
extern int vhangup (void) throw ();
extern int revoke (__const char *__file) throw () __attribute__ ((__nonnull__ (1))) ;
extern int profil (unsigned short int *__sample_buffer, size_t __size,
     size_t __offset, unsigned int __scale)
     throw () __attribute__ ((__nonnull__ (1)));
extern int acct (__const char *__name) throw ();
extern char *getusershell (void) throw ();
extern void endusershell (void) throw ();
extern void setusershell (void) throw ();
extern int daemon (int __nochdir, int __noclose) throw () ;
extern int chroot (__const char *__path) throw () __attribute__ ((__nonnull__ (1))) ;
extern char *getpass (__const char *__prompt) __attribute__ ((__nonnull__ (1)));
extern int fsync (int __fd);
extern long int gethostid (void);
extern void sync (void) throw ();
extern int getpagesize (void) throw () __attribute__ ((__const__));
extern int getdtablesize (void) throw ();
extern int truncate (__const char *__file, __off_t __length)
     throw () __attribute__ ((__nonnull__ (1))) ;
extern int truncate64 (__const char *__file, __off64_t __length)
     throw () __attribute__ ((__nonnull__ (1))) ;
extern int ftruncate (int __fd, __off_t __length) throw () ;
extern int ftruncate64 (int __fd, __off64_t __length) throw () ;
extern int brk (void *__addr) throw () ;
extern void *sbrk (intptr_t __delta) throw ();
extern long int syscall (long int __sysno, ...) throw ();
extern int lockf (int __fd, int __cmd, __off_t __len) ;
extern int lockf64 (int __fd, int __cmd, __off64_t __len) ;
extern int fdatasync (int __fildes);
extern char *crypt (__const char *__key, __const char *__salt)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern void encrypt (char *__block, int __edflag) throw () __attribute__ ((__nonnull__ (1)));
extern void swab (__const void *__restrict __from, void *__restrict __to,
    ssize_t __n) throw () __attribute__ ((__nonnull__ (1, 2)));
extern char *ctermid (char *__s) throw ();
}
typedef pthread_key_t __gthread_key_t;
typedef pthread_once_t __gthread_once_t;
typedef pthread_mutex_t __gthread_mutex_t;
typedef pthread_mutex_t __gthread_recursive_mutex_t;
extern __typeof(pthread_once) __gthrw_pthread_once __attribute__ ((__weakref__("pthread_once")));
extern __typeof(pthread_getspecific) __gthrw_pthread_getspecific __attribute__ ((__weakref__("pthread_getspecific")));
extern __typeof(pthread_setspecific) __gthrw_pthread_setspecific __attribute__ ((__weakref__("pthread_setspecific")));
extern __typeof(pthread_create) __gthrw_pthread_create __attribute__ ((__weakref__("pthread_create")));
extern __typeof(pthread_cancel) __gthrw_pthread_cancel __attribute__ ((__weakref__("pthread_cancel")));
extern __typeof(pthread_mutex_lock) __gthrw_pthread_mutex_lock __attribute__ ((__weakref__("pthread_mutex_lock")));
extern __typeof(pthread_mutex_trylock) __gthrw_pthread_mutex_trylock __attribute__ ((__weakref__("pthread_mutex_trylock")));
extern __typeof(pthread_mutex_unlock) __gthrw_pthread_mutex_unlock __attribute__ ((__weakref__("pthread_mutex_unlock")));
extern __typeof(pthread_mutex_init) __gthrw_pthread_mutex_init __attribute__ ((__weakref__("pthread_mutex_init")));
extern __typeof(pthread_key_create) __gthrw_pthread_key_create __attribute__ ((__weakref__("pthread_key_create")));
extern __typeof(pthread_key_delete) __gthrw_pthread_key_delete __attribute__ ((__weakref__("pthread_key_delete")));
extern __typeof(pthread_mutexattr_init) __gthrw_pthread_mutexattr_init __attribute__ ((__weakref__("pthread_mutexattr_init")));
extern __typeof(pthread_mutexattr_settype) __gthrw_pthread_mutexattr_settype __attribute__ ((__weakref__("pthread_mutexattr_settype")));
extern __typeof(pthread_mutexattr_destroy) __gthrw_pthread_mutexattr_destroy __attribute__ ((__weakref__("pthread_mutexattr_destroy")));
static inline int
__gthread_active_p (void)
{
  static void *const __gthread_active_ptr
    = __extension__ (void *) &__gthrw_pthread_cancel;
  return __gthread_active_ptr != 0;
}
static inline int
__gthread_once (__gthread_once_t *once, void (*func) (void))
{
  if (__gthread_active_p ())
    return __gthrw_pthread_once (once, func);
  else
    return -1;
}
static inline int
__gthread_key_create (__gthread_key_t *key, void (*dtor) (void *))
{
  return __gthrw_pthread_key_create (key, dtor);
}
static inline int
__gthread_key_delete (__gthread_key_t key)
{
  return __gthrw_pthread_key_delete (key);
}
static inline void *
__gthread_getspecific (__gthread_key_t key)
{
  return __gthrw_pthread_getspecific (key);
}
static inline int
__gthread_setspecific (__gthread_key_t key, const void *ptr)
{
  return __gthrw_pthread_setspecific (key, ptr);
}
static inline int
__gthread_mutex_lock (__gthread_mutex_t *mutex)
{
  if (__gthread_active_p ())
    return __gthrw_pthread_mutex_lock (mutex);
  else
    return 0;
}
static inline int
__gthread_mutex_trylock (__gthread_mutex_t *mutex)
{
  if (__gthread_active_p ())
    return __gthrw_pthread_mutex_trylock (mutex);
  else
    return 0;
}
static inline int
__gthread_mutex_unlock (__gthread_mutex_t *mutex)
{
  if (__gthread_active_p ())
    return __gthrw_pthread_mutex_unlock (mutex);
  else
    return 0;
}
static inline int
__gthread_recursive_mutex_lock (__gthread_recursive_mutex_t *mutex)
{
  return __gthread_mutex_lock (mutex);
}
static inline int
__gthread_recursive_mutex_trylock (__gthread_recursive_mutex_t *mutex)
{
  return __gthread_mutex_trylock (mutex);
}
static inline int
__gthread_recursive_mutex_unlock (__gthread_recursive_mutex_t *mutex)
{
  return __gthread_mutex_unlock (mutex);
}
namespace std
{
  typedef __gthread_mutex_t __c_lock;
  typedef FILE __c_file;
}
extern "C" {
enum
{
  _ISupper = ((0) < 8 ? ((1 << (0)) << 8) : ((1 << (0)) >> 8)),
  _ISlower = ((1) < 8 ? ((1 << (1)) << 8) : ((1 << (1)) >> 8)),
  _ISalpha = ((2) < 8 ? ((1 << (2)) << 8) : ((1 << (2)) >> 8)),
  _ISdigit = ((3) < 8 ? ((1 << (3)) << 8) : ((1 << (3)) >> 8)),
  _ISxdigit = ((4) < 8 ? ((1 << (4)) << 8) : ((1 << (4)) >> 8)),
  _ISspace = ((5) < 8 ? ((1 << (5)) << 8) : ((1 << (5)) >> 8)),
  _ISprint = ((6) < 8 ? ((1 << (6)) << 8) : ((1 << (6)) >> 8)),
  _ISgraph = ((7) < 8 ? ((1 << (7)) << 8) : ((1 << (7)) >> 8)),
  _ISblank = ((8) < 8 ? ((1 << (8)) << 8) : ((1 << (8)) >> 8)),
  _IScntrl = ((9) < 8 ? ((1 << (9)) << 8) : ((1 << (9)) >> 8)),
  _ISpunct = ((10) < 8 ? ((1 << (10)) << 8) : ((1 << (10)) >> 8)),
  _ISalnum = ((11) < 8 ? ((1 << (11)) << 8) : ((1 << (11)) >> 8))
};
extern __const unsigned short int **__ctype_b_loc (void)
     __attribute__ ((__const));
extern __const __int32_t **__ctype_tolower_loc (void)
     __attribute__ ((__const));
extern __const __int32_t **__ctype_toupper_loc (void)
     __attribute__ ((__const));
extern int isalnum (int) throw ();
extern int isalpha (int) throw ();
extern int iscntrl (int) throw ();
extern int isdigit (int) throw ();
extern int islower (int) throw ();
extern int isgraph (int) throw ();
extern int isprint (int) throw ();
extern int ispunct (int) throw ();
extern int isspace (int) throw ();
extern int isupper (int) throw ();
extern int isxdigit (int) throw ();
extern int tolower (int __c) throw ();
extern int toupper (int __c) throw ();
extern int isblank (int) throw ();
extern int isctype (int __c, int __mask) throw ();
extern int isascii (int __c) throw ();
extern int toascii (int __c) throw ();
extern int _toupper (int) throw ();
extern int _tolower (int) throw ();
extern int isalnum_l (int, __locale_t) throw ();
extern int isalpha_l (int, __locale_t) throw ();
extern int iscntrl_l (int, __locale_t) throw ();
extern int isdigit_l (int, __locale_t) throw ();
extern int islower_l (int, __locale_t) throw ();
extern int isgraph_l (int, __locale_t) throw ();
extern int isprint_l (int, __locale_t) throw ();
extern int ispunct_l (int, __locale_t) throw ();
extern int isspace_l (int, __locale_t) throw ();
extern int isupper_l (int, __locale_t) throw ();
extern int isxdigit_l (int, __locale_t) throw ();
extern int isblank_l (int, __locale_t) throw ();
extern int __tolower_l (int __c, __locale_t __l) throw ();
extern int tolower_l (int __c, __locale_t __l) throw ();
extern int __toupper_l (int __c, __locale_t __l) throw ();
extern int toupper_l (int __c, __locale_t __l) throw ();
}
namespace std
{
  using ::isalnum;
  using ::isalpha;
  using ::iscntrl;
  using ::isdigit;
  using ::isgraph;
  using ::islower;
  using ::isprint;
  using ::ispunct;
  using ::isspace;
  using ::isupper;
  using ::isxdigit;
  using ::tolower;
  using ::toupper;
}
namespace std
{
  template<typename _Alloc>
    class allocator;
  template<class _CharT>
    struct char_traits;
  template<typename _CharT, typename _Traits = char_traits<_CharT>,
           typename _Alloc = allocator<_CharT> >
    class basic_string;
  template<> struct char_traits<char>;
  typedef basic_string<char> string;
  template<> struct char_traits<wchar_t>;
  typedef basic_string<wchar_t> wstring;
}
namespace std
{
  using ::clock_t;
  using ::time_t;
  using ::tm;
  using ::clock;
  using ::difftime;
  using ::mktime;
  using ::time;
  using ::asctime;
  using ::ctime;
  using ::gmtime;
  using ::localtime;
  using ::strftime;
}
typedef unsigned int wint_t;
typedef __mbstate_t mbstate_t;
extern "C" {
struct tm;
extern wchar_t *wcscpy (wchar_t *__restrict __dest,
   __const wchar_t *__restrict __src) throw ();
extern wchar_t *wcsncpy (wchar_t *__restrict __dest,
    __const wchar_t *__restrict __src, size_t __n)
     throw ();
extern wchar_t *wcscat (wchar_t *__restrict __dest,
   __const wchar_t *__restrict __src) throw ();
extern wchar_t *wcsncat (wchar_t *__restrict __dest,
    __const wchar_t *__restrict __src, size_t __n)
     throw ();
extern int wcscmp (__const wchar_t *__s1, __const wchar_t *__s2)
     throw () __attribute__ ((__pure__));
extern int wcsncmp (__const wchar_t *__s1, __const wchar_t *__s2, size_t __n)
     throw () __attribute__ ((__pure__));
extern int wcscasecmp (__const wchar_t *__s1, __const wchar_t *__s2) throw ();
extern int wcsncasecmp (__const wchar_t *__s1, __const wchar_t *__s2,
   size_t __n) throw ();
extern int wcscasecmp_l (__const wchar_t *__s1, __const wchar_t *__s2,
    __locale_t __loc) throw ();
extern int wcsncasecmp_l (__const wchar_t *__s1, __const wchar_t *__s2,
     size_t __n, __locale_t __loc) throw ();
extern int wcscoll (__const wchar_t *__s1, __const wchar_t *__s2) throw ();
extern size_t wcsxfrm (wchar_t *__restrict __s1,
         __const wchar_t *__restrict __s2, size_t __n) throw ();
extern int wcscoll_l (__const wchar_t *__s1, __const wchar_t *__s2,
        __locale_t __loc) throw ();
extern size_t wcsxfrm_l (wchar_t *__s1, __const wchar_t *__s2,
    size_t __n, __locale_t __loc) throw ();
extern wchar_t *wcsdup (__const wchar_t *__s) throw () __attribute__ ((__malloc__));
extern wchar_t *wcschr (__const wchar_t *__wcs, wchar_t __wc)
     throw () __attribute__ ((__pure__));
extern wchar_t *wcsrchr (__const wchar_t *__wcs, wchar_t __wc)
     throw () __attribute__ ((__pure__));
extern wchar_t *wcschrnul (__const wchar_t *__s, wchar_t __wc)
     throw () __attribute__ ((__pure__));
extern size_t wcscspn (__const wchar_t *__wcs, __const wchar_t *__reject)
     throw () __attribute__ ((__pure__));
extern size_t wcsspn (__const wchar_t *__wcs, __const wchar_t *__accept)
     throw () __attribute__ ((__pure__));
extern wchar_t *wcspbrk (__const wchar_t *__wcs, __const wchar_t *__accept)
     throw () __attribute__ ((__pure__));
extern wchar_t *wcsstr (__const wchar_t *__haystack, __const wchar_t *__needle)
     throw () __attribute__ ((__pure__));
extern wchar_t *wcstok (wchar_t *__restrict __s,
   __const wchar_t *__restrict __delim,
   wchar_t **__restrict __ptr) throw ();
extern size_t wcslen (__const wchar_t *__s) throw () __attribute__ ((__pure__));
extern wchar_t *wcswcs (__const wchar_t *__haystack, __const wchar_t *__needle)
     throw () __attribute__ ((__pure__));
extern size_t wcsnlen (__const wchar_t *__s, size_t __maxlen)
     throw () __attribute__ ((__pure__));
extern wchar_t *wmemchr (__const wchar_t *__s, wchar_t __c, size_t __n)
     throw () __attribute__ ((__pure__));
extern int wmemcmp (__const wchar_t *__restrict __s1,
      __const wchar_t *__restrict __s2, size_t __n)
     throw () __attribute__ ((__pure__));
extern wchar_t *wmemcpy (wchar_t *__restrict __s1,
    __const wchar_t *__restrict __s2, size_t __n) throw ();
extern wchar_t *wmemmove (wchar_t *__s1, __const wchar_t *__s2, size_t __n)
     throw ();
extern wchar_t *wmemset (wchar_t *__s, wchar_t __c, size_t __n) throw ();
extern wchar_t *wmempcpy (wchar_t *__restrict __s1,
     __const wchar_t *__restrict __s2, size_t __n)
     throw ();
extern wint_t btowc (int __c) throw ();
extern int wctob (wint_t __c) throw ();
extern int mbsinit (__const mbstate_t *__ps) throw () __attribute__ ((__pure__));
extern size_t mbrtowc (wchar_t *__restrict __pwc,
         __const char *__restrict __s, size_t __n,
         mbstate_t *__p) throw ();
extern size_t wcrtomb (char *__restrict __s, wchar_t __wc,
         mbstate_t *__restrict __ps) throw ();
extern size_t __mbrlen (__const char *__restrict __s, size_t __n,
   mbstate_t *__restrict __ps) throw ();
extern size_t mbrlen (__const char *__restrict __s, size_t __n,
        mbstate_t *__restrict __ps) throw ();
extern size_t mbsrtowcs (wchar_t *__restrict __dst,
    __const char **__restrict __src, size_t __len,
    mbstate_t *__restrict __ps) throw ();
extern size_t wcsrtombs (char *__restrict __dst,
    __const wchar_t **__restrict __src, size_t __len,
    mbstate_t *__restrict __ps) throw ();
extern size_t mbsnrtowcs (wchar_t *__restrict __dst,
     __const char **__restrict __src, size_t __nmc,
     size_t __len, mbstate_t *__restrict __ps) throw ();
extern size_t wcsnrtombs (char *__restrict __dst,
     __const wchar_t **__restrict __src,
     size_t __nwc, size_t __len,
     mbstate_t *__restrict __ps) throw ();
extern int wcwidth (wchar_t __c) throw ();
extern int wcswidth (__const wchar_t *__s, size_t __n) throw ();
extern double wcstod (__const wchar_t *__restrict __nptr,
        wchar_t **__restrict __endptr) throw ();
extern float wcstof (__const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr) throw ();
extern long double wcstold (__const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr) throw ();
extern long int wcstol (__const wchar_t *__restrict __nptr,
   wchar_t **__restrict __endptr, int __base) throw ();
extern unsigned long int wcstoul (__const wchar_t *__restrict __nptr,
      wchar_t **__restrict __endptr, int __base)
     throw ();
__extension__
extern long long int wcstoll (__const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr, int __base)
     throw ();
__extension__
extern unsigned long long int wcstoull (__const wchar_t *__restrict __nptr,
     wchar_t **__restrict __endptr,
     int __base) throw ();
__extension__
extern long long int wcstoq (__const wchar_t *__restrict __nptr,
        wchar_t **__restrict __endptr, int __base)
     throw ();
__extension__
extern unsigned long long int wcstouq (__const wchar_t *__restrict __nptr,
           wchar_t **__restrict __endptr,
           int __base) throw ();
extern long int wcstol_l (__const wchar_t *__restrict __nptr,
     wchar_t **__restrict __endptr, int __base,
     __locale_t __loc) throw ();
extern unsigned long int wcstoul_l (__const wchar_t *__restrict __nptr,
        wchar_t **__restrict __endptr,
        int __base, __locale_t __loc) throw ();
__extension__
extern long long int wcstoll_l (__const wchar_t *__restrict __nptr,
    wchar_t **__restrict __endptr,
    int __base, __locale_t __loc) throw ();
__extension__
extern unsigned long long int wcstoull_l (__const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr,
       int __base, __locale_t __loc)
     throw ();
extern double wcstod_l (__const wchar_t *__restrict __nptr,
   wchar_t **__restrict __endptr, __locale_t __loc)
     throw ();
extern float wcstof_l (__const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr, __locale_t __loc)
     throw ();
extern long double wcstold_l (__const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr,
         __locale_t __loc) throw ();
extern wchar_t *wcpcpy (wchar_t *__dest, __const wchar_t *__src) throw ();
extern wchar_t *wcpncpy (wchar_t *__dest, __const wchar_t *__src, size_t __n)
     throw ();
extern __FILE *open_wmemstream (wchar_t **__bufloc, size_t *__sizeloc) throw ();
extern int fwide (__FILE *__fp, int __mode) throw ();
extern int fwprintf (__FILE *__restrict __stream,
       __const wchar_t *__restrict __format, ...)
                                                           ;
extern int wprintf (__const wchar_t *__restrict __format, ...)
                                                           ;
extern int swprintf (wchar_t *__restrict __s, size_t __n,
       __const wchar_t *__restrict __format, ...)
     throw () ;
extern int vfwprintf (__FILE *__restrict __s,
        __const wchar_t *__restrict __format,
        __gnuc_va_list __arg)
                                                           ;
extern int vwprintf (__const wchar_t *__restrict __format,
       __gnuc_va_list __arg)
                                                           ;
extern int vswprintf (wchar_t *__restrict __s, size_t __n,
        __const wchar_t *__restrict __format,
        __gnuc_va_list __arg)
     throw () ;
extern int fwscanf (__FILE *__restrict __stream,
      __const wchar_t *__restrict __format, ...)
                                                          ;
extern int wscanf (__const wchar_t *__restrict __format, ...)
                                                          ;
extern int swscanf (__const wchar_t *__restrict __s,
      __const wchar_t *__restrict __format, ...)
     throw () ;
extern int vfwscanf (__FILE *__restrict __s,
       __const wchar_t *__restrict __format,
       __gnuc_va_list __arg)
                                                          ;
extern int vwscanf (__const wchar_t *__restrict __format,
      __gnuc_va_list __arg)
                                                          ;
extern int vswscanf (__const wchar_t *__restrict __s,
       __const wchar_t *__restrict __format,
       __gnuc_va_list __arg)
     throw () ;
extern wint_t fgetwc (__FILE *__stream);
extern wint_t getwc (__FILE *__stream);
extern wint_t getwchar (void);
extern wint_t fputwc (wchar_t __wc, __FILE *__stream);
extern wint_t putwc (wchar_t __wc, __FILE *__stream);
extern wint_t putwchar (wchar_t __wc);
extern wchar_t *fgetws (wchar_t *__restrict __ws, int __n,
   __FILE *__restrict __stream);
extern int fputws (__const wchar_t *__restrict __ws,
     __FILE *__restrict __stream);
extern wint_t ungetwc (wint_t __wc, __FILE *__stream);
extern wint_t getwc_unlocked (__FILE *__stream);
extern wint_t getwchar_unlocked (void);
extern wint_t fgetwc_unlocked (__FILE *__stream);
extern wint_t fputwc_unlocked (wchar_t __wc, __FILE *__stream);
extern wint_t putwc_unlocked (wchar_t __wc, __FILE *__stream);
extern wint_t putwchar_unlocked (wchar_t __wc);
extern wchar_t *fgetws_unlocked (wchar_t *__restrict __ws, int __n,
     __FILE *__restrict __stream);
extern int fputws_unlocked (__const wchar_t *__restrict __ws,
       __FILE *__restrict __stream);
extern size_t wcsftime (wchar_t *__restrict __s, size_t __maxsize,
   __const wchar_t *__restrict __format,
   __const struct tm *__restrict __tp) throw ();
extern size_t wcsftime_l (wchar_t *__restrict __s, size_t __maxsize,
     __const wchar_t *__restrict __format,
     __const struct tm *__restrict __tp,
     __locale_t __loc) throw ();
}
namespace std
{
  using ::mbstate_t;
}
namespace std
{
  using ::wint_t;
  using ::btowc;
  using ::fgetwc;
  using ::fgetws;
  using ::fputwc;
  using ::fputws;
  using ::fwide;
  using ::fwprintf;
  using ::fwscanf;
  using ::getwc;
  using ::getwchar;
  using ::mbrlen;
  using ::mbrtowc;
  using ::mbsinit;
  using ::mbsrtowcs;
  using ::putwc;
  using ::putwchar;
  using ::swprintf;
  using ::swscanf;
  using ::ungetwc;
  using ::vfwprintf;
  using ::vfwscanf;
  using ::vswprintf;
  using ::vswscanf;
  using ::vwprintf;
  using ::vwscanf;
  using ::wcrtomb;
  using ::wcscat;
  using ::wcscmp;
  using ::wcscoll;
  using ::wcscpy;
  using ::wcscspn;
  using ::wcslen;
  using ::wcsncat;
  using ::wcsncmp;
  using ::wcsncpy;
  using ::wcsrtombs;
  using ::wcsspn;
  using ::wcstod;
  using ::wcstof;
  using ::wcstok;
  using ::wcstol;
  using ::wcstoul;
  using ::wcsxfrm;
  using ::wctob;
  using ::wmemcmp;
  using ::wmemcpy;
  using ::wmemmove;
  using ::wmemset;
  using ::wprintf;
  using ::wscanf;
  using ::wcschr;
  inline wchar_t*
  wcschr(wchar_t* __p, wchar_t __c)
  { return wcschr(const_cast<const wchar_t*>(__p), __c); }
  using ::wcspbrk;
  inline wchar_t*
  wcspbrk(wchar_t* __s1, const wchar_t* __s2)
  { return wcspbrk(const_cast<const wchar_t*>(__s1), __s2); }
  using ::wcsrchr;
  inline wchar_t*
  wcsrchr(wchar_t* __p, wchar_t __c)
  { return wcsrchr(const_cast<const wchar_t*>(__p), __c); }
  using ::wcsstr;
  inline wchar_t*
  wcsstr(wchar_t* __s1, const wchar_t* __s2)
  { return wcsstr(const_cast<const wchar_t*>(__s1), __s2); }
  using ::wmemchr;
  inline wchar_t*
  wmemchr(wchar_t* __p, wchar_t __c, size_t __n)
  { return wmemchr(const_cast<const wchar_t*>(__p), __c, __n); }
}
namespace __gnu_cxx
{
  using ::wcstold;
  using ::wcstoll;
  using ::wcstoull;
}
namespace std
{
  using __gnu_cxx::wcstold;
  using __gnu_cxx::wcstoll;
  using __gnu_cxx::wcstoull;
}
typedef unsigned char uint8_t;
typedef unsigned short int uint16_t;
typedef unsigned int uint32_t;
__extension__
typedef unsigned long long int uint64_t;
typedef signed char int_least8_t;
typedef short int int_least16_t;
typedef int int_least32_t;
__extension__
typedef long long int int_least64_t;
typedef unsigned char uint_least8_t;
typedef unsigned short int uint_least16_t;
typedef unsigned int uint_least32_t;
__extension__
typedef unsigned long long int uint_least64_t;
typedef signed char int_fast8_t;
typedef int int_fast16_t;
typedef int int_fast32_t;
__extension__
typedef long long int int_fast64_t;
typedef unsigned char uint_fast8_t;
typedef unsigned int uint_fast16_t;
typedef unsigned int uint_fast32_t;
__extension__
typedef unsigned long long int uint_fast64_t;
typedef unsigned int uintptr_t;
__extension__
typedef long long int intmax_t;
__extension__
typedef unsigned long long int uintmax_t;
namespace std
{
  typedef int64_t streamoff;
  typedef ptrdiff_t streamsize;
  template<typename _StateT>
    class fpos;
  template<typename _StateT>
    class fpos
    {
    private:
      streamoff _M_off;
      _StateT _M_state;
    public:
      fpos()
      : _M_off(0), _M_state() { }
      fpos(streamoff __off)
      : _M_off(__off), _M_state() { }
      operator streamoff() const { return _M_off; }
      void
      state(_StateT __st)
      { _M_state = __st; }
      _StateT
      state() const
      { return _M_state; }
      bool
      operator==(const fpos& __other) const
      { return _M_off == __other._M_off; }
      bool
      operator!=(const fpos& __other) const
      { return _M_off != __other._M_off; }
      fpos&
      operator+=(streamoff __off)
      {
 _M_off += __off;
 return *this;
      }
      fpos&
      operator-=(streamoff __off)
      {
 _M_off -= __off;
 return *this;
      }
      fpos
      operator+(streamoff __off) const
      {
 fpos __pos(*this);
 __pos += __off;
 return __pos;
      }
      fpos
      operator-(streamoff __off) const
      {
 fpos __pos(*this);
 __pos -= __off;
 return __pos;
      }
      streamoff
      operator-(const fpos& __other) const
      { return _M_off - __other._M_off; }
    };
  typedef fpos<mbstate_t> streampos;
  typedef fpos<mbstate_t> wstreampos;
}
namespace std
{
  void
  __throw_bad_exception(void) __attribute__((__noreturn__));
  void
  __throw_bad_alloc(void) __attribute__((__noreturn__));
  void
  __throw_bad_cast(void) __attribute__((__noreturn__));
  void
  __throw_bad_typeid(void) __attribute__((__noreturn__));
  void
  __throw_logic_error(const char*) __attribute__((__noreturn__));
  void
  __throw_domain_error(const char*) __attribute__((__noreturn__));
  void
  __throw_invalid_argument(const char*) __attribute__((__noreturn__));
  void
  __throw_length_error(const char*) __attribute__((__noreturn__));
  void
  __throw_out_of_range(const char*) __attribute__((__noreturn__));
  void
  __throw_runtime_error(const char*) __attribute__((__noreturn__));
  void
  __throw_range_error(const char*) __attribute__((__noreturn__));
  void
  __throw_overflow_error(const char*) __attribute__((__noreturn__));
  void
  __throw_underflow_error(const char*) __attribute__((__noreturn__));
  void
  __throw_ios_failure(const char*) __attribute__((__noreturn__));
}
namespace std
{
  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ios;
  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_streambuf;
  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_istream;
  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ostream;
  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_iostream;
  template<typename _CharT, typename _Traits = char_traits<_CharT>,
     typename _Alloc = allocator<_CharT> >
    class basic_stringbuf;
  template<typename _CharT, typename _Traits = char_traits<_CharT>,
    typename _Alloc = allocator<_CharT> >
    class basic_istringstream;
  template<typename _CharT, typename _Traits = char_traits<_CharT>,
    typename _Alloc = allocator<_CharT> >
    class basic_ostringstream;
  template<typename _CharT, typename _Traits = char_traits<_CharT>,
    typename _Alloc = allocator<_CharT> >
    class basic_stringstream;
  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_filebuf;
  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ifstream;
  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ofstream;
  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_fstream;
  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class istreambuf_iterator;
  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class ostreambuf_iterator;
  class ios_base;
  typedef basic_ios<char> ios;
  typedef basic_streambuf<char> streambuf;
  typedef basic_istream<char> istream;
  typedef basic_ostream<char> ostream;
  typedef basic_iostream<char> iostream;
  typedef basic_stringbuf<char> stringbuf;
  typedef basic_istringstream<char> istringstream;
  typedef basic_ostringstream<char> ostringstream;
  typedef basic_stringstream<char> stringstream;
  typedef basic_filebuf<char> filebuf;
  typedef basic_ifstream<char> ifstream;
  typedef basic_ofstream<char> ofstream;
  typedef basic_fstream<char> fstream;
  typedef basic_ios<wchar_t> wios;
  typedef basic_streambuf<wchar_t> wstreambuf;
  typedef basic_istream<wchar_t> wistream;
  typedef basic_ostream<wchar_t> wostream;
  typedef basic_iostream<wchar_t> wiostream;
  typedef basic_stringbuf<wchar_t> wstringbuf;
  typedef basic_istringstream<wchar_t> wistringstream;
  typedef basic_ostringstream<wchar_t> wostringstream;
  typedef basic_stringstream<wchar_t> wstringstream;
  typedef basic_filebuf<wchar_t> wfilebuf;
  typedef basic_ifstream<wchar_t> wifstream;
  typedef basic_ofstream<wchar_t> wofstream;
  typedef basic_fstream<wchar_t> wfstream;
}
namespace std
{
  template<class _T1, class _T2>
    struct pair
    {
      typedef _T1 first_type;
      typedef _T2 second_type;
      _T1 first;
      _T2 second;
      pair()
      : first(), second() { }
      pair(const _T1& __a, const _T2& __b)
      : first(__a), second(__b) { }
      template<class _U1, class _U2>
        pair(const pair<_U1, _U2>& __p)
 : first(__p.first), second(__p.second) { }
    };
  template<class _T1, class _T2>
    inline bool
    operator==(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __x.first == __y.first && __x.second == __y.second; }
  template<class _T1, class _T2>
    inline bool
    operator<(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __x.first < __y.first
      || (!(__y.first < __x.first) && __x.second < __y.second); }
  template<class _T1, class _T2>
    inline bool
    operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__x == __y); }
  template<class _T1, class _T2>
    inline bool
    operator>(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __y < __x; }
  template<class _T1, class _T2>
    inline bool
    operator<=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__y < __x); }
  template<class _T1, class _T2>
    inline bool
    operator>=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__x < __y); }
  template<class _T1, class _T2>
    inline pair<_T1, _T2>
    make_pair(_T1 __x, _T2 __y)
    { return pair<_T1, _T2>(__x, __y); }
}
namespace __gnu_internal
{
  typedef char __one;
  typedef char __two[2];
  template<typename _Tp>
  __one __test_type(int _Tp::*);
  template<typename _Tp>
  __two& __test_type(...);
}
namespace __gnu_cxx
{
  template<typename _Iterator, typename _Container>
    class __normal_iterator;
}
struct __true_type { };
struct __false_type { };
namespace std
{
  template<bool>
    struct __truth_type
    { typedef __false_type __type; };
  template<>
    struct __truth_type<true>
    { typedef __true_type __type; };
  template<class _Sp, class _Tp>
    struct __traitor
    {
      enum { __value = bool(_Sp::__value) || bool(_Tp::__value) };
      typedef typename __truth_type<__value>::__type __type;
    };
  template<typename, typename>
    struct __are_same
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };
  template<typename _Tp>
    struct __are_same<_Tp, _Tp>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
  template<typename, bool>
    struct __enable_if
    {
    };
  template<typename _Tp>
    struct __enable_if<_Tp, true>
    {
      typedef _Tp __type;
    };
  template<typename _Tp>
    struct __is_void
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };
  template<>
    struct __is_void<void>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
  template<typename _Tp>
    struct __is_integer
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };
  template<>
    struct __is_integer<bool>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
  template<>
    struct __is_integer<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
  template<>
    struct __is_integer<signed char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
  template<>
    struct __is_integer<unsigned char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
  template<>
    struct __is_integer<wchar_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
  template<>
    struct __is_integer<short>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
  template<>
    struct __is_integer<unsigned short>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
  template<>
    struct __is_integer<int>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
  template<>
    struct __is_integer<unsigned int>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
  template<>
    struct __is_integer<long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
  template<>
    struct __is_integer<unsigned long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
  template<>
    struct __is_integer<long long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
  template<>
    struct __is_integer<unsigned long long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
  template<typename _Tp>
    struct __is_floating
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };
  template<>
    struct __is_floating<float>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
  template<>
    struct __is_floating<double>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
  template<>
    struct __is_floating<long double>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
  template<typename _Tp>
    struct __is_pointer
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };
  template<typename _Tp>
    struct __is_pointer<_Tp*>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
  template<typename _Tp>
    struct __is_normal_iterator
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };
  template<typename _Iterator, typename _Container>
    struct __is_normal_iterator< __gnu_cxx::__normal_iterator<_Iterator,
             _Container> >
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
  template<typename _Tp>
    struct __is_arithmetic
    : public __traitor<__is_integer<_Tp>, __is_floating<_Tp> >
    { };
  template<typename _Tp>
    struct __is_fundamental
    : public __traitor<__is_void<_Tp>, __is_arithmetic<_Tp> >
    { };
  template<typename _Tp>
    struct __is_scalar
    : public __traitor<__is_arithmetic<_Tp>, __is_pointer<_Tp> >
    { };
  template<typename _Tp>
    struct __is_pod
    {
      enum
 {
   __value = (sizeof(__gnu_internal::__test_type<_Tp>(0))
       != sizeof(__gnu_internal::__one))
 };
    };
  template<typename _Tp>
    struct __is_empty
    {
    private:
      template<typename>
        struct __first { };
      template<typename _Up>
        struct __second
        : public _Up { };
    public:
      enum
 {
   __value = sizeof(__first<_Tp>) == sizeof(__second<_Tp>)
 };
    };
}
namespace std
{
  struct input_iterator_tag {};
  struct output_iterator_tag {};
  struct forward_iterator_tag : public input_iterator_tag {};
  struct bidirectional_iterator_tag : public forward_iterator_tag {};
  struct random_access_iterator_tag : public bidirectional_iterator_tag {};
  template<typename _Category, typename _Tp, typename _Distance = ptrdiff_t,
           typename _Pointer = _Tp*, typename _Reference = _Tp&>
    struct iterator
    {
      typedef _Category iterator_category;
      typedef _Tp value_type;
      typedef _Distance difference_type;
      typedef _Pointer pointer;
      typedef _Reference reference;
    };
  template<typename _Iterator>
    struct iterator_traits
    {
      typedef typename _Iterator::iterator_category iterator_category;
      typedef typename _Iterator::value_type value_type;
      typedef typename _Iterator::difference_type difference_type;
      typedef typename _Iterator::pointer pointer;
      typedef typename _Iterator::reference reference;
    };
  template<typename _Tp>
    struct iterator_traits<_Tp*>
    {
      typedef random_access_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp* pointer;
      typedef _Tp& reference;
    };
  template<typename _Tp>
    struct iterator_traits<const _Tp*>
    {
      typedef random_access_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef ptrdiff_t difference_type;
      typedef const _Tp* pointer;
      typedef const _Tp& reference;
    };
  template<typename _Iter>
    inline typename iterator_traits<_Iter>::iterator_category
    __iterator_category(const _Iter&)
    { return typename iterator_traits<_Iter>::iterator_category(); }
}
namespace std
{
  template<typename _InputIterator>
    inline typename iterator_traits<_InputIterator>::difference_type
    __distance(_InputIterator __first, _InputIterator __last,
               input_iterator_tag)
    {
      typename iterator_traits<_InputIterator>::difference_type __n = 0;
      while (__first != __last)
 {
   ++__first;
   ++__n;
 }
      return __n;
    }
  template<typename _RandomAccessIterator>
    inline typename iterator_traits<_RandomAccessIterator>::difference_type
    __distance(_RandomAccessIterator __first, _RandomAccessIterator __last,
               random_access_iterator_tag)
    {
      return __last - __first;
    }
  template<typename _InputIterator>
    inline typename iterator_traits<_InputIterator>::difference_type
    distance(_InputIterator __first, _InputIterator __last)
    {
      return std::__distance(__first, __last,
        std::__iterator_category(__first));
    }
  template<typename _InputIterator, typename _Distance>
    inline void
    __advance(_InputIterator& __i, _Distance __n, input_iterator_tag)
    {
      while (__n--)
 ++__i;
    }
  template<typename _BidirectionalIterator, typename _Distance>
    inline void
    __advance(_BidirectionalIterator& __i, _Distance __n,
              bidirectional_iterator_tag)
    {
      if (__n > 0)
        while (__n--)
   ++__i;
      else
        while (__n++)
   --__i;
    }
  template<typename _RandomAccessIterator, typename _Distance>
    inline void
    __advance(_RandomAccessIterator& __i, _Distance __n,
              random_access_iterator_tag)
    {
      __i += __n;
    }
  template<typename _InputIterator, typename _Distance>
    inline void
    advance(_InputIterator& __i, _Distance __n)
    {
      std::__advance(__i, __n, std::__iterator_category(__i));
    }
}
namespace std
{
  template<typename _Iterator>
    class reverse_iterator
    : public iterator<typename iterator_traits<_Iterator>::iterator_category,
        typename iterator_traits<_Iterator>::value_type,
        typename iterator_traits<_Iterator>::difference_type,
        typename iterator_traits<_Iterator>::pointer,
                      typename iterator_traits<_Iterator>::reference>
    {
    protected:
      _Iterator current;
    public:
      typedef _Iterator iterator_type;
      typedef typename iterator_traits<_Iterator>::difference_type
              difference_type;
      typedef typename iterator_traits<_Iterator>::reference reference;
      typedef typename iterator_traits<_Iterator>::pointer pointer;
    public:
      reverse_iterator() : current() { }
      explicit
      reverse_iterator(iterator_type __x) : current(__x) { }
      reverse_iterator(const reverse_iterator& __x)
      : current(__x.current) { }
      template<typename _Iter>
        reverse_iterator(const reverse_iterator<_Iter>& __x)
 : current(__x.base()) { }
      iterator_type
      base() const
      { return current; }
      reference
      operator*() const
      {
 _Iterator __tmp = current;
 return *--__tmp;
      }
      pointer
      operator->() const
      { return &(operator*()); }
      reverse_iterator&
      operator++()
      {
 --current;
 return *this;
      }
      reverse_iterator
      operator++(int)
      {
 reverse_iterator __tmp = *this;
 --current;
 return __tmp;
      }
      reverse_iterator&
      operator--()
      {
 ++current;
 return *this;
      }
      reverse_iterator
      operator--(int)
      {
 reverse_iterator __tmp = *this;
 ++current;
 return __tmp;
      }
      reverse_iterator
      operator+(difference_type __n) const
      { return reverse_iterator(current - __n); }
      reverse_iterator&
      operator+=(difference_type __n)
      {
 current -= __n;
 return *this;
      }
      reverse_iterator
      operator-(difference_type __n) const
      { return reverse_iterator(current + __n); }
      reverse_iterator&
      operator-=(difference_type __n)
      {
 current += __n;
 return *this;
      }
      reference
      operator[](difference_type __n) const
      { return *(*this + __n); }
    };
  template<typename _Iterator>
    inline bool
    operator==(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return __x.base() == __y.base(); }
  template<typename _Iterator>
    inline bool
    operator<(const reverse_iterator<_Iterator>& __x,
       const reverse_iterator<_Iterator>& __y)
    { return __y.base() < __x.base(); }
  template<typename _Iterator>
    inline bool
    operator!=(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return !(__x == __y); }
  template<typename _Iterator>
    inline bool
    operator>(const reverse_iterator<_Iterator>& __x,
       const reverse_iterator<_Iterator>& __y)
    { return __y < __x; }
  template<typename _Iterator>
    inline bool
    operator<=(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return !(__y < __x); }
  template<typename _Iterator>
    inline bool
    operator>=(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return !(__x < __y); }
  template<typename _Iterator>
    inline typename reverse_iterator<_Iterator>::difference_type
    operator-(const reverse_iterator<_Iterator>& __x,
       const reverse_iterator<_Iterator>& __y)
    { return __y.base() - __x.base(); }
  template<typename _Iterator>
    inline reverse_iterator<_Iterator>
    operator+(typename reverse_iterator<_Iterator>::difference_type __n,
       const reverse_iterator<_Iterator>& __x)
    { return reverse_iterator<_Iterator>(__x.base() - __n); }
  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator==(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return __x.base() == __y.base(); }
  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator<(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)
    { return __y.base() < __x.base(); }
  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator!=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return !(__x == __y); }
  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator>(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)
    { return __y < __x; }
  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator<=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return !(__y < __x); }
  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator>=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return !(__x < __y); }
  template<typename _IteratorL, typename _IteratorR>
    inline typename reverse_iterator<_IteratorL>::difference_type
    operator-(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)
    { return __y.base() - __x.base(); }
  template<typename _Container>
    class back_insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;
    public:
      typedef _Container container_type;
      explicit
      back_insert_iterator(_Container& __x) : container(&__x) { }
      back_insert_iterator&
      operator=(typename _Container::const_reference __value)
      {
 container->push_back(__value);
 return *this;
      }
      back_insert_iterator&
      operator*()
      { return *this; }
      back_insert_iterator&
      operator++()
      { return *this; }
      back_insert_iterator
      operator++(int)
      { return *this; }
    };
  template<typename _Container>
    inline back_insert_iterator<_Container>
    back_inserter(_Container& __x)
    { return back_insert_iterator<_Container>(__x); }
  template<typename _Container>
    class front_insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;
    public:
      typedef _Container container_type;
      explicit front_insert_iterator(_Container& __x) : container(&__x) { }
      front_insert_iterator&
      operator=(typename _Container::const_reference __value)
      {
 container->push_front(__value);
 return *this;
      }
      front_insert_iterator&
      operator*()
      { return *this; }
      front_insert_iterator&
      operator++()
      { return *this; }
      front_insert_iterator
      operator++(int)
      { return *this; }
    };
  template<typename _Container>
    inline front_insert_iterator<_Container>
    front_inserter(_Container& __x)
    { return front_insert_iterator<_Container>(__x); }
  template<typename _Container>
    class insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;
      typename _Container::iterator iter;
    public:
      typedef _Container container_type;
      insert_iterator(_Container& __x, typename _Container::iterator __i)
      : container(&__x), iter(__i) {}
      insert_iterator&
      operator=(const typename _Container::const_reference __value)
      {
 iter = container->insert(iter, __value);
 ++iter;
 return *this;
      }
      insert_iterator&
      operator*()
      { return *this; }
      insert_iterator&
      operator++()
      { return *this; }
      insert_iterator&
      operator++(int)
      { return *this; }
    };
  template<typename _Container, typename _Iterator>
    inline insert_iterator<_Container>
    inserter(_Container& __x, _Iterator __i)
    {
      return insert_iterator<_Container>(__x,
      typename _Container::iterator(__i));
    }
}
namespace __gnu_cxx
{
  using std::iterator_traits;
  using std::iterator;
  template<typename _Iterator, typename _Container>
    class __normal_iterator
    {
    protected:
      _Iterator _M_current;
    public:
      typedef typename iterator_traits<_Iterator>::iterator_category
                                                             iterator_category;
      typedef typename iterator_traits<_Iterator>::value_type value_type;
      typedef typename iterator_traits<_Iterator>::difference_type
                                                             difference_type;
      typedef typename iterator_traits<_Iterator>::reference reference;
      typedef typename iterator_traits<_Iterator>::pointer pointer;
      __normal_iterator() : _M_current(_Iterator()) { }
      explicit
      __normal_iterator(const _Iterator& __i) : _M_current(__i) { }
      template<typename _Iter>
        __normal_iterator(const __normal_iterator<_Iter,
     typename std::__enable_if<_Container,
     (std::__are_same<_Iter,
      typename _Container::pointer>::__value)
     >::__type>& __i)
        : _M_current(__i.base()) { }
      reference
      operator*() const
      { return *_M_current; }
      pointer
      operator->() const
      { return _M_current; }
      __normal_iterator&
      operator++()
      {
 ++_M_current;
 return *this;
      }
      __normal_iterator
      operator++(int)
      { return __normal_iterator(_M_current++); }
      __normal_iterator&
      operator--()
      {
 --_M_current;
 return *this;
      }
      __normal_iterator
      operator--(int)
      { return __normal_iterator(_M_current--); }
      reference
      operator[](const difference_type& __n) const
      { return _M_current[__n]; }
      __normal_iterator&
      operator+=(const difference_type& __n)
      { _M_current += __n; return *this; }
      __normal_iterator
      operator+(const difference_type& __n) const
      { return __normal_iterator(_M_current + __n); }
      __normal_iterator&
      operator-=(const difference_type& __n)
      { _M_current -= __n; return *this; }
      __normal_iterator
      operator-(const difference_type& __n) const
      { return __normal_iterator(_M_current - __n); }
      const _Iterator&
      base() const
      { return _M_current; }
    };
  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator==(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() == __rhs.base(); }
  template<typename _Iterator, typename _Container>
    inline bool
    operator==(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() == __rhs.base(); }
  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator!=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() != __rhs.base(); }
  template<typename _Iterator, typename _Container>
    inline bool
    operator!=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() != __rhs.base(); }
  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator<(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() < __rhs.base(); }
  template<typename _Iterator, typename _Container>
    inline bool
    operator<(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() < __rhs.base(); }
  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator>(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() > __rhs.base(); }
  template<typename _Iterator, typename _Container>
    inline bool
    operator>(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() > __rhs.base(); }
  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator<=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() <= __rhs.base(); }
  template<typename _Iterator, typename _Container>
    inline bool
    operator<=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() <= __rhs.base(); }
  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator>=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() >= __rhs.base(); }
  template<typename _Iterator, typename _Container>
    inline bool
    operator>=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() >= __rhs.base(); }
  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline typename __normal_iterator<_IteratorL, _Container>::difference_type
    operator-(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() - __rhs.base(); }
  template<typename _Iterator, typename _Container>
    inline __normal_iterator<_Iterator, _Container>
    operator+(typename __normal_iterator<_Iterator, _Container>::difference_type
       __n, const __normal_iterator<_Iterator, _Container>& __i)
    { return __normal_iterator<_Iterator, _Container>(__i.base() + __n); }
}
namespace std
{
  template<typename _Tp>
    inline void
    swap(_Tp& __a, _Tp& __b)
    {
      _Tp __tmp = __a;
      __a = __b;
      __b = __tmp;
    }
  template<bool _BoolType>
    struct __iter_swap
    {
      template<typename _ForwardIterator1, typename _ForwardIterator2>
        static void
        iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
        {
          typedef typename iterator_traits<_ForwardIterator1>::value_type
            _ValueType1;
          _ValueType1 __tmp = *__a;
          *__a = *__b;
          *__b = __tmp;
 }
    };
  template<>
    struct __iter_swap<true>
    {
      template<typename _ForwardIterator1, typename _ForwardIterator2>
        static void
        iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
        {
          swap(*__a, *__b);
        }
    };
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    inline void
    iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
    {
      typedef typename iterator_traits<_ForwardIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_ForwardIterator2>::value_type
 _ValueType2;
      typedef typename iterator_traits<_ForwardIterator1>::reference
 _ReferenceType1;
      typedef typename iterator_traits<_ForwardIterator2>::reference
 _ReferenceType2;
      std::__iter_swap<__are_same<_ValueType1, _ValueType2>::__value &&
 __are_same<_ValueType1 &, _ReferenceType1>::__value &&
 __are_same<_ValueType2 &, _ReferenceType2>::__value>::
 iter_swap(__a, __b);
    }
  template<typename _Tp>
    inline const _Tp&
    min(const _Tp& __a, const _Tp& __b)
    {
      if (__b < __a)
 return __b;
      return __a;
    }
  template<typename _Tp>
    inline const _Tp&
    max(const _Tp& __a, const _Tp& __b)
    {
      if (__a < __b)
 return __b;
      return __a;
    }
  template<typename _Tp, typename _Compare>
    inline const _Tp&
    min(const _Tp& __a, const _Tp& __b, _Compare __comp)
    {
      if (__comp(__b, __a))
 return __b;
      return __a;
    }
  template<typename _Tp, typename _Compare>
    inline const _Tp&
    max(const _Tp& __a, const _Tp& __b, _Compare __comp)
    {
      if (__comp(__a, __b))
 return __b;
      return __a;
    }
  template<bool, typename>
    struct __copy
    {
      template<typename _II, typename _OI>
        static _OI
        copy(_II __first, _II __last, _OI __result)
        {
   for (; __first != __last; ++__result, ++__first)
     *__result = *__first;
   return __result;
 }
    };
  template<bool _BoolType>
    struct __copy<_BoolType, random_access_iterator_tag>
    {
      template<typename _II, typename _OI>
        static _OI
        copy(_II __first, _II __last, _OI __result)
        {
   typedef typename iterator_traits<_II>::difference_type _Distance;
   for(_Distance __n = __last - __first; __n > 0; --__n)
     {
       *__result = *__first;
       ++__first;
       ++__result;
     }
   return __result;
 }
    };
  template<>
    struct __copy<true, random_access_iterator_tag>
    {
      template<typename _Tp>
        static _Tp*
        copy(const _Tp* __first, const _Tp* __last, _Tp* __result)
        {
   std::memmove(__result, __first, sizeof(_Tp) * (__last - __first));
   return __result + (__last - __first);
 }
    };
  template<typename _II, typename _OI>
    inline _OI
    __copy_aux(_II __first, _II __last, _OI __result)
    {
      typedef typename iterator_traits<_II>::value_type _ValueTypeI;
      typedef typename iterator_traits<_OI>::value_type _ValueTypeO;
      typedef typename iterator_traits<_II>::iterator_category _Category;
      const bool __simple = (__is_scalar<_ValueTypeI>::__value
                      && __is_pointer<_II>::__value
                      && __is_pointer<_OI>::__value
        && __are_same<_ValueTypeI, _ValueTypeO>::__value);
      return std::__copy<__simple, _Category>::copy(__first, __last, __result);
    }
  template<bool, bool>
    struct __copy_normal
    {
      template<typename _II, typename _OI>
        static _OI
        copy_n(_II __first, _II __last, _OI __result)
        { return std::__copy_aux(__first, __last, __result); }
    };
  template<>
    struct __copy_normal<true, false>
    {
      template<typename _II, typename _OI>
        static _OI
        copy_n(_II __first, _II __last, _OI __result)
        { return std::__copy_aux(__first.base(), __last.base(), __result); }
    };
  template<>
    struct __copy_normal<false, true>
    {
      template<typename _II, typename _OI>
        static _OI
        copy_n(_II __first, _II __last, _OI __result)
        { return _OI(std::__copy_aux(__first, __last, __result.base())); }
    };
  template<>
    struct __copy_normal<true, true>
    {
      template<typename _II, typename _OI>
        static _OI
        copy_n(_II __first, _II __last, _OI __result)
        { return _OI(std::__copy_aux(__first.base(), __last.base(),
         __result.base())); }
    };
  template<typename _InputIterator, typename _OutputIterator>
    inline _OutputIterator
    copy(_InputIterator __first, _InputIterator __last,
  _OutputIterator __result)
    {
      ;
       const bool __in = __is_normal_iterator<_InputIterator>::__value;
       const bool __out = __is_normal_iterator<_OutputIterator>::__value;
       return std::__copy_normal<__in, __out>::copy_n(__first, __last,
            __result);
    }
  template<bool, typename>
    struct __copy_backward
    {
      template<typename _BI1, typename _BI2>
        static _BI2
        copy_b(_BI1 __first, _BI1 __last, _BI2 __result)
        {
   while (__first != __last)
     *--__result = *--__last;
   return __result;
 }
    };
  template<bool _BoolType>
    struct __copy_backward<_BoolType, random_access_iterator_tag>
    {
      template<typename _BI1, typename _BI2>
        static _BI2
        copy_b(_BI1 __first, _BI1 __last, _BI2 __result)
        {
   typename iterator_traits<_BI1>::difference_type __n;
   for (__n = __last - __first; __n > 0; --__n)
     *--__result = *--__last;
   return __result;
 }
    };
  template<>
    struct __copy_backward<true, random_access_iterator_tag>
    {
      template<typename _Tp>
        static _Tp*
        copy_b(const _Tp* __first, const _Tp* __last, _Tp* __result)
        {
   const ptrdiff_t _Num = __last - __first;
   std::memmove(__result - _Num, __first, sizeof(_Tp) * _Num);
   return __result - _Num;
 }
    };
  template<typename _BI1, typename _BI2>
    inline _BI2
    __copy_backward_aux(_BI1 __first, _BI1 __last, _BI2 __result)
    {
      typedef typename iterator_traits<_BI1>::value_type _ValueType1;
      typedef typename iterator_traits<_BI2>::value_type _ValueType2;
      typedef typename iterator_traits<_BI1>::iterator_category _Category;
      const bool __simple = (__is_scalar<_ValueType1>::__value
                      && __is_pointer<_BI1>::__value
                      && __is_pointer<_BI2>::__value
        && __are_same<_ValueType1, _ValueType2>::__value);
      return std::__copy_backward<__simple, _Category>::copy_b(__first, __last,
              __result);
    }
  template<bool, bool>
    struct __copy_backward_normal
    {
      template<typename _BI1, typename _BI2>
        static _BI2
        copy_b_n(_BI1 __first, _BI1 __last, _BI2 __result)
        { return std::__copy_backward_aux(__first, __last, __result); }
    };
  template<>
    struct __copy_backward_normal<true, false>
    {
      template<typename _BI1, typename _BI2>
        static _BI2
        copy_b_n(_BI1 __first, _BI1 __last, _BI2 __result)
        { return std::__copy_backward_aux(__first.base(), __last.base(),
       __result); }
    };
  template<>
    struct __copy_backward_normal<false, true>
    {
      template<typename _BI1, typename _BI2>
        static _BI2
        copy_b_n(_BI1 __first, _BI1 __last, _BI2 __result)
        { return _BI2(std::__copy_backward_aux(__first, __last,
            __result.base())); }
    };
  template<>
    struct __copy_backward_normal<true, true>
    {
      template<typename _BI1, typename _BI2>
        static _BI2
        copy_b_n(_BI1 __first, _BI1 __last, _BI2 __result)
        { return _BI2(std::__copy_backward_aux(__first.base(), __last.base(),
            __result.base())); }
    };
  template <typename _BI1, typename _BI2>
    inline _BI2
    copy_backward(_BI1 __first, _BI1 __last, _BI2 __result)
    {
      ;
      const bool __bi1 = __is_normal_iterator<_BI1>::__value;
      const bool __bi2 = __is_normal_iterator<_BI2>::__value;
      return std::__copy_backward_normal<__bi1, __bi2>::copy_b_n(__first, __last,
         __result);
    }
  template<bool>
    struct __fill
    {
      template<typename _ForwardIterator, typename _Tp>
        static void
        fill(_ForwardIterator __first, _ForwardIterator __last,
      const _Tp& __value)
        {
   for (; __first != __last; ++__first)
     *__first = __value;
 }
    };
  template<>
    struct __fill<true>
    {
      template<typename _ForwardIterator, typename _Tp>
        static void
        fill(_ForwardIterator __first, _ForwardIterator __last,
      const _Tp& __value)
        {
   const _Tp __tmp = __value;
   for (; __first != __last; ++__first)
     *__first = __tmp;
 }
    };
  template<typename _ForwardIterator, typename _Tp>
    void
    fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value)
    {
      ;
      const bool __scalar = __is_scalar<_Tp>::__value;
      std::__fill<__scalar>::fill(__first, __last, __value);
    }
  inline void
  fill(unsigned char* __first, unsigned char* __last, const unsigned char& __c)
  {
    ;
    const unsigned char __tmp = __c;
    std::memset(__first, __tmp, __last - __first);
  }
  inline void
  fill(signed char* __first, signed char* __last, const signed char& __c)
  {
    ;
    const signed char __tmp = __c;
    std::memset(__first, static_cast<unsigned char>(__tmp), __last - __first);
  }
  inline void
  fill(char* __first, char* __last, const char& __c)
  {
    ;
    const char __tmp = __c;
    std::memset(__first, static_cast<unsigned char>(__tmp), __last - __first);
  }
  template<bool>
    struct __fill_n
    {
      template<typename _OutputIterator, typename _Size, typename _Tp>
        static _OutputIterator
        fill_n(_OutputIterator __first, _Size __n, const _Tp& __value)
        {
   for (; __n > 0; --__n, ++__first)
     *__first = __value;
   return __first;
 }
    };
  template<>
    struct __fill_n<true>
    {
      template<typename _OutputIterator, typename _Size, typename _Tp>
        static _OutputIterator
        fill_n(_OutputIterator __first, _Size __n, const _Tp& __value)
        {
   const _Tp __tmp = __value;
   for (; __n > 0; --__n, ++__first)
     *__first = __tmp;
   return __first;
 }
    };
  template<typename _OutputIterator, typename _Size, typename _Tp>
    _OutputIterator
    fill_n(_OutputIterator __first, _Size __n, const _Tp& __value)
    {
      const bool __scalar = __is_scalar<_Tp>::__value;
      return std::__fill_n<__scalar>::fill_n(__first, __n, __value);
    }
  template<typename _Size>
    inline unsigned char*
    fill_n(unsigned char* __first, _Size __n, const unsigned char& __c)
    {
      std::fill(__first, __first + __n, __c);
      return __first + __n;
    }
  template<typename _Size>
    inline signed char*
    fill_n(char* __first, _Size __n, const signed char& __c)
    {
      std::fill(__first, __first + __n, __c);
      return __first + __n;
    }
  template<typename _Size>
    inline char*
    fill_n(char* __first, _Size __n, const char& __c)
    {
      std::fill(__first, __first + __n, __c);
      return __first + __n;
    }
  template<typename _InputIterator1, typename _InputIterator2>
    pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2)
    {
      ;
      while (__first1 != __last1 && *__first1 == *__first2)
        {
   ++__first1;
   ++__first2;
        }
      return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
    }
  template<typename _InputIterator1, typename _InputIterator2,
    typename _BinaryPredicate>
    pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _BinaryPredicate __binary_pred)
    {
      ;
      while (__first1 != __last1 && __binary_pred(*__first1, *__first2))
        {
   ++__first1;
   ++__first2;
        }
      return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
    }
  template<typename _InputIterator1, typename _InputIterator2>
    inline bool
    equal(_InputIterator1 __first1, _InputIterator1 __last1,
   _InputIterator2 __first2)
    {
      ;
      for (; __first1 != __last1; ++__first1, ++__first2)
 if (!(*__first1 == *__first2))
   return false;
      return true;
    }
  template<typename _InputIterator1, typename _InputIterator2,
    typename _BinaryPredicate>
    inline bool
    equal(_InputIterator1 __first1, _InputIterator1 __last1,
   _InputIterator2 __first2,
   _BinaryPredicate __binary_pred)
    {
      ;
      for (; __first1 != __last1; ++__first1, ++__first2)
 if (!__binary_pred(*__first1, *__first2))
   return false;
      return true;
    }
  template<typename _InputIterator1, typename _InputIterator2>
    bool
    lexicographical_compare(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2)
    {
      ;
      ;
      for (; __first1 != __last1 && __first2 != __last2;
    ++__first1, ++__first2)
 {
   if (*__first1 < *__first2)
     return true;
   if (*__first2 < *__first1)
     return false;
 }
      return __first1 == __last1 && __first2 != __last2;
    }
  template<typename _InputIterator1, typename _InputIterator2,
    typename _Compare>
    bool
    lexicographical_compare(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2,
       _Compare __comp)
    {
      ;
      ;
      for (; __first1 != __last1 && __first2 != __last2;
    ++__first1, ++__first2)
 {
   if (__comp(*__first1, *__first2))
     return true;
   if (__comp(*__first2, *__first1))
     return false;
 }
      return __first1 == __last1 && __first2 != __last2;
    }
  inline bool
  lexicographical_compare(const unsigned char* __first1,
     const unsigned char* __last1,
     const unsigned char* __first2,
     const unsigned char* __last2)
  {
    ;
    ;
    const size_t __len1 = __last1 - __first1;
    const size_t __len2 = __last2 - __first2;
    const int __result = std::memcmp(__first1, __first2,
         std::min(__len1, __len2));
    return __result != 0 ? __result < 0 : __len1 < __len2;
  }
  inline bool
  lexicographical_compare(const char* __first1, const char* __last1,
     const char* __first2, const char* __last2)
  {
    ;
    ;
    return std::lexicographical_compare((const signed char*) __first1,
     (const signed char*) __last1,
     (const signed char*) __first2,
     (const signed char*) __last2);
  }
}
extern "C++" {
namespace std
{
  class exception
  {
  public:
    exception() throw() { }
    virtual ~exception() throw();
    virtual const char* what() const throw();
  };
  class bad_exception : public exception
  {
  public:
    bad_exception() throw() { }
    virtual ~bad_exception() throw();
  };
  typedef void (*terminate_handler) ();
  typedef void (*unexpected_handler) ();
  terminate_handler set_terminate(terminate_handler) throw();
  void terminate() __attribute__ ((__noreturn__));
  unexpected_handler set_unexpected(unexpected_handler) throw();
  void unexpected() __attribute__ ((__noreturn__));
  bool uncaught_exception() throw();
}
namespace __gnu_cxx
{
  void __verbose_terminate_handler ();
}
}
extern "C++" {
namespace std
{
  class bad_alloc : public exception
  {
  public:
    bad_alloc() throw() { }
    virtual ~bad_alloc() throw();
  };
  struct nothrow_t { };
  extern const nothrow_t nothrow;
  typedef void (*new_handler)();
  new_handler set_new_handler(new_handler) throw();
}
void* operator new(std::size_t) throw (std::bad_alloc);
void* operator new[](std::size_t) throw (std::bad_alloc);
void operator delete(void*) throw();
void operator delete[](void*) throw();
void* operator new(std::size_t, const std::nothrow_t&) throw();
void* operator new[](std::size_t, const std::nothrow_t&) throw();
void operator delete(void*, const std::nothrow_t&) throw();
void operator delete[](void*, const std::nothrow_t&) throw();
inline void* operator new(std::size_t, void* __p) throw() { return __p; }
inline void* operator new[](std::size_t, void* __p) throw() { return __p; }
inline void operator delete (void*, void*) throw() { }
inline void operator delete[](void*, void*) throw() { }
}
namespace std
{
  template<typename _T1, typename _T2>
    inline void
    _Construct(_T1* __p, const _T2& __value)
    {
      ::new(static_cast<void*>(__p)) _T1(__value);
    }
  template<typename _T1>
    inline void
    _Construct(_T1* __p)
    {
      ::new(static_cast<void*>(__p)) _T1();
    }
  template<typename _Tp>
    inline void
    _Destroy(_Tp* __pointer)
    { __pointer->~_Tp(); }
  template<typename _ForwardIterator>
    inline void
    __destroy_aux(_ForwardIterator __first, _ForwardIterator __last,
    __false_type)
    {
      for (; __first != __last; ++__first)
 std::_Destroy(&*__first);
    }
  template<typename _ForwardIterator>
    inline void
    __destroy_aux(_ForwardIterator, _ForwardIterator, __true_type)
    { }
  template<typename _ForwardIterator>
    inline void
    _Destroy(_ForwardIterator __first, _ForwardIterator __last)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
                       _Value_type;
      typedef typename std::__is_scalar<_Value_type>::__type
                _Has_trivial_destructor;
      std::__destroy_aux(__first, __last, _Has_trivial_destructor());
    }
  template <typename _Tp> class allocator;
  template<typename _ForwardIterator, typename _Allocator>
    void
    _Destroy(_ForwardIterator __first, _ForwardIterator __last,
      _Allocator __alloc)
    {
      for (; __first != __last; ++__first)
 __alloc.destroy(&*__first);
    }
  template<typename _ForwardIterator, typename _Tp>
    inline void
    _Destroy(_ForwardIterator __first, _ForwardIterator __last,
      allocator<_Tp>)
    {
      _Destroy(__first, __last);
    }
}
namespace std
{
  template<typename _InputIterator, typename _ForwardIterator>
    inline _ForwardIterator
    __uninitialized_copy_aux(_InputIterator __first, _InputIterator __last,
        _ForwardIterator __result,
        __true_type)
    { return std::copy(__first, __last, __result); }
  template<typename _InputIterator, typename _ForwardIterator>
    inline _ForwardIterator
    __uninitialized_copy_aux(_InputIterator __first, _InputIterator __last,
        _ForwardIterator __result,
        __false_type)
    {
      _ForwardIterator __cur = __result;
      try
 {
   for (; __first != __last; ++__first, ++__cur)
     std::_Construct(&*__cur, *__first);
   return __cur;
 }
      catch(...)
 {
   std::_Destroy(__result, __cur);
   throw;
 }
    }
  template<typename _InputIterator, typename _ForwardIterator>
    inline _ForwardIterator
    uninitialized_copy(_InputIterator __first, _InputIterator __last,
         _ForwardIterator __result)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type _ValueType;
      typedef typename std::__is_scalar<_ValueType>::__type _Is_POD;
      return std::__uninitialized_copy_aux(__first, __last, __result,
        _Is_POD());
    }
  inline char*
  uninitialized_copy(const char* __first, const char* __last, char* __result)
  {
    std::memmove(__result, __first, __last - __first);
    return __result + (__last - __first);
  }
  inline wchar_t*
  uninitialized_copy(const wchar_t* __first, const wchar_t* __last,
       wchar_t* __result)
  {
    std::memmove(__result, __first, sizeof(wchar_t) * (__last - __first));
    return __result + (__last - __first);
  }
  template<typename _ForwardIterator, typename _Tp>
    inline void
    __uninitialized_fill_aux(_ForwardIterator __first,
        _ForwardIterator __last,
        const _Tp& __x, __true_type)
    { std::fill(__first, __last, __x); }
  template<typename _ForwardIterator, typename _Tp>
    void
    __uninitialized_fill_aux(_ForwardIterator __first, _ForwardIterator __last,
        const _Tp& __x, __false_type)
    {
      _ForwardIterator __cur = __first;
      try
 {
   for (; __cur != __last; ++__cur)
     std::_Construct(&*__cur, __x);
 }
      catch(...)
 {
   std::_Destroy(__first, __cur);
   throw;
 }
    }
  template<typename _ForwardIterator, typename _Tp>
    inline void
    uninitialized_fill(_ForwardIterator __first, _ForwardIterator __last,
         const _Tp& __x)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type _ValueType;
      typedef typename std::__is_scalar<_ValueType>::__type _Is_POD;
      std::__uninitialized_fill_aux(__first, __last, __x, _Is_POD());
    }
  template<typename _ForwardIterator, typename _Size, typename _Tp>
    inline void
    __uninitialized_fill_n_aux(_ForwardIterator __first, _Size __n,
          const _Tp& __x, __true_type)
    { std::fill_n(__first, __n, __x); }
  template<typename _ForwardIterator, typename _Size, typename _Tp>
    void
    __uninitialized_fill_n_aux(_ForwardIterator __first, _Size __n,
          const _Tp& __x, __false_type)
    {
      _ForwardIterator __cur = __first;
      try
 {
   for (; __n > 0; --__n, ++__cur)
     std::_Construct(&*__cur, __x);
 }
      catch(...)
 {
   std::_Destroy(__first, __cur);
   throw;
 }
    }
  template<typename _ForwardIterator, typename _Size, typename _Tp>
    inline void
    uninitialized_fill_n(_ForwardIterator __first, _Size __n, const _Tp& __x)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type _ValueType;
      typedef typename std::__is_scalar<_ValueType>::__type _Is_POD;
      std::__uninitialized_fill_n_aux(__first, __n, __x, _Is_POD());
    }
  template<typename _InputIterator, typename _ForwardIterator,
    typename _Allocator>
    _ForwardIterator
    __uninitialized_copy_a(_InputIterator __first, _InputIterator __last,
      _ForwardIterator __result,
      _Allocator __alloc)
    {
      _ForwardIterator __cur = __result;
      try
 {
   for (; __first != __last; ++__first, ++__cur)
     __alloc.construct(&*__cur, *__first);
   return __cur;
 }
      catch(...)
 {
   std::_Destroy(__result, __cur, __alloc);
   throw;
 }
    }
  template<typename _InputIterator, typename _ForwardIterator, typename _Tp>
    inline _ForwardIterator
    __uninitialized_copy_a(_InputIterator __first, _InputIterator __last,
      _ForwardIterator __result,
      allocator<_Tp>)
    {
      return std::uninitialized_copy(__first, __last, __result);
    }
  template<typename _ForwardIterator, typename _Tp, typename _Allocator>
    void
    __uninitialized_fill_a(_ForwardIterator __first, _ForwardIterator __last,
      const _Tp& __x, _Allocator __alloc)
    {
      _ForwardIterator __cur = __first;
      try
 {
   for (; __cur != __last; ++__cur)
     __alloc.construct(&*__cur, __x);
 }
      catch(...)
 {
   std::_Destroy(__first, __cur, __alloc);
   throw;
 }
    }
  template<typename _ForwardIterator, typename _Tp, typename _Tp2>
    inline void
    __uninitialized_fill_a(_ForwardIterator __first, _ForwardIterator __last,
      const _Tp& __x, allocator<_Tp2>)
    {
      std::uninitialized_fill(__first, __last, __x);
    }
  template<typename _ForwardIterator, typename _Size, typename _Tp,
    typename _Allocator>
    void
    __uninitialized_fill_n_a(_ForwardIterator __first, _Size __n,
        const _Tp& __x,
        _Allocator __alloc)
    {
      _ForwardIterator __cur = __first;
      try
 {
   for (; __n > 0; --__n, ++__cur)
     __alloc.construct(&*__cur, __x);
 }
      catch(...)
 {
   std::_Destroy(__first, __cur, __alloc);
   throw;
 }
    }
  template<typename _ForwardIterator, typename _Size, typename _Tp,
    typename _Tp2>
    void
    __uninitialized_fill_n_a(_ForwardIterator __first, _Size __n,
        const _Tp& __x,
        allocator<_Tp2>)
    {
      std::uninitialized_fill_n(__first, __n, __x);
    }
  template<typename _InputIterator1, typename _InputIterator2,
    typename _ForwardIterator, typename _Allocator>
    inline _ForwardIterator
    __uninitialized_copy_copy(_InputIterator1 __first1,
         _InputIterator1 __last1,
         _InputIterator2 __first2,
         _InputIterator2 __last2,
         _ForwardIterator __result,
         _Allocator __alloc)
    {
      _ForwardIterator __mid = std::__uninitialized_copy_a(__first1, __last1,
          __result,
          __alloc);
      try
 {
   return std::__uninitialized_copy_a(__first2, __last2, __mid, __alloc);
 }
      catch(...)
 {
   std::_Destroy(__result, __mid, __alloc);
   throw;
 }
    }
  template<typename _ForwardIterator, typename _Tp, typename _InputIterator,
    typename _Allocator>
    inline _ForwardIterator
    __uninitialized_fill_copy(_ForwardIterator __result, _ForwardIterator __mid,
         const _Tp& __x, _InputIterator __first,
         _InputIterator __last,
         _Allocator __alloc)
    {
      std::__uninitialized_fill_a(__result, __mid, __x, __alloc);
      try
 {
   return std::__uninitialized_copy_a(__first, __last, __mid, __alloc);
 }
      catch(...)
 {
   std::_Destroy(__result, __mid, __alloc);
   throw;
 }
    }
  template<typename _InputIterator, typename _ForwardIterator, typename _Tp,
    typename _Allocator>
    inline void
    __uninitialized_copy_fill(_InputIterator __first1, _InputIterator __last1,
         _ForwardIterator __first2,
         _ForwardIterator __last2, const _Tp& __x,
         _Allocator __alloc)
    {
      _ForwardIterator __mid2 = std::__uninitialized_copy_a(__first1, __last1,
           __first2,
           __alloc);
      try
 {
   std::__uninitialized_fill_a(__mid2, __last2, __x, __alloc);
 }
      catch(...)
 {
   std::_Destroy(__first2, __mid2, __alloc);
   throw;
 }
    }
}
namespace std
{
  template<typename _RandomAccessIterator, typename _Distance>
    bool
    __is_heap(_RandomAccessIterator __first, _Distance __n)
    {
      _Distance __parent = 0;
      for (_Distance __child = 1; __child < __n; ++__child)
 {
   if (__first[__parent] < __first[__child])
     return false;
   if ((__child & 1) == 0)
     ++__parent;
 }
      return true;
    }
  template<typename _RandomAccessIterator, typename _Distance,
           typename _StrictWeakOrdering>
    bool
    __is_heap(_RandomAccessIterator __first, _StrictWeakOrdering __comp,
       _Distance __n)
    {
      _Distance __parent = 0;
      for (_Distance __child = 1; __child < __n; ++__child)
 {
   if (__comp(__first[__parent], __first[__child]))
     return false;
   if ((__child & 1) == 0)
     ++__parent;
 }
      return true;
    }
  template<typename _RandomAccessIterator>
    bool
    __is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    { return std::__is_heap(__first, std::distance(__first, __last)); }
  template<typename _RandomAccessIterator, typename _StrictWeakOrdering>
    bool
    __is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
     _StrictWeakOrdering __comp)
    { return std::__is_heap(__first, __comp, std::distance(__first, __last)); }
  template<typename _RandomAccessIterator, typename _Distance, typename _Tp>
    void
    __push_heap(_RandomAccessIterator __first,
  _Distance __holeIndex, _Distance __topIndex, _Tp __value)
    {
      _Distance __parent = (__holeIndex - 1) / 2;
      while (__holeIndex > __topIndex && *(__first + __parent) < __value)
 {
   *(__first + __holeIndex) = *(__first + __parent);
   __holeIndex = __parent;
   __parent = (__holeIndex - 1) / 2;
 }
      *(__first + __holeIndex) = __value;
    }
  template<typename _RandomAccessIterator>
    inline void
    push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
   _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
   _DistanceType;
      ;
      std::__push_heap(__first, _DistanceType((__last - __first) - 1),
         _DistanceType(0), _ValueType(*(__last - 1)));
    }
  template<typename _RandomAccessIterator, typename _Distance, typename _Tp,
     typename _Compare>
    void
    __push_heap(_RandomAccessIterator __first, _Distance __holeIndex,
  _Distance __topIndex, _Tp __value, _Compare __comp)
    {
      _Distance __parent = (__holeIndex - 1) / 2;
      while (__holeIndex > __topIndex
      && __comp(*(__first + __parent), __value))
 {
   *(__first + __holeIndex) = *(__first + __parent);
   __holeIndex = __parent;
   __parent = (__holeIndex - 1) / 2;
 }
      *(__first + __holeIndex) = __value;
    }
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
       _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
   _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
   _DistanceType;
      ;
      ;
      std::__push_heap(__first, _DistanceType((__last - __first) - 1),
         _DistanceType(0), _ValueType(*(__last - 1)), __comp);
    }
  template<typename _RandomAccessIterator, typename _Distance, typename _Tp>
    void
    __adjust_heap(_RandomAccessIterator __first, _Distance __holeIndex,
    _Distance __len, _Tp __value)
    {
      const _Distance __topIndex = __holeIndex;
      _Distance __secondChild = 2 * __holeIndex + 2;
      while (__secondChild < __len)
 {
   if (*(__first + __secondChild) < *(__first + (__secondChild - 1)))
     __secondChild--;
   *(__first + __holeIndex) = *(__first + __secondChild);
   __holeIndex = __secondChild;
   __secondChild = 2 * (__secondChild + 1);
 }
      if (__secondChild == __len)
 {
   *(__first + __holeIndex) = *(__first + (__secondChild - 1));
   __holeIndex = __secondChild - 1;
 }
      std::__push_heap(__first, __holeIndex, __topIndex, __value);
    }
  template<typename _RandomAccessIterator, typename _Tp>
    inline void
    __pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
        _RandomAccessIterator __result, _Tp __value)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _Distance;
      *__result = *__first;
      std::__adjust_heap(__first, _Distance(0), _Distance(__last - __first),
    __value);
    }
  template<typename _RandomAccessIterator>
    inline void
    pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;
      ;
      ;
      std::__pop_heap(__first, __last - 1, __last - 1,
        _ValueType(*(__last - 1)));
    }
  template<typename _RandomAccessIterator, typename _Distance,
    typename _Tp, typename _Compare>
    void
    __adjust_heap(_RandomAccessIterator __first, _Distance __holeIndex,
    _Distance __len, _Tp __value, _Compare __comp)
    {
      const _Distance __topIndex = __holeIndex;
      _Distance __secondChild = 2 * __holeIndex + 2;
      while (__secondChild < __len)
 {
   if (__comp(*(__first + __secondChild),
       *(__first + (__secondChild - 1))))
     __secondChild--;
   *(__first + __holeIndex) = *(__first + __secondChild);
   __holeIndex = __secondChild;
   __secondChild = 2 * (__secondChild + 1);
 }
      if (__secondChild == __len)
 {
   *(__first + __holeIndex) = *(__first + (__secondChild - 1));
   __holeIndex = __secondChild - 1;
 }
      std::__push_heap(__first, __holeIndex, __topIndex, __value, __comp);
    }
  template<typename _RandomAccessIterator, typename _Tp, typename _Compare>
    inline void
    __pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
        _RandomAccessIterator __result, _Tp __value, _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _Distance;
      *__result = *__first;
      std::__adjust_heap(__first, _Distance(0), _Distance(__last - __first),
    __value, __comp);
    }
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    pop_heap(_RandomAccessIterator __first,
      _RandomAccessIterator __last, _Compare __comp)
    {
      ;
      ;
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;
      std::__pop_heap(__first, __last - 1, __last - 1,
        _ValueType(*(__last - 1)), __comp);
    }
  template<typename _RandomAccessIterator>
    void
    make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
   _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
   _DistanceType;
      ;
      if (__last - __first < 2)
 return;
      const _DistanceType __len = __last - __first;
      _DistanceType __parent = (__len - 2) / 2;
      while (true)
 {
   std::__adjust_heap(__first, __parent, __len,
        _ValueType(*(__first + __parent)));
   if (__parent == 0)
     return;
   __parent--;
 }
    }
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
       _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
   _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
   _DistanceType;
      ;
      if (__last - __first < 2)
 return;
      const _DistanceType __len = __last - __first;
      _DistanceType __parent = (__len - 2) / 2;
      while (true)
 {
   std::__adjust_heap(__first, __parent, __len,
        _ValueType(*(__first + __parent)), __comp);
   if (__parent == 0)
     return;
   __parent--;
 }
    }
  template<typename _RandomAccessIterator>
    void
    sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {
      ;
      while (__last - __first > 1)
 std::pop_heap(__first, __last--);
    }
  template<typename _RandomAccessIterator, typename _Compare>
    void
    sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
       _Compare __comp)
    {
      ;
      ;
      while (__last - __first > 1)
 std::pop_heap(__first, __last--, __comp);
    }
}
namespace __gnu_cxx
{
  template<typename _Tp>
    class new_allocator
    {
    public:
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp* pointer;
      typedef const _Tp* const_pointer;
      typedef _Tp& reference;
      typedef const _Tp& const_reference;
      typedef _Tp value_type;
      template<typename _Tp1>
        struct rebind
        { typedef new_allocator<_Tp1> other; };
      new_allocator() throw() { }
      new_allocator(const new_allocator&) throw() { }
      template<typename _Tp1>
        new_allocator(const new_allocator<_Tp1>&) throw() { }
      ~new_allocator() throw() { }
      pointer
      address(reference __x) const { return &__x; }
      const_pointer
      address(const_reference __x) const { return &__x; }
      pointer
      allocate(size_type __n, const void* = 0)
      {
 if (__builtin_expect(__n > this->max_size(), false))
   std::__throw_bad_alloc();
 return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp)));
      }
      void
      deallocate(pointer __p, size_type)
      { ::operator delete(__p); }
      size_type
      max_size() const throw()
      { return size_t(-1) / sizeof(_Tp); }
      void
      construct(pointer __p, const _Tp& __val)
      { ::new(__p) _Tp(__val); }
      void
      destroy(pointer __p) { __p->~_Tp(); }
    };
  template<typename _Tp>
    inline bool
    operator==(const new_allocator<_Tp>&, const new_allocator<_Tp>&)
    { return true; }
  template<typename _Tp>
    inline bool
    operator!=(const new_allocator<_Tp>&, const new_allocator<_Tp>&)
    { return false; }
}
namespace std
{
  template<typename _Tp>
    class allocator;
  template<>
    class allocator<void>
    {
    public:
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef void* pointer;
      typedef const void* const_pointer;
      typedef void value_type;
      template<typename _Tp1>
        struct rebind
        { typedef allocator<_Tp1> other; };
    };
  template<typename _Tp>
    class allocator: public __gnu_cxx::new_allocator<_Tp>
    {
   public:
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp* pointer;
      typedef const _Tp* const_pointer;
      typedef _Tp& reference;
      typedef const _Tp& const_reference;
      typedef _Tp value_type;
      template<typename _Tp1>
        struct rebind
        { typedef allocator<_Tp1> other; };
      allocator() throw() { }
      allocator(const allocator& __a) throw()
      : __gnu_cxx::new_allocator<_Tp>(__a) { }
      template<typename _Tp1>
        allocator(const allocator<_Tp1>&) throw() { }
      ~allocator() throw() { }
    };
  template<typename _T1, typename _T2>
    inline bool
    operator==(const allocator<_T1>&, const allocator<_T2>&)
    { return true; }
  template<typename _T1, typename _T2>
    inline bool
    operator!=(const allocator<_T1>&, const allocator<_T2>&)
    { return false; }
  extern template class allocator<char>;
  extern template class allocator<wchar_t>;
}
namespace std
{
  template <class _ForwardIterator, class _Tp>
    class raw_storage_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _ForwardIterator _M_iter;
    public:
      explicit
      raw_storage_iterator(_ForwardIterator __x)
      : _M_iter(__x) {}
      raw_storage_iterator&
      operator*() { return *this; }
      raw_storage_iterator&
      operator=(const _Tp& __element)
      {
 std::_Construct(&*_M_iter, __element);
 return *this;
      }
      raw_storage_iterator<_ForwardIterator, _Tp>&
      operator++()
      {
 ++_M_iter;
 return *this;
      }
      raw_storage_iterator<_ForwardIterator, _Tp>
      operator++(int)
      {
 raw_storage_iterator<_ForwardIterator, _Tp> __tmp = *this;
 ++_M_iter;
 return __tmp;
      }
    };
}
namespace std
{
  enum float_round_style
  {
    round_indeterminate = -1,
    round_toward_zero = 0,
    round_to_nearest = 1,
    round_toward_infinity = 2,
    round_toward_neg_infinity = 3
  };
  enum float_denorm_style
  {
    denorm_indeterminate = -1,
    denorm_absent = 0,
    denorm_present = 1
  };
  struct __numeric_limits_base
  {
    static const bool is_specialized = false;
    static const int digits = 0;
    static const int digits10 = 0;
    static const bool is_signed = false;
    static const bool is_integer = false;
    static const bool is_exact = false;
    static const int radix = 0;
    static const int min_exponent = 0;
    static const int min_exponent10 = 0;
    static const int max_exponent = 0;
    static const int max_exponent10 = 0;
    static const bool has_infinity = false;
    static const bool has_quiet_NaN = false;
    static const bool has_signaling_NaN = false;
    static const float_denorm_style has_denorm = denorm_absent;
    static const bool has_denorm_loss = false;
    static const bool is_iec559 = false;
    static const bool is_bounded = false;
    static const bool is_modulo = false;
    static const bool traps = false;
    static const bool tinyness_before = false;
    static const float_round_style round_style = round_toward_zero;
  };
  template<typename _Tp>
    struct numeric_limits : public __numeric_limits_base
    {
      static _Tp min() throw() { return static_cast<_Tp>(0); }
      static _Tp max() throw() { return static_cast<_Tp>(0); }
      static _Tp epsilon() throw() { return static_cast<_Tp>(0); }
      static _Tp round_error() throw() { return static_cast<_Tp>(0); }
      static _Tp infinity() throw() { return static_cast<_Tp>(0); }
      static _Tp quiet_NaN() throw() { return static_cast<_Tp>(0); }
      static _Tp signaling_NaN() throw() { return static_cast<_Tp>(0); }
      static _Tp denorm_min() throw() { return static_cast<_Tp>(0); }
    };
  template<>
    struct numeric_limits<bool>
    {
      static const bool is_specialized = true;
      static bool min() throw()
      { return false; }
      static bool max() throw()
      { return true; }
      static const int digits = 1;
      static const int digits10 = 0;
      static const bool is_signed = false;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static bool epsilon() throw()
      { return false; }
      static bool round_error() throw()
      { return false; }
      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;
      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;
      static bool infinity() throw()
      { return false; }
      static bool quiet_NaN() throw()
      { return false; }
      static bool signaling_NaN() throw()
      { return false; }
      static bool denorm_min() throw()
      { return false; }
      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = false;
      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };
  template<>
    struct numeric_limits<char>
    {
      static const bool is_specialized = true;
      static char min() throw()
      { return (((char)(-1) < 0) ? (char)1 << (sizeof(char) * 8 - ((char)(-1) < 0)) : (char)0); }
      static char max() throw()
      { return (((char)(-1) < 0) ? ((char)1 << (sizeof(char) * 8 - ((char)(-1) < 0))) - 1 : ~(char)0); }
      static const int digits = (sizeof(char) * 8 - ((char)(-1) < 0));
      static const int digits10 = ((sizeof(char) * 8 - ((char)(-1) < 0)) * 643 / 2136);
      static const bool is_signed = ((char)(-1) < 0);
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static char epsilon() throw()
      { return 0; }
      static char round_error() throw()
      { return 0; }
      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;
      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;
      static char infinity() throw()
      { return char(); }
      static char quiet_NaN() throw()
      { return char(); }
      static char signaling_NaN() throw()
      { return char(); }
      static char denorm_min() throw()
      { return static_cast<char>(0); }
      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;
      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };
  template<>
    struct numeric_limits<signed char>
    {
      static const bool is_specialized = true;
      static signed char min() throw()
      { return -127 - 1; }
      static signed char max() throw()
      { return 127; }
      static const int digits = (sizeof(signed char) * 8 - ((signed char)(-1) < 0));
      static const int digits10 = ((sizeof(signed char) * 8 - ((signed char)(-1) < 0)) * 643 / 2136);
      static const bool is_signed = true;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static signed char epsilon() throw()
      { return 0; }
      static signed char round_error() throw()
      { return 0; }
      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;
      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;
      static signed char infinity() throw()
      { return static_cast<signed char>(0); }
      static signed char quiet_NaN() throw()
      { return static_cast<signed char>(0); }
      static signed char signaling_NaN() throw()
      { return static_cast<signed char>(0); }
      static signed char denorm_min() throw()
      { return static_cast<signed char>(0); }
      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;
      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };
  template<>
    struct numeric_limits<unsigned char>
    {
      static const bool is_specialized = true;
      static unsigned char min() throw()
      { return 0; }
      static unsigned char max() throw()
      { return 127 * 2U + 1; }
      static const int digits = (sizeof(unsigned char) * 8 - ((unsigned char)(-1) < 0));
      static const int digits10 = ((sizeof(unsigned char) * 8 - ((unsigned char)(-1) < 0)) * 643 / 2136);
      static const bool is_signed = false;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static unsigned char epsilon() throw()
      { return 0; }
      static unsigned char round_error() throw()
      { return 0; }
      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;
      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;
      static unsigned char infinity() throw()
      { return static_cast<unsigned char>(0); }
      static unsigned char quiet_NaN() throw()
      { return static_cast<unsigned char>(0); }
      static unsigned char signaling_NaN() throw()
      { return static_cast<unsigned char>(0); }
      static unsigned char denorm_min() throw()
      { return static_cast<unsigned char>(0); }
      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;
      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };
  template<>
    struct numeric_limits<wchar_t>
    {
      static const bool is_specialized = true;
      static wchar_t min() throw()
      { return (((wchar_t)(-1) < 0) ? (wchar_t)1 << (sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) : (wchar_t)0); }
      static wchar_t max() throw()
      { return (((wchar_t)(-1) < 0) ? ((wchar_t)1 << (sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0))) - 1 : ~(wchar_t)0); }
      static const int digits = (sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0));
      static const int digits10 = ((sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) * 643 / 2136);
      static const bool is_signed = ((wchar_t)(-1) < 0);
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static wchar_t epsilon() throw()
      { return 0; }
      static wchar_t round_error() throw()
      { return 0; }
      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;
      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;
      static wchar_t infinity() throw()
      { return wchar_t(); }
      static wchar_t quiet_NaN() throw()
      { return wchar_t(); }
      static wchar_t signaling_NaN() throw()
      { return wchar_t(); }
      static wchar_t denorm_min() throw()
      { return wchar_t(); }
      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;
      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };
  template<>
    struct numeric_limits<short>
    {
      static const bool is_specialized = true;
      static short min() throw()
      { return -32767 - 1; }
      static short max() throw()
      { return 32767; }
      static const int digits = (sizeof(short) * 8 - ((short)(-1) < 0));
      static const int digits10 = ((sizeof(short) * 8 - ((short)(-1) < 0)) * 643 / 2136);
      static const bool is_signed = true;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static short epsilon() throw()
      { return 0; }
      static short round_error() throw()
      { return 0; }
      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;
      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;
      static short infinity() throw()
      { return short(); }
      static short quiet_NaN() throw()
      { return short(); }
      static short signaling_NaN() throw()
      { return short(); }
      static short denorm_min() throw()
      { return short(); }
      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;
      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };
  template<>
    struct numeric_limits<unsigned short>
    {
      static const bool is_specialized = true;
      static unsigned short min() throw()
      { return 0; }
      static unsigned short max() throw()
      { return 32767 * 2U + 1; }
      static const int digits = (sizeof(unsigned short) * 8 - ((unsigned short)(-1) < 0));
      static const int digits10 = ((sizeof(unsigned short) * 8 - ((unsigned short)(-1) < 0)) * 643 / 2136);
      static const bool is_signed = false;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static unsigned short epsilon() throw()
      { return 0; }
      static unsigned short round_error() throw()
      { return 0; }
      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;
      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;
      static unsigned short infinity() throw()
      { return static_cast<unsigned short>(0); }
      static unsigned short quiet_NaN() throw()
      { return static_cast<unsigned short>(0); }
      static unsigned short signaling_NaN() throw()
      { return static_cast<unsigned short>(0); }
      static unsigned short denorm_min() throw()
      { return static_cast<unsigned short>(0); }
      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;
      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };
  template<>
    struct numeric_limits<int>
    {
      static const bool is_specialized = true;
      static int min() throw()
      { return -2147483647 - 1; }
      static int max() throw()
      { return 2147483647; }
      static const int digits = (sizeof(int) * 8 - ((int)(-1) < 0));
      static const int digits10 = ((sizeof(int) * 8 - ((int)(-1) < 0)) * 643 / 2136);
      static const bool is_signed = true;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static int epsilon() throw()
      { return 0; }
      static int round_error() throw()
      { return 0; }
      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;
      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;
      static int infinity() throw()
      { return static_cast<int>(0); }
      static int quiet_NaN() throw()
      { return static_cast<int>(0); }
      static int signaling_NaN() throw()
      { return static_cast<int>(0); }
      static int denorm_min() throw()
      { return static_cast<int>(0); }
      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;
      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };
  template<>
    struct numeric_limits<unsigned int>
    {
      static const bool is_specialized = true;
      static unsigned int min() throw()
      { return 0; }
      static unsigned int max() throw()
      { return 2147483647 * 2U + 1; }
      static const int digits = (sizeof(unsigned int) * 8 - ((unsigned int)(-1) < 0));
      static const int digits10 = ((sizeof(unsigned int) * 8 - ((unsigned int)(-1) < 0)) * 643 / 2136);
      static const bool is_signed = false;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static unsigned int epsilon() throw()
      { return 0; }
      static unsigned int round_error() throw()
      { return 0; }
      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;
      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;
      static unsigned int infinity() throw()
      { return static_cast<unsigned int>(0); }
      static unsigned int quiet_NaN() throw()
      { return static_cast<unsigned int>(0); }
      static unsigned int signaling_NaN() throw()
      { return static_cast<unsigned int>(0); }
      static unsigned int denorm_min() throw()
      { return static_cast<unsigned int>(0); }
      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;
      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };
  template<>
    struct numeric_limits<long>
    {
      static const bool is_specialized = true;
      static long min() throw()
      { return -2147483647L - 1; }
      static long max() throw()
      { return 2147483647L; }
      static const int digits = (sizeof(long) * 8 - ((long)(-1) < 0));
      static const int digits10 = ((sizeof(long) * 8 - ((long)(-1) < 0)) * 643 / 2136);
      static const bool is_signed = true;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static long epsilon() throw()
      { return 0; }
      static long round_error() throw()
      { return 0; }
      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;
      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;
      static long infinity() throw()
      { return static_cast<long>(0); }
      static long quiet_NaN() throw()
      { return static_cast<long>(0); }
      static long signaling_NaN() throw()
      { return static_cast<long>(0); }
      static long denorm_min() throw()
      { return static_cast<long>(0); }
      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;
      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };
  template<>
    struct numeric_limits<unsigned long>
    {
      static const bool is_specialized = true;
      static unsigned long min() throw()
      { return 0; }
      static unsigned long max() throw()
      { return 2147483647L * 2UL + 1; }
      static const int digits = (sizeof(unsigned long) * 8 - ((unsigned long)(-1) < 0));
      static const int digits10 = ((sizeof(unsigned long) * 8 - ((unsigned long)(-1) < 0)) * 643 / 2136);
      static const bool is_signed = false;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static unsigned long epsilon() throw()
      { return 0; }
      static unsigned long round_error() throw()
      { return 0; }
      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;
      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;
      static unsigned long infinity() throw()
      { return static_cast<unsigned long>(0); }
      static unsigned long quiet_NaN() throw()
      { return static_cast<unsigned long>(0); }
      static unsigned long signaling_NaN() throw()
      { return static_cast<unsigned long>(0); }
      static unsigned long denorm_min() throw()
      { return static_cast<unsigned long>(0); }
      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;
      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };
  template<>
    struct numeric_limits<long long>
    {
      static const bool is_specialized = true;
      static long long min() throw()
      { return -9223372036854775807LL - 1; }
      static long long max() throw()
      { return 9223372036854775807LL; }
      static const int digits = (sizeof(long long) * 8 - ((long long)(-1) < 0));
      static const int digits10 = ((sizeof(long long) * 8 - ((long long)(-1) < 0)) * 643 / 2136);
      static const bool is_signed = true;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static long long epsilon() throw()
      { return 0; }
      static long long round_error() throw()
      { return 0; }
      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;
      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;
      static long long infinity() throw()
      { return static_cast<long long>(0); }
      static long long quiet_NaN() throw()
      { return static_cast<long long>(0); }
      static long long signaling_NaN() throw()
      { return static_cast<long long>(0); }
      static long long denorm_min() throw()
      { return static_cast<long long>(0); }
      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;
      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };
  template<>
    struct numeric_limits<unsigned long long>
    {
      static const bool is_specialized = true;
      static unsigned long long min() throw()
      { return 0; }
      static unsigned long long max() throw()
      { return 9223372036854775807LL * 2ULL + 1; }
      static const int digits = (sizeof(unsigned long long) * 8 - ((unsigned long long)(-1) < 0));
      static const int digits10 = ((sizeof(unsigned long long) * 8 - ((unsigned long long)(-1) < 0)) * 643 / 2136);
      static const bool is_signed = false;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static unsigned long long epsilon() throw()
      { return 0; }
      static unsigned long long round_error() throw()
      { return 0; }
      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;
      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;
      static unsigned long long infinity() throw()
      { return static_cast<unsigned long long>(0); }
      static unsigned long long quiet_NaN() throw()
      { return static_cast<unsigned long long>(0); }
      static unsigned long long signaling_NaN() throw()
      { return static_cast<unsigned long long>(0); }
      static unsigned long long denorm_min() throw()
      { return static_cast<unsigned long long>(0); }
      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;
      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };
  template<>
    struct numeric_limits<float>
    {
      static const bool is_specialized = true;
      static float min() throw()
      { return 1.17549435e-38F; }
      static float max() throw()
      { return 3.40282347e+38F; }
      static const int digits = 24;
      static const int digits10 = 6;
      static const bool is_signed = true;
      static const bool is_integer = false;
      static const bool is_exact = false;
      static const int radix = 2;
      static float epsilon() throw()
      { return 1.19209290e-7F; }
      static float round_error() throw()
      { return 0.5F; }
      static const int min_exponent = (-125);
      static const int min_exponent10 = (-37);
      static const int max_exponent = 128;
      static const int max_exponent10 = 38;
      static const bool has_infinity = 1;
      static const bool has_quiet_NaN = 1;
      static const bool has_signaling_NaN = has_quiet_NaN;
      static const float_denorm_style has_denorm
 = bool(1.40129846e-45F) ? denorm_present : denorm_absent;
      static const bool has_denorm_loss = false;
      static float infinity() throw()
      { return __builtin_huge_valf (); }
      static float quiet_NaN() throw()
      { return __builtin_nanf (""); }
      static float signaling_NaN() throw()
      { return __builtin_nansf (""); }
      static float denorm_min() throw()
      { return 1.40129846e-45F; }
      static const bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static const bool is_bounded = true;
      static const bool is_modulo = false;
      static const bool traps = false;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_to_nearest;
    };
  template<>
    struct numeric_limits<double>
    {
      static const bool is_specialized = true;
      static double min() throw()
      { return 2.2250738585072014e-308; }
      static double max() throw()
      { return 1.7976931348623157e+308; }
      static const int digits = 53;
      static const int digits10 = 15;
      static const bool is_signed = true;
      static const bool is_integer = false;
      static const bool is_exact = false;
      static const int radix = 2;
      static double epsilon() throw()
      { return 2.2204460492503131e-16; }
      static double round_error() throw()
      { return 0.5; }
      static const int min_exponent = (-1021);
      static const int min_exponent10 = (-307);
      static const int max_exponent = 1024;
      static const int max_exponent10 = 308;
      static const bool has_infinity = 1;
      static const bool has_quiet_NaN = 1;
      static const bool has_signaling_NaN = has_quiet_NaN;
      static const float_denorm_style has_denorm
 = bool(4.9406564584124654e-324) ? denorm_present : denorm_absent;
      static const bool has_denorm_loss = false;
      static double infinity() throw()
      { return __builtin_huge_val(); }
      static double quiet_NaN() throw()
      { return __builtin_nan (""); }
      static double signaling_NaN() throw()
      { return __builtin_nans (""); }
      static double denorm_min() throw()
      { return 4.9406564584124654e-324; }
      static const bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static const bool is_bounded = true;
      static const bool is_modulo = false;
      static const bool traps = false;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_to_nearest;
    };
  template<>
    struct numeric_limits<long double>
    {
      static const bool is_specialized = true;
      static long double min() throw()
      { return 3.36210314311209350626e-4932L; }
      static long double max() throw()
      { return 1.18973149535723176502e+4932L; }
      static const int digits = 64;
      static const int digits10 = 18;
      static const bool is_signed = true;
      static const bool is_integer = false;
      static const bool is_exact = false;
      static const int radix = 2;
      static long double epsilon() throw()
      { return 1.08420217248550443401e-19L; }
      static long double round_error() throw()
      { return 0.5L; }
      static const int min_exponent = (-16381);
      static const int min_exponent10 = (-4931);
      static const int max_exponent = 16384;
      static const int max_exponent10 = 4932;
      static const bool has_infinity = 1;
      static const bool has_quiet_NaN = 1;
      static const bool has_signaling_NaN = has_quiet_NaN;
      static const float_denorm_style has_denorm
 = bool(3.64519953188247460253e-4951L) ? denorm_present : denorm_absent;
      static const bool has_denorm_loss
 = false;
      static long double infinity() throw()
      { return __builtin_huge_vall (); }
      static long double quiet_NaN() throw()
      { return __builtin_nanl (""); }
      static long double signaling_NaN() throw()
      { return __builtin_nansl (""); }
      static long double denorm_min() throw()
      { return 3.64519953188247460253e-4951L; }
      static const bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static const bool is_bounded = true;
      static const bool is_modulo = false;
      static const bool traps = false;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_to_nearest;
    };
}
namespace std
{
  template<typename _Tp>
    pair<_Tp*, ptrdiff_t>
    __get_temporary_buffer(ptrdiff_t __len, _Tp*)
    {
      const ptrdiff_t __max = numeric_limits<ptrdiff_t>::max() / sizeof(_Tp);
      if (__len > __max)
 __len = __max;
      while (__len > 0)
 {
   _Tp* __tmp = static_cast<_Tp*>(::operator new(__len * sizeof(_Tp),
       nothrow));
   if (__tmp != 0)
     return pair<_Tp*, ptrdiff_t>(__tmp, __len);
   __len /= 2;
 }
      return pair<_Tp*, ptrdiff_t>(static_cast<_Tp*>(0), 0);
    }
  template<typename _Tp>
    inline pair<_Tp*, ptrdiff_t>
    get_temporary_buffer(ptrdiff_t __len)
    { return std::__get_temporary_buffer(__len, static_cast<_Tp*>(0)); }
  template<typename _Tp>
    void
    return_temporary_buffer(_Tp* __p)
    { ::operator delete(__p, nothrow); }
  template<typename _Tp1>
    struct auto_ptr_ref
    {
      _Tp1* _M_ptr;
      explicit
      auto_ptr_ref(_Tp1* __p): _M_ptr(__p) { }
    };
  template<typename _Tp>
    class auto_ptr
    {
    private:
      _Tp* _M_ptr;
    public:
      typedef _Tp element_type;
      explicit
      auto_ptr(element_type* __p = 0) throw() : _M_ptr(__p) { }
      auto_ptr(auto_ptr& __a) throw() : _M_ptr(__a.release()) { }
      template<typename _Tp1>
        auto_ptr(auto_ptr<_Tp1>& __a) throw() : _M_ptr(__a.release()) { }
      auto_ptr&
      operator=(auto_ptr& __a) throw()
      {
 reset(__a.release());
 return *this;
      }
      template<typename _Tp1>
        auto_ptr&
        operator=(auto_ptr<_Tp1>& __a) throw()
        {
   reset(__a.release());
   return *this;
 }
      ~auto_ptr() { delete _M_ptr; }
      element_type&
      operator*() const throw()
      {
 ;
 return *_M_ptr;
      }
      element_type*
      operator->() const throw()
      {
 ;
 return _M_ptr;
      }
      element_type*
      get() const throw() { return _M_ptr; }
      element_type*
      release() throw()
      {
 element_type* __tmp = _M_ptr;
 _M_ptr = 0;
 return __tmp;
      }
      void
      reset(element_type* __p = 0) throw()
      {
 if (__p != _M_ptr)
   {
     delete _M_ptr;
     _M_ptr = __p;
   }
      }
      auto_ptr(auto_ptr_ref<element_type> __ref) throw()
      : _M_ptr(__ref._M_ptr) { }
      auto_ptr&
      operator=(auto_ptr_ref<element_type> __ref) throw()
      {
 if (__ref._M_ptr != this->get())
   {
     delete _M_ptr;
     _M_ptr = __ref._M_ptr;
   }
 return *this;
      }
      template<typename _Tp1>
        operator auto_ptr_ref<_Tp1>() throw()
        { return auto_ptr_ref<_Tp1>(this->release()); }
      template<typename _Tp1>
        operator auto_ptr<_Tp1>() throw()
        { return auto_ptr<_Tp1>(this->release()); }
  };
}
namespace std
{
  template<typename _ForwardIterator, typename _Tp>
    class _Temporary_buffer
    {
 public:
      typedef _Tp value_type;
      typedef value_type* pointer;
      typedef pointer iterator;
      typedef ptrdiff_t size_type;
    protected:
      size_type _M_original_len;
      size_type _M_len;
      pointer _M_buffer;
      void
      _M_initialize_buffer(const _Tp&, __true_type) { }
      void
      _M_initialize_buffer(const _Tp& val, __false_type)
      { std::uninitialized_fill_n(_M_buffer, _M_len, val); }
    public:
      size_type
      size() const
      { return _M_len; }
      size_type
      requested_size() const
      { return _M_original_len; }
      iterator
      begin()
      { return _M_buffer; }
      iterator
      end()
      { return _M_buffer + _M_len; }
      _Temporary_buffer(_ForwardIterator __first, _ForwardIterator __last);
      ~_Temporary_buffer()
      {
 std::_Destroy(_M_buffer, _M_buffer + _M_len);
 std::return_temporary_buffer(_M_buffer);
      }
    private:
      _Temporary_buffer(const _Temporary_buffer&);
      void
      operator=(const _Temporary_buffer&);
    };
  template<typename _ForwardIterator, typename _Tp>
    _Temporary_buffer<_ForwardIterator, _Tp>::
    _Temporary_buffer(_ForwardIterator __first, _ForwardIterator __last)
    : _M_original_len(std::distance(__first, __last)),
      _M_len(0), _M_buffer(0)
    {
      typedef typename std::__is_scalar<_Tp>::__type _Trivial;
      try
 {
   pair<pointer, size_type> __p(get_temporary_buffer<
           value_type>(_M_original_len));
   _M_buffer = __p.first;
   _M_len = __p.second;
   if (_M_len > 0)
     _M_initialize_buffer(*__first, _Trivial());
 }
      catch(...)
 {
   std::return_temporary_buffer(_M_buffer);
   _M_buffer = 0;
   _M_len = 0;
   throw;
 }
    }
}
namespace std
{
  template<typename _Tp>
    inline const _Tp&
    __median(const _Tp& __a, const _Tp& __b, const _Tp& __c)
    {
      if (__a < __b)
 if (__b < __c)
   return __b;
 else if (__a < __c)
   return __c;
 else
   return __a;
      else if (__a < __c)
 return __a;
      else if (__b < __c)
 return __c;
      else
 return __b;
    }
  template<typename _Tp, typename _Compare>
    inline const _Tp&
    __median(const _Tp& __a, const _Tp& __b, const _Tp& __c, _Compare __comp)
    {
      if (__comp(__a, __b))
 if (__comp(__b, __c))
   return __b;
 else if (__comp(__a, __c))
   return __c;
 else
   return __a;
      else if (__comp(__a, __c))
 return __a;
      else if (__comp(__b, __c))
 return __c;
      else
 return __b;
    }
  template<typename _InputIterator, typename _Function>
    _Function
    for_each(_InputIterator __first, _InputIterator __last, _Function __f)
    {
      ;
      for ( ; __first != __last; ++__first)
 __f(*__first);
      return __f;
    }
  template<typename _InputIterator, typename _Tp>
    inline _InputIterator
    __find(_InputIterator __first, _InputIterator __last,
    const _Tp& __val, input_iterator_tag)
    {
      while (__first != __last && !(*__first == __val))
 ++__first;
      return __first;
    }
  template<typename _InputIterator, typename _Predicate>
    inline _InputIterator
    __find_if(_InputIterator __first, _InputIterator __last,
       _Predicate __pred, input_iterator_tag)
    {
      while (__first != __last && !__pred(*__first))
 ++__first;
      return __first;
    }
  template<typename _RandomAccessIterator, typename _Tp>
    _RandomAccessIterator
    __find(_RandomAccessIterator __first, _RandomAccessIterator __last,
    const _Tp& __val, random_access_iterator_tag)
    {
      typename iterator_traits<_RandomAccessIterator>::difference_type
 __trip_count = (__last - __first) >> 2;
      for ( ; __trip_count > 0 ; --__trip_count)
 {
   if (*__first == __val)
     return __first;
   ++__first;
   if (*__first == __val)
     return __first;
   ++__first;
   if (*__first == __val)
     return __first;
   ++__first;
   if (*__first == __val)
     return __first;
   ++__first;
 }
      switch (__last - __first)
 {
 case 3:
   if (*__first == __val)
     return __first;
   ++__first;
 case 2:
   if (*__first == __val)
     return __first;
   ++__first;
 case 1:
   if (*__first == __val)
     return __first;
   ++__first;
 case 0:
 default:
   return __last;
 }
    }
  template<typename _RandomAccessIterator, typename _Predicate>
    _RandomAccessIterator
    __find_if(_RandomAccessIterator __first, _RandomAccessIterator __last,
       _Predicate __pred, random_access_iterator_tag)
    {
      typename iterator_traits<_RandomAccessIterator>::difference_type
 __trip_count = (__last - __first) >> 2;
      for ( ; __trip_count > 0 ; --__trip_count)
 {
   if (__pred(*__first))
     return __first;
   ++__first;
   if (__pred(*__first))
     return __first;
   ++__first;
   if (__pred(*__first))
     return __first;
   ++__first;
   if (__pred(*__first))
     return __first;
   ++__first;
 }
      switch (__last - __first)
 {
 case 3:
   if (__pred(*__first))
     return __first;
   ++__first;
 case 2:
   if (__pred(*__first))
     return __first;
   ++__first;
 case 1:
   if (__pred(*__first))
     return __first;
   ++__first;
 case 0:
 default:
   return __last;
 }
    }
  template<typename _InputIterator, typename _Tp>
    inline _InputIterator
    find(_InputIterator __first, _InputIterator __last,
  const _Tp& __val)
    {
      ;
      return std::__find(__first, __last, __val,
           std::__iterator_category(__first));
    }
  template<typename _InputIterator, typename _Predicate>
    inline _InputIterator
    find_if(_InputIterator __first, _InputIterator __last,
     _Predicate __pred)
    {
      ;
      return std::__find_if(__first, __last, __pred,
       std::__iterator_category(__first));
    }
  template<typename _ForwardIterator>
    _ForwardIterator
    adjacent_find(_ForwardIterator __first, _ForwardIterator __last)
    {
      ;
      if (__first == __last)
 return __last;
      _ForwardIterator __next = __first;
      while(++__next != __last)
 {
   if (*__first == *__next)
     return __first;
   __first = __next;
 }
      return __last;
    }
  template<typename _ForwardIterator, typename _BinaryPredicate>
    _ForwardIterator
    adjacent_find(_ForwardIterator __first, _ForwardIterator __last,
    _BinaryPredicate __binary_pred)
    {
      ;
      if (__first == __last)
 return __last;
      _ForwardIterator __next = __first;
      while(++__next != __last)
 {
   if (__binary_pred(*__first, *__next))
     return __first;
   __first = __next;
 }
      return __last;
    }
  template<typename _InputIterator, typename _Tp>
    typename iterator_traits<_InputIterator>::difference_type
    count(_InputIterator __first, _InputIterator __last, const _Tp& __value)
    {
      ;
      typename iterator_traits<_InputIterator>::difference_type __n = 0;
      for ( ; __first != __last; ++__first)
 if (*__first == __value)
   ++__n;
      return __n;
    }
  template<typename _InputIterator, typename _Predicate>
    typename iterator_traits<_InputIterator>::difference_type
    count_if(_InputIterator __first, _InputIterator __last, _Predicate __pred)
    {
      ;
      typename iterator_traits<_InputIterator>::difference_type __n = 0;
      for ( ; __first != __last; ++__first)
 if (__pred(*__first))
   ++__n;
      return __n;
    }
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    _ForwardIterator1
    search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
    _ForwardIterator2 __first2, _ForwardIterator2 __last2)
    {
      ;
      ;
      if (__first1 == __last1 || __first2 == __last2)
 return __first1;
      _ForwardIterator2 __tmp(__first2);
      ++__tmp;
      if (__tmp == __last2)
 return std::find(__first1, __last1, *__first2);
      _ForwardIterator2 __p1, __p;
      __p1 = __first2; ++__p1;
      _ForwardIterator1 __current = __first1;
      while (__first1 != __last1)
 {
   __first1 = std::find(__first1, __last1, *__first2);
   if (__first1 == __last1)
     return __last1;
   __p = __p1;
   __current = __first1;
   if (++__current == __last1)
     return __last1;
   while (*__current == *__p)
     {
       if (++__p == __last2)
  return __first1;
       if (++__current == __last1)
  return __last1;
     }
   ++__first1;
 }
      return __first1;
    }
  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    _ForwardIterator1
    search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
    _ForwardIterator2 __first2, _ForwardIterator2 __last2,
    _BinaryPredicate __predicate)
    {
      ;
      ;
      if (__first1 == __last1 || __first2 == __last2)
 return __first1;
      _ForwardIterator2 __tmp(__first2);
      ++__tmp;
      if (__tmp == __last2)
 {
   while (__first1 != __last1 && !__predicate(*__first1, *__first2))
     ++__first1;
   return __first1;
 }
      _ForwardIterator2 __p1, __p;
      __p1 = __first2; ++__p1;
      _ForwardIterator1 __current = __first1;
      while (__first1 != __last1)
 {
   while (__first1 != __last1)
     {
       if (__predicate(*__first1, *__first2))
  break;
       ++__first1;
     }
   while (__first1 != __last1 && !__predicate(*__first1, *__first2))
     ++__first1;
   if (__first1 == __last1)
     return __last1;
   __p = __p1;
   __current = __first1;
   if (++__current == __last1)
     return __last1;
   while (__predicate(*__current, *__p))
     {
       if (++__p == __last2)
  return __first1;
       if (++__current == __last1)
  return __last1;
     }
   ++__first1;
 }
      return __first1;
    }
  template<typename _ForwardIterator, typename _Integer, typename _Tp>
    _ForwardIterator
    __search_n(_ForwardIterator __first, _ForwardIterator __last,
        _Integer __count, const _Tp& __val,
        std::forward_iterator_tag)
    {
      __first = std::find(__first, __last, __val);
      while (__first != __last)
 {
   typename iterator_traits<_ForwardIterator>::difference_type
     __n = __count;
   _ForwardIterator __i = __first;
   ++__i;
   while (__i != __last && __n != 1 && *__i == __val)
     {
       ++__i;
       --__n;
     }
   if (__n == 1)
     return __first;
   if (__i == __last)
     return __last;
   __first = std::find(++__i, __last, __val);
 }
      return __last;
    }
  template<typename _RandomAccessIter, typename _Integer, typename _Tp>
    _RandomAccessIter
    __search_n(_RandomAccessIter __first, _RandomAccessIter __last,
        _Integer __count, const _Tp& __val,
        std::random_access_iterator_tag)
    {
      typedef typename std::iterator_traits<_RandomAccessIter>::difference_type
 _DistanceType;
      _DistanceType __tailSize = __last - __first;
      const _DistanceType __pattSize = __count;
      if (__tailSize < __pattSize)
        return __last;
      const _DistanceType __skipOffset = __pattSize - 1;
      _RandomAccessIter __lookAhead = __first + __skipOffset;
      __tailSize -= __pattSize;
      while (1)
 {
   while (!(*__lookAhead == __val))
     {
       if (__tailSize < __pattSize)
  return __last;
       __lookAhead += __pattSize;
       __tailSize -= __pattSize;
     }
   _DistanceType __remainder = __skipOffset;
   for (_RandomAccessIter __backTrack = __lookAhead - 1;
        *__backTrack == __val; --__backTrack)
     {
       if (--__remainder == 0)
  return (__lookAhead - __skipOffset);
     }
   if (__remainder > __tailSize)
     return __last;
   __lookAhead += __remainder;
   __tailSize -= __remainder;
 }
    }
  template<typename _ForwardIterator, typename _Integer, typename _Tp>
    _ForwardIterator
    search_n(_ForwardIterator __first, _ForwardIterator __last,
      _Integer __count, const _Tp& __val)
    {
      ;
      if (__count <= 0)
 return __first;
      if (__count == 1)
 return std::find(__first, __last, __val);
      return std::__search_n(__first, __last, __count, __val,
        std::__iterator_category(__first));
    }
  template<typename _ForwardIterator, typename _Integer, typename _Tp,
           typename _BinaryPredicate>
    _ForwardIterator
    __search_n(_ForwardIterator __first, _ForwardIterator __last,
        _Integer __count, const _Tp& __val,
        _BinaryPredicate __binary_pred, std::forward_iterator_tag)
    {
      while (__first != __last && !__binary_pred(*__first, __val))
        ++__first;
      while (__first != __last)
 {
   typename iterator_traits<_ForwardIterator>::difference_type
     __n = __count;
   _ForwardIterator __i = __first;
   ++__i;
   while (__i != __last && __n != 1 && __binary_pred(*__i, __val))
     {
       ++__i;
       --__n;
     }
   if (__n == 1)
     return __first;
   if (__i == __last)
     return __last;
   __first = ++__i;
   while (__first != __last && !__binary_pred(*__first, __val))
     ++__first;
 }
      return __last;
    }
  template<typename _RandomAccessIter, typename _Integer, typename _Tp,
    typename _BinaryPredicate>
    _RandomAccessIter
    __search_n(_RandomAccessIter __first, _RandomAccessIter __last,
        _Integer __count, const _Tp& __val,
        _BinaryPredicate __binary_pred, std::random_access_iterator_tag)
    {
      typedef typename std::iterator_traits<_RandomAccessIter>::difference_type
 _DistanceType;
      _DistanceType __tailSize = __last - __first;
      const _DistanceType __pattSize = __count;
      if (__tailSize < __pattSize)
        return __last;
      const _DistanceType __skipOffset = __pattSize - 1;
      _RandomAccessIter __lookAhead = __first + __skipOffset;
      __tailSize -= __pattSize;
      while (1)
 {
   while (!__binary_pred(*__lookAhead, __val))
     {
       if (__tailSize < __pattSize)
  return __last;
       __lookAhead += __pattSize;
       __tailSize -= __pattSize;
     }
   _DistanceType __remainder = __skipOffset;
   for (_RandomAccessIter __backTrack = __lookAhead - 1;
        __binary_pred(*__backTrack, __val); --__backTrack)
     {
       if (--__remainder == 0)
  return (__lookAhead - __skipOffset);
     }
   if (__remainder > __tailSize)
     return __last;
   __lookAhead += __remainder;
   __tailSize -= __remainder;
 }
    }
  template<typename _ForwardIterator, typename _Integer, typename _Tp,
           typename _BinaryPredicate>
    _ForwardIterator
    search_n(_ForwardIterator __first, _ForwardIterator __last,
      _Integer __count, const _Tp& __val,
      _BinaryPredicate __binary_pred)
    {
      ;
      if (__count <= 0)
 return __first;
      if (__count == 1)
 {
   while (__first != __last && !__binary_pred(*__first, __val))
     ++__first;
   return __first;
 }
      return std::__search_n(__first, __last, __count, __val, __binary_pred,
        std::__iterator_category(__first));
    }
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    _ForwardIterator2
    swap_ranges(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
  _ForwardIterator2 __first2)
    {
      ;
      for ( ; __first1 != __last1; ++__first1, ++__first2)
 std::iter_swap(__first1, __first2);
      return __first2;
    }
  template<typename _InputIterator, typename _OutputIterator,
    typename _UnaryOperation>
    _OutputIterator
    transform(_InputIterator __first, _InputIterator __last,
       _OutputIterator __result, _UnaryOperation __unary_op)
    {
      ;
      for ( ; __first != __last; ++__first, ++__result)
 *__result = __unary_op(*__first);
      return __result;
    }
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _BinaryOperation>
    _OutputIterator
    transform(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _OutputIterator __result,
       _BinaryOperation __binary_op)
    {
      ;
      for ( ; __first1 != __last1; ++__first1, ++__first2, ++__result)
 *__result = __binary_op(*__first1, *__first2);
      return __result;
    }
  template<typename _ForwardIterator, typename _Tp>
    void
    replace(_ForwardIterator __first, _ForwardIterator __last,
     const _Tp& __old_value, const _Tp& __new_value)
    {
      ;
      for ( ; __first != __last; ++__first)
 if (*__first == __old_value)
   *__first = __new_value;
    }
  template<typename _ForwardIterator, typename _Predicate, typename _Tp>
    void
    replace_if(_ForwardIterator __first, _ForwardIterator __last,
        _Predicate __pred, const _Tp& __new_value)
    {
      ;
      for ( ; __first != __last; ++__first)
 if (__pred(*__first))
   *__first = __new_value;
    }
  template<typename _InputIterator, typename _OutputIterator, typename _Tp>
    _OutputIterator
    replace_copy(_InputIterator __first, _InputIterator __last,
   _OutputIterator __result,
   const _Tp& __old_value, const _Tp& __new_value)
    {
      ;
      for ( ; __first != __last; ++__first, ++__result)
 if (*__first == __old_value)
   *__result = __new_value;
 else
   *__result = *__first;
      return __result;
    }
  template<typename _InputIterator, typename _OutputIterator,
    typename _Predicate, typename _Tp>
    _OutputIterator
    replace_copy_if(_InputIterator __first, _InputIterator __last,
      _OutputIterator __result,
      _Predicate __pred, const _Tp& __new_value)
    {
      ;
      for ( ; __first != __last; ++__first, ++__result)
 if (__pred(*__first))
   *__result = __new_value;
 else
   *__result = *__first;
      return __result;
    }
  template<typename _ForwardIterator, typename _Generator>
    void
    generate(_ForwardIterator __first, _ForwardIterator __last,
      _Generator __gen)
    {
      ;
      for ( ; __first != __last; ++__first)
 *__first = __gen();
    }
  template<typename _OutputIterator, typename _Size, typename _Generator>
    _OutputIterator
    generate_n(_OutputIterator __first, _Size __n, _Generator __gen)
    {
      for ( ; __n > 0; --__n, ++__first)
 *__first = __gen();
      return __first;
    }
  template<typename _InputIterator, typename _OutputIterator, typename _Tp>
    _OutputIterator
    remove_copy(_InputIterator __first, _InputIterator __last,
  _OutputIterator __result, const _Tp& __value)
    {
      ;
      for ( ; __first != __last; ++__first)
 if (!(*__first == __value))
   {
     *__result = *__first;
     ++__result;
   }
      return __result;
    }
  template<typename _InputIterator, typename _OutputIterator,
    typename _Predicate>
    _OutputIterator
    remove_copy_if(_InputIterator __first, _InputIterator __last,
     _OutputIterator __result, _Predicate __pred)
    {
      ;
      for ( ; __first != __last; ++__first)
 if (!__pred(*__first))
   {
     *__result = *__first;
     ++__result;
   }
      return __result;
    }
  template<typename _ForwardIterator, typename _Tp>
    _ForwardIterator
    remove(_ForwardIterator __first, _ForwardIterator __last,
    const _Tp& __value)
    {
      ;
      __first = std::find(__first, __last, __value);
      _ForwardIterator __i = __first;
      return __first == __last ? __first
          : std::remove_copy(++__i, __last,
        __first, __value);
    }
  template<typename _ForwardIterator, typename _Predicate>
    _ForwardIterator
    remove_if(_ForwardIterator __first, _ForwardIterator __last,
       _Predicate __pred)
    {
      ;
      __first = std::find_if(__first, __last, __pred);
      _ForwardIterator __i = __first;
      return __first == __last ? __first
          : std::remove_copy_if(++__i, __last,
           __first, __pred);
    }
  template<typename _InputIterator, typename _OutputIterator>
    _OutputIterator
    __unique_copy(_InputIterator __first, _InputIterator __last,
    _OutputIterator __result,
    output_iterator_tag)
    {
      typename iterator_traits<_InputIterator>::value_type __value = *__first;
      *__result = __value;
      while (++__first != __last)
 if (!(__value == *__first))
   {
     __value = *__first;
     *++__result = __value;
   }
      return ++__result;
    }
  template<typename _InputIterator, typename _ForwardIterator>
    _ForwardIterator
    __unique_copy(_InputIterator __first, _InputIterator __last,
    _ForwardIterator __result,
    forward_iterator_tag)
    {
      *__result = *__first;
      while (++__first != __last)
 if (!(*__result == *__first))
   *++__result = *__first;
      return ++__result;
    }
  template<typename _InputIterator, typename _OutputIterator,
    typename _BinaryPredicate>
    _OutputIterator
    __unique_copy(_InputIterator __first, _InputIterator __last,
    _OutputIterator __result,
    _BinaryPredicate __binary_pred,
    output_iterator_tag)
    {
      typename iterator_traits<_InputIterator>::value_type __value = *__first;
      *__result = __value;
      while (++__first != __last)
 if (!__binary_pred(__value, *__first))
   {
     __value = *__first;
     *++__result = __value;
   }
      return ++__result;
    }
  template<typename _InputIterator, typename _ForwardIterator,
    typename _BinaryPredicate>
    _ForwardIterator
    __unique_copy(_InputIterator __first, _InputIterator __last,
    _ForwardIterator __result,
    _BinaryPredicate __binary_pred,
    forward_iterator_tag)
    {
      *__result = *__first;
      while (++__first != __last)
 if (!__binary_pred(*__result, *__first)) *++__result = *__first;
      return ++__result;
    }
  template<typename _InputIterator, typename _OutputIterator>
    inline _OutputIterator
    unique_copy(_InputIterator __first, _InputIterator __last,
  _OutputIterator __result)
    {
      ;
      typedef typename iterator_traits<_OutputIterator>::iterator_category
 _IterType;
      if (__first == __last) return __result;
      return std::__unique_copy(__first, __last, __result, _IterType());
    }
  template<typename _InputIterator, typename _OutputIterator,
    typename _BinaryPredicate>
    inline _OutputIterator
    unique_copy(_InputIterator __first, _InputIterator __last,
  _OutputIterator __result,
  _BinaryPredicate __binary_pred)
    {
      ;
      typedef typename iterator_traits<_OutputIterator>::iterator_category
 _IterType;
      if (__first == __last) return __result;
      return std::__unique_copy(__first, __last, __result,
    __binary_pred, _IterType());
    }
  template<typename _ForwardIterator>
    _ForwardIterator
    unique(_ForwardIterator __first, _ForwardIterator __last)
    {
      ;
      __first = std::adjacent_find(__first, __last);
      if (__first == __last)
 return __last;
      _ForwardIterator __dest = __first;
      ++__first;
      while (++__first != __last)
 if (!(*__dest == *__first))
   *++__dest = *__first;
      return ++__dest;
    }
  template<typename _ForwardIterator, typename _BinaryPredicate>
    _ForwardIterator
    unique(_ForwardIterator __first, _ForwardIterator __last,
           _BinaryPredicate __binary_pred)
    {
      ;
      __first = std::adjacent_find(__first, __last, __binary_pred);
      if (__first == __last)
 return __last;
      _ForwardIterator __dest = __first;
      ++__first;
      while (++__first != __last)
 if (!__binary_pred(*__dest, *__first))
   *++__dest = *__first;
      return ++__dest;
    }
  template<typename _BidirectionalIterator>
    void
    __reverse(_BidirectionalIterator __first, _BidirectionalIterator __last,
       bidirectional_iterator_tag)
    {
      while (true)
 if (__first == __last || __first == --__last)
   return;
 else
   {
     std::iter_swap(__first, __last);
     ++__first;
   }
    }
  template<typename _RandomAccessIterator>
    void
    __reverse(_RandomAccessIterator __first, _RandomAccessIterator __last,
       random_access_iterator_tag)
    {
      if (__first == __last)
 return;
      --__last;
      while (__first < __last)
 {
   std::iter_swap(__first, __last);
   ++__first;
   --__last;
 }
    }
  template<typename _BidirectionalIterator>
    inline void
    reverse(_BidirectionalIterator __first, _BidirectionalIterator __last)
    {
      ;
      std::__reverse(__first, __last, std::__iterator_category(__first));
    }
  template<typename _BidirectionalIterator, typename _OutputIterator>
    _OutputIterator
    reverse_copy(_BidirectionalIterator __first, _BidirectionalIterator __last,
        _OutputIterator __result)
    {
      ;
      while (__first != __last)
 {
   --__last;
   *__result = *__last;
   ++__result;
 }
      return __result;
    }
  template<typename _EuclideanRingElement>
    _EuclideanRingElement
    __gcd(_EuclideanRingElement __m, _EuclideanRingElement __n)
    {
      while (__n != 0)
 {
   _EuclideanRingElement __t = __m % __n;
   __m = __n;
   __n = __t;
 }
      return __m;
    }
  template<typename _ForwardIterator>
    void
    __rotate(_ForwardIterator __first,
      _ForwardIterator __middle,
      _ForwardIterator __last,
      forward_iterator_tag)
    {
      if (__first == __middle || __last == __middle)
 return;
      _ForwardIterator __first2 = __middle;
      do
 {
   swap(*__first, *__first2);
   ++__first;
   ++__first2;
   if (__first == __middle)
     __middle = __first2;
 }
      while (__first2 != __last);
      __first2 = __middle;
      while (__first2 != __last)
 {
   swap(*__first, *__first2);
   ++__first;
   ++__first2;
   if (__first == __middle)
     __middle = __first2;
   else if (__first2 == __last)
     __first2 = __middle;
 }
    }
  template<typename _BidirectionalIterator>
    void
    __rotate(_BidirectionalIterator __first,
      _BidirectionalIterator __middle,
      _BidirectionalIterator __last,
       bidirectional_iterator_tag)
    {
      if (__first == __middle || __last == __middle)
 return;
      std::__reverse(__first, __middle, bidirectional_iterator_tag());
      std::__reverse(__middle, __last, bidirectional_iterator_tag());
      while (__first != __middle && __middle != __last)
 {
   swap(*__first, *--__last);
   ++__first;
 }
      if (__first == __middle)
 std::__reverse(__middle, __last, bidirectional_iterator_tag());
      else
 std::__reverse(__first, __middle, bidirectional_iterator_tag());
    }
  template<typename _RandomAccessIterator>
    void
    __rotate(_RandomAccessIterator __first,
      _RandomAccessIterator __middle,
      _RandomAccessIterator __last,
      random_access_iterator_tag)
    {
      if (__first == __middle || __last == __middle)
 return;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _Distance;
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;
      const _Distance __n = __last - __first;
      const _Distance __k = __middle - __first;
      const _Distance __l = __n - __k;
      if (__k == __l)
 {
   std::swap_ranges(__first, __middle, __middle);
   return;
 }
      const _Distance __d = __gcd(__n, __k);
      for (_Distance __i = 0; __i < __d; __i++)
 {
   _ValueType __tmp = *__first;
   _RandomAccessIterator __p = __first;
   if (__k < __l)
     {
       for (_Distance __j = 0; __j < __l / __d; __j++)
  {
    if (__p > __first + __l)
      {
        *__p = *(__p - __l);
        __p -= __l;
      }
    *__p = *(__p + __k);
    __p += __k;
  }
     }
   else
     {
       for (_Distance __j = 0; __j < __k / __d - 1; __j ++)
  {
    if (__p < __last - __k)
      {
        *__p = *(__p + __k);
        __p += __k;
      }
    *__p = * (__p - __l);
    __p -= __l;
  }
     }
   *__p = __tmp;
   ++__first;
 }
    }
  template<typename _ForwardIterator>
    inline void
    rotate(_ForwardIterator __first, _ForwardIterator __middle,
    _ForwardIterator __last)
    {
      ;
      ;
      typedef typename iterator_traits<_ForwardIterator>::iterator_category
 _IterType;
      std::__rotate(__first, __middle, __last, _IterType());
    }
  template<typename _ForwardIterator, typename _OutputIterator>
    _OutputIterator
    rotate_copy(_ForwardIterator __first, _ForwardIterator __middle,
                _ForwardIterator __last, _OutputIterator __result)
    {
      ;
      ;
      return std::copy(__first, __middle,
                       std::copy(__middle, __last, __result));
    }
  template<typename _RandomAccessIterator>
    inline void
    random_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {
      ;
      if (__first != __last)
 for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
   std::iter_swap(__i, __first + (std::rand() % ((__i - __first) + 1)));
    }
  template<typename _RandomAccessIterator, typename _RandomNumberGenerator>
    void
    random_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last,
     _RandomNumberGenerator& __rand)
    {
      ;
      if (__first == __last)
 return;
      for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
 std::iter_swap(__i, __first + __rand((__i - __first) + 1));
    }
  template<typename _ForwardIterator, typename _Predicate>
    _ForwardIterator
    __partition(_ForwardIterator __first, _ForwardIterator __last,
  _Predicate __pred,
  forward_iterator_tag)
    {
      if (__first == __last)
 return __first;
      while (__pred(*__first))
 if (++__first == __last)
   return __first;
      _ForwardIterator __next = __first;
      while (++__next != __last)
 if (__pred(*__next))
   {
     swap(*__first, *__next);
     ++__first;
   }
      return __first;
    }
  template<typename _BidirectionalIterator, typename _Predicate>
    _BidirectionalIterator
    __partition(_BidirectionalIterator __first, _BidirectionalIterator __last,
  _Predicate __pred,
  bidirectional_iterator_tag)
    {
      while (true)
 {
   while (true)
     if (__first == __last)
       return __first;
     else if (__pred(*__first))
       ++__first;
     else
       break;
   --__last;
   while (true)
     if (__first == __last)
       return __first;
     else if (!__pred(*__last))
       --__last;
     else
       break;
   std::iter_swap(__first, __last);
   ++__first;
 }
    }
  template<typename _ForwardIterator, typename _Predicate>
    inline _ForwardIterator
    partition(_ForwardIterator __first, _ForwardIterator __last,
       _Predicate __pred)
    {
      ;
      return std::__partition(__first, __last, __pred,
         std::__iterator_category(__first));
    }
  template<typename _ForwardIterator, typename _Predicate, typename _Distance>
    _ForwardIterator
    __inplace_stable_partition(_ForwardIterator __first,
          _ForwardIterator __last,
          _Predicate __pred, _Distance __len)
    {
      if (__len == 1)
 return __pred(*__first) ? __last : __first;
      _ForwardIterator __middle = __first;
      std::advance(__middle, __len / 2);
      _ForwardIterator __begin = std::__inplace_stable_partition(__first,
         __middle,
         __pred,
         __len / 2);
      _ForwardIterator __end = std::__inplace_stable_partition(__middle, __last,
              __pred,
              __len
              - __len / 2);
      std::rotate(__begin, __middle, __end);
      std::advance(__begin, std::distance(__middle, __end));
      return __begin;
    }
  template<typename _ForwardIterator, typename _Pointer, typename _Predicate,
    typename _Distance>
    _ForwardIterator
    __stable_partition_adaptive(_ForwardIterator __first,
    _ForwardIterator __last,
    _Predicate __pred, _Distance __len,
    _Pointer __buffer,
    _Distance __buffer_size)
    {
      if (__len <= __buffer_size)
 {
   _ForwardIterator __result1 = __first;
   _Pointer __result2 = __buffer;
   for ( ; __first != __last ; ++__first)
     if (__pred(*__first))
       {
  *__result1 = *__first;
  ++__result1;
       }
     else
       {
  *__result2 = *__first;
  ++__result2;
       }
   std::copy(__buffer, __result2, __result1);
   return __result1;
 }
      else
 {
   _ForwardIterator __middle = __first;
   std::advance(__middle, __len / 2);
   _ForwardIterator __begin =
     std::__stable_partition_adaptive(__first, __middle, __pred,
          __len / 2, __buffer,
          __buffer_size);
   _ForwardIterator __end =
     std::__stable_partition_adaptive(__middle, __last, __pred,
          __len - __len / 2,
          __buffer, __buffer_size);
   std::rotate(__begin, __middle, __end);
   std::advance(__begin, std::distance(__middle, __end));
   return __begin;
 }
    }
  template<typename _ForwardIterator, typename _Predicate>
    _ForwardIterator
    stable_partition(_ForwardIterator __first, _ForwardIterator __last,
       _Predicate __pred)
    {
      ;
      if (__first == __last)
 return __first;
      else
 {
   typedef typename iterator_traits<_ForwardIterator>::value_type
     _ValueType;
   typedef typename iterator_traits<_ForwardIterator>::difference_type
     _DistanceType;
   _Temporary_buffer<_ForwardIterator, _ValueType> __buf(__first,
        __last);
 if (__buf.size() > 0)
   return
     std::__stable_partition_adaptive(__first, __last, __pred,
       _DistanceType(__buf.requested_size()),
       __buf.begin(), __buf.size());
 else
   return
     std::__inplace_stable_partition(__first, __last, __pred,
      _DistanceType(__buf.requested_size()));
 }
    }
  template<typename _RandomAccessIterator, typename _Tp>
    _RandomAccessIterator
    __unguarded_partition(_RandomAccessIterator __first,
     _RandomAccessIterator __last, _Tp __pivot)
    {
      while (true)
 {
   while (*__first < __pivot)
     ++__first;
   --__last;
   while (__pivot < *__last)
     --__last;
   if (!(__first < __last))
     return __first;
   std::iter_swap(__first, __last);
   ++__first;
 }
    }
  template<typename _RandomAccessIterator, typename _Tp, typename _Compare>
    _RandomAccessIterator
    __unguarded_partition(_RandomAccessIterator __first,
     _RandomAccessIterator __last,
     _Tp __pivot, _Compare __comp)
    {
      while (true)
 {
   while (__comp(*__first, __pivot))
     ++__first;
   --__last;
   while (__comp(__pivot, *__last))
     --__last;
   if (!(__first < __last))
     return __first;
   std::iter_swap(__first, __last);
   ++__first;
 }
    }
  enum { _S_threshold = 16 };
  template<typename _RandomAccessIterator, typename _Tp>
    void
    __unguarded_linear_insert(_RandomAccessIterator __last, _Tp __val)
    {
      _RandomAccessIterator __next = __last;
      --__next;
      while (__val < *__next)
 {
   *__last = *__next;
   __last = __next;
   --__next;
 }
      *__last = __val;
    }
  template<typename _RandomAccessIterator, typename _Tp, typename _Compare>
    void
    __unguarded_linear_insert(_RandomAccessIterator __last, _Tp __val,
         _Compare __comp)
    {
      _RandomAccessIterator __next = __last;
      --__next;
      while (__comp(__val, *__next))
 {
   *__last = *__next;
   __last = __next;
   --__next;
 }
      *__last = __val;
    }
  template<typename _RandomAccessIterator>
    void
    __insertion_sort(_RandomAccessIterator __first,
       _RandomAccessIterator __last)
    {
      if (__first == __last)
 return;
      for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
 {
   typename iterator_traits<_RandomAccessIterator>::value_type
     __val = *__i;
   if (__val < *__first)
     {
       std::copy_backward(__first, __i, __i + 1);
       *__first = __val;
     }
   else
     std::__unguarded_linear_insert(__i, __val);
 }
    }
  template<typename _RandomAccessIterator, typename _Compare>
    void
    __insertion_sort(_RandomAccessIterator __first,
       _RandomAccessIterator __last, _Compare __comp)
    {
      if (__first == __last) return;
      for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
 {
   typename iterator_traits<_RandomAccessIterator>::value_type
     __val = *__i;
   if (__comp(__val, *__first))
     {
       std::copy_backward(__first, __i, __i + 1);
       *__first = __val;
     }
   else
     std::__unguarded_linear_insert(__i, __val, __comp);
 }
    }
  template<typename _RandomAccessIterator>
    inline void
    __unguarded_insertion_sort(_RandomAccessIterator __first,
          _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;
      for (_RandomAccessIterator __i = __first; __i != __last; ++__i)
 std::__unguarded_linear_insert(__i, _ValueType(*__i));
    }
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    __unguarded_insertion_sort(_RandomAccessIterator __first,
          _RandomAccessIterator __last, _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;
      for (_RandomAccessIterator __i = __first; __i != __last; ++__i)
 std::__unguarded_linear_insert(__i, _ValueType(*__i), __comp);
    }
  template<typename _RandomAccessIterator>
    void
    __final_insertion_sort(_RandomAccessIterator __first,
      _RandomAccessIterator __last)
    {
      if (__last - __first > int(_S_threshold))
 {
   std::__insertion_sort(__first, __first + int(_S_threshold));
   std::__unguarded_insertion_sort(__first + int(_S_threshold), __last);
 }
      else
 std::__insertion_sort(__first, __last);
    }
  template<typename _RandomAccessIterator, typename _Compare>
    void
    __final_insertion_sort(_RandomAccessIterator __first,
      _RandomAccessIterator __last, _Compare __comp)
    {
      if (__last - __first > int(_S_threshold))
 {
   std::__insertion_sort(__first, __first + int(_S_threshold), __comp);
   std::__unguarded_insertion_sort(__first + int(_S_threshold), __last,
       __comp);
 }
      else
 std::__insertion_sort(__first, __last, __comp);
    }
  template<typename _Size>
    inline _Size
    __lg(_Size __n)
    {
      _Size __k;
      for (__k = 0; __n != 1; __n >>= 1)
 ++__k;
      return __k;
    }
  template<typename _RandomAccessIterator>
    void
    partial_sort(_RandomAccessIterator __first,
   _RandomAccessIterator __middle,
   _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;
      ;
      ;
      std::make_heap(__first, __middle);
      for (_RandomAccessIterator __i = __middle; __i < __last; ++__i)
 if (*__i < *__first)
   std::__pop_heap(__first, __middle, __i, _ValueType(*__i));
      std::sort_heap(__first, __middle);
    }
  template<typename _RandomAccessIterator, typename _Compare>
    void
    partial_sort(_RandomAccessIterator __first,
   _RandomAccessIterator __middle,
   _RandomAccessIterator __last,
   _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;
      ;
      ;
      std::make_heap(__first, __middle, __comp);
      for (_RandomAccessIterator __i = __middle; __i < __last; ++__i)
 if (__comp(*__i, *__first))
   std::__pop_heap(__first, __middle, __i, _ValueType(*__i), __comp);
      std::sort_heap(__first, __middle, __comp);
    }
  template<typename _InputIterator, typename _RandomAccessIterator>
    _RandomAccessIterator
    partial_sort_copy(_InputIterator __first, _InputIterator __last,
        _RandomAccessIterator __result_first,
        _RandomAccessIterator __result_last)
    {
      typedef typename iterator_traits<_InputIterator>::value_type
 _InputValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _OutputValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _DistanceType;
      ;
      ;
      if (__result_first == __result_last)
 return __result_last;
      _RandomAccessIterator __result_real_last = __result_first;
      while(__first != __last && __result_real_last != __result_last)
 {
   *__result_real_last = *__first;
   ++__result_real_last;
   ++__first;
 }
      std::make_heap(__result_first, __result_real_last);
      while (__first != __last)
 {
   if (*__first < *__result_first)
     std::__adjust_heap(__result_first, _DistanceType(0),
          _DistanceType(__result_real_last
          - __result_first),
          _InputValueType(*__first));
   ++__first;
 }
      std::sort_heap(__result_first, __result_real_last);
      return __result_real_last;
    }
  template<typename _InputIterator, typename _RandomAccessIterator, typename _Compare>
    _RandomAccessIterator
    partial_sort_copy(_InputIterator __first, _InputIterator __last,
        _RandomAccessIterator __result_first,
        _RandomAccessIterator __result_last,
        _Compare __comp)
    {
      typedef typename iterator_traits<_InputIterator>::value_type
 _InputValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _OutputValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _DistanceType;
      ;
      ;
      if (__result_first == __result_last)
 return __result_last;
      _RandomAccessIterator __result_real_last = __result_first;
      while(__first != __last && __result_real_last != __result_last)
 {
   *__result_real_last = *__first;
   ++__result_real_last;
   ++__first;
 }
      std::make_heap(__result_first, __result_real_last, __comp);
      while (__first != __last)
 {
   if (__comp(*__first, *__result_first))
     std::__adjust_heap(__result_first, _DistanceType(0),
          _DistanceType(__result_real_last
          - __result_first),
          _InputValueType(*__first),
          __comp);
   ++__first;
 }
      std::sort_heap(__result_first, __result_real_last, __comp);
      return __result_real_last;
    }
  template<typename _RandomAccessIterator, typename _Size>
    void
    __introsort_loop(_RandomAccessIterator __first,
       _RandomAccessIterator __last,
       _Size __depth_limit)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;
      while (__last - __first > int(_S_threshold))
 {
   if (__depth_limit == 0)
     {
       std::partial_sort(__first, __last, __last);
       return;
     }
   --__depth_limit;
   _RandomAccessIterator __cut =
     std::__unguarded_partition(__first, __last,
           _ValueType(std::__median(*__first,
        *(__first
          + (__last
             - __first)
          / 2),
        *(__last
          - 1))));
   std::__introsort_loop(__cut, __last, __depth_limit);
   __last = __cut;
 }
    }
  template<typename _RandomAccessIterator, typename _Size, typename _Compare>
    void
    __introsort_loop(_RandomAccessIterator __first,
       _RandomAccessIterator __last,
       _Size __depth_limit, _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;
      while (__last - __first > int(_S_threshold))
 {
   if (__depth_limit == 0)
     {
       std::partial_sort(__first, __last, __last, __comp);
       return;
     }
   --__depth_limit;
   _RandomAccessIterator __cut =
     std::__unguarded_partition(__first, __last,
           _ValueType(std::__median(*__first,
        *(__first
          + (__last
             - __first)
          / 2),
        *(__last - 1),
        __comp)),
           __comp);
   std::__introsort_loop(__cut, __last, __depth_limit, __comp);
   __last = __cut;
 }
    }
  template<typename _RandomAccessIterator>
    inline void
    sort(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;
      ;
      if (__first != __last)
 {
   std::__introsort_loop(__first, __last, __lg(__last - __first) * 2);
   std::__final_insertion_sort(__first, __last);
 }
    }
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    sort(_RandomAccessIterator __first, _RandomAccessIterator __last,
  _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;
      ;
      if (__first != __last)
 {
   std::__introsort_loop(__first, __last, __lg(__last - __first) * 2,
    __comp);
   std::__final_insertion_sort(__first, __last, __comp);
 }
    }
  template<typename _ForwardIterator, typename _Tp>
    _ForwardIterator
    lower_bound(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;
      ;
      _DistanceType __len = std::distance(__first, __last);
      _DistanceType __half;
      _ForwardIterator __middle;
      while (__len > 0)
 {
   __half = __len >> 1;
   __middle = __first;
   std::advance(__middle, __half);
   if (*__middle < __val)
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
   else
     __len = __half;
 }
      return __first;
    }
  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    _ForwardIterator
    lower_bound(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val, _Compare __comp)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;
      ;
      _DistanceType __len = std::distance(__first, __last);
      _DistanceType __half;
      _ForwardIterator __middle;
      while (__len > 0)
 {
   __half = __len >> 1;
   __middle = __first;
   std::advance(__middle, __half);
   if (__comp(*__middle, __val))
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
   else
     __len = __half;
 }
      return __first;
    }
  template<typename _ForwardIterator, typename _Tp>
    _ForwardIterator
    upper_bound(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;
      ;
      _DistanceType __len = std::distance(__first, __last);
      _DistanceType __half;
      _ForwardIterator __middle;
      while (__len > 0)
 {
   __half = __len >> 1;
   __middle = __first;
   std::advance(__middle, __half);
   if (__val < *__middle)
     __len = __half;
   else
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
 }
      return __first;
    }
  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    _ForwardIterator
    upper_bound(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val, _Compare __comp)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;
      ;
      _DistanceType __len = std::distance(__first, __last);
      _DistanceType __half;
      _ForwardIterator __middle;
      while (__len > 0)
 {
   __half = __len >> 1;
   __middle = __first;
   std::advance(__middle, __half);
   if (__comp(__val, *__middle))
     __len = __half;
   else
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
 }
      return __first;
    }
  template<typename _BidirectionalIterator, typename _Distance>
    void
    __merge_without_buffer(_BidirectionalIterator __first,
      _BidirectionalIterator __middle,
      _BidirectionalIterator __last,
      _Distance __len1, _Distance __len2)
    {
      if (__len1 == 0 || __len2 == 0)
 return;
      if (__len1 + __len2 == 2)
 {
   if (*__middle < *__first)
     std::iter_swap(__first, __middle);
   return;
 }
      _BidirectionalIterator __first_cut = __first;
      _BidirectionalIterator __second_cut = __middle;
      _Distance __len11 = 0;
      _Distance __len22 = 0;
      if (__len1 > __len2)
 {
   __len11 = __len1 / 2;
   std::advance(__first_cut, __len11);
   __second_cut = std::lower_bound(__middle, __last, *__first_cut);
   __len22 = std::distance(__middle, __second_cut);
 }
      else
 {
   __len22 = __len2 / 2;
   std::advance(__second_cut, __len22);
   __first_cut = std::upper_bound(__first, __middle, *__second_cut);
   __len11 = std::distance(__first, __first_cut);
 }
      std::rotate(__first_cut, __middle, __second_cut);
      _BidirectionalIterator __new_middle = __first_cut;
      std::advance(__new_middle, std::distance(__middle, __second_cut));
      std::__merge_without_buffer(__first, __first_cut, __new_middle,
      __len11, __len22);
      std::__merge_without_buffer(__new_middle, __second_cut, __last,
      __len1 - __len11, __len2 - __len22);
    }
  template<typename _BidirectionalIterator, typename _Distance,
    typename _Compare>
    void
    __merge_without_buffer(_BidirectionalIterator __first,
                           _BidirectionalIterator __middle,
      _BidirectionalIterator __last,
      _Distance __len1, _Distance __len2,
      _Compare __comp)
    {
      if (__len1 == 0 || __len2 == 0)
 return;
      if (__len1 + __len2 == 2)
 {
   if (__comp(*__middle, *__first))
     std::iter_swap(__first, __middle);
   return;
 }
      _BidirectionalIterator __first_cut = __first;
      _BidirectionalIterator __second_cut = __middle;
      _Distance __len11 = 0;
      _Distance __len22 = 0;
      if (__len1 > __len2)
 {
   __len11 = __len1 / 2;
   std::advance(__first_cut, __len11);
   __second_cut = std::lower_bound(__middle, __last, *__first_cut,
       __comp);
   __len22 = std::distance(__middle, __second_cut);
 }
      else
 {
   __len22 = __len2 / 2;
   std::advance(__second_cut, __len22);
   __first_cut = std::upper_bound(__first, __middle, *__second_cut,
      __comp);
   __len11 = std::distance(__first, __first_cut);
 }
      std::rotate(__first_cut, __middle, __second_cut);
      _BidirectionalIterator __new_middle = __first_cut;
      std::advance(__new_middle, std::distance(__middle, __second_cut));
      std::__merge_without_buffer(__first, __first_cut, __new_middle,
      __len11, __len22, __comp);
      std::__merge_without_buffer(__new_middle, __second_cut, __last,
      __len1 - __len11, __len2 - __len22, __comp);
    }
  template<typename _RandomAccessIterator>
    void
    __inplace_stable_sort(_RandomAccessIterator __first,
     _RandomAccessIterator __last)
    {
      if (__last - __first < 15)
 {
   std::__insertion_sort(__first, __last);
   return;
 }
      _RandomAccessIterator __middle = __first + (__last - __first) / 2;
      std::__inplace_stable_sort(__first, __middle);
      std::__inplace_stable_sort(__middle, __last);
      std::__merge_without_buffer(__first, __middle, __last,
      __middle - __first,
      __last - __middle);
    }
  template<typename _RandomAccessIterator, typename _Compare>
    void
    __inplace_stable_sort(_RandomAccessIterator __first,
     _RandomAccessIterator __last, _Compare __comp)
    {
      if (__last - __first < 15)
 {
   std::__insertion_sort(__first, __last, __comp);
   return;
 }
      _RandomAccessIterator __middle = __first + (__last - __first) / 2;
      std::__inplace_stable_sort(__first, __middle, __comp);
      std::__inplace_stable_sort(__middle, __last, __comp);
      std::__merge_without_buffer(__first, __middle, __last,
      __middle - __first,
      __last - __middle,
      __comp);
    }
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    _OutputIterator
    merge(_InputIterator1 __first1, _InputIterator1 __last1,
   _InputIterator2 __first2, _InputIterator2 __last2,
   _OutputIterator __result)
    {
      ;
      ;
      while (__first1 != __last1 && __first2 != __last2)
 {
   if (*__first2 < *__first1)
     {
       *__result = *__first2;
       ++__first2;
     }
   else
     {
       *__result = *__first1;
       ++__first1;
     }
   ++__result;
 }
      return std::copy(__first2, __last2, std::copy(__first1, __last1,
          __result));
    }
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    _OutputIterator
    merge(_InputIterator1 __first1, _InputIterator1 __last1,
   _InputIterator2 __first2, _InputIterator2 __last2,
   _OutputIterator __result, _Compare __comp)
    {
      ;
      ;
      while (__first1 != __last1 && __first2 != __last2)
 {
   if (__comp(*__first2, *__first1))
     {
       *__result = *__first2;
       ++__first2;
     }
   else
     {
       *__result = *__first1;
       ++__first1;
     }
   ++__result;
 }
      return std::copy(__first2, __last2, std::copy(__first1, __last1,
          __result));
    }
  template<typename _RandomAccessIterator1, typename _RandomAccessIterator2,
    typename _Distance>
    void
    __merge_sort_loop(_RandomAccessIterator1 __first,
        _RandomAccessIterator1 __last,
        _RandomAccessIterator2 __result,
        _Distance __step_size)
    {
      const _Distance __two_step = 2 * __step_size;
      while (__last - __first >= __two_step)
 {
   __result = std::merge(__first, __first + __step_size,
    __first + __step_size, __first + __two_step,
    __result);
   __first += __two_step;
 }
      __step_size = std::min(_Distance(__last - __first), __step_size);
      std::merge(__first, __first + __step_size, __first + __step_size, __last,
   __result);
    }
  template<typename _RandomAccessIterator1, typename _RandomAccessIterator2,
    typename _Distance, typename _Compare>
    void
    __merge_sort_loop(_RandomAccessIterator1 __first,
        _RandomAccessIterator1 __last,
        _RandomAccessIterator2 __result, _Distance __step_size,
        _Compare __comp)
    {
      const _Distance __two_step = 2 * __step_size;
      while (__last - __first >= __two_step)
 {
   __result = std::merge(__first, __first + __step_size,
    __first + __step_size, __first + __two_step,
    __result,
    __comp);
   __first += __two_step;
 }
      __step_size = std::min(_Distance(__last - __first), __step_size);
      std::merge(__first, __first + __step_size,
   __first + __step_size, __last,
   __result,
   __comp);
    }
  enum { _S_chunk_size = 7 };
  template<typename _RandomAccessIterator, typename _Distance>
    void
    __chunk_insertion_sort(_RandomAccessIterator __first,
      _RandomAccessIterator __last,
      _Distance __chunk_size)
    {
      while (__last - __first >= __chunk_size)
 {
   std::__insertion_sort(__first, __first + __chunk_size);
   __first += __chunk_size;
 }
      std::__insertion_sort(__first, __last);
    }
  template<typename _RandomAccessIterator, typename _Distance, typename _Compare>
    void
    __chunk_insertion_sort(_RandomAccessIterator __first,
      _RandomAccessIterator __last,
      _Distance __chunk_size, _Compare __comp)
    {
      while (__last - __first >= __chunk_size)
 {
   std::__insertion_sort(__first, __first + __chunk_size, __comp);
   __first += __chunk_size;
 }
      std::__insertion_sort(__first, __last, __comp);
    }
  template<typename _RandomAccessIterator, typename _Pointer>
    void
    __merge_sort_with_buffer(_RandomAccessIterator __first,
        _RandomAccessIterator __last,
                             _Pointer __buffer)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _Distance;
      const _Distance __len = __last - __first;
      const _Pointer __buffer_last = __buffer + __len;
      _Distance __step_size = _S_chunk_size;
      std::__chunk_insertion_sort(__first, __last, __step_size);
      while (__step_size < __len)
 {
   std::__merge_sort_loop(__first, __last, __buffer, __step_size);
   __step_size *= 2;
   std::__merge_sort_loop(__buffer, __buffer_last, __first, __step_size);
   __step_size *= 2;
 }
    }
  template<typename _RandomAccessIterator, typename _Pointer, typename _Compare>
    void
    __merge_sort_with_buffer(_RandomAccessIterator __first,
        _RandomAccessIterator __last,
                             _Pointer __buffer, _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _Distance;
      const _Distance __len = __last - __first;
      const _Pointer __buffer_last = __buffer + __len;
      _Distance __step_size = _S_chunk_size;
      std::__chunk_insertion_sort(__first, __last, __step_size, __comp);
      while (__step_size < __len)
 {
   std::__merge_sort_loop(__first, __last, __buffer,
     __step_size, __comp);
   __step_size *= 2;
   std::__merge_sort_loop(__buffer, __buffer_last, __first,
     __step_size, __comp);
   __step_size *= 2;
 }
    }
  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2,
    typename _BidirectionalIterator3>
    _BidirectionalIterator3
    __merge_backward(_BidirectionalIterator1 __first1,
       _BidirectionalIterator1 __last1,
       _BidirectionalIterator2 __first2,
       _BidirectionalIterator2 __last2,
       _BidirectionalIterator3 __result)
    {
      if (__first1 == __last1)
 return std::copy_backward(__first2, __last2, __result);
      if (__first2 == __last2)
 return std::copy_backward(__first1, __last1, __result);
      --__last1;
      --__last2;
      while (true)
 {
   if (*__last2 < *__last1)
     {
       *--__result = *__last1;
       if (__first1 == __last1)
  return std::copy_backward(__first2, ++__last2, __result);
       --__last1;
     }
   else
     {
       *--__result = *__last2;
       if (__first2 == __last2)
  return std::copy_backward(__first1, ++__last1, __result);
       --__last2;
     }
 }
    }
  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2,
    typename _BidirectionalIterator3, typename _Compare>
    _BidirectionalIterator3
    __merge_backward(_BidirectionalIterator1 __first1,
       _BidirectionalIterator1 __last1,
       _BidirectionalIterator2 __first2,
       _BidirectionalIterator2 __last2,
       _BidirectionalIterator3 __result,
       _Compare __comp)
    {
      if (__first1 == __last1)
 return std::copy_backward(__first2, __last2, __result);
      if (__first2 == __last2)
 return std::copy_backward(__first1, __last1, __result);
      --__last1;
      --__last2;
      while (true)
 {
   if (__comp(*__last2, *__last1))
     {
       *--__result = *__last1;
       if (__first1 == __last1)
  return std::copy_backward(__first2, ++__last2, __result);
       --__last1;
     }
   else
     {
       *--__result = *__last2;
       if (__first2 == __last2)
  return std::copy_backward(__first1, ++__last1, __result);
       --__last2;
     }
 }
    }
  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2,
    typename _Distance>
    _BidirectionalIterator1
    __rotate_adaptive(_BidirectionalIterator1 __first,
        _BidirectionalIterator1 __middle,
        _BidirectionalIterator1 __last,
        _Distance __len1, _Distance __len2,
        _BidirectionalIterator2 __buffer,
        _Distance __buffer_size)
    {
      _BidirectionalIterator2 __buffer_end;
      if (__len1 > __len2 && __len2 <= __buffer_size)
 {
   __buffer_end = std::copy(__middle, __last, __buffer);
   std::copy_backward(__first, __middle, __last);
   return std::copy(__buffer, __buffer_end, __first);
 }
      else if (__len1 <= __buffer_size)
 {
   __buffer_end = std::copy(__first, __middle, __buffer);
   std::copy(__middle, __last, __first);
   return std::copy_backward(__buffer, __buffer_end, __last);
 }
      else
 {
   std::rotate(__first, __middle, __last);
   std::advance(__first, std::distance(__middle, __last));
   return __first;
 }
    }
  template<typename _BidirectionalIterator, typename _Distance,
    typename _Pointer>
    void
    __merge_adaptive(_BidirectionalIterator __first,
                     _BidirectionalIterator __middle,
       _BidirectionalIterator __last,
       _Distance __len1, _Distance __len2,
       _Pointer __buffer, _Distance __buffer_size)
    {
      if (__len1 <= __len2 && __len1 <= __buffer_size)
 {
   _Pointer __buffer_end = std::copy(__first, __middle, __buffer);
   std::merge(__buffer, __buffer_end, __middle, __last, __first);
 }
      else if (__len2 <= __buffer_size)
 {
   _Pointer __buffer_end = std::copy(__middle, __last, __buffer);
   std::__merge_backward(__first, __middle, __buffer,
    __buffer_end, __last);
 }
      else
 {
   _BidirectionalIterator __first_cut = __first;
   _BidirectionalIterator __second_cut = __middle;
   _Distance __len11 = 0;
   _Distance __len22 = 0;
   if (__len1 > __len2)
     {
       __len11 = __len1 / 2;
       std::advance(__first_cut, __len11);
       __second_cut = std::lower_bound(__middle, __last,
           *__first_cut);
       __len22 = std::distance(__middle, __second_cut);
     }
   else
     {
       __len22 = __len2 / 2;
       std::advance(__second_cut, __len22);
       __first_cut = std::upper_bound(__first, __middle,
          *__second_cut);
       __len11 = std::distance(__first, __first_cut);
     }
   _BidirectionalIterator __new_middle =
     std::__rotate_adaptive(__first_cut, __middle, __second_cut,
       __len1 - __len11, __len22, __buffer,
       __buffer_size);
   std::__merge_adaptive(__first, __first_cut, __new_middle, __len11,
    __len22, __buffer, __buffer_size);
   std::__merge_adaptive(__new_middle, __second_cut, __last,
    __len1 - __len11,
    __len2 - __len22, __buffer, __buffer_size);
 }
    }
  template<typename _BidirectionalIterator, typename _Distance, typename _Pointer,
    typename _Compare>
    void
    __merge_adaptive(_BidirectionalIterator __first,
                     _BidirectionalIterator __middle,
       _BidirectionalIterator __last,
       _Distance __len1, _Distance __len2,
       _Pointer __buffer, _Distance __buffer_size,
       _Compare __comp)
    {
      if (__len1 <= __len2 && __len1 <= __buffer_size)
 {
   _Pointer __buffer_end = std::copy(__first, __middle, __buffer);
   std::merge(__buffer, __buffer_end, __middle, __last, __first, __comp);
 }
      else if (__len2 <= __buffer_size)
 {
   _Pointer __buffer_end = std::copy(__middle, __last, __buffer);
   std::__merge_backward(__first, __middle, __buffer, __buffer_end,
    __last, __comp);
 }
      else
 {
   _BidirectionalIterator __first_cut = __first;
   _BidirectionalIterator __second_cut = __middle;
   _Distance __len11 = 0;
   _Distance __len22 = 0;
   if (__len1 > __len2)
     {
       __len11 = __len1 / 2;
       std::advance(__first_cut, __len11);
       __second_cut = std::lower_bound(__middle, __last, *__first_cut,
           __comp);
       __len22 = std::distance(__middle, __second_cut);
     }
   else
     {
       __len22 = __len2 / 2;
       std::advance(__second_cut, __len22);
       __first_cut = std::upper_bound(__first, __middle, *__second_cut,
          __comp);
       __len11 = std::distance(__first, __first_cut);
     }
   _BidirectionalIterator __new_middle =
     std::__rotate_adaptive(__first_cut, __middle, __second_cut,
       __len1 - __len11, __len22, __buffer,
       __buffer_size);
   std::__merge_adaptive(__first, __first_cut, __new_middle, __len11,
    __len22, __buffer, __buffer_size, __comp);
   std::__merge_adaptive(__new_middle, __second_cut, __last,
    __len1 - __len11,
    __len2 - __len22, __buffer,
    __buffer_size, __comp);
 }
    }
  template<typename _BidirectionalIterator>
    void
    inplace_merge(_BidirectionalIterator __first,
    _BidirectionalIterator __middle,
    _BidirectionalIterator __last)
    {
      typedef typename iterator_traits<_BidirectionalIterator>::value_type
          _ValueType;
      typedef typename iterator_traits<_BidirectionalIterator>::difference_type
          _DistanceType;
      ;
      ;
      if (__first == __middle || __middle == __last)
 return;
      _DistanceType __len1 = std::distance(__first, __middle);
      _DistanceType __len2 = std::distance(__middle, __last);
      _Temporary_buffer<_BidirectionalIterator, _ValueType> __buf(__first,
          __last);
      if (__buf.begin() == 0)
 std::__merge_without_buffer(__first, __middle, __last, __len1, __len2);
      else
 std::__merge_adaptive(__first, __middle, __last, __len1, __len2,
         __buf.begin(), _DistanceType(__buf.size()));
    }
  template<typename _BidirectionalIterator, typename _Compare>
    void
    inplace_merge(_BidirectionalIterator __first,
    _BidirectionalIterator __middle,
    _BidirectionalIterator __last,
    _Compare __comp)
    {
      typedef typename iterator_traits<_BidirectionalIterator>::value_type
          _ValueType;
      typedef typename iterator_traits<_BidirectionalIterator>::difference_type
          _DistanceType;
      ;
      ;
      if (__first == __middle || __middle == __last)
 return;
      const _DistanceType __len1 = std::distance(__first, __middle);
      const _DistanceType __len2 = std::distance(__middle, __last);
      _Temporary_buffer<_BidirectionalIterator, _ValueType> __buf(__first,
          __last);
      if (__buf.begin() == 0)
 std::__merge_without_buffer(__first, __middle, __last, __len1,
        __len2, __comp);
      else
 std::__merge_adaptive(__first, __middle, __last, __len1, __len2,
         __buf.begin(), _DistanceType(__buf.size()),
         __comp);
    }
  template<typename _RandomAccessIterator, typename _Pointer,
    typename _Distance>
    void
    __stable_sort_adaptive(_RandomAccessIterator __first,
      _RandomAccessIterator __last,
                           _Pointer __buffer, _Distance __buffer_size)
    {
      const _Distance __len = (__last - __first + 1) / 2;
      const _RandomAccessIterator __middle = __first + __len;
      if (__len > __buffer_size)
 {
   std::__stable_sort_adaptive(__first, __middle,
          __buffer, __buffer_size);
   std::__stable_sort_adaptive(__middle, __last,
          __buffer, __buffer_size);
 }
      else
 {
   std::__merge_sort_with_buffer(__first, __middle, __buffer);
   std::__merge_sort_with_buffer(__middle, __last, __buffer);
 }
      std::__merge_adaptive(__first, __middle, __last,
       _Distance(__middle - __first),
       _Distance(__last - __middle),
       __buffer, __buffer_size);
    }
  template<typename _RandomAccessIterator, typename _Pointer,
    typename _Distance, typename _Compare>
    void
    __stable_sort_adaptive(_RandomAccessIterator __first,
      _RandomAccessIterator __last,
                           _Pointer __buffer, _Distance __buffer_size,
                           _Compare __comp)
    {
      const _Distance __len = (__last - __first + 1) / 2;
      const _RandomAccessIterator __middle = __first + __len;
      if (__len > __buffer_size)
 {
   std::__stable_sort_adaptive(__first, __middle, __buffer,
          __buffer_size, __comp);
   std::__stable_sort_adaptive(__middle, __last, __buffer,
          __buffer_size, __comp);
 }
      else
 {
   std::__merge_sort_with_buffer(__first, __middle, __buffer, __comp);
   std::__merge_sort_with_buffer(__middle, __last, __buffer, __comp);
 }
      std::__merge_adaptive(__first, __middle, __last,
       _Distance(__middle - __first),
       _Distance(__last - __middle),
       __buffer, __buffer_size,
       __comp);
    }
  template<typename _RandomAccessIterator>
    inline void
    stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _DistanceType;
      ;
      _Temporary_buffer<_RandomAccessIterator, _ValueType>
 buf(__first, __last);
      if (buf.begin() == 0)
 std::__inplace_stable_sort(__first, __last);
      else
 std::__stable_sort_adaptive(__first, __last, buf.begin(),
        _DistanceType(buf.size()));
    }
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last,
  _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _DistanceType;
      ;
      _Temporary_buffer<_RandomAccessIterator, _ValueType> buf(__first, __last);
      if (buf.begin() == 0)
 std::__inplace_stable_sort(__first, __last, __comp);
      else
 std::__stable_sort_adaptive(__first, __last, buf.begin(),
        _DistanceType(buf.size()), __comp);
    }
  template<typename _RandomAccessIterator>
    void
    nth_element(_RandomAccessIterator __first,
  _RandomAccessIterator __nth,
  _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;
      ;
      ;
      while (__last - __first > 3)
 {
   _RandomAccessIterator __cut =
     std::__unguarded_partition(__first, __last,
           _ValueType(std::__median(*__first,
        *(__first
          + (__last
             - __first)
          / 2),
        *(__last
          - 1))));
   if (__cut <= __nth)
     __first = __cut;
   else
     __last = __cut;
 }
      std::__insertion_sort(__first, __last);
    }
  template<typename _RandomAccessIterator, typename _Compare>
    void
    nth_element(_RandomAccessIterator __first,
  _RandomAccessIterator __nth,
  _RandomAccessIterator __last,
       _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;
      ;
      ;
      while (__last - __first > 3)
 {
   _RandomAccessIterator __cut =
     std::__unguarded_partition(__first, __last,
           _ValueType(std::__median(*__first,
        *(__first
          + (__last
             - __first)
          / 2),
        *(__last - 1),
             __comp)), __comp);
   if (__cut <= __nth)
     __first = __cut;
   else
     __last = __cut;
 }
      std::__insertion_sort(__first, __last, __comp);
    }
  template<typename _ForwardIterator, typename _Tp>
    pair<_ForwardIterator, _ForwardIterator>
    equal_range(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;
      ;
      _DistanceType __len = std::distance(__first, __last);
      _DistanceType __half;
      _ForwardIterator __middle, __left, __right;
      while (__len > 0)
 {
   __half = __len >> 1;
   __middle = __first;
   std::advance(__middle, __half);
   if (*__middle < __val)
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
   else if (__val < *__middle)
     __len = __half;
   else
     {
       __left = std::lower_bound(__first, __middle, __val);
       std::advance(__first, __len);
       __right = std::upper_bound(++__middle, __first, __val);
       return pair<_ForwardIterator, _ForwardIterator>(__left, __right);
     }
 }
      return pair<_ForwardIterator, _ForwardIterator>(__first, __first);
    }
  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    pair<_ForwardIterator, _ForwardIterator>
    equal_range(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val,
  _Compare __comp)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;
      ;
      _DistanceType __len = std::distance(__first, __last);
      _DistanceType __half;
      _ForwardIterator __middle, __left, __right;
      while (__len > 0)
 {
   __half = __len >> 1;
   __middle = __first;
   std::advance(__middle, __half);
   if (__comp(*__middle, __val))
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
   else if (__comp(__val, *__middle))
     __len = __half;
   else
     {
       __left = std::lower_bound(__first, __middle, __val, __comp);
       std::advance(__first, __len);
       __right = std::upper_bound(++__middle, __first, __val, __comp);
       return pair<_ForwardIterator, _ForwardIterator>(__left, __right);
     }
 }
      return pair<_ForwardIterator, _ForwardIterator>(__first, __first);
    }
  template<typename _ForwardIterator, typename _Tp>
    bool
    binary_search(_ForwardIterator __first, _ForwardIterator __last,
                  const _Tp& __val)
    {
      ;
      _ForwardIterator __i = std::lower_bound(__first, __last, __val);
      return __i != __last && !(__val < *__i);
    }
  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    bool
    binary_search(_ForwardIterator __first, _ForwardIterator __last,
                  const _Tp& __val, _Compare __comp)
    {
      ;
      _ForwardIterator __i = std::lower_bound(__first, __last, __val, __comp);
      return __i != __last && !__comp(__val, *__i);
    }
  template<typename _InputIterator1, typename _InputIterator2>
    bool
    includes(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2)
    {
      ;
      ;
      while (__first1 != __last1 && __first2 != __last2)
 if (*__first2 < *__first1)
   return false;
 else if(*__first1 < *__first2)
   ++__first1;
 else
   ++__first1, ++__first2;
      return __first2 == __last2;
    }
  template<typename _InputIterator1, typename _InputIterator2,
    typename _Compare>
    bool
    includes(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2, _Compare __comp)
    {
      ;
      ;
      while (__first1 != __last1 && __first2 != __last2)
 if (__comp(*__first2, *__first1))
   return false;
 else if(__comp(*__first1, *__first2))
   ++__first1;
 else
   ++__first1, ++__first2;
      return __first2 == __last2;
    }
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    _OutputIterator
    set_union(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2,
       _OutputIterator __result)
    {
      ;
      ;
      while (__first1 != __last1 && __first2 != __last2)
 {
   if (*__first1 < *__first2)
     {
       *__result = *__first1;
       ++__first1;
     }
   else if (*__first2 < *__first1)
     {
       *__result = *__first2;
       ++__first2;
     }
   else
     {
       *__result = *__first1;
       ++__first1;
       ++__first2;
     }
   ++__result;
 }
      return std::copy(__first2, __last2, std::copy(__first1, __last1,
          __result));
    }
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    _OutputIterator
    set_union(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2,
       _OutputIterator __result, _Compare __comp)
    {
      ;
      ;
      while (__first1 != __last1 && __first2 != __last2)
 {
   if (__comp(*__first1, *__first2))
     {
       *__result = *__first1;
       ++__first1;
     }
   else if (__comp(*__first2, *__first1))
     {
       *__result = *__first2;
       ++__first2;
     }
   else
     {
       *__result = *__first1;
       ++__first1;
       ++__first2;
     }
   ++__result;
 }
      return std::copy(__first2, __last2, std::copy(__first1, __last1,
          __result));
    }
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    _OutputIterator
    set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2,
       _OutputIterator __result)
    {
      ;
      ;
      while (__first1 != __last1 && __first2 != __last2)
 if (*__first1 < *__first2)
   ++__first1;
 else if (*__first2 < *__first1)
   ++__first2;
 else
   {
     *__result = *__first1;
     ++__first1;
     ++__first2;
     ++__result;
   }
      return __result;
    }
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    _OutputIterator
    set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2,
       _OutputIterator __result, _Compare __comp)
    {
      ;
      ;
      while (__first1 != __last1 && __first2 != __last2)
 if (__comp(*__first1, *__first2))
   ++__first1;
 else if (__comp(*__first2, *__first1))
   ++__first2;
 else
   {
     *__result = *__first1;
     ++__first1;
     ++__first2;
     ++__result;
   }
      return __result;
    }
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    _OutputIterator
    set_difference(_InputIterator1 __first1, _InputIterator1 __last1,
     _InputIterator2 __first2, _InputIterator2 __last2,
     _OutputIterator __result)
    {
      ;
      ;
      while (__first1 != __last1 && __first2 != __last2)
 if (*__first1 < *__first2)
   {
     *__result = *__first1;
     ++__first1;
     ++__result;
   }
 else if (*__first2 < *__first1)
   ++__first2;
 else
   {
     ++__first1;
     ++__first2;
   }
      return std::copy(__first1, __last1, __result);
    }
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    _OutputIterator
    set_difference(_InputIterator1 __first1, _InputIterator1 __last1,
     _InputIterator2 __first2, _InputIterator2 __last2,
     _OutputIterator __result, _Compare __comp)
    {
      ;
      ;
      while (__first1 != __last1 && __first2 != __last2)
 if (__comp(*__first1, *__first2))
   {
     *__result = *__first1;
     ++__first1;
     ++__result;
   }
 else if (__comp(*__first2, *__first1))
   ++__first2;
 else
   {
     ++__first1;
     ++__first2;
   }
      return std::copy(__first1, __last1, __result);
    }
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    _OutputIterator
    set_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _InputIterator2 __last2,
        _OutputIterator __result)
    {
      ;
      ;
      while (__first1 != __last1 && __first2 != __last2)
 if (*__first1 < *__first2)
   {
     *__result = *__first1;
     ++__first1;
     ++__result;
   }
 else if (*__first2 < *__first1)
   {
     *__result = *__first2;
     ++__first2;
     ++__result;
   }
 else
   {
     ++__first1;
     ++__first2;
   }
      return std::copy(__first2, __last2, std::copy(__first1,
          __last1, __result));
    }
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    _OutputIterator
    set_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _InputIterator2 __last2,
        _OutputIterator __result,
        _Compare __comp)
    {
      ;
      ;
      while (__first1 != __last1 && __first2 != __last2)
 if (__comp(*__first1, *__first2))
   {
     *__result = *__first1;
     ++__first1;
     ++__result;
   }
 else if (__comp(*__first2, *__first1))
   {
     *__result = *__first2;
     ++__first2;
     ++__result;
   }
 else
   {
     ++__first1;
     ++__first2;
   }
      return std::copy(__first2, __last2, std::copy(__first1,
          __last1, __result));
    }
  template<typename _ForwardIterator>
    _ForwardIterator
    max_element(_ForwardIterator __first, _ForwardIterator __last)
    {
      ;
      if (__first == __last)
 return __first;
      _ForwardIterator __result = __first;
      while (++__first != __last)
 if (*__result < *__first)
   __result = __first;
      return __result;
    }
  template<typename _ForwardIterator, typename _Compare>
    _ForwardIterator
    max_element(_ForwardIterator __first, _ForwardIterator __last,
  _Compare __comp)
    {
      ;
      if (__first == __last) return __first;
      _ForwardIterator __result = __first;
      while (++__first != __last)
 if (__comp(*__result, *__first)) __result = __first;
      return __result;
    }
  template<typename _ForwardIterator>
    _ForwardIterator
    min_element(_ForwardIterator __first, _ForwardIterator __last)
    {
      ;
      if (__first == __last)
 return __first;
      _ForwardIterator __result = __first;
      while (++__first != __last)
 if (*__first < *__result)
   __result = __first;
      return __result;
    }
  template<typename _ForwardIterator, typename _Compare>
    _ForwardIterator
    min_element(_ForwardIterator __first, _ForwardIterator __last,
  _Compare __comp)
    {
      ;
      if (__first == __last)
 return __first;
      _ForwardIterator __result = __first;
      while (++__first != __last)
 if (__comp(*__first, *__result))
   __result = __first;
      return __result;
    }
  template<typename _BidirectionalIterator>
    bool
    next_permutation(_BidirectionalIterator __first,
       _BidirectionalIterator __last)
    {
      ;
      if (__first == __last)
 return false;
      _BidirectionalIterator __i = __first;
      ++__i;
      if (__i == __last)
 return false;
      __i = __last;
      --__i;
      for(;;)
 {
   _BidirectionalIterator __ii = __i;
   --__i;
   if (*__i < *__ii)
     {
       _BidirectionalIterator __j = __last;
       while (!(*__i < *--__j))
  {}
       std::iter_swap(__i, __j);
       std::reverse(__ii, __last);
       return true;
     }
   if (__i == __first)
     {
       std::reverse(__first, __last);
       return false;
     }
 }
    }
  template<typename _BidirectionalIterator, typename _Compare>
    bool
    next_permutation(_BidirectionalIterator __first,
       _BidirectionalIterator __last, _Compare __comp)
    {
      ;
      if (__first == __last)
 return false;
      _BidirectionalIterator __i = __first;
      ++__i;
      if (__i == __last)
 return false;
      __i = __last;
      --__i;
      for(;;)
 {
   _BidirectionalIterator __ii = __i;
   --__i;
   if (__comp(*__i, *__ii))
     {
       _BidirectionalIterator __j = __last;
       while (!__comp(*__i, *--__j))
  {}
       std::iter_swap(__i, __j);
       std::reverse(__ii, __last);
       return true;
     }
   if (__i == __first)
     {
       std::reverse(__first, __last);
       return false;
     }
 }
    }
  template<typename _BidirectionalIterator>
    bool
    prev_permutation(_BidirectionalIterator __first,
       _BidirectionalIterator __last)
    {
      ;
      if (__first == __last)
 return false;
      _BidirectionalIterator __i = __first;
      ++__i;
      if (__i == __last)
 return false;
      __i = __last;
      --__i;
      for(;;)
 {
   _BidirectionalIterator __ii = __i;
   --__i;
   if (*__ii < *__i)
     {
       _BidirectionalIterator __j = __last;
       while (!(*--__j < *__i))
  {}
       std::iter_swap(__i, __j);
       std::reverse(__ii, __last);
       return true;
     }
   if (__i == __first)
     {
       std::reverse(__first, __last);
       return false;
     }
 }
    }
  template<typename _BidirectionalIterator, typename _Compare>
    bool
    prev_permutation(_BidirectionalIterator __first,
       _BidirectionalIterator __last, _Compare __comp)
    {
      ;
      if (__first == __last)
 return false;
      _BidirectionalIterator __i = __first;
      ++__i;
      if (__i == __last)
 return false;
      __i = __last;
      --__i;
      for(;;)
 {
   _BidirectionalIterator __ii = __i;
   --__i;
   if (__comp(*__ii, *__i))
     {
       _BidirectionalIterator __j = __last;
       while (!__comp(*--__j, *__i))
  {}
       std::iter_swap(__i, __j);
       std::reverse(__ii, __last);
       return true;
     }
   if (__i == __first)
     {
       std::reverse(__first, __last);
       return false;
     }
 }
    }
  template<typename _InputIterator, typename _ForwardIterator>
    _InputIterator
    find_first_of(_InputIterator __first1, _InputIterator __last1,
    _ForwardIterator __first2, _ForwardIterator __last2)
    {
      ;
      ;
      for ( ; __first1 != __last1; ++__first1)
 for (_ForwardIterator __iter = __first2; __iter != __last2; ++__iter)
   if (*__first1 == *__iter)
     return __first1;
      return __last1;
    }
  template<typename _InputIterator, typename _ForwardIterator,
    typename _BinaryPredicate>
    _InputIterator
    find_first_of(_InputIterator __first1, _InputIterator __last1,
    _ForwardIterator __first2, _ForwardIterator __last2,
    _BinaryPredicate __comp)
    {
      ;
      ;
      for ( ; __first1 != __last1; ++__first1)
 for (_ForwardIterator __iter = __first2; __iter != __last2; ++__iter)
   if (__comp(*__first1, *__iter))
     return __first1;
      return __last1;
    }
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    _ForwardIterator1
    __find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
        _ForwardIterator2 __first2, _ForwardIterator2 __last2,
        forward_iterator_tag, forward_iterator_tag)
    {
      if (__first2 == __last2)
 return __last1;
      else
 {
   _ForwardIterator1 __result = __last1;
   while (1)
     {
       _ForwardIterator1 __new_result
  = std::search(__first1, __last1, __first2, __last2);
       if (__new_result == __last1)
  return __result;
       else
  {
    __result = __new_result;
    __first1 = __new_result;
    ++__first1;
  }
     }
 }
    }
  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    _ForwardIterator1
    __find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
        _ForwardIterator2 __first2, _ForwardIterator2 __last2,
        forward_iterator_tag, forward_iterator_tag,
        _BinaryPredicate __comp)
    {
      if (__first2 == __last2)
 return __last1;
      else
 {
   _ForwardIterator1 __result = __last1;
   while (1)
     {
       _ForwardIterator1 __new_result
  = std::search(__first1, __last1, __first2, __last2, __comp);
       if (__new_result == __last1)
  return __result;
       else
  {
    __result = __new_result;
    __first1 = __new_result;
    ++__first1;
  }
     }
 }
    }
  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2>
    _BidirectionalIterator1
    __find_end(_BidirectionalIterator1 __first1,
        _BidirectionalIterator1 __last1,
        _BidirectionalIterator2 __first2,
        _BidirectionalIterator2 __last2,
        bidirectional_iterator_tag, bidirectional_iterator_tag)
    {
      typedef reverse_iterator<_BidirectionalIterator1> _RevIterator1;
      typedef reverse_iterator<_BidirectionalIterator2> _RevIterator2;
      _RevIterator1 __rlast1(__first1);
      _RevIterator2 __rlast2(__first2);
      _RevIterator1 __rresult = std::search(_RevIterator1(__last1), __rlast1,
         _RevIterator2(__last2), __rlast2);
      if (__rresult == __rlast1)
 return __last1;
      else
 {
   _BidirectionalIterator1 __result = __rresult.base();
   std::advance(__result, -std::distance(__first2, __last2));
   return __result;
 }
    }
  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2,
    typename _BinaryPredicate>
    _BidirectionalIterator1
    __find_end(_BidirectionalIterator1 __first1,
        _BidirectionalIterator1 __last1,
        _BidirectionalIterator2 __first2,
        _BidirectionalIterator2 __last2,
        bidirectional_iterator_tag, bidirectional_iterator_tag,
        _BinaryPredicate __comp)
    {
      typedef reverse_iterator<_BidirectionalIterator1> _RevIterator1;
      typedef reverse_iterator<_BidirectionalIterator2> _RevIterator2;
      _RevIterator1 __rlast1(__first1);
      _RevIterator2 __rlast2(__first2);
      _RevIterator1 __rresult = std::search(_RevIterator1(__last1), __rlast1,
         _RevIterator2(__last2), __rlast2,
         __comp);
      if (__rresult == __rlast1)
 return __last1;
      else
 {
   _BidirectionalIterator1 __result = __rresult.base();
   std::advance(__result, -std::distance(__first2, __last2));
   return __result;
 }
    }
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    inline _ForwardIterator1
    find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
      _ForwardIterator2 __first2, _ForwardIterator2 __last2)
    {
      ;
      ;
      return std::__find_end(__first1, __last1, __first2, __last2,
        std::__iterator_category(__first1),
        std::__iterator_category(__first2));
    }
  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    inline _ForwardIterator1
    find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
      _ForwardIterator2 __first2, _ForwardIterator2 __last2,
      _BinaryPredicate __comp)
    {
      ;
      ;
      return std::__find_end(__first1, __last1, __first2, __last2,
        std::__iterator_category(__first1),
        std::__iterator_category(__first2),
        __comp);
    }
}
namespace __gnu_cxx
{
  template <class _CharT>
    struct _Char_types
    {
      typedef unsigned long int_type;
      typedef std::streampos pos_type;
      typedef std::streamoff off_type;
      typedef std::mbstate_t state_type;
    };
  template<typename _CharT>
    struct char_traits
    {
      typedef _CharT char_type;
      typedef typename _Char_types<_CharT>::int_type int_type;
      typedef typename _Char_types<_CharT>::pos_type pos_type;
      typedef typename _Char_types<_CharT>::off_type off_type;
      typedef typename _Char_types<_CharT>::state_type state_type;
      static void
      assign(char_type& __c1, const char_type& __c2)
      { __c1 = __c2; }
      static bool
      eq(const char_type& __c1, const char_type& __c2)
      { return __c1 == __c2; }
      static bool
      lt(const char_type& __c1, const char_type& __c2)
      { return __c1 < __c2; }
      static int
      compare(const char_type* __s1, const char_type* __s2, std::size_t __n);
      static std::size_t
      length(const char_type* __s);
      static const char_type*
      find(const char_type* __s, std::size_t __n, const char_type& __a);
      static char_type*
      move(char_type* __s1, const char_type* __s2, std::size_t __n);
      static char_type*
      copy(char_type* __s1, const char_type* __s2, std::size_t __n);
      static char_type*
      assign(char_type* __s, std::size_t __n, char_type __a);
      static char_type
      to_char_type(const int_type& __c)
      { return static_cast<char_type>(__c); }
      static int_type
      to_int_type(const char_type& __c)
      { return static_cast<int_type>(__c); }
      static bool
      eq_int_type(const int_type& __c1, const int_type& __c2)
      { return __c1 == __c2; }
      static int_type
      eof()
      { return static_cast<int_type>((-1)); }
      static int_type
      not_eof(const int_type& __c)
      { return !eq_int_type(__c, eof()) ? __c : to_int_type(char_type()); }
    };
  template<typename _CharT>
    int
    char_traits<_CharT>::
    compare(const char_type* __s1, const char_type* __s2, std::size_t __n)
    {
      for (size_t __i = 0; __i < __n; ++__i)
 if (lt(__s1[__i], __s2[__i]))
   return -1;
 else if (lt(__s2[__i], __s1[__i]))
   return 1;
      return 0;
    }
  template<typename _CharT>
    std::size_t
    char_traits<_CharT>::
    length(const char_type* __p)
    {
      std::size_t __i = 0;
      while (!eq(__p[__i], char_type()))
        ++__i;
      return __i;
    }
  template<typename _CharT>
    const typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    find(const char_type* __s, std::size_t __n, const char_type& __a)
    {
      for (std::size_t __i = 0; __i < __n; ++__i)
        if (eq(__s[__i], __a))
          return __s + __i;
      return 0;
    }
  template<typename _CharT>
    typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    move(char_type* __s1, const char_type* __s2, std::size_t __n)
    {
      return static_cast<_CharT*>(std::memmove(__s1, __s2,
            __n * sizeof(char_type)));
    }
  template<typename _CharT>
    typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    copy(char_type* __s1, const char_type* __s2, std::size_t __n)
    {
      std::copy(__s2, __s2 + __n, __s1);
      return __s1;
    }
  template<typename _CharT>
    typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    assign(char_type* __s, std::size_t __n, char_type __a)
    {
      std::fill_n(__s, __n, __a);
      return __s;
    }
}
namespace std
{
  template<class _CharT>
    struct char_traits : public __gnu_cxx::char_traits<_CharT>
    { };
  template<>
    struct char_traits<char>
    {
      typedef char char_type;
      typedef int int_type;
      typedef streampos pos_type;
      typedef streamoff off_type;
      typedef mbstate_t state_type;
      static void
      assign(char_type& __c1, const char_type& __c2)
      { __c1 = __c2; }
      static bool
      eq(const char_type& __c1, const char_type& __c2)
      { return __c1 == __c2; }
      static bool
      lt(const char_type& __c1, const char_type& __c2)
      { return __c1 < __c2; }
      static int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      { return memcmp(__s1, __s2, __n); }
      static size_t
      length(const char_type* __s)
      { return strlen(__s); }
      static const char_type*
      find(const char_type* __s, size_t __n, const char_type& __a)
      { return static_cast<const char_type*>(memchr(__s, __a, __n)); }
      static char_type*
      move(char_type* __s1, const char_type* __s2, size_t __n)
      { return static_cast<char_type*>(memmove(__s1, __s2, __n)); }
      static char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n)
      { return static_cast<char_type*>(memcpy(__s1, __s2, __n)); }
      static char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      { return static_cast<char_type*>(memset(__s, __a, __n)); }
      static char_type
      to_char_type(const int_type& __c)
      { return static_cast<char_type>(__c); }
      static int_type
      to_int_type(const char_type& __c)
      { return static_cast<int_type>(static_cast<unsigned char>(__c)); }
      static bool
      eq_int_type(const int_type& __c1, const int_type& __c2)
      { return __c1 == __c2; }
      static int_type
      eof() { return static_cast<int_type>((-1)); }
      static int_type
      not_eof(const int_type& __c)
      { return (__c == eof()) ? 0 : __c; }
  };
  template<>
    struct char_traits<wchar_t>
    {
      typedef wchar_t char_type;
      typedef wint_t int_type;
      typedef streamoff off_type;
      typedef wstreampos pos_type;
      typedef mbstate_t state_type;
      static void
      assign(char_type& __c1, const char_type& __c2)
      { __c1 = __c2; }
      static bool
      eq(const char_type& __c1, const char_type& __c2)
      { return __c1 == __c2; }
      static bool
      lt(const char_type& __c1, const char_type& __c2)
      { return __c1 < __c2; }
      static int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      { return wmemcmp(__s1, __s2, __n); }
      static size_t
      length(const char_type* __s)
      { return wcslen(__s); }
      static const char_type*
      find(const char_type* __s, size_t __n, const char_type& __a)
      { return wmemchr(__s, __a, __n); }
      static char_type*
      move(char_type* __s1, const char_type* __s2, size_t __n)
      { return wmemmove(__s1, __s2, __n); }
      static char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n)
      { return wmemcpy(__s1, __s2, __n); }
      static char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      { return wmemset(__s, __a, __n); }
      static char_type
      to_char_type(const int_type& __c) { return char_type(__c); }
      static int_type
      to_int_type(const char_type& __c) { return int_type(__c); }
      static bool
      eq_int_type(const int_type& __c1, const int_type& __c2)
      { return __c1 == __c2; }
      static int_type
      eof() { return static_cast<int_type>((0xffffffffu)); }
      static int_type
      not_eof(const int_type& __c)
      { return eq_int_type(__c, eof()) ? 0 : __c; }
  };
}
namespace std
{
  class locale;
  template<typename _CharT>
    inline bool
    isspace(_CharT, const locale&);
  template<typename _CharT>
    inline bool
    isprint(_CharT, const locale&);
  template<typename _CharT>
    inline bool
    iscntrl(_CharT, const locale&);
  template<typename _CharT>
    inline bool
    isupper(_CharT, const locale&);
  template<typename _CharT>
    inline bool
    islower(_CharT, const locale&);
  template<typename _CharT>
    inline bool
    isalpha(_CharT, const locale&);
  template<typename _CharT>
    inline bool
    isdigit(_CharT, const locale&);
  template<typename _CharT>
    inline bool
    ispunct(_CharT, const locale&);
  template<typename _CharT>
    inline bool
    isxdigit(_CharT, const locale&);
  template<typename _CharT>
    inline bool
    isalnum(_CharT, const locale&);
  template<typename _CharT>
    inline bool
    isgraph(_CharT, const locale&);
  template<typename _CharT>
    inline _CharT
    toupper(_CharT, const locale&);
  template<typename _CharT>
    inline _CharT
    tolower(_CharT, const locale&);
  class ctype_base;
  template<typename _CharT>
    class ctype;
  template<> class ctype<char>;
  template<> class ctype<wchar_t>;
  template<typename _CharT>
    class ctype_byname;
  class codecvt_base;
  class __enc_traits;
  template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt;
  template<> class codecvt<char, char, mbstate_t>;
  template<> class codecvt<wchar_t, char, mbstate_t>;
  template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt_byname;
  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class num_get;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class num_put;
  template<typename _CharT> class numpunct;
  template<typename _CharT> class numpunct_byname;
  template<typename _CharT>
    class collate;
  template<typename _CharT> class
    collate_byname;
  class time_base;
  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class time_get;
  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class time_get_byname;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class time_put;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class time_put_byname;
  class money_base;
  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class money_get;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class money_put;
  template<typename _CharT, bool _Intl = false>
    class moneypunct;
  template<typename _CharT, bool _Intl = false>
    class moneypunct_byname;
  class messages_base;
  template<typename _CharT>
    class messages;
  template<typename _CharT>
    class messages_byname;
  template<typename _Facet>
    bool
    has_facet(const locale& __loc) throw();
  template<typename _Facet>
    const _Facet&
    use_facet(const locale& __loc);
  template<typename _Facet>
    inline const _Facet&
    __check_facet(const _Facet* __f)
    {
      if (!__f)
 __throw_bad_cast();
      return *__f;
    }
}
typedef int _Atomic_word;
namespace __gnu_cxx
{
  _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add(volatile _Atomic_word* __mem, int __val);
  void
  __attribute__ ((__unused__))
  __atomic_add(volatile _Atomic_word* __mem, int __val);
}
namespace std
{
  template <class _Arg, class _Result>
    struct unary_function
    {
      typedef _Arg argument_type;
      typedef _Result result_type;
    };
  template <class _Arg1, class _Arg2, class _Result>
    struct binary_function
    {
      typedef _Arg1 first_argument_type;
      typedef _Arg2 second_argument_type;
      typedef _Result result_type;
    };
  template <class _Tp>
    struct plus : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x + __y; }
    };
  template <class _Tp>
    struct minus : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x - __y; }
    };
  template <class _Tp>
    struct multiplies : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x * __y; }
    };
  template <class _Tp>
    struct divides : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x / __y; }
    };
  template <class _Tp>
    struct modulus : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x % __y; }
    };
  template <class _Tp>
    struct negate : public unary_function<_Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x) const
      { return -__x; }
    };
  template <class _Tp>
    struct equal_to : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x == __y; }
    };
  template <class _Tp>
    struct not_equal_to : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x != __y; }
    };
  template <class _Tp>
    struct greater : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x > __y; }
    };
  template <class _Tp>
    struct less : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x < __y; }
    };
  template <class _Tp>
    struct greater_equal : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x >= __y; }
    };
  template <class _Tp>
    struct less_equal : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x <= __y; }
    };
  template <class _Tp>
    struct logical_and : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x && __y; }
    };
  template <class _Tp>
    struct logical_or : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x || __y; }
    };
  template <class _Tp>
    struct logical_not : public unary_function<_Tp, bool>
    {
      bool
      operator()(const _Tp& __x) const
      { return !__x; }
    };
  template <class _Predicate>
    class unary_negate
    : public unary_function<typename _Predicate::argument_type, bool>
    {
    protected:
      _Predicate _M_pred;
    public:
      explicit
      unary_negate(const _Predicate& __x) : _M_pred(__x) {}
      bool
      operator()(const typename _Predicate::argument_type& __x) const
      { return !_M_pred(__x); }
    };
  template <class _Predicate>
    inline unary_negate<_Predicate>
    not1(const _Predicate& __pred)
    { return unary_negate<_Predicate>(__pred); }
  template <class _Predicate>
    class binary_negate
    : public binary_function<typename _Predicate::first_argument_type,
        typename _Predicate::second_argument_type,
        bool>
    {
    protected:
      _Predicate _M_pred;
    public:
      explicit
      binary_negate(const _Predicate& __x)
      : _M_pred(__x) { }
      bool
      operator()(const typename _Predicate::first_argument_type& __x,
   const typename _Predicate::second_argument_type& __y) const
      { return !_M_pred(__x, __y); }
    };
  template <class _Predicate>
    inline binary_negate<_Predicate>
    not2(const _Predicate& __pred)
    { return binary_negate<_Predicate>(__pred); }
  template <class _Operation>
    class binder1st
    : public unary_function<typename _Operation::second_argument_type,
       typename _Operation::result_type>
    {
    protected:
      _Operation op;
      typename _Operation::first_argument_type value;
    public:
      binder1st(const _Operation& __x,
  const typename _Operation::first_argument_type& __y)
      : op(__x), value(__y) {}
      typename _Operation::result_type
      operator()(const typename _Operation::second_argument_type& __x) const
      { return op(value, __x); }
      typename _Operation::result_type
      operator()(typename _Operation::second_argument_type& __x) const
      { return op(value, __x); }
    };
  template <class _Operation, class _Tp>
    inline binder1st<_Operation>
    bind1st(const _Operation& __fn, const _Tp& __x)
    {
      typedef typename _Operation::first_argument_type _Arg1_type;
      return binder1st<_Operation>(__fn, _Arg1_type(__x));
    }
  template <class _Operation>
    class binder2nd
    : public unary_function<typename _Operation::first_argument_type,
       typename _Operation::result_type>
    {
    protected:
      _Operation op;
      typename _Operation::second_argument_type value;
    public:
      binder2nd(const _Operation& __x,
  const typename _Operation::second_argument_type& __y)
      : op(__x), value(__y) {}
      typename _Operation::result_type
      operator()(const typename _Operation::first_argument_type& __x) const
      { return op(__x, value); }
      typename _Operation::result_type
      operator()(typename _Operation::first_argument_type& __x) const
      { return op(__x, value); }
    };
  template <class _Operation, class _Tp>
    inline binder2nd<_Operation>
    bind2nd(const _Operation& __fn, const _Tp& __x)
    {
      typedef typename _Operation::second_argument_type _Arg2_type;
      return binder2nd<_Operation>(__fn, _Arg2_type(__x));
    }
  template <class _Arg, class _Result>
    class pointer_to_unary_function : public unary_function<_Arg, _Result>
    {
    protected:
      _Result (*_M_ptr)(_Arg);
    public:
      pointer_to_unary_function() {}
      explicit
      pointer_to_unary_function(_Result (*__x)(_Arg))
      : _M_ptr(__x) {}
      _Result
      operator()(_Arg __x) const
      { return _M_ptr(__x); }
    };
  template <class _Arg, class _Result>
    inline pointer_to_unary_function<_Arg, _Result>
    ptr_fun(_Result (*__x)(_Arg))
    { return pointer_to_unary_function<_Arg, _Result>(__x); }
  template <class _Arg1, class _Arg2, class _Result>
    class pointer_to_binary_function
    : public binary_function<_Arg1, _Arg2, _Result>
    {
    protected:
      _Result (*_M_ptr)(_Arg1, _Arg2);
    public:
      pointer_to_binary_function() {}
      explicit
      pointer_to_binary_function(_Result (*__x)(_Arg1, _Arg2))
      : _M_ptr(__x) {}
      _Result
      operator()(_Arg1 __x, _Arg2 __y) const
      { return _M_ptr(__x, __y); }
    };
  template <class _Arg1, class _Arg2, class _Result>
    inline pointer_to_binary_function<_Arg1, _Arg2, _Result>
    ptr_fun(_Result (*__x)(_Arg1, _Arg2))
    { return pointer_to_binary_function<_Arg1, _Arg2, _Result>(__x); }
  template <class _Tp>
    struct _Identity : public unary_function<_Tp,_Tp>
    {
      _Tp&
      operator()(_Tp& __x) const
      { return __x; }
      const _Tp&
      operator()(const _Tp& __x) const
      { return __x; }
    };
  template <class _Pair>
    struct _Select1st : public unary_function<_Pair,
           typename _Pair::first_type>
    {
      typename _Pair::first_type&
      operator()(_Pair& __x) const
      { return __x.first; }
      const typename _Pair::first_type&
      operator()(const _Pair& __x) const
      { return __x.first; }
    };
  template <class _Pair>
    struct _Select2nd : public unary_function<_Pair,
           typename _Pair::second_type>
    {
      typename _Pair::second_type&
      operator()(_Pair& __x) const
      { return __x.second; }
      const typename _Pair::second_type&
      operator()(const _Pair& __x) const
      { return __x.second; }
    };
  template <class _Ret, class _Tp>
    class mem_fun_t : public unary_function<_Tp*, _Ret>
    {
    public:
      explicit
      mem_fun_t(_Ret (_Tp::*__pf)())
      : _M_f(__pf) {}
      _Ret
      operator()(_Tp* __p) const
      { return (__p->*_M_f)(); }
    private:
      _Ret (_Tp::*_M_f)();
    };
  template <class _Ret, class _Tp>
    class const_mem_fun_t : public unary_function<const _Tp*, _Ret>
    {
    public:
      explicit
      const_mem_fun_t(_Ret (_Tp::*__pf)() const)
      : _M_f(__pf) {}
      _Ret
      operator()(const _Tp* __p) const
      { return (__p->*_M_f)(); }
    private:
      _Ret (_Tp::*_M_f)() const;
    };
  template <class _Ret, class _Tp>
    class mem_fun_ref_t : public unary_function<_Tp, _Ret>
    {
    public:
      explicit
      mem_fun_ref_t(_Ret (_Tp::*__pf)())
      : _M_f(__pf) {}
      _Ret
      operator()(_Tp& __r) const
      { return (__r.*_M_f)(); }
    private:
      _Ret (_Tp::*_M_f)();
  };
  template <class _Ret, class _Tp>
    class const_mem_fun_ref_t : public unary_function<_Tp, _Ret>
    {
    public:
      explicit
      const_mem_fun_ref_t(_Ret (_Tp::*__pf)() const)
      : _M_f(__pf) {}
      _Ret
      operator()(const _Tp& __r) const
      { return (__r.*_M_f)(); }
    private:
      _Ret (_Tp::*_M_f)() const;
    };
  template <class _Ret, class _Tp, class _Arg>
    class mem_fun1_t : public binary_function<_Tp*, _Arg, _Ret>
    {
    public:
      explicit
      mem_fun1_t(_Ret (_Tp::*__pf)(_Arg))
      : _M_f(__pf) {}
      _Ret
      operator()(_Tp* __p, _Arg __x) const
      { return (__p->*_M_f)(__x); }
    private:
      _Ret (_Tp::*_M_f)(_Arg);
    };
  template <class _Ret, class _Tp, class _Arg>
    class const_mem_fun1_t : public binary_function<const _Tp*, _Arg, _Ret>
    {
    public:
      explicit
      const_mem_fun1_t(_Ret (_Tp::*__pf)(_Arg) const)
      : _M_f(__pf) {}
      _Ret
      operator()(const _Tp* __p, _Arg __x) const
      { return (__p->*_M_f)(__x); }
    private:
      _Ret (_Tp::*_M_f)(_Arg) const;
    };
  template <class _Ret, class _Tp, class _Arg>
    class mem_fun1_ref_t : public binary_function<_Tp, _Arg, _Ret>
    {
    public:
      explicit
      mem_fun1_ref_t(_Ret (_Tp::*__pf)(_Arg))
      : _M_f(__pf) {}
      _Ret
      operator()(_Tp& __r, _Arg __x) const
      { return (__r.*_M_f)(__x); }
    private:
      _Ret (_Tp::*_M_f)(_Arg);
    };
  template <class _Ret, class _Tp, class _Arg>
    class const_mem_fun1_ref_t : public binary_function<_Tp, _Arg, _Ret>
    {
    public:
      explicit
      const_mem_fun1_ref_t(_Ret (_Tp::*__pf)(_Arg) const)
      : _M_f(__pf) {}
      _Ret
      operator()(const _Tp& __r, _Arg __x) const
      { return (__r.*_M_f)(__x); }
    private:
      _Ret (_Tp::*_M_f)(_Arg) const;
    };
  template <class _Ret, class _Tp>
    inline mem_fun_t<_Ret, _Tp>
    mem_fun(_Ret (_Tp::*__f)())
    { return mem_fun_t<_Ret, _Tp>(__f); }
  template <class _Ret, class _Tp>
    inline const_mem_fun_t<_Ret, _Tp>
    mem_fun(_Ret (_Tp::*__f)() const)
    { return const_mem_fun_t<_Ret, _Tp>(__f); }
  template <class _Ret, class _Tp>
    inline mem_fun_ref_t<_Ret, _Tp>
    mem_fun_ref(_Ret (_Tp::*__f)())
    { return mem_fun_ref_t<_Ret, _Tp>(__f); }
  template <class _Ret, class _Tp>
    inline const_mem_fun_ref_t<_Ret, _Tp>
    mem_fun_ref(_Ret (_Tp::*__f)() const)
    { return const_mem_fun_ref_t<_Ret, _Tp>(__f); }
  template <class _Ret, class _Tp, class _Arg>
    inline mem_fun1_t<_Ret, _Tp, _Arg>
    mem_fun(_Ret (_Tp::*__f)(_Arg))
    { return mem_fun1_t<_Ret, _Tp, _Arg>(__f); }
  template <class _Ret, class _Tp, class _Arg>
    inline const_mem_fun1_t<_Ret, _Tp, _Arg>
    mem_fun(_Ret (_Tp::*__f)(_Arg) const)
    { return const_mem_fun1_t<_Ret, _Tp, _Arg>(__f); }
  template <class _Ret, class _Tp, class _Arg>
    inline mem_fun1_ref_t<_Ret, _Tp, _Arg>
    mem_fun_ref(_Ret (_Tp::*__f)(_Arg))
    { return mem_fun1_ref_t<_Ret, _Tp, _Arg>(__f); }
  template <class _Ret, class _Tp, class _Arg>
    inline const_mem_fun1_ref_t<_Ret, _Tp, _Arg>
    mem_fun_ref(_Ret (_Tp::*__f)(_Arg) const)
    { return const_mem_fun1_ref_t<_Ret, _Tp, _Arg>(__f); }
}
namespace std
{
  template<typename _CharT, typename _Traits, typename _Alloc>
    class basic_string
    {
      typedef typename _Alloc::template rebind<_CharT>::other _CharT_alloc_type;
    public:
      typedef _Traits traits_type;
      typedef typename _Traits::char_type value_type;
      typedef _Alloc allocator_type;
      typedef typename _CharT_alloc_type::size_type size_type;
      typedef typename _CharT_alloc_type::difference_type difference_type;
      typedef typename _CharT_alloc_type::reference reference;
      typedef typename _CharT_alloc_type::const_reference const_reference;
      typedef typename _CharT_alloc_type::pointer pointer;
      typedef typename _CharT_alloc_type::const_pointer const_pointer;
      typedef __gnu_cxx::__normal_iterator<pointer, basic_string> iterator;
      typedef __gnu_cxx::__normal_iterator<const_pointer, basic_string>
                                                            const_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
      typedef std::reverse_iterator<iterator> reverse_iterator;
    private:
      struct _Rep_base
      {
 size_type _M_length;
 size_type _M_capacity;
 _Atomic_word _M_refcount;
      };
      struct _Rep : _Rep_base
      {
 typedef typename _Alloc::template rebind<char>::other _Raw_bytes_alloc;
 static const size_type _S_max_size;
 static const _CharT _S_terminal;
        static size_type _S_empty_rep_storage[];
        static _Rep&
        _S_empty_rep()
        {
   void* __p = reinterpret_cast<void*>(&_S_empty_rep_storage);
   return *reinterpret_cast<_Rep*>(__p);
 }
        bool
 _M_is_leaked() const
        { return this->_M_refcount < 0; }
        bool
 _M_is_shared() const
        { return this->_M_refcount > 0; }
        void
 _M_set_leaked()
        { this->_M_refcount = -1; }
        void
 _M_set_sharable()
        { this->_M_refcount = 0; }
 void
 _M_set_length_and_sharable(size_type __n)
 {
   this->_M_set_sharable();
   this->_M_length = __n;
   traits_type::assign(this->_M_refdata()[__n], _S_terminal);
 }
 _CharT*
 _M_refdata() throw()
 { return reinterpret_cast<_CharT*>(this + 1); }
 _CharT*
 _M_grab(const _Alloc& __alloc1, const _Alloc& __alloc2)
 {
   return (!_M_is_leaked() && __alloc1 == __alloc2)
           ? _M_refcopy() : _M_clone(__alloc1);
 }
 static _Rep*
 _S_create(size_type, size_type, const _Alloc&);
 void
 _M_dispose(const _Alloc& __a)
 {
   if (__builtin_expect(this != &_S_empty_rep(), false))
     if (__gnu_cxx::__exchange_and_add(&this->_M_refcount, -1) <= 0)
       _M_destroy(__a);
 }
 void
 _M_destroy(const _Alloc&) throw();
 _CharT*
 _M_refcopy() throw()
 {
   if (__builtin_expect(this != &_S_empty_rep(), false))
            __gnu_cxx::__atomic_add(&this->_M_refcount, 1);
   return _M_refdata();
 }
 _CharT*
 _M_clone(const _Alloc&, size_type __res = 0);
      };
      struct _Alloc_hider : _Alloc
      {
 _Alloc_hider(_CharT* __dat, const _Alloc& __a)
 : _Alloc(__a), _M_p(__dat) { }
 _CharT* _M_p;
      };
    public:
      static const size_type npos = static_cast<size_type>(-1);
    private:
      mutable _Alloc_hider _M_dataplus;
      _CharT*
      _M_data() const
      { return _M_dataplus._M_p; }
      _CharT*
      _M_data(_CharT* __p)
      { return (_M_dataplus._M_p = __p); }
      _Rep*
      _M_rep() const
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
      iterator
      _M_ibegin() const
      { return iterator(_M_data()); }
      iterator
      _M_iend() const
      { return iterator(_M_data() + this->size()); }
      void
      _M_leak()
      {
 if (!_M_rep()->_M_is_leaked())
   _M_leak_hard();
      }
      size_type
      _M_check(size_type __pos, const char* __s) const
      {
 if (__pos > this->size())
   __throw_out_of_range((__s));
 return __pos;
      }
      void
      _M_check_length(size_type __n1, size_type __n2, const char* __s) const
      {
 if (this->max_size() - (this->size() - __n1) < __n2)
   __throw_length_error((__s));
      }
      size_type
      _M_limit(size_type __pos, size_type __off) const
      {
 const bool __testoff = __off < this->size() - __pos;
 return __testoff ? __off : this->size() - __pos;
      }
      bool
      _M_disjunct(const _CharT* __s) const
      {
 return (less<const _CharT*>()(__s, _M_data())
  || less<const _CharT*>()(_M_data() + this->size(), __s));
      }
      static void
      _M_copy(_CharT* __d, const _CharT* __s, size_type __n)
      {
 if (__n == 1)
   traits_type::assign(*__d, *__s);
 else
   traits_type::copy(__d, __s, __n);
      }
      static void
      _M_move(_CharT* __d, const _CharT* __s, size_type __n)
      {
 if (__n == 1)
   traits_type::assign(*__d, *__s);
 else
   traits_type::move(__d, __s, __n);
      }
      static void
      _M_assign(_CharT* __d, size_type __n, _CharT __c)
      {
 if (__n == 1)
   traits_type::assign(*__d, __c);
 else
   traits_type::assign(__d, __n, __c);
      }
      template<class _Iterator>
        static void
        _S_copy_chars(_CharT* __p, _Iterator __k1, _Iterator __k2)
        {
   for (; __k1 != __k2; ++__k1, ++__p)
     traits_type::assign(*__p, *__k1);
 }
      static void
      _S_copy_chars(_CharT* __p, iterator __k1, iterator __k2)
      { _S_copy_chars(__p, __k1.base(), __k2.base()); }
      static void
      _S_copy_chars(_CharT* __p, const_iterator __k1, const_iterator __k2)
      { _S_copy_chars(__p, __k1.base(), __k2.base()); }
      static void
      _S_copy_chars(_CharT* __p, _CharT* __k1, _CharT* __k2)
      { _M_copy(__p, __k1, __k2 - __k1); }
      static void
      _S_copy_chars(_CharT* __p, const _CharT* __k1, const _CharT* __k2)
      { _M_copy(__p, __k1, __k2 - __k1); }
      void
      _M_mutate(size_type __pos, size_type __len1, size_type __len2);
      void
      _M_leak_hard();
      static _Rep&
      _S_empty_rep()
      { return _Rep::_S_empty_rep(); }
    public:
      inline
      basic_string();
      explicit
      basic_string(const _Alloc& __a);
      basic_string(const basic_string& __str);
      basic_string(const basic_string& __str, size_type __pos,
     size_type __n = npos);
      basic_string(const basic_string& __str, size_type __pos,
     size_type __n, const _Alloc& __a);
      basic_string(const _CharT* __s, size_type __n,
     const _Alloc& __a = _Alloc());
      basic_string(const _CharT* __s, const _Alloc& __a = _Alloc());
      basic_string(size_type __n, _CharT __c, const _Alloc& __a = _Alloc());
      template<class _InputIterator>
        basic_string(_InputIterator __beg, _InputIterator __end,
       const _Alloc& __a = _Alloc());
      ~basic_string()
      { _M_rep()->_M_dispose(this->get_allocator()); }
      basic_string&
      operator=(const basic_string& __str)
      { return this->assign(__str); }
      basic_string&
      operator=(const _CharT* __s)
      { return this->assign(__s); }
      basic_string&
      operator=(_CharT __c)
      {
 this->assign(1, __c);
 return *this;
      }
      iterator
      begin()
      {
 _M_leak();
 return iterator(_M_data());
      }
      const_iterator
      begin() const
      { return const_iterator(_M_data()); }
      iterator
      end()
      {
 _M_leak();
 return iterator(_M_data() + this->size());
      }
      const_iterator
      end() const
      { return const_iterator(_M_data() + this->size()); }
      reverse_iterator
      rbegin()
      { return reverse_iterator(this->end()); }
      const_reverse_iterator
      rbegin() const
      { return const_reverse_iterator(this->end()); }
      reverse_iterator
      rend()
      { return reverse_iterator(this->begin()); }
      const_reverse_iterator
      rend() const
      { return const_reverse_iterator(this->begin()); }
    public:
      size_type
      size() const
      { return _M_rep()->_M_length; }
      size_type
      length() const
      { return _M_rep()->_M_length; }
      size_type
      max_size() const
      { return _Rep::_S_max_size; }
      void
      resize(size_type __n, _CharT __c);
      void
      resize(size_type __n)
      { this->resize(__n, _CharT()); }
      size_type
      capacity() const
      { return _M_rep()->_M_capacity; }
      void
      reserve(size_type __res_arg = 0);
      void
      clear()
      { _M_mutate(0, this->size(), 0); }
      bool
      empty() const
      { return this->size() == 0; }
      const_reference
      operator[] (size_type __pos) const
      {
 ;
 return _M_data()[__pos];
      }
      reference
      operator[](size_type __pos)
      {
 ;
 ;
 _M_leak();
 return _M_data()[__pos];
      }
      const_reference
      at(size_type __n) const
      {
 if (__n >= this->size())
   __throw_out_of_range(("basic_string::at"));
 return _M_data()[__n];
      }
      reference
      at(size_type __n)
      {
 if (__n >= size())
   __throw_out_of_range(("basic_string::at"));
 _M_leak();
 return _M_data()[__n];
      }
      basic_string&
      operator+=(const basic_string& __str)
      { return this->append(__str); }
      basic_string&
      operator+=(const _CharT* __s)
      { return this->append(__s); }
      basic_string&
      operator+=(_CharT __c)
      {
 this->push_back(__c);
 return *this;
      }
      basic_string&
      append(const basic_string& __str);
      basic_string&
      append(const basic_string& __str, size_type __pos, size_type __n);
      basic_string&
      append(const _CharT* __s, size_type __n);
      basic_string&
      append(const _CharT* __s)
      {
 ;
 return this->append(__s, traits_type::length(__s));
      }
      basic_string&
      append(size_type __n, _CharT __c);
      template<class _InputIterator>
        basic_string&
        append(_InputIterator __first, _InputIterator __last)
        { return this->replace(_M_iend(), _M_iend(), __first, __last); }
      void
      push_back(_CharT __c)
      {
 const size_type __len = 1 + this->size();
 if (__len > this->capacity() || _M_rep()->_M_is_shared())
   this->reserve(__len);
 traits_type::assign(_M_data()[this->size()], __c);
 _M_rep()->_M_set_length_and_sharable(__len);
      }
      basic_string&
      assign(const basic_string& __str);
      basic_string&
      assign(const basic_string& __str, size_type __pos, size_type __n)
      { return this->assign(__str._M_data()
       + __str._M_check(__pos, "basic_string::assign"),
       __str._M_limit(__pos, __n)); }
      basic_string&
      assign(const _CharT* __s, size_type __n);
      basic_string&
      assign(const _CharT* __s)
      {
 ;
 return this->assign(__s, traits_type::length(__s));
      }
      basic_string&
      assign(size_type __n, _CharT __c)
      { return _M_replace_aux(size_type(0), this->size(), __n, __c); }
      template<class _InputIterator>
        basic_string&
        assign(_InputIterator __first, _InputIterator __last)
        { return this->replace(_M_ibegin(), _M_iend(), __first, __last); }
      void
      insert(iterator __p, size_type __n, _CharT __c)
      { this->replace(__p, __p, __n, __c); }
      template<class _InputIterator>
        void
        insert(iterator __p, _InputIterator __beg, _InputIterator __end)
        { this->replace(__p, __p, __beg, __end); }
      basic_string&
      insert(size_type __pos1, const basic_string& __str)
      { return this->insert(__pos1, __str, size_type(0), __str.size()); }
      basic_string&
      insert(size_type __pos1, const basic_string& __str,
      size_type __pos2, size_type __n)
      { return this->insert(__pos1, __str._M_data()
       + __str._M_check(__pos2, "basic_string::insert"),
       __str._M_limit(__pos2, __n)); }
      basic_string&
      insert(size_type __pos, const _CharT* __s, size_type __n);
      basic_string&
      insert(size_type __pos, const _CharT* __s)
      {
 ;
 return this->insert(__pos, __s, traits_type::length(__s));
      }
      basic_string&
      insert(size_type __pos, size_type __n, _CharT __c)
      { return _M_replace_aux(_M_check(__pos, "basic_string::insert"),
         size_type(0), __n, __c); }
      iterator
      insert(iterator __p, _CharT __c)
      {
 ;
 const size_type __pos = __p - _M_ibegin();
 _M_replace_aux(__pos, size_type(0), size_type(1), __c);
 _M_rep()->_M_set_leaked();
 return this->_M_ibegin() + __pos;
      }
      basic_string&
      erase(size_type __pos = 0, size_type __n = npos)
      {
 _M_mutate(_M_check(__pos, "basic_string::erase"),
    _M_limit(__pos, __n), size_type(0));
 return *this;
      }
      iterator
      erase(iterator __position)
      {
 ;
 const size_type __pos = __position - _M_ibegin();
 _M_mutate(__pos, size_type(1), size_type(0));
 _M_rep()->_M_set_leaked();
 return _M_ibegin() + __pos;
      }
      iterator
      erase(iterator __first, iterator __last)
      {
 ;
        const size_type __pos = __first - _M_ibegin();
 _M_mutate(__pos, __last - __first, size_type(0));
 _M_rep()->_M_set_leaked();
 return _M_ibegin() + __pos;
      }
      basic_string&
      replace(size_type __pos, size_type __n, const basic_string& __str)
      { return this->replace(__pos, __n, __str._M_data(), __str.size()); }
      basic_string&
      replace(size_type __pos1, size_type __n1, const basic_string& __str,
       size_type __pos2, size_type __n2)
      { return this->replace(__pos1, __n1, __str._M_data()
        + __str._M_check(__pos2, "basic_string::replace"),
        __str._M_limit(__pos2, __n2)); }
      basic_string&
      replace(size_type __pos, size_type __n1, const _CharT* __s,
       size_type __n2);
      basic_string&
      replace(size_type __pos, size_type __n1, const _CharT* __s)
      {
 ;
 return this->replace(__pos, __n1, __s, traits_type::length(__s));
      }
      basic_string&
      replace(size_type __pos, size_type __n1, size_type __n2, _CharT __c)
      { return _M_replace_aux(_M_check(__pos, "basic_string::replace"),
         _M_limit(__pos, __n1), __n2, __c); }
      basic_string&
      replace(iterator __i1, iterator __i2, const basic_string& __str)
      { return this->replace(__i1, __i2, __str._M_data(), __str.size()); }
      basic_string&
      replace(iterator __i1, iterator __i2, const _CharT* __s, size_type __n)
      {
 ;
 return this->replace(__i1 - _M_ibegin(), __i2 - __i1, __s, __n);
      }
      basic_string&
      replace(iterator __i1, iterator __i2, const _CharT* __s)
      {
 ;
 return this->replace(__i1, __i2, __s, traits_type::length(__s));
      }
      basic_string&
      replace(iterator __i1, iterator __i2, size_type __n, _CharT __c)
      {
 ;
 return _M_replace_aux(__i1 - _M_ibegin(), __i2 - __i1, __n, __c);
      }
      template<class _InputIterator>
        basic_string&
        replace(iterator __i1, iterator __i2,
  _InputIterator __k1, _InputIterator __k2)
        {
   ;
   ;
   typedef typename std::__is_integer<_InputIterator>::__type _Integral;
   return _M_replace_dispatch(__i1, __i2, __k1, __k2, _Integral());
 }
      basic_string&
      replace(iterator __i1, iterator __i2, _CharT* __k1, _CharT* __k2)
      {
 ;
 ;
 return this->replace(__i1 - _M_ibegin(), __i2 - __i1,
        __k1, __k2 - __k1);
      }
      basic_string&
      replace(iterator __i1, iterator __i2,
       const _CharT* __k1, const _CharT* __k2)
      {
 ;
 ;
 return this->replace(__i1 - _M_ibegin(), __i2 - __i1,
        __k1, __k2 - __k1);
      }
      basic_string&
      replace(iterator __i1, iterator __i2, iterator __k1, iterator __k2)
      {
 ;
 ;
 return this->replace(__i1 - _M_ibegin(), __i2 - __i1,
        __k1.base(), __k2 - __k1);
      }
      basic_string&
      replace(iterator __i1, iterator __i2,
       const_iterator __k1, const_iterator __k2)
      {
 ;
 ;
 return this->replace(__i1 - _M_ibegin(), __i2 - __i1,
        __k1.base(), __k2 - __k1);
      }
    private:
      template<class _Integer>
 basic_string&
 _M_replace_dispatch(iterator __i1, iterator __i2, _Integer __n,
       _Integer __val, __true_type)
        { return _M_replace_aux(__i1 - _M_ibegin(), __i2 - __i1, __n, __val); }
      template<class _InputIterator>
 basic_string&
 _M_replace_dispatch(iterator __i1, iterator __i2, _InputIterator __k1,
       _InputIterator __k2, __false_type);
      basic_string&
      _M_replace_aux(size_type __pos1, size_type __n1, size_type __n2,
       _CharT __c);
      basic_string&
      _M_replace_safe(size_type __pos1, size_type __n1, const _CharT* __s,
        size_type __n2);
      template<class _InIterator>
        static _CharT*
        _S_construct_aux(_InIterator __beg, _InIterator __end,
    const _Alloc& __a, __false_type)
 {
          typedef typename iterator_traits<_InIterator>::iterator_category _Tag;
          return _S_construct(__beg, __end, __a, _Tag());
 }
      template<class _InIterator>
        static _CharT*
        _S_construct_aux(_InIterator __beg, _InIterator __end,
    const _Alloc& __a, __true_type)
 { return _S_construct(static_cast<size_type>(__beg),
         static_cast<value_type>(__end), __a); }
      template<class _InIterator>
        static _CharT*
        _S_construct(_InIterator __beg, _InIterator __end, const _Alloc& __a)
 {
   typedef typename std::__is_integer<_InIterator>::__type _Integral;
   return _S_construct_aux(__beg, __end, __a, _Integral());
        }
      template<class _InIterator>
        static _CharT*
         _S_construct(_InIterator __beg, _InIterator __end, const _Alloc& __a,
        input_iterator_tag);
      template<class _FwdIterator>
        static _CharT*
        _S_construct(_FwdIterator __beg, _FwdIterator __end, const _Alloc& __a,
       forward_iterator_tag);
      static _CharT*
      _S_construct(size_type __req, _CharT __c, const _Alloc& __a);
    public:
      size_type
      copy(_CharT* __s, size_type __n, size_type __pos = 0) const;
      void
      swap(basic_string& __s);
      const _CharT*
      c_str() const
      { return _M_data(); }
      const _CharT*
      data() const
      { return _M_data(); }
      allocator_type
      get_allocator() const
      { return _M_dataplus; }
      size_type
      find(const _CharT* __s, size_type __pos, size_type __n) const;
      size_type
      find(const basic_string& __str, size_type __pos = 0) const
      { return this->find(__str.data(), __pos, __str.size()); }
      size_type
      find(const _CharT* __s, size_type __pos = 0) const
      {
 ;
 return this->find(__s, __pos, traits_type::length(__s));
      }
      size_type
      find(_CharT __c, size_type __pos = 0) const;
      size_type
      rfind(const basic_string& __str, size_type __pos = npos) const
      { return this->rfind(__str.data(), __pos, __str.size()); }
      size_type
      rfind(const _CharT* __s, size_type __pos, size_type __n) const;
      size_type
      rfind(const _CharT* __s, size_type __pos = npos) const
      {
 ;
 return this->rfind(__s, __pos, traits_type::length(__s));
      }
      size_type
      rfind(_CharT __c, size_type __pos = npos) const;
      size_type
      find_first_of(const basic_string& __str, size_type __pos = 0) const
      { return this->find_first_of(__str.data(), __pos, __str.size()); }
      size_type
      find_first_of(const _CharT* __s, size_type __pos, size_type __n) const;
      size_type
      find_first_of(const _CharT* __s, size_type __pos = 0) const
      {
 ;
 return this->find_first_of(__s, __pos, traits_type::length(__s));
      }
      size_type
      find_first_of(_CharT __c, size_type __pos = 0) const
      { return this->find(__c, __pos); }
      size_type
      find_last_of(const basic_string& __str, size_type __pos = npos) const
      { return this->find_last_of(__str.data(), __pos, __str.size()); }
      size_type
      find_last_of(const _CharT* __s, size_type __pos, size_type __n) const;
      size_type
      find_last_of(const _CharT* __s, size_type __pos = npos) const
      {
 ;
 return this->find_last_of(__s, __pos, traits_type::length(__s));
      }
      size_type
      find_last_of(_CharT __c, size_type __pos = npos) const
      { return this->rfind(__c, __pos); }
      size_type
      find_first_not_of(const basic_string& __str, size_type __pos = 0) const
      { return this->find_first_not_of(__str.data(), __pos, __str.size()); }
      size_type
      find_first_not_of(const _CharT* __s, size_type __pos,
   size_type __n) const;
      size_type
      find_first_not_of(const _CharT* __s, size_type __pos = 0) const
      {
 ;
 return this->find_first_not_of(__s, __pos, traits_type::length(__s));
      }
      size_type
      find_first_not_of(_CharT __c, size_type __pos = 0) const;
      size_type
      find_last_not_of(const basic_string& __str, size_type __pos = npos) const
      { return this->find_last_not_of(__str.data(), __pos, __str.size()); }
      size_type
      find_last_not_of(const _CharT* __s, size_type __pos,
         size_type __n) const;
      size_type
      find_last_not_of(const _CharT* __s, size_type __pos = npos) const
      {
 ;
 return this->find_last_not_of(__s, __pos, traits_type::length(__s));
      }
      size_type
      find_last_not_of(_CharT __c, size_type __pos = npos) const;
      basic_string
      substr(size_type __pos = 0, size_type __n = npos) const
      { return basic_string(*this,
       _M_check(__pos, "basic_string::substr"), __n); }
      int
      compare(const basic_string& __str) const
      {
 const size_type __size = this->size();
 const size_type __osize = __str.size();
 const size_type __len = std::min(__size, __osize);
 int __r = traits_type::compare(_M_data(), __str.data(), __len);
 if (!__r)
   __r = __size - __osize;
 return __r;
      }
      int
      compare(size_type __pos, size_type __n, const basic_string& __str) const;
      int
      compare(size_type __pos1, size_type __n1, const basic_string& __str,
       size_type __pos2, size_type __n2) const;
      int
      compare(const _CharT* __s) const;
      int
      compare(size_type __pos, size_type __n1, const _CharT* __s) const;
      int
      compare(size_type __pos, size_type __n1, const _CharT* __s,
       size_type __n2) const;
  };
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>::
    basic_string()
    : _M_dataplus(_S_empty_rep()._M_refdata(), _Alloc()) { }
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    {
      basic_string<_CharT, _Traits, _Alloc> __str(__lhs);
      __str.append(__rhs);
      return __str;
    }
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT,_Traits,_Alloc>
    operator+(const _CharT* __lhs,
       const basic_string<_CharT,_Traits,_Alloc>& __rhs);
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT,_Traits,_Alloc>
    operator+(_CharT __lhs, const basic_string<_CharT,_Traits,_Alloc>& __rhs);
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
      const _CharT* __rhs)
    {
      basic_string<_CharT, _Traits, _Alloc> __str(__lhs);
      __str.append(__rhs);
      return __str;
    }
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs, _CharT __rhs)
    {
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;
      __string_type __str(__lhs);
      __str.append(__size_type(1), __rhs);
      return __str;
    }
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) == 0; }
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator==(const _CharT* __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) == 0; }
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return __lhs.compare(__rhs) == 0; }
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) != 0; }
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator!=(const _CharT* __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) != 0; }
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return __lhs.compare(__rhs) != 0; }
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) < 0; }
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const _CharT* __rhs)
    { return __lhs.compare(__rhs) < 0; }
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<(const _CharT* __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) > 0; }
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) > 0; }
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const _CharT* __rhs)
    { return __lhs.compare(__rhs) > 0; }
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>(const _CharT* __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) < 0; }
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) <= 0; }
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return __lhs.compare(__rhs) <= 0; }
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<=(const _CharT* __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) >= 0; }
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) >= 0; }
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return __lhs.compare(__rhs) >= 0; }
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>=(const _CharT* __lhs,
      const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) <= 0; }
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline void
    swap(basic_string<_CharT, _Traits, _Alloc>& __lhs,
  basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { __lhs.swap(__rhs); }
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is,
        basic_string<_CharT, _Traits, _Alloc>& __str);
  template<>
    basic_istream<char>&
    operator>>(basic_istream<char>& __is, basic_string<char>& __str);
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os,
        const basic_string<_CharT, _Traits, _Alloc>& __str);
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>& __is,
     basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim);
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>& __is,
     basic_string<_CharT, _Traits, _Alloc>& __str);
  template<>
    basic_istream<char>&
    getline(basic_istream<char>& __in, basic_string<char>& __str,
     char __delim);
  template<>
    basic_istream<wchar_t>&
    getline(basic_istream<wchar_t>& __in, basic_string<wchar_t>& __str,
     wchar_t __delim);
}
namespace std
{
  template<typename _Type>
    inline bool
    __is_null_pointer(_Type* __ptr)
    { return __ptr == 0; }
  template<typename _Type>
    inline bool
    __is_null_pointer(_Type)
    { return false; }
  template<typename _CharT, typename _Traits, typename _Alloc>
    const typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    _Rep::_S_max_size = (((npos - sizeof(_Rep_base))/sizeof(_CharT)) - 1) / 4;
  template<typename _CharT, typename _Traits, typename _Alloc>
    const _CharT
    basic_string<_CharT, _Traits, _Alloc>::
    _Rep::_S_terminal = _CharT();
  template<typename _CharT, typename _Traits, typename _Alloc>
    const typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::npos;
  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::_Rep::_S_empty_rep_storage[
    (sizeof(_Rep_base) + sizeof(_CharT) + sizeof(size_type) - 1) /
      sizeof(size_type)];
  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _InIterator>
      _CharT*
      basic_string<_CharT, _Traits, _Alloc>::
      _S_construct(_InIterator __beg, _InIterator __end, const _Alloc& __a,
     input_iterator_tag)
      {
 if (__beg == __end && __a == _Alloc())
   return _S_empty_rep()._M_refdata();
 _CharT __buf[128];
 size_type __len = 0;
 while (__beg != __end && __len < sizeof(__buf) / sizeof(_CharT))
   {
     __buf[__len++] = *__beg;
     ++__beg;
   }
 _Rep* __r = _Rep::_S_create(__len, size_type(0), __a);
 _M_copy(__r->_M_refdata(), __buf, __len);
 try
   {
     while (__beg != __end)
       {
  if (__len == __r->_M_capacity)
    {
      _Rep* __another = _Rep::_S_create(__len + 1, __len, __a);
      _M_copy(__another->_M_refdata(), __r->_M_refdata(), __len);
      __r->_M_destroy(__a);
      __r = __another;
    }
  __r->_M_refdata()[__len++] = *__beg;
  ++__beg;
       }
   }
 catch(...)
   {
     __r->_M_destroy(__a);
     throw;
   }
 __r->_M_set_length_and_sharable(__len);
 return __r->_M_refdata();
      }
  template<typename _CharT, typename _Traits, typename _Alloc>
    template <typename _InIterator>
      _CharT*
      basic_string<_CharT, _Traits, _Alloc>::
      _S_construct(_InIterator __beg, _InIterator __end, const _Alloc& __a,
     forward_iterator_tag)
      {
 if (__beg == __end && __a == _Alloc())
   return _S_empty_rep()._M_refdata();
 if (__builtin_expect(__is_null_pointer(__beg) && __beg != __end, 0))
   __throw_logic_error(("basic_string::_S_construct NULL not valid"));
 const size_type __dnew = static_cast<size_type>(std::distance(__beg,
              __end));
 _Rep* __r = _Rep::_S_create(__dnew, size_type(0), __a);
 try
   { _S_copy_chars(__r->_M_refdata(), __beg, __end); }
 catch(...)
   {
     __r->_M_destroy(__a);
     throw;
   }
 __r->_M_set_length_and_sharable(__dnew);
 return __r->_M_refdata();
      }
  template<typename _CharT, typename _Traits, typename _Alloc>
    _CharT*
    basic_string<_CharT, _Traits, _Alloc>::
    _S_construct(size_type __n, _CharT __c, const _Alloc& __a)
    {
      if (__n == 0 && __a == _Alloc())
 return _S_empty_rep()._M_refdata();
      _Rep* __r = _Rep::_S_create(__n, size_type(0), __a);
      if (__n)
 _M_assign(__r->_M_refdata(), __n, __c);
      __r->_M_set_length_and_sharable(__n);
      return __r->_M_refdata();
    }
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const basic_string& __str)
    : _M_dataplus(__str._M_rep()->_M_grab(_Alloc(__str.get_allocator()),
       __str.get_allocator()),
    __str.get_allocator())
    { }
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const _Alloc& __a)
    : _M_dataplus(_S_construct(size_type(), _CharT(), __a), __a)
    { }
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const basic_string& __str, size_type __pos, size_type __n)
    : _M_dataplus(_S_construct(__str._M_data()
          + __str._M_check(__pos,
      "basic_string::basic_string"),
          __str._M_data() + __str._M_limit(__pos, __n)
          + __pos, _Alloc()), _Alloc())
    { }
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const basic_string& __str, size_type __pos,
   size_type __n, const _Alloc& __a)
    : _M_dataplus(_S_construct(__str._M_data()
          + __str._M_check(__pos,
      "basic_string::basic_string"),
          __str._M_data() + __str._M_limit(__pos, __n)
          + __pos, __a), __a)
    { }
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const _CharT* __s, size_type __n, const _Alloc& __a)
    : _M_dataplus(_S_construct(__s, __s + __n, __a), __a)
    { }
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const _CharT* __s, const _Alloc& __a)
    : _M_dataplus(_S_construct(__s, __s ? __s + traits_type::length(__s) :
          __s + npos, __a), __a)
    { }
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(size_type __n, _CharT __c, const _Alloc& __a)
    : _M_dataplus(_S_construct(__n, __c, __a), __a)
    { }
  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _InputIterator>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(_InputIterator __beg, _InputIterator __end, const _Alloc& __a)
    : _M_dataplus(_S_construct(__beg, __end, __a), __a)
    { }
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    assign(const basic_string& __str)
    {
      if (_M_rep() != __str._M_rep())
 {
   const allocator_type __a = this->get_allocator();
   _CharT* __tmp = __str._M_rep()->_M_grab(__a, __str.get_allocator());
   _M_rep()->_M_dispose(__a);
   _M_data(__tmp);
 }
      return *this;
    }
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    assign(const _CharT* __s, size_type __n)
    {
      ;
      _M_check_length(this->size(), __n, "basic_string::assign");
      if (_M_disjunct(__s) || _M_rep()->_M_is_shared())
 return _M_replace_safe(size_type(0), this->size(), __s, __n);
      else
 {
   const size_type __pos = __s - _M_data();
   if (__pos >= __n)
     _M_copy(_M_data(), __s, __n);
   else if (__pos)
     _M_move(_M_data(), __s, __n);
   _M_rep()->_M_set_length_and_sharable(__n);
   return *this;
 }
     }
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    append(size_type __n, _CharT __c)
    {
      if (__n)
 {
   _M_check_length(size_type(0), __n, "basic_string::append");
   const size_type __len = __n + this->size();
   if (__len > this->capacity() || _M_rep()->_M_is_shared())
     this->reserve(__len);
   _M_assign(_M_data() + this->size(), __n, __c);
   _M_rep()->_M_set_length_and_sharable(__len);
 }
      return *this;
    }
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    append(const _CharT* __s, size_type __n)
    {
      ;
      if (__n)
 {
   _M_check_length(size_type(0), __n, "basic_string::append");
   const size_type __len = __n + this->size();
   if (__len > this->capacity() || _M_rep()->_M_is_shared())
     {
       if (_M_disjunct(__s))
  this->reserve(__len);
       else
  {
    const size_type __off = __s - _M_data();
    this->reserve(__len);
    __s = _M_data() + __off;
  }
     }
   _M_copy(_M_data() + this->size(), __s, __n);
   _M_rep()->_M_set_length_and_sharable(__len);
 }
      return *this;
    }
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    append(const basic_string& __str)
    {
      const size_type __size = __str.size();
      if (__size)
 {
   const size_type __len = __size + this->size();
   if (__len > this->capacity() || _M_rep()->_M_is_shared())
     this->reserve(__len);
   _M_copy(_M_data() + this->size(), __str._M_data(), __size);
   _M_rep()->_M_set_length_and_sharable(__len);
 }
      return *this;
    }
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    append(const basic_string& __str, size_type __pos, size_type __n)
    {
      __str._M_check(__pos, "basic_string::append");
      __n = __str._M_limit(__pos, __n);
      if (__n)
 {
   const size_type __len = __n + this->size();
   if (__len > this->capacity() || _M_rep()->_M_is_shared())
     this->reserve(__len);
   _M_copy(_M_data() + this->size(), __str._M_data() + __pos, __n);
   _M_rep()->_M_set_length_and_sharable(__len);
 }
      return *this;
    }
   template<typename _CharT, typename _Traits, typename _Alloc>
     basic_string<_CharT, _Traits, _Alloc>&
     basic_string<_CharT, _Traits, _Alloc>::
     insert(size_type __pos, const _CharT* __s, size_type __n)
     {
       ;
       _M_check(__pos, "basic_string::insert");
       _M_check_length(size_type(0), __n, "basic_string::insert");
       if (_M_disjunct(__s) || _M_rep()->_M_is_shared())
         return _M_replace_safe(__pos, size_type(0), __s, __n);
       else
         {
           const size_type __off = __s - _M_data();
           _M_mutate(__pos, 0, __n);
           __s = _M_data() + __off;
           _CharT* __p = _M_data() + __pos;
           if (__s + __n <= __p)
             _M_copy(__p, __s, __n);
           else if (__s >= __p)
             _M_copy(__p, __s + __n, __n);
           else
             {
        const size_type __nleft = __p - __s;
               _M_copy(__p, __s, __nleft);
               _M_copy(__p + __nleft, __p + __n, __n - __nleft);
             }
           return *this;
         }
     }
   template<typename _CharT, typename _Traits, typename _Alloc>
     basic_string<_CharT, _Traits, _Alloc>&
     basic_string<_CharT, _Traits, _Alloc>::
     replace(size_type __pos, size_type __n1, const _CharT* __s,
      size_type __n2)
     {
       ;
       _M_check(__pos, "basic_string::replace");
       __n1 = _M_limit(__pos, __n1);
       _M_check_length(__n1, __n2, "basic_string::replace");
       bool __left;
       if (_M_disjunct(__s) || _M_rep()->_M_is_shared())
         return _M_replace_safe(__pos, __n1, __s, __n2);
       else if ((__left = __s + __n2 <= _M_data() + __pos)
  || _M_data() + __pos + __n1 <= __s)
  {
    size_type __off = __s - _M_data();
    __left ? __off : (__off += __n2 - __n1);
    _M_mutate(__pos, __n1, __n2);
    _M_copy(_M_data() + __pos, _M_data() + __off, __n2);
    return *this;
  }
       else
  {
    const basic_string __tmp(__s, __n2);
    return _M_replace_safe(__pos, __n1, __tmp._M_data(), __n2);
  }
     }
  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::_Rep::
    _M_destroy(const _Alloc& __a) throw ()
    {
      const size_type __size = sizeof(_Rep_base) +
                        (this->_M_capacity + 1) * sizeof(_CharT);
      _Raw_bytes_alloc(__a).deallocate(reinterpret_cast<char*>(this), __size);
    }
  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    _M_leak_hard()
    {
      if (_M_rep() == &_S_empty_rep())
 return;
      if (_M_rep()->_M_is_shared())
 _M_mutate(0, 0, 0);
      _M_rep()->_M_set_leaked();
    }
  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    _M_mutate(size_type __pos, size_type __len1, size_type __len2)
    {
      const size_type __old_size = this->size();
      const size_type __new_size = __old_size + __len2 - __len1;
      const size_type __how_much = __old_size - __pos - __len1;
      if (__new_size > this->capacity() || _M_rep()->_M_is_shared())
 {
   const allocator_type __a = get_allocator();
   _Rep* __r = _Rep::_S_create(__new_size, this->capacity(), __a);
   if (__pos)
     _M_copy(__r->_M_refdata(), _M_data(), __pos);
   if (__how_much)
     _M_copy(__r->_M_refdata() + __pos + __len2,
      _M_data() + __pos + __len1, __how_much);
   _M_rep()->_M_dispose(__a);
   _M_data(__r->_M_refdata());
 }
      else if (__how_much && __len1 != __len2)
 {
   _M_move(_M_data() + __pos + __len2,
    _M_data() + __pos + __len1, __how_much);
 }
      _M_rep()->_M_set_length_and_sharable(__new_size);
    }
  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    reserve(size_type __res)
    {
      if (__res != this->capacity() || _M_rep()->_M_is_shared())
        {
   if (__res < this->size())
     __res = this->size();
   const allocator_type __a = get_allocator();
   _CharT* __tmp = _M_rep()->_M_clone(__a, __res - this->size());
   _M_rep()->_M_dispose(__a);
   _M_data(__tmp);
        }
    }
  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    swap(basic_string& __s)
    {
      if (_M_rep()->_M_is_leaked())
 _M_rep()->_M_set_sharable();
      if (__s._M_rep()->_M_is_leaked())
 __s._M_rep()->_M_set_sharable();
      if (this->get_allocator() == __s.get_allocator())
 {
   _CharT* __tmp = _M_data();
   _M_data(__s._M_data());
   __s._M_data(__tmp);
 }
      else
 {
   const basic_string __tmp1(_M_ibegin(), _M_iend(),
        __s.get_allocator());
   const basic_string __tmp2(__s._M_ibegin(), __s._M_iend(),
        this->get_allocator());
   *this = __tmp2;
   __s = __tmp1;
 }
    }
  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::_Rep*
    basic_string<_CharT, _Traits, _Alloc>::_Rep::
    _S_create(size_type __capacity, size_type __old_capacity,
       const _Alloc& __alloc)
    {
      if (__capacity > _S_max_size)
 __throw_length_error(("basic_string::_S_create"));
      const size_type __pagesize = 4096;
      const size_type __malloc_header_size = 4 * sizeof(void*);
      if (__capacity > __old_capacity && __capacity < 2 * __old_capacity)
 __capacity = 2 * __old_capacity;
      size_type __size = (__capacity + 1) * sizeof(_CharT) + sizeof(_Rep);
      const size_type __adj_size = __size + __malloc_header_size;
      if (__adj_size > __pagesize && __capacity > __old_capacity)
 {
   const size_type __extra = __pagesize - __adj_size % __pagesize;
   __capacity += __extra / sizeof(_CharT);
   if (__capacity > _S_max_size)
     __capacity = _S_max_size;
   __size = (__capacity + 1) * sizeof(_CharT) + sizeof(_Rep);
 }
      void* __place = _Raw_bytes_alloc(__alloc).allocate(__size);
      _Rep *__p = new (__place) _Rep;
      __p->_M_capacity = __capacity;
      __p->_M_set_sharable();
      return __p;
    }
  template<typename _CharT, typename _Traits, typename _Alloc>
    _CharT*
    basic_string<_CharT, _Traits, _Alloc>::_Rep::
    _M_clone(const _Alloc& __alloc, size_type __res)
    {
      const size_type __requested_cap = this->_M_length + __res;
      _Rep* __r = _Rep::_S_create(__requested_cap, this->_M_capacity,
      __alloc);
      if (this->_M_length)
 _M_copy(__r->_M_refdata(), _M_refdata(), this->_M_length);
      __r->_M_set_length_and_sharable(this->_M_length);
      return __r->_M_refdata();
    }
  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    resize(size_type __n, _CharT __c)
    {
      const size_type __size = this->size();
      _M_check_length(__size, __n, "basic_string::resize");
      if (__size < __n)
 this->append(__n - __size, __c);
      else if (__n < __size)
 this->erase(__n);
    }
  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _InputIterator>
      basic_string<_CharT, _Traits, _Alloc>&
      basic_string<_CharT, _Traits, _Alloc>::
      _M_replace_dispatch(iterator __i1, iterator __i2, _InputIterator __k1,
     _InputIterator __k2, __false_type)
      {
 const basic_string __s(__k1, __k2);
 const size_type __n1 = __i2 - __i1;
 _M_check_length(__n1, __s.size(), "basic_string::_M_replace_dispatch");
 return _M_replace_safe(__i1 - _M_ibegin(), __n1, __s._M_data(),
          __s.size());
      }
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    _M_replace_aux(size_type __pos1, size_type __n1, size_type __n2,
     _CharT __c)
    {
      _M_check_length(__n1, __n2, "basic_string::_M_replace_aux");
      _M_mutate(__pos1, __n1, __n2);
      if (__n2)
 _M_assign(_M_data() + __pos1, __n2, __c);
      return *this;
    }
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    _M_replace_safe(size_type __pos1, size_type __n1, const _CharT* __s,
      size_type __n2)
    {
      _M_mutate(__pos1, __n1, __n2);
      if (__n2)
 _M_copy(_M_data() + __pos1, __s, __n2);
      return *this;
    }
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>
    operator+(const _CharT* __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    {
      ;
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;
      const __size_type __len = _Traits::length(__lhs);
      __string_type __str;
      __str.reserve(__len + __rhs.size());
      __str.append(__lhs, __len);
      __str.append(__rhs);
      return __str;
    }
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>
    operator+(_CharT __lhs, const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    {
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;
      __string_type __str;
      const __size_type __len = __rhs.size();
      __str.reserve(__len + 1);
      __str.append(__size_type(1), __lhs);
      __str.append(__rhs);
      return __str;
    }
  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    copy(_CharT* __s, size_type __n, size_type __pos) const
    {
      _M_check(__pos, "basic_string::copy");
      __n = _M_limit(__pos, __n);
      ;
      if (__n)
 _M_copy(__s, _M_data() + __pos, __n);
      return __n;
    }
  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      size_type __ret = npos;
      const size_type __size = this->size();
      if (__pos + __n <= __size)
 {
   const _CharT* __data = _M_data();
   const _CharT* __p = std::search(__data + __pos, __data + __size,
       __s, __s + __n, traits_type::eq);
   if (__p != __data + __size || __n == 0)
     __ret = __p - __data;
 }
      return __ret;
    }
  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find(_CharT __c, size_type __pos) const
    {
      size_type __ret = npos;
      const size_type __size = this->size();
      if (__pos < __size)
 {
   const _CharT* __data = _M_data();
   const size_type __n = __size - __pos;
   const _CharT* __p = traits_type::find(__data + __pos, __n, __c);
   if (__p)
     __ret = __p - __data;
 }
      return __ret;
    }
  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    rfind(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      const size_type __size = this->size();
      if (__n <= __size)
 {
   __pos = std::min(size_type(__size - __n), __pos);
   const _CharT* __data = _M_data();
   do
     {
       if (traits_type::compare(__data + __pos, __s, __n) == 0)
  return __pos;
     }
   while (__pos-- > 0);
 }
      return npos;
    }
  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    rfind(_CharT __c, size_type __pos) const
    {
      size_type __size = this->size();
      if (__size)
 {
   if (--__size > __pos)
     __size = __pos;
   for (++__size; __size-- > 0; )
     if (traits_type::eq(_M_data()[__size], __c))
       return __size;
 }
      return npos;
    }
  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_first_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      for (; __n && __pos < this->size(); ++__pos)
 {
   const _CharT* __p = traits_type::find(__s, __n, _M_data()[__pos]);
   if (__p)
     return __pos;
 }
      return npos;
    }
  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_last_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      size_type __size = this->size();
      if (__size && __n)
 {
   if (--__size > __pos)
     __size = __pos;
   do
     {
       if (traits_type::find(__s, __n, _M_data()[__size]))
  return __size;
     }
   while (__size-- != 0);
 }
      return npos;
    }
  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_first_not_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      for (; __pos < this->size(); ++__pos)
 if (!traits_type::find(__s, __n, _M_data()[__pos]))
   return __pos;
      return npos;
    }
  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_first_not_of(_CharT __c, size_type __pos) const
    {
      for (; __pos < this->size(); ++__pos)
 if (!traits_type::eq(_M_data()[__pos], __c))
   return __pos;
      return npos;
    }
  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_last_not_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      size_type __size = this->size();
      if (__size)
 {
   if (--__size > __pos)
     __size = __pos;
   do
     {
       if (!traits_type::find(__s, __n, _M_data()[__size]))
  return __size;
     }
   while (__size--);
 }
      return npos;
    }
  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_last_not_of(_CharT __c, size_type __pos) const
    {
      size_type __size = this->size();
      if (__size)
 {
   if (--__size > __pos)
     __size = __pos;
   do
     {
       if (!traits_type::eq(_M_data()[__size], __c))
  return __size;
     }
   while (__size--);
 }
      return npos;
    }
  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string<_CharT, _Traits, _Alloc>::
    compare(size_type __pos, size_type __n, const basic_string& __str) const
    {
      _M_check(__pos, "basic_string::compare");
      __n = _M_limit(__pos, __n);
      const size_type __osize = __str.size();
      const size_type __len = std::min(__n, __osize);
      int __r = traits_type::compare(_M_data() + __pos, __str.data(), __len);
      if (!__r)
 __r = __n - __osize;
      return __r;
    }
  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string<_CharT, _Traits, _Alloc>::
    compare(size_type __pos1, size_type __n1, const basic_string& __str,
     size_type __pos2, size_type __n2) const
    {
      _M_check(__pos1, "basic_string::compare");
      __str._M_check(__pos2, "basic_string::compare");
      __n1 = _M_limit(__pos1, __n1);
      __n2 = __str._M_limit(__pos2, __n2);
      const size_type __len = std::min(__n1, __n2);
      int __r = traits_type::compare(_M_data() + __pos1,
         __str.data() + __pos2, __len);
      if (!__r)
 __r = __n1 - __n2;
      return __r;
    }
  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string<_CharT, _Traits, _Alloc>::
    compare(const _CharT* __s) const
    {
      ;
      const size_type __size = this->size();
      const size_type __osize = traits_type::length(__s);
      const size_type __len = std::min(__size, __osize);
      int __r = traits_type::compare(_M_data(), __s, __len);
      if (!__r)
 __r = __size - __osize;
      return __r;
    }
  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string <_CharT, _Traits, _Alloc>::
    compare(size_type __pos, size_type __n1, const _CharT* __s) const
    {
      ;
      _M_check(__pos, "basic_string::compare");
      __n1 = _M_limit(__pos, __n1);
      const size_type __osize = traits_type::length(__s);
      const size_type __len = std::min(__n1, __osize);
      int __r = traits_type::compare(_M_data() + __pos, __s, __len);
      if (!__r)
 __r = __n1 - __osize;
      return __r;
    }
  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string <_CharT, _Traits, _Alloc>::
    compare(size_type __pos, size_type __n1, const _CharT* __s,
     size_type __n2) const
    {
      ;
      _M_check(__pos, "basic_string::compare");
      __n1 = _M_limit(__pos, __n1);
      const size_type __len = std::min(__n1, __n2);
      int __r = traits_type::compare(_M_data() + __pos, __s, __len);
      if (!__r)
 __r = __n1 - __n2;
      return __r;
    }
  extern template class basic_string<char>;
  extern template
    basic_istream<char>&
    operator>>(basic_istream<char>&, string&);
  extern template
    basic_ostream<char>&
    operator<<(basic_ostream<char>&, const string&);
  extern template
    basic_istream<char>&
    getline(basic_istream<char>&, string&, char);
  extern template
    basic_istream<char>&
    getline(basic_istream<char>&, string&);
  extern template class basic_string<wchar_t>;
  extern template
    basic_istream<wchar_t>&
    operator>>(basic_istream<wchar_t>&, wstring&);
  extern template
    basic_ostream<wchar_t>&
    operator<<(basic_ostream<wchar_t>&, const wstring&);
  extern template
    basic_istream<wchar_t>&
    getline(basic_istream<wchar_t>&, wstring&, wchar_t);
  extern template
    basic_istream<wchar_t>&
    getline(basic_istream<wchar_t>&, wstring&);
}
namespace std
{
  class locale
  {
  public:
    typedef int category;
    class facet;
    class id;
    class _Impl;
    friend class facet;
    friend class _Impl;
    template<typename _Facet>
      friend bool
      has_facet(const locale&) throw();
    template<typename _Facet>
      friend const _Facet&
      use_facet(const locale&);
    template<typename _Cache>
      friend struct __use_cache;
    static const category none = 0;
    static const category ctype = 1L << 0;
    static const category numeric = 1L << 1;
    static const category collate = 1L << 2;
    static const category time = 1L << 3;
    static const category monetary = 1L << 4;
    static const category messages = 1L << 5;
    static const category all = (ctype | numeric | collate |
        time | monetary | messages);
    locale() throw();
    locale(const locale& __other) throw();
    explicit
    locale(const char* __s);
    locale(const locale& __base, const char* __s, category __cat);
    locale(const locale& __base, const locale& __add, category __cat);
    template<typename _Facet>
      locale(const locale& __other, _Facet* __f);
    ~locale() throw();
    const locale&
    operator=(const locale& __other) throw();
    template<typename _Facet>
      locale
      combine(const locale& __other) const;
    string
    name() const;
    bool
    operator==(const locale& __other) const throw ();
    inline bool
    operator!=(const locale& __other) const throw ()
    { return !(this->operator==(__other)); }
    template<typename _Char, typename _Traits, typename _Alloc>
      bool
      operator()(const basic_string<_Char, _Traits, _Alloc>& __s1,
   const basic_string<_Char, _Traits, _Alloc>& __s2) const;
    static locale
    global(const locale&);
    static const locale&
    classic();
  private:
    _Impl* _M_impl;
    static _Impl* _S_classic;
    static _Impl* _S_global;
    static const char* const* const _S_categories;
    enum { _S_categories_size = 6 + 6 };
    static __gthread_once_t _S_once;
    explicit
    locale(_Impl*) throw();
    static void
    _S_initialize();
    static void
    _S_initialize_once();
    static category
    _S_normalize_category(category);
    void
    _M_coalesce(const locale& __base, const locale& __add, category __cat);
  };
  class locale::facet
  {
  private:
    friend class locale;
    friend class locale::_Impl;
    mutable _Atomic_word _M_refcount;
    static __c_locale _S_c_locale;
    static const char _S_c_name[2];
    static __gthread_once_t _S_once;
    static void
    _S_initialize_once();
  protected:
    explicit
    facet(size_t __refs = 0) throw() : _M_refcount(__refs ? 1 : 0)
    { }
    virtual
    ~facet();
    static void
    _S_create_c_locale(__c_locale& __cloc, const char* __s,
         __c_locale __old = 0);
    static __c_locale
    _S_clone_c_locale(__c_locale& __cloc);
    static void
    _S_destroy_c_locale(__c_locale& __cloc);
    static __c_locale
    _S_get_c_locale();
    static const char*
    _S_get_c_name();
  private:
    inline void
    _M_add_reference() const throw()
    { __gnu_cxx::__atomic_add(&_M_refcount, 1); }
    inline void
    _M_remove_reference() const throw()
    {
      if (__gnu_cxx::__exchange_and_add(&_M_refcount, -1) == 1)
 {
   try
     { delete this; }
   catch (...)
     { }
 }
    }
    facet(const facet&);
    facet&
    operator=(const facet&);
  };
  class locale::id
  {
  private:
    friend class locale;
    friend class locale::_Impl;
    template<typename _Facet>
      friend const _Facet&
      use_facet(const locale&);
    template<typename _Facet>
      friend bool
      has_facet(const locale&) throw ();
    mutable size_t _M_index;
    static _Atomic_word _S_refcount;
    void
    operator=(const id&);
    id(const id&);
  public:
    id() { }
    size_t
    _M_id() const;
  };
  class locale::_Impl
  {
  public:
    friend class locale;
    friend class locale::facet;
    template<typename _Facet>
      friend bool
      has_facet(const locale&) throw();
    template<typename _Facet>
      friend const _Facet&
      use_facet(const locale&);
    template<typename _Cache>
      friend struct __use_cache;
  private:
    _Atomic_word _M_refcount;
    const facet** _M_facets;
    size_t _M_facets_size;
    const facet** _M_caches;
    char** _M_names;
    static const locale::id* const _S_id_ctype[];
    static const locale::id* const _S_id_numeric[];
    static const locale::id* const _S_id_collate[];
    static const locale::id* const _S_id_time[];
    static const locale::id* const _S_id_monetary[];
    static const locale::id* const _S_id_messages[];
    static const locale::id* const* const _S_facet_categories[];
    inline void
    _M_add_reference() throw()
    { __gnu_cxx::__atomic_add(&_M_refcount, 1); }
    inline void
    _M_remove_reference() throw()
    {
      if (__gnu_cxx::__exchange_and_add(&_M_refcount, -1) == 1)
 {
   try
     { delete this; }
   catch(...)
     { }
 }
    }
    _Impl(const _Impl&, size_t);
    _Impl(const char*, size_t);
    _Impl(size_t) throw();
   ~_Impl() throw();
    _Impl(const _Impl&);
    void
    operator=(const _Impl&);
    inline bool
    _M_check_same_name()
    {
      bool __ret = true;
      if (_M_names[1])
 for (size_t __i = 0; __ret && __i < _S_categories_size - 1; ++__i)
   __ret = std::strcmp(_M_names[__i], _M_names[__i + 1]) == 0;
      return __ret;
    }
    void
    _M_replace_categories(const _Impl*, category);
    void
    _M_replace_category(const _Impl*, const locale::id* const*);
    void
    _M_replace_facet(const _Impl*, const locale::id*);
    void
    _M_install_facet(const locale::id*, const facet*);
    template<typename _Facet>
      inline void
      _M_init_facet(_Facet* __facet)
      { _M_install_facet(&_Facet::id, __facet); }
    void
    _M_install_cache(const facet*, size_t);
  };
  template<typename _Facet>
    locale::locale(const locale& __other, _Facet* __f)
    {
      _M_impl = new _Impl(*__other._M_impl, 1);
      try
 { _M_impl->_M_install_facet(&_Facet::id, __f); }
      catch(...)
 {
   _M_impl->_M_remove_reference();
   throw;
 }
      delete [] _M_impl->_M_names[0];
      _M_impl->_M_names[0] = 0;
    }
}
namespace std
{
  enum _Ios_Fmtflags
    {
      _S_boolalpha = 1L << 0,
      _S_dec = 1L << 1,
      _S_fixed = 1L << 2,
      _S_hex = 1L << 3,
      _S_internal = 1L << 4,
      _S_left = 1L << 5,
      _S_oct = 1L << 6,
      _S_right = 1L << 7,
      _S_scientific = 1L << 8,
      _S_showbase = 1L << 9,
      _S_showpoint = 1L << 10,
      _S_showpos = 1L << 11,
      _S_skipws = 1L << 12,
      _S_unitbuf = 1L << 13,
      _S_uppercase = 1L << 14,
      _S_adjustfield = _S_left | _S_right | _S_internal,
      _S_basefield = _S_dec | _S_oct | _S_hex,
      _S_floatfield = _S_scientific | _S_fixed,
      _S_ios_fmtflags_end = 1L << 16
    };
  inline _Ios_Fmtflags
  operator&(_Ios_Fmtflags __a, _Ios_Fmtflags __b)
  { return _Ios_Fmtflags(static_cast<int>(__a) & static_cast<int>(__b)); }
  inline _Ios_Fmtflags
  operator|(_Ios_Fmtflags __a, _Ios_Fmtflags __b)
  { return _Ios_Fmtflags(static_cast<int>(__a) | static_cast<int>(__b)); }
  inline _Ios_Fmtflags
  operator^(_Ios_Fmtflags __a, _Ios_Fmtflags __b)
  { return _Ios_Fmtflags(static_cast<int>(__a) ^ static_cast<int>(__b)); }
  inline _Ios_Fmtflags&
  operator|=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)
  { return __a = __a | __b; }
  inline _Ios_Fmtflags&
  operator&=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)
  { return __a = __a & __b; }
  inline _Ios_Fmtflags&
  operator^=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)
  { return __a = __a ^ __b; }
  inline _Ios_Fmtflags
  operator~(_Ios_Fmtflags __a)
  { return _Ios_Fmtflags(~static_cast<int>(__a)); }
  enum _Ios_Openmode
    {
      _S_app = 1L << 0,
      _S_ate = 1L << 1,
      _S_bin = 1L << 2,
      _S_in = 1L << 3,
      _S_out = 1L << 4,
      _S_trunc = 1L << 5,
      _S_ios_openmode_end = 1L << 16
    };
  inline _Ios_Openmode
  operator&(_Ios_Openmode __a, _Ios_Openmode __b)
  { return _Ios_Openmode(static_cast<int>(__a) & static_cast<int>(__b)); }
  inline _Ios_Openmode
  operator|(_Ios_Openmode __a, _Ios_Openmode __b)
  { return _Ios_Openmode(static_cast<int>(__a) | static_cast<int>(__b)); }
  inline _Ios_Openmode
  operator^(_Ios_Openmode __a, _Ios_Openmode __b)
  { return _Ios_Openmode(static_cast<int>(__a) ^ static_cast<int>(__b)); }
  inline _Ios_Openmode&
  operator|=(_Ios_Openmode& __a, _Ios_Openmode __b)
  { return __a = __a | __b; }
  inline _Ios_Openmode&
  operator&=(_Ios_Openmode& __a, _Ios_Openmode __b)
  { return __a = __a & __b; }
  inline _Ios_Openmode&
  operator^=(_Ios_Openmode& __a, _Ios_Openmode __b)
  { return __a = __a ^ __b; }
  inline _Ios_Openmode
  operator~(_Ios_Openmode __a)
  { return _Ios_Openmode(~static_cast<int>(__a)); }
  enum _Ios_Iostate
    {
      _S_goodbit = 0,
      _S_badbit = 1L << 0,
      _S_eofbit = 1L << 1,
      _S_failbit = 1L << 2,
      _S_ios_iostate_end = 1L << 16
    };
  inline _Ios_Iostate
  operator&(_Ios_Iostate __a, _Ios_Iostate __b)
  { return _Ios_Iostate(static_cast<int>(__a) & static_cast<int>(__b)); }
  inline _Ios_Iostate
  operator|(_Ios_Iostate __a, _Ios_Iostate __b)
  { return _Ios_Iostate(static_cast<int>(__a) | static_cast<int>(__b)); }
  inline _Ios_Iostate
  operator^(_Ios_Iostate __a, _Ios_Iostate __b)
  { return _Ios_Iostate(static_cast<int>(__a) ^ static_cast<int>(__b)); }
  inline _Ios_Iostate&
  operator|=(_Ios_Iostate& __a, _Ios_Iostate __b)
  { return __a = __a | __b; }
  inline _Ios_Iostate&
  operator&=(_Ios_Iostate& __a, _Ios_Iostate __b)
  { return __a = __a & __b; }
  inline _Ios_Iostate&
  operator^=(_Ios_Iostate& __a, _Ios_Iostate __b)
  { return __a = __a ^ __b; }
  inline _Ios_Iostate
  operator~(_Ios_Iostate __a)
  { return _Ios_Iostate(~static_cast<int>(__a)); }
  enum _Ios_Seekdir
    {
      _S_beg = 0,
      _S_cur = 1,
      _S_end = 2,
      _S_ios_seekdir_end = 1L << 16
    };
  class ios_base
  {
  public:
    class failure : public exception
    {
    public:
      explicit
      failure(const string& __str) throw();
      virtual
      ~failure() throw();
      virtual const char*
      what() const throw();
    private:
      string _M_msg;
    };
    typedef _Ios_Fmtflags fmtflags;
    static const fmtflags boolalpha = _S_boolalpha;
    static const fmtflags dec = _S_dec;
    static const fmtflags fixed = _S_fixed;
    static const fmtflags hex = _S_hex;
    static const fmtflags internal = _S_internal;
    static const fmtflags left = _S_left;
    static const fmtflags oct = _S_oct;
    static const fmtflags right = _S_right;
    static const fmtflags scientific = _S_scientific;
    static const fmtflags showbase = _S_showbase;
    static const fmtflags showpoint = _S_showpoint;
    static const fmtflags showpos = _S_showpos;
    static const fmtflags skipws = _S_skipws;
    static const fmtflags unitbuf = _S_unitbuf;
    static const fmtflags uppercase = _S_uppercase;
    static const fmtflags adjustfield = _S_adjustfield;
    static const fmtflags basefield = _S_basefield;
    static const fmtflags floatfield = _S_floatfield;
    typedef _Ios_Iostate iostate;
    static const iostate badbit = _S_badbit;
    static const iostate eofbit = _S_eofbit;
    static const iostate failbit = _S_failbit;
    static const iostate goodbit = _S_goodbit;
    typedef _Ios_Openmode openmode;
    static const openmode app = _S_app;
    static const openmode ate = _S_ate;
    static const openmode binary = _S_bin;
    static const openmode in = _S_in;
    static const openmode out = _S_out;
    static const openmode trunc = _S_trunc;
    typedef _Ios_Seekdir seekdir;
    static const seekdir beg = _S_beg;
    static const seekdir cur = _S_cur;
    static const seekdir end = _S_end;
    typedef int io_state;
    typedef int open_mode;
    typedef int seek_dir;
    typedef std::streampos streampos;
    typedef std::streamoff streamoff;
    enum event
    {
      erase_event,
      imbue_event,
      copyfmt_event
    };
    typedef void (*event_callback) (event, ios_base&, int);
    void
    register_callback(event_callback __fn, int __index);
  protected:
    streamsize _M_precision;
    streamsize _M_width;
    fmtflags _M_flags;
    iostate _M_exception;
    iostate _M_streambuf_state;
    struct _Callback_list
    {
      _Callback_list* _M_next;
      ios_base::event_callback _M_fn;
      int _M_index;
      _Atomic_word _M_refcount;
      _Callback_list(ios_base::event_callback __fn, int __index,
       _Callback_list* __cb)
      : _M_next(__cb), _M_fn(__fn), _M_index(__index), _M_refcount(0) { }
      void
      _M_add_reference() { __gnu_cxx::__atomic_add(&_M_refcount, 1); }
      int
      _M_remove_reference()
      { return __gnu_cxx::__exchange_and_add(&_M_refcount, -1); }
    };
     _Callback_list* _M_callbacks;
    void
    _M_call_callbacks(event __ev) throw();
    void
    _M_dispose_callbacks(void);
    struct _Words
    {
      void* _M_pword;
      long _M_iword;
      _Words() : _M_pword(0), _M_iword(0) { }
    };
    _Words _M_word_zero;
    enum { _S_local_word_size = 8 };
    _Words _M_local_word[_S_local_word_size];
    int _M_word_size;
    _Words* _M_word;
    _Words&
    _M_grow_words(int __index, bool __iword);
    locale _M_ios_locale;
    void
    _M_init();
  public:
    class Init
    {
      friend class ios_base;
    public:
      Init();
      ~Init();
    private:
      static _Atomic_word _S_refcount;
      static bool _S_synced_with_stdio;
    };
    inline fmtflags
    flags() const { return _M_flags; }
    inline fmtflags
    flags(fmtflags __fmtfl)
    {
      fmtflags __old = _M_flags;
      _M_flags = __fmtfl;
      return __old;
    }
    inline fmtflags
    setf(fmtflags __fmtfl)
    {
      fmtflags __old = _M_flags;
      _M_flags |= __fmtfl;
      return __old;
    }
    inline fmtflags
    setf(fmtflags __fmtfl, fmtflags __mask)
    {
      fmtflags __old = _M_flags;
      _M_flags &= ~__mask;
      _M_flags |= (__fmtfl & __mask);
      return __old;
    }
    inline void
    unsetf(fmtflags __mask) { _M_flags &= ~__mask; }
    inline streamsize
    precision() const { return _M_precision; }
    inline streamsize
    precision(streamsize __prec)
    {
      streamsize __old = _M_precision;
      _M_precision = __prec;
      return __old;
    }
    inline streamsize
    width() const { return _M_width; }
    inline streamsize
    width(streamsize __wide)
    {
      streamsize __old = _M_width;
      _M_width = __wide;
      return __old;
    }
    static bool
    sync_with_stdio(bool __sync = true);
    locale
    imbue(const locale& __loc);
    inline locale
    getloc() const { return _M_ios_locale; }
    inline const locale&
    _M_getloc() const { return _M_ios_locale; }
    static int
    xalloc() throw();
    inline long&
    iword(int __ix)
    {
      _Words& __word = (__ix < _M_word_size)
   ? _M_word[__ix] : _M_grow_words(__ix, true);
      return __word._M_iword;
    }
    inline void*&
    pword(int __ix)
    {
      _Words& __word = (__ix < _M_word_size)
   ? _M_word[__ix] : _M_grow_words(__ix, false);
      return __word._M_pword;
    }
    virtual ~ios_base();
  protected:
    ios_base();
  private:
    ios_base(const ios_base&);
    ios_base&
    operator=(const ios_base&);
  };
  inline ios_base&
  boolalpha(ios_base& __base)
  {
    __base.setf(ios_base::boolalpha);
    return __base;
  }
  inline ios_base&
  noboolalpha(ios_base& __base)
  {
    __base.unsetf(ios_base::boolalpha);
    return __base;
  }
  inline ios_base&
  showbase(ios_base& __base)
  {
    __base.setf(ios_base::showbase);
    return __base;
  }
  inline ios_base&
  noshowbase(ios_base& __base)
  {
    __base.unsetf(ios_base::showbase);
    return __base;
  }
  inline ios_base&
  showpoint(ios_base& __base)
  {
    __base.setf(ios_base::showpoint);
    return __base;
  }
  inline ios_base&
  noshowpoint(ios_base& __base)
  {
    __base.unsetf(ios_base::showpoint);
    return __base;
  }
  inline ios_base&
  showpos(ios_base& __base)
  {
    __base.setf(ios_base::showpos);
    return __base;
  }
  inline ios_base&
  noshowpos(ios_base& __base)
  {
    __base.unsetf(ios_base::showpos);
    return __base;
  }
  inline ios_base&
  skipws(ios_base& __base)
  {
    __base.setf(ios_base::skipws);
    return __base;
  }
  inline ios_base&
  noskipws(ios_base& __base)
  {
    __base.unsetf(ios_base::skipws);
    return __base;
  }
  inline ios_base&
  uppercase(ios_base& __base)
  {
    __base.setf(ios_base::uppercase);
    return __base;
  }
  inline ios_base&
  nouppercase(ios_base& __base)
  {
    __base.unsetf(ios_base::uppercase);
    return __base;
  }
  inline ios_base&
  unitbuf(ios_base& __base)
  {
     __base.setf(ios_base::unitbuf);
     return __base;
  }
  inline ios_base&
  nounitbuf(ios_base& __base)
  {
     __base.unsetf(ios_base::unitbuf);
     return __base;
  }
  inline ios_base&
  internal(ios_base& __base)
  {
     __base.setf(ios_base::internal, ios_base::adjustfield);
     return __base;
  }
  inline ios_base&
  left(ios_base& __base)
  {
    __base.setf(ios_base::left, ios_base::adjustfield);
    return __base;
  }
  inline ios_base&
  right(ios_base& __base)
  {
    __base.setf(ios_base::right, ios_base::adjustfield);
    return __base;
  }
  inline ios_base&
  dec(ios_base& __base)
  {
    __base.setf(ios_base::dec, ios_base::basefield);
    return __base;
  }
  inline ios_base&
  hex(ios_base& __base)
  {
    __base.setf(ios_base::hex, ios_base::basefield);
    return __base;
  }
  inline ios_base&
  oct(ios_base& __base)
  {
    __base.setf(ios_base::oct, ios_base::basefield);
    return __base;
  }
  inline ios_base&
  fixed(ios_base& __base)
  {
    __base.setf(ios_base::fixed, ios_base::floatfield);
    return __base;
  }
  inline ios_base&
  scientific(ios_base& __base)
  {
    __base.setf(ios_base::scientific, ios_base::floatfield);
    return __base;
  }
}
namespace std
{
  template<typename _CharT, typename _Traits>
    streamsize
    __copy_streambufs(basic_streambuf<_CharT, _Traits>* __sbin,
        basic_streambuf<_CharT, _Traits>* __sbout);
  template<typename _CharT, typename _Traits>
    class basic_streambuf
    {
    public:
      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;
      typedef basic_streambuf<char_type, traits_type> __streambuf_type;
      friend class basic_ios<char_type, traits_type>;
      friend class basic_istream<char_type, traits_type>;
      friend class basic_ostream<char_type, traits_type>;
      friend class istreambuf_iterator<char_type, traits_type>;
      friend class ostreambuf_iterator<char_type, traits_type>;
      friend streamsize
      __copy_streambufs<>(__streambuf_type* __sbin,
     __streambuf_type* __sbout);
      template<typename _CharT2, typename _Traits2>
        friend basic_istream<_CharT2, _Traits2>&
        operator>>(basic_istream<_CharT2, _Traits2>&, _CharT2*);
      template<typename _CharT2, typename _Traits2, typename _Alloc>
        friend basic_istream<_CharT2, _Traits2>&
        operator>>(basic_istream<_CharT2, _Traits2>&,
     basic_string<_CharT2, _Traits2, _Alloc>&);
      template<typename _CharT2, typename _Traits2, typename _Alloc>
        friend basic_istream<_CharT2, _Traits2>&
        getline(basic_istream<_CharT2, _Traits2>&,
  basic_string<_CharT2, _Traits2, _Alloc>&, _CharT2);
    protected:
      char_type* _M_in_beg;
      char_type* _M_in_cur;
      char_type* _M_in_end;
      char_type* _M_out_beg;
      char_type* _M_out_cur;
      char_type* _M_out_end;
      locale _M_buf_locale;
  public:
      virtual
      ~basic_streambuf()
      { }
      locale
      pubimbue(const locale &__loc)
      {
 locale __tmp(this->getloc());
 this->imbue(__loc);
 _M_buf_locale = __loc;
 return __tmp;
      }
      locale
      getloc() const
      { return _M_buf_locale; }
      __streambuf_type*
      pubsetbuf(char_type* __s, streamsize __n)
      { return this->setbuf(__s, __n); }
      pos_type
      pubseekoff(off_type __off, ios_base::seekdir __way,
   ios_base::openmode __mode = ios_base::in | ios_base::out)
      { return this->seekoff(__off, __way, __mode); }
      pos_type
      pubseekpos(pos_type __sp,
   ios_base::openmode __mode = ios_base::in | ios_base::out)
      { return this->seekpos(__sp, __mode); }
      int
      pubsync() { return this->sync(); }
      streamsize
      in_avail()
      {
 const streamsize __ret = this->egptr() - this->gptr();
 return __ret ? __ret : this->showmanyc();
      }
      int_type
      snextc()
      {
 int_type __ret = traits_type::eof();
 if (__builtin_expect(!traits_type::eq_int_type(this->sbumpc(),
             __ret), true))
   __ret = this->sgetc();
 return __ret;
      }
      int_type
      sbumpc()
      {
 int_type __ret;
 if (__builtin_expect(this->gptr() < this->egptr(), true))
   {
     __ret = traits_type::to_int_type(*this->gptr());
     this->gbump(1);
   }
 else
   __ret = this->uflow();
 return __ret;
      }
      int_type
      sgetc()
      {
 int_type __ret;
 if (__builtin_expect(this->gptr() < this->egptr(), true))
   __ret = traits_type::to_int_type(*this->gptr());
 else
   __ret = this->underflow();
 return __ret;
      }
      streamsize
      sgetn(char_type* __s, streamsize __n)
      { return this->xsgetn(__s, __n); }
      int_type
      sputbackc(char_type __c)
      {
 int_type __ret;
 const bool __testpos = this->eback() < this->gptr();
 if (__builtin_expect(!__testpos ||
        !traits_type::eq(__c, this->gptr()[-1]), false))
   __ret = this->pbackfail(traits_type::to_int_type(__c));
 else
   {
     this->gbump(-1);
     __ret = traits_type::to_int_type(*this->gptr());
   }
 return __ret;
      }
      int_type
      sungetc()
      {
 int_type __ret;
 if (__builtin_expect(this->eback() < this->gptr(), true))
   {
     this->gbump(-1);
     __ret = traits_type::to_int_type(*this->gptr());
   }
 else
   __ret = this->pbackfail();
 return __ret;
      }
      int_type
      sputc(char_type __c)
      {
 int_type __ret;
 if (__builtin_expect(this->pptr() < this->epptr(), true))
   {
     *this->pptr() = __c;
     this->pbump(1);
     __ret = traits_type::to_int_type(__c);
   }
 else
   __ret = this->overflow(traits_type::to_int_type(__c));
 return __ret;
      }
      streamsize
      sputn(const char_type* __s, streamsize __n)
      { return this->xsputn(__s, __n); }
    protected:
      basic_streambuf()
      : _M_in_beg(0), _M_in_cur(0), _M_in_end(0),
      _M_out_beg(0), _M_out_cur(0), _M_out_end(0),
      _M_buf_locale(locale())
      { }
      char_type*
      eback() const { return _M_in_beg; }
      char_type*
      gptr() const { return _M_in_cur; }
      char_type*
      egptr() const { return _M_in_end; }
      void
      gbump(int __n) { _M_in_cur += __n; }
      void
      setg(char_type* __gbeg, char_type* __gnext, char_type* __gend)
      {
 _M_in_beg = __gbeg;
 _M_in_cur = __gnext;
 _M_in_end = __gend;
      }
      char_type*
      pbase() const { return _M_out_beg; }
      char_type*
      pptr() const { return _M_out_cur; }
      char_type*
      epptr() const { return _M_out_end; }
      void
      pbump(int __n) { _M_out_cur += __n; }
      void
      setp(char_type* __pbeg, char_type* __pend)
      {
 _M_out_beg = _M_out_cur = __pbeg;
 _M_out_end = __pend;
      }
      virtual void
      imbue(const locale&)
      { }
      virtual basic_streambuf<char_type,_Traits>*
      setbuf(char_type*, streamsize)
      { return this; }
      virtual pos_type
      seekoff(off_type, ios_base::seekdir,
       ios_base::openmode = ios_base::in | ios_base::out)
      { return pos_type(off_type(-1)); }
      virtual pos_type
      seekpos(pos_type,
       ios_base::openmode = ios_base::in | ios_base::out)
      { return pos_type(off_type(-1)); }
      virtual int
      sync() { return 0; }
      virtual streamsize
      showmanyc() { return 0; }
      virtual streamsize
      xsgetn(char_type* __s, streamsize __n);
      virtual int_type
      underflow()
      { return traits_type::eof(); }
      virtual int_type
      uflow()
      {
 int_type __ret = traits_type::eof();
 const bool __testeof = traits_type::eq_int_type(this->underflow(),
       __ret);
 if (!__testeof)
   {
     __ret = traits_type::to_int_type(*this->gptr());
     this->gbump(1);
   }
 return __ret;
      }
      virtual int_type
      pbackfail(int_type = traits_type::eof())
      { return traits_type::eof(); }
      virtual streamsize
      xsputn(const char_type* __s, streamsize __n);
      virtual int_type
      overflow(int_type = traits_type::eof())
      { return traits_type::eof(); }
    private:
      basic_streambuf(const __streambuf_type& __sb)
      : _M_in_beg(__sb._M_in_beg), _M_in_cur(__sb._M_in_cur),
      _M_in_end(__sb._M_in_end), _M_out_beg(__sb._M_out_beg),
      _M_out_cur(__sb._M_out_cur), _M_out_end(__sb._M_out_cur),
      _M_buf_locale(__sb._M_buf_locale)
      { }
      __streambuf_type&
      operator=(const __streambuf_type&) { return *this; };
    };
  template<>
    streamsize
    __copy_streambufs(basic_streambuf<char>* __sbin,
        basic_streambuf<char>* __sbout);
  template<>
    streamsize
    __copy_streambufs(basic_streambuf<wchar_t>* __sbin,
        basic_streambuf<wchar_t>* __sbout);
}
namespace std
{
  template<typename _CharT, typename _Traits>
    streamsize
    basic_streambuf<_CharT, _Traits>::
    xsgetn(char_type* __s, streamsize __n)
    {
      streamsize __ret = 0;
      while (__ret < __n)
 {
   const streamsize __buf_len = this->egptr() - this->gptr();
   if (__buf_len)
     {
       const streamsize __remaining = __n - __ret;
       const streamsize __len = std::min(__buf_len, __remaining);
       traits_type::copy(__s, this->gptr(), __len);
       __ret += __len;
       __s += __len;
       this->gbump(__len);
     }
   if (__ret < __n)
     {
       const int_type __c = this->uflow();
       if (!traits_type::eq_int_type(__c, traits_type::eof()))
  {
    traits_type::assign(*__s++, traits_type::to_char_type(__c));
    ++__ret;
  }
       else
  break;
     }
 }
      return __ret;
    }
  template<typename _CharT, typename _Traits>
    streamsize
    basic_streambuf<_CharT, _Traits>::
    xsputn(const char_type* __s, streamsize __n)
    {
      streamsize __ret = 0;
      while (__ret < __n)
 {
   const streamsize __buf_len = this->epptr() - this->pptr();
   if (__buf_len)
     {
       const streamsize __remaining = __n - __ret;
       const streamsize __len = std::min(__buf_len, __remaining);
       traits_type::copy(this->pptr(), __s, __len);
       __ret += __len;
       __s += __len;
       this->pbump(__len);
     }
   if (__ret < __n)
     {
       int_type __c = this->overflow(traits_type::to_int_type(*__s));
       if (!traits_type::eq_int_type(__c, traits_type::eof()))
  {
    ++__ret;
    ++__s;
  }
       else
  break;
     }
 }
      return __ret;
    }
  template<typename _CharT, typename _Traits>
    streamsize
    __copy_streambufs(basic_streambuf<_CharT, _Traits>* __sbin,
        basic_streambuf<_CharT, _Traits>* __sbout)
    {
      streamsize __ret = 0;
      typename _Traits::int_type __c = __sbin->sgetc();
      while (!_Traits::eq_int_type(__c, _Traits::eof()))
 {
   __c = __sbout->sputc(_Traits::to_char_type(__c));
   if (_Traits::eq_int_type(__c, _Traits::eof()))
     break;
   ++__ret;
   __c = __sbin->snextc();
 }
      return __ret;
    }
  extern template class basic_streambuf<char>;
  extern template
    streamsize
    __copy_streambufs(basic_streambuf<char>*, basic_streambuf<char>*);
  extern template class basic_streambuf<wchar_t>;
  extern template
    streamsize
    __copy_streambufs(basic_streambuf<wchar_t>*, basic_streambuf<wchar_t>*);
}
namespace std
{
  template<typename _CharT, typename _Traits>
    class istreambuf_iterator
    : public iterator<input_iterator_tag, _CharT, typename _Traits::off_type,
        _CharT*, _CharT&>
    {
    public:
      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename _Traits::int_type int_type;
      typedef basic_streambuf<_CharT, _Traits> streambuf_type;
      typedef basic_istream<_CharT, _Traits> istream_type;
    private:
      mutable streambuf_type* _M_sbuf;
      mutable int_type _M_c;
    public:
      istreambuf_iterator() throw()
      : _M_sbuf(0), _M_c(traits_type::eof()) { }
      istreambuf_iterator(istream_type& __s) throw()
      : _M_sbuf(__s.rdbuf()), _M_c(traits_type::eof()) { }
      istreambuf_iterator(streambuf_type* __s) throw()
      : _M_sbuf(__s), _M_c(traits_type::eof()) { }
      char_type
      operator*() const
      {
 return traits_type::to_char_type(_M_get());
      }
      istreambuf_iterator&
      operator++()
      {
 ;
 if (_M_sbuf)
   {
     _M_sbuf->sbumpc();
     _M_c = traits_type::eof();
   }
 return *this;
      }
      istreambuf_iterator
      operator++(int)
      {
 ;
 istreambuf_iterator __old = *this;
 if (_M_sbuf)
   {
     __old._M_c = _M_sbuf->sbumpc();
     _M_c = traits_type::eof();
   }
 return __old;
      }
      bool
      equal(const istreambuf_iterator& __b) const
      {
 const bool __thiseof = _M_at_eof();
 const bool __beof = __b._M_at_eof();
 return (__thiseof && __beof || (!__thiseof && !__beof));
      }
    private:
      int_type
      _M_get() const
      {
 const int_type __eof = traits_type::eof();
 int_type __ret = __eof;
 if (_M_sbuf)
   {
     if (!traits_type::eq_int_type(_M_c, __eof))
       __ret = _M_c;
     else if (!traits_type::eq_int_type((__ret = _M_sbuf->sgetc()),
            __eof))
       _M_c = __ret;
     else
       _M_sbuf = 0;
   }
 return __ret;
      }
      bool
      _M_at_eof() const
      {
 const int_type __eof = traits_type::eof();
 return traits_type::eq_int_type(_M_get(), __eof);
      }
    };
  template<typename _CharT, typename _Traits>
    inline bool
    operator==(const istreambuf_iterator<_CharT, _Traits>& __a,
        const istreambuf_iterator<_CharT, _Traits>& __b)
    { return __a.equal(__b); }
  template<typename _CharT, typename _Traits>
    inline bool
    operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,
        const istreambuf_iterator<_CharT, _Traits>& __b)
    { return !__a.equal(__b); }
  template<typename _CharT, typename _Traits>
    class ostreambuf_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    public:
      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef basic_streambuf<_CharT, _Traits> streambuf_type;
      typedef basic_ostream<_CharT, _Traits> ostream_type;
    private:
      streambuf_type* _M_sbuf;
      bool _M_failed;
    public:
      ostreambuf_iterator(ostream_type& __s) throw ()
      : _M_sbuf(__s.rdbuf()), _M_failed(!_M_sbuf) { }
      ostreambuf_iterator(streambuf_type* __s) throw ()
      : _M_sbuf(__s), _M_failed(!_M_sbuf) { }
      ostreambuf_iterator&
      operator=(_CharT __c)
      {
 if (!_M_failed &&
     _Traits::eq_int_type(_M_sbuf->sputc(__c), _Traits::eof()))
   _M_failed = true;
 return *this;
      }
      ostreambuf_iterator&
      operator*()
      { return *this; }
      ostreambuf_iterator&
      operator++(int)
      { return *this; }
      ostreambuf_iterator&
      operator++()
      { return *this; }
      bool
      failed() const throw()
      { return _M_failed; }
      ostreambuf_iterator&
      _M_put(const _CharT* __ws, streamsize __len)
      {
 if (__builtin_expect(!_M_failed, true)
     && __builtin_expect(this->_M_sbuf->sputn(__ws, __len) != __len,
    false))
   _M_failed = true;
 return *this;
      }
    };
}
typedef unsigned long int wctype_t;
enum
{
  __ISwupper = 0,
  __ISwlower = 1,
  __ISwalpha = 2,
  __ISwdigit = 3,
  __ISwxdigit = 4,
  __ISwspace = 5,
  __ISwprint = 6,
  __ISwgraph = 7,
  __ISwblank = 8,
  __ISwcntrl = 9,
  __ISwpunct = 10,
  __ISwalnum = 11,
  _ISwupper = ((__ISwupper) < 8 ? (int) ((1UL << (__ISwupper)) << 24) : ((__ISwupper) < 16 ? (int) ((1UL << (__ISwupper)) << 8) : ((__ISwupper) < 24 ? (int) ((1UL << (__ISwupper)) >> 8) : (int) ((1UL << (__ISwupper)) >> 24)))),
  _ISwlower = ((__ISwlower) < 8 ? (int) ((1UL << (__ISwlower)) << 24) : ((__ISwlower) < 16 ? (int) ((1UL << (__ISwlower)) << 8) : ((__ISwlower) < 24 ? (int) ((1UL << (__ISwlower)) >> 8) : (int) ((1UL << (__ISwlower)) >> 24)))),
  _ISwalpha = ((__ISwalpha) < 8 ? (int) ((1UL << (__ISwalpha)) << 24) : ((__ISwalpha) < 16 ? (int) ((1UL << (__ISwalpha)) << 8) : ((__ISwalpha) < 24 ? (int) ((1UL << (__ISwalpha)) >> 8) : (int) ((1UL << (__ISwalpha)) >> 24)))),
  _ISwdigit = ((__ISwdigit) < 8 ? (int) ((1UL << (__ISwdigit)) << 24) : ((__ISwdigit) < 16 ? (int) ((1UL << (__ISwdigit)) << 8) : ((__ISwdigit) < 24 ? (int) ((1UL << (__ISwdigit)) >> 8) : (int) ((1UL << (__ISwdigit)) >> 24)))),
  _ISwxdigit = ((__ISwxdigit) < 8 ? (int) ((1UL << (__ISwxdigit)) << 24) : ((__ISwxdigit) < 16 ? (int) ((1UL << (__ISwxdigit)) << 8) : ((__ISwxdigit) < 24 ? (int) ((1UL << (__ISwxdigit)) >> 8) : (int) ((1UL << (__ISwxdigit)) >> 24)))),
  _ISwspace = ((__ISwspace) < 8 ? (int) ((1UL << (__ISwspace)) << 24) : ((__ISwspace) < 16 ? (int) ((1UL << (__ISwspace)) << 8) : ((__ISwspace) < 24 ? (int) ((1UL << (__ISwspace)) >> 8) : (int) ((1UL << (__ISwspace)) >> 24)))),
  _ISwprint = ((__ISwprint) < 8 ? (int) ((1UL << (__ISwprint)) << 24) : ((__ISwprint) < 16 ? (int) ((1UL << (__ISwprint)) << 8) : ((__ISwprint) < 24 ? (int) ((1UL << (__ISwprint)) >> 8) : (int) ((1UL << (__ISwprint)) >> 24)))),
  _ISwgraph = ((__ISwgraph) < 8 ? (int) ((1UL << (__ISwgraph)) << 24) : ((__ISwgraph) < 16 ? (int) ((1UL << (__ISwgraph)) << 8) : ((__ISwgraph) < 24 ? (int) ((1UL << (__ISwgraph)) >> 8) : (int) ((1UL << (__ISwgraph)) >> 24)))),
  _ISwblank = ((__ISwblank) < 8 ? (int) ((1UL << (__ISwblank)) << 24) : ((__ISwblank) < 16 ? (int) ((1UL << (__ISwblank)) << 8) : ((__ISwblank) < 24 ? (int) ((1UL << (__ISwblank)) >> 8) : (int) ((1UL << (__ISwblank)) >> 24)))),
  _ISwcntrl = ((__ISwcntrl) < 8 ? (int) ((1UL << (__ISwcntrl)) << 24) : ((__ISwcntrl) < 16 ? (int) ((1UL << (__ISwcntrl)) << 8) : ((__ISwcntrl) < 24 ? (int) ((1UL << (__ISwcntrl)) >> 8) : (int) ((1UL << (__ISwcntrl)) >> 24)))),
  _ISwpunct = ((__ISwpunct) < 8 ? (int) ((1UL << (__ISwpunct)) << 24) : ((__ISwpunct) < 16 ? (int) ((1UL << (__ISwpunct)) << 8) : ((__ISwpunct) < 24 ? (int) ((1UL << (__ISwpunct)) >> 8) : (int) ((1UL << (__ISwpunct)) >> 24)))),
  _ISwalnum = ((__ISwalnum) < 8 ? (int) ((1UL << (__ISwalnum)) << 24) : ((__ISwalnum) < 16 ? (int) ((1UL << (__ISwalnum)) << 8) : ((__ISwalnum) < 24 ? (int) ((1UL << (__ISwalnum)) >> 8) : (int) ((1UL << (__ISwalnum)) >> 24))))
};
extern "C" {
extern int iswalnum (wint_t __wc) throw ();
extern int iswalpha (wint_t __wc) throw ();
extern int iswcntrl (wint_t __wc) throw ();
extern int iswdigit (wint_t __wc) throw ();
extern int iswgraph (wint_t __wc) throw ();
extern int iswlower (wint_t __wc) throw ();
extern int iswprint (wint_t __wc) throw ();
extern int iswpunct (wint_t __wc) throw ();
extern int iswspace (wint_t __wc) throw ();
extern int iswupper (wint_t __wc) throw ();
extern int iswxdigit (wint_t __wc) throw ();
extern int iswblank (wint_t __wc) throw ();
extern wctype_t wctype (__const char *__property) throw ();
extern int iswctype (wint_t __wc, wctype_t __desc) throw ();
typedef __const __int32_t *wctrans_t;
extern wint_t towlower (wint_t __wc) throw ();
extern wint_t towupper (wint_t __wc) throw ();
}
extern "C" {
extern wctrans_t wctrans (__const char *__property) throw ();
extern wint_t towctrans (wint_t __wc, wctrans_t __desc) throw ();
extern int iswalnum_l (wint_t __wc, __locale_t __locale) throw ();
extern int iswalpha_l (wint_t __wc, __locale_t __locale) throw ();
extern int iswcntrl_l (wint_t __wc, __locale_t __locale) throw ();
extern int iswdigit_l (wint_t __wc, __locale_t __locale) throw ();
extern int iswgraph_l (wint_t __wc, __locale_t __locale) throw ();
extern int iswlower_l (wint_t __wc, __locale_t __locale) throw ();
extern int iswprint_l (wint_t __wc, __locale_t __locale) throw ();
extern int iswpunct_l (wint_t __wc, __locale_t __locale) throw ();
extern int iswspace_l (wint_t __wc, __locale_t __locale) throw ();
extern int iswupper_l (wint_t __wc, __locale_t __locale) throw ();
extern int iswxdigit_l (wint_t __wc, __locale_t __locale) throw ();
extern int iswblank_l (wint_t __wc, __locale_t __locale) throw ();
extern wctype_t wctype_l (__const char *__property, __locale_t __locale)
     throw ();
extern int iswctype_l (wint_t __wc, wctype_t __desc, __locale_t __locale)
     throw ();
extern wint_t towlower_l (wint_t __wc, __locale_t __locale) throw ();
extern wint_t towupper_l (wint_t __wc, __locale_t __locale) throw ();
extern wctrans_t wctrans_l (__const char *__property, __locale_t __locale)
     throw ();
extern wint_t towctrans_l (wint_t __wc, wctrans_t __desc,
      __locale_t __locale) throw ();
}
namespace std
{
  using ::wint_t;
  using ::wctype_t;
  using ::wctrans_t;
  using ::iswalnum;
  using ::iswalpha;
  using ::iswblank;
  using ::iswcntrl;
  using ::iswctype;
  using ::iswdigit;
  using ::iswgraph;
  using ::iswlower;
  using ::iswprint;
  using ::iswpunct;
  using ::iswspace;
  using ::iswupper;
  using ::iswxdigit;
  using ::towctrans;
  using ::towlower;
  using ::towupper;
  using ::wctrans;
  using ::wctype;
}
namespace std
{
  template<typename _Tv>
    void
    __convert_to_v(const char* __in, _Tv& __out, ios_base::iostate& __err,
     const __c_locale& __cloc);
  template<>
    void
    __convert_to_v(const char*, float&, ios_base::iostate&,
     const __c_locale&);
  template<>
    void
    __convert_to_v(const char*, double&, ios_base::iostate&,
     const __c_locale&);
  template<>
    void
    __convert_to_v(const char*, long double&, ios_base::iostate&,
     const __c_locale&);
  template<typename _CharT, typename _Traits>
    struct __pad
    {
      static void
      _S_pad(ios_base& __io, _CharT __fill, _CharT* __news,
      const _CharT* __olds, const streamsize __newlen,
      const streamsize __oldlen, const bool __num);
    };
  template<typename _CharT>
    _CharT*
    __add_grouping(_CharT* __s, _CharT __sep,
     const char* __gbeg, size_t __gsize,
     const _CharT* __first, const _CharT* __last);
  template<typename _CharT>
    inline
    ostreambuf_iterator<_CharT>
    __write(ostreambuf_iterator<_CharT> __s, const _CharT* __ws, int __len)
    {
      __s._M_put(__ws, __len);
      return __s;
    }
  template<typename _CharT, typename _OutIter>
    inline
    _OutIter
    __write(_OutIter __s, const _CharT* __ws, int __len)
    {
      for (int __j = 0; __j < __len; __j++, ++__s)
 *__s = __ws[__j];
      return __s;
    }
  struct ctype_base
  {
    typedef const int* __to_type;
    typedef unsigned short mask;
    static const mask upper = _ISupper;
    static const mask lower = _ISlower;
    static const mask alpha = _ISalpha;
    static const mask digit = _ISdigit;
    static const mask xdigit = _ISxdigit;
    static const mask space = _ISspace;
    static const mask print = _ISprint;
    static const mask graph = _ISalpha | _ISdigit | _ISpunct;
    static const mask cntrl = _IScntrl;
    static const mask punct = _ISpunct;
    static const mask alnum = _ISalpha | _ISdigit;
  };
  template<typename _CharT>
    class __ctype_abstract_base : public locale::facet, public ctype_base
    {
    public:
      typedef _CharT char_type;
      bool
      is(mask __m, char_type __c) const
      { return this->do_is(__m, __c); }
      const char_type*
      is(const char_type *__lo, const char_type *__hi, mask *__vec) const
      { return this->do_is(__lo, __hi, __vec); }
      const char_type*
      scan_is(mask __m, const char_type* __lo, const char_type* __hi) const
      { return this->do_scan_is(__m, __lo, __hi); }
      const char_type*
      scan_not(mask __m, const char_type* __lo, const char_type* __hi) const
      { return this->do_scan_not(__m, __lo, __hi); }
      char_type
      toupper(char_type __c) const
      { return this->do_toupper(__c); }
      const char_type*
      toupper(char_type *__lo, const char_type* __hi) const
      { return this->do_toupper(__lo, __hi); }
      char_type
      tolower(char_type __c) const
      { return this->do_tolower(__c); }
      const char_type*
      tolower(char_type* __lo, const char_type* __hi) const
      { return this->do_tolower(__lo, __hi); }
      char_type
      widen(char __c) const
      { return this->do_widen(__c); }
      const char*
      widen(const char* __lo, const char* __hi, char_type* __to) const
      { return this->do_widen(__lo, __hi, __to); }
      char
      narrow(char_type __c, char __dfault) const
      { return this->do_narrow(__c, __dfault); }
      const char_type*
      narrow(const char_type* __lo, const char_type* __hi,
       char __dfault, char *__to) const
      { return this->do_narrow(__lo, __hi, __dfault, __to); }
    protected:
      explicit
      __ctype_abstract_base(size_t __refs = 0): facet(__refs) { }
      virtual
      ~__ctype_abstract_base() { }
      virtual bool
      do_is(mask __m, char_type __c) const = 0;
      virtual const char_type*
      do_is(const char_type* __lo, const char_type* __hi,
     mask* __vec) const = 0;
      virtual const char_type*
      do_scan_is(mask __m, const char_type* __lo,
   const char_type* __hi) const = 0;
      virtual const char_type*
      do_scan_not(mask __m, const char_type* __lo,
    const char_type* __hi) const = 0;
      virtual char_type
      do_toupper(char_type) const = 0;
      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const = 0;
      virtual char_type
      do_tolower(char_type) const = 0;
      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const = 0;
      virtual char_type
      do_widen(char) const = 0;
      virtual const char*
      do_widen(const char* __lo, const char* __hi,
        char_type* __dest) const = 0;
      virtual char
      do_narrow(char_type, char __dfault) const = 0;
      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char __dfault, char* __dest) const = 0;
    };
  template<typename _CharT>
    class ctype : public __ctype_abstract_base<_CharT>
    {
    public:
      typedef _CharT char_type;
      typedef typename __ctype_abstract_base<_CharT>::mask mask;
      static locale::id id;
      explicit
      ctype(size_t __refs = 0) : __ctype_abstract_base<_CharT>(__refs) { }
   protected:
      virtual
      ~ctype();
      virtual bool
      do_is(mask __m, char_type __c) const;
      virtual const char_type*
      do_is(const char_type* __lo, const char_type* __hi, mask* __vec) const;
      virtual const char_type*
      do_scan_is(mask __m, const char_type* __lo, const char_type* __hi) const;
      virtual const char_type*
      do_scan_not(mask __m, const char_type* __lo,
    const char_type* __hi) const;
      virtual char_type
      do_toupper(char_type __c) const;
      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const;
      virtual char_type
      do_tolower(char_type __c) const;
      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const;
      virtual char_type
      do_widen(char __c) const;
      virtual const char*
      do_widen(const char* __lo, const char* __hi, char_type* __dest) const;
      virtual char
      do_narrow(char_type, char __dfault) const;
      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char __dfault, char* __dest) const;
    };
  template<typename _CharT>
    locale::id ctype<_CharT>::id;
  template<>
    class ctype<char> : public locale::facet, public ctype_base
    {
    public:
      typedef char char_type;
    protected:
      __c_locale _M_c_locale_ctype;
      bool _M_del;
      __to_type _M_toupper;
      __to_type _M_tolower;
      const mask* _M_table;
      mutable char _M_widen_ok;
      mutable char _M_widen[1 + static_cast<unsigned char>(-1)];
      mutable char _M_narrow[1 + static_cast<unsigned char>(-1)];
      mutable char _M_narrow_ok;
    public:
      static locale::id id;
      static const size_t table_size = 1 + static_cast<unsigned char>(-1);
      explicit
      ctype(const mask* __table = 0, bool __del = false, size_t __refs = 0);
      explicit
      ctype(__c_locale __cloc, const mask* __table = 0, bool __del = false,
     size_t __refs = 0);
      inline bool
      is(mask __m, char __c) const;
      inline const char*
      is(const char* __lo, const char* __hi, mask* __vec) const;
      inline const char*
      scan_is(mask __m, const char* __lo, const char* __hi) const;
      inline const char*
      scan_not(mask __m, const char* __lo, const char* __hi) const;
      char_type
      toupper(char_type __c) const
      { return this->do_toupper(__c); }
      const char_type*
      toupper(char_type *__lo, const char_type* __hi) const
      { return this->do_toupper(__lo, __hi); }
      char_type
      tolower(char_type __c) const
      { return this->do_tolower(__c); }
      const char_type*
      tolower(char_type* __lo, const char_type* __hi) const
      { return this->do_tolower(__lo, __hi); }
      char_type
      widen(char __c) const
      {
 if (_M_widen_ok)
   return _M_widen[static_cast<unsigned char>(__c)];
 this->_M_widen_init();
 return this->do_widen(__c);
      }
      const char*
      widen(const char* __lo, const char* __hi, char_type* __to) const
      {
 if (_M_widen_ok == 1)
   {
     memcpy(__to, __lo, __hi - __lo);
     return __hi;
   }
 if (!_M_widen_ok)
   _M_widen_init();
 return this->do_widen(__lo, __hi, __to);
      }
      char
      narrow(char_type __c, char __dfault) const
      {
 if (_M_narrow[static_cast<unsigned char>(__c)])
   return _M_narrow[static_cast<unsigned char>(__c)];
 const char __t = do_narrow(__c, __dfault);
 if (__t != __dfault)
   _M_narrow[static_cast<unsigned char>(__c)] = __t;
 return __t;
      }
      const char_type*
      narrow(const char_type* __lo, const char_type* __hi,
      char __dfault, char *__to) const
      {
 if (__builtin_expect(_M_narrow_ok == 1, true))
   {
     memcpy(__to, __lo, __hi - __lo);
     return __hi;
   }
 if (!_M_narrow_ok)
   _M_narrow_init();
 return this->do_narrow(__lo, __hi, __dfault, __to);
      }
    protected:
      const mask*
      table() const throw()
      { return _M_table; }
      static const mask*
      classic_table() throw();
      virtual
      ~ctype();
      virtual char_type
      do_toupper(char_type) const;
      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const;
      virtual char_type
      do_tolower(char_type) const;
      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const;
      virtual char_type
      do_widen(char __c) const
      { return __c; }
      virtual const char*
      do_widen(const char* __lo, const char* __hi, char_type* __dest) const
      {
 memcpy(__dest, __lo, __hi - __lo);
 return __hi;
      }
      virtual char
      do_narrow(char_type __c, char) const
      { return __c; }
      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char, char* __dest) const
      {
 memcpy(__dest, __lo, __hi - __lo);
 return __hi;
      }
    private:
      void _M_widen_init() const
      {
 char __tmp[sizeof(_M_widen)];
 for (size_t __i = 0; __i < sizeof(_M_widen); ++__i)
   __tmp[__i] = __i;
 do_widen(__tmp, __tmp + sizeof(__tmp), _M_widen);
 _M_widen_ok = 1;
 if (memcmp(__tmp, _M_widen, sizeof(_M_widen)))
   _M_widen_ok = 2;
      }
      void _M_narrow_init() const
      {
 char __tmp[sizeof(_M_narrow)];
 for (size_t __i = 0; __i < sizeof(_M_narrow); ++__i)
   __tmp[__i] = __i;
 do_narrow(__tmp, __tmp + sizeof(__tmp), 0, _M_narrow);
 _M_narrow_ok = 1;
 if (memcmp(__tmp, _M_narrow, sizeof(_M_narrow)))
   _M_narrow_ok = 2;
 else
   {
     char __c;
     do_narrow(__tmp, __tmp + 1, 1, &__c);
     if (__c == 1)
       _M_narrow_ok = 2;
   }
      }
    };
  template<>
    const ctype<char>&
    use_facet<ctype<char> >(const locale& __loc);
  template<>
    class ctype<wchar_t> : public __ctype_abstract_base<wchar_t>
    {
    public:
      typedef wchar_t char_type;
      typedef wctype_t __wmask_type;
    protected:
      __c_locale _M_c_locale_ctype;
      bool _M_narrow_ok;
      char _M_narrow[128];
      wint_t _M_widen[1 + static_cast<unsigned char>(-1)];
      mask _M_bit[16];
      __wmask_type _M_wmask[16];
    public:
      static locale::id id;
      explicit
      ctype(size_t __refs = 0);
      explicit
      ctype(__c_locale __cloc, size_t __refs = 0);
    protected:
      __wmask_type
      _M_convert_to_wmask(const mask __m) const;
      virtual
      ~ctype();
      virtual bool
      do_is(mask __m, char_type __c) const;
      virtual const char_type*
      do_is(const char_type* __lo, const char_type* __hi, mask* __vec) const;
      virtual const char_type*
      do_scan_is(mask __m, const char_type* __lo, const char_type* __hi) const;
      virtual const char_type*
      do_scan_not(mask __m, const char_type* __lo,
    const char_type* __hi) const;
      virtual char_type
      do_toupper(char_type) const;
      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const;
      virtual char_type
      do_tolower(char_type) const;
      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const;
      virtual char_type
      do_widen(char) const;
      virtual const char*
      do_widen(const char* __lo, const char* __hi, char_type* __dest) const;
      virtual char
      do_narrow(char_type, char __dfault) const;
      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char __dfault, char* __dest) const;
      void
      _M_initialize_ctype();
    };
  template<>
    const ctype<wchar_t>&
    use_facet<ctype<wchar_t> >(const locale& __loc);
  bool
  ctype<char>::
  is(mask __m, char __c) const
  { return _M_table[static_cast<unsigned char>(__c)] & __m; }
  const char*
  ctype<char>::
  is(const char* __low, const char* __high, mask* __vec) const
  {
    while (__low < __high)
      *__vec++ = _M_table[static_cast<unsigned char>(*__low++)];
    return __high;
  }
  const char*
  ctype<char>::
  scan_is(mask __m, const char* __low, const char* __high) const
  {
    while (__low < __high
    && !(_M_table[static_cast<unsigned char>(*__low)] & __m))
      ++__low;
    return __low;
  }
  const char*
  ctype<char>::
  scan_not(mask __m, const char* __low, const char* __high) const
  {
    while (__low < __high
    && (_M_table[static_cast<unsigned char>(*__low)] & __m) != 0)
      ++__low;
    return __low;
  }
  template<typename _CharT>
    class ctype_byname : public ctype<_CharT>
    {
    public:
      typedef _CharT char_type;
      explicit
      ctype_byname(const char* __s, size_t __refs = 0);
    protected:
      virtual
      ~ctype_byname() { };
    };
  template<>
    ctype_byname<char>::ctype_byname(const char*, size_t refs);
  template<>
    ctype_byname<wchar_t>::ctype_byname(const char*, size_t refs);
  class codecvt_base
  {
  public:
    enum result
    {
      ok,
      partial,
      error,
      noconv
    };
  };
  template<typename _InternT, typename _ExternT, typename _StateT>
    class __codecvt_abstract_base
    : public locale::facet, public codecvt_base
    {
    public:
      typedef codecvt_base::result result;
      typedef _InternT intern_type;
      typedef _ExternT extern_type;
      typedef _StateT state_type;
      result
      out(state_type& __state, const intern_type* __from,
   const intern_type* __from_end, const intern_type*& __from_next,
   extern_type* __to, extern_type* __to_end,
   extern_type*& __to_next) const
      {
 return this->do_out(__state, __from, __from_end, __from_next,
       __to, __to_end, __to_next);
      }
      result
      unshift(state_type& __state, extern_type* __to, extern_type* __to_end,
       extern_type*& __to_next) const
      { return this->do_unshift(__state, __to,__to_end,__to_next); }
      result
      in(state_type& __state, const extern_type* __from,
  const extern_type* __from_end, const extern_type*& __from_next,
  intern_type* __to, intern_type* __to_end,
  intern_type*& __to_next) const
      {
 return this->do_in(__state, __from, __from_end, __from_next,
      __to, __to_end, __to_next);
      }
      int
      encoding() const throw()
      { return this->do_encoding(); }
      bool
      always_noconv() const throw()
      { return this->do_always_noconv(); }
      int
      length(state_type& __state, const extern_type* __from,
      const extern_type* __end, size_t __max) const
      { return this->do_length(__state, __from, __end, __max); }
      int
      max_length() const throw()
      { return this->do_max_length(); }
    protected:
      explicit
      __codecvt_abstract_base(size_t __refs = 0) : locale::facet(__refs) { }
      virtual
      ~__codecvt_abstract_base() { }
      virtual result
      do_out(state_type& __state, const intern_type* __from,
      const intern_type* __from_end, const intern_type*& __from_next,
      extern_type* __to, extern_type* __to_end,
      extern_type*& __to_next) const = 0;
      virtual result
      do_unshift(state_type& __state, extern_type* __to,
   extern_type* __to_end, extern_type*& __to_next) const = 0;
      virtual result
      do_in(state_type& __state, const extern_type* __from,
     const extern_type* __from_end, const extern_type*& __from_next,
     intern_type* __to, intern_type* __to_end,
     intern_type*& __to_next) const = 0;
      virtual int
      do_encoding() const throw() = 0;
      virtual bool
      do_always_noconv() const throw() = 0;
      virtual int
      do_length(state_type&, const extern_type* __from,
  const extern_type* __end, size_t __max) const = 0;
      virtual int
      do_max_length() const throw() = 0;
    };
  template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt
    : public __codecvt_abstract_base<_InternT, _ExternT, _StateT>
    {
    public:
      typedef codecvt_base::result result;
      typedef _InternT intern_type;
      typedef _ExternT extern_type;
      typedef _StateT state_type;
    protected:
      __c_locale _M_c_locale_codecvt;
    public:
      static locale::id id;
      explicit
      codecvt(size_t __refs = 0)
      : __codecvt_abstract_base<_InternT, _ExternT, _StateT> (__refs) { }
      explicit
      codecvt(__c_locale __cloc, size_t __refs = 0);
    protected:
      virtual
      ~codecvt() { }
      virtual result
      do_out(state_type& __state, const intern_type* __from,
      const intern_type* __from_end, const intern_type*& __from_next,
      extern_type* __to, extern_type* __to_end,
      extern_type*& __to_next) const;
      virtual result
      do_unshift(state_type& __state, extern_type* __to,
   extern_type* __to_end, extern_type*& __to_next) const;
      virtual result
      do_in(state_type& __state, const extern_type* __from,
     const extern_type* __from_end, const extern_type*& __from_next,
     intern_type* __to, intern_type* __to_end,
     intern_type*& __to_next) const;
      virtual int
      do_encoding() const throw();
      virtual bool
      do_always_noconv() const throw();
      virtual int
      do_length(state_type&, const extern_type* __from,
  const extern_type* __end, size_t __max) const;
      virtual int
      do_max_length() const throw();
    };
  template<typename _InternT, typename _ExternT, typename _StateT>
    locale::id codecvt<_InternT, _ExternT, _StateT>::id;
  template<>
    class codecvt<char, char, mbstate_t>
    : public __codecvt_abstract_base<char, char, mbstate_t>
    {
    public:
      typedef char intern_type;
      typedef char extern_type;
      typedef mbstate_t state_type;
    protected:
      __c_locale _M_c_locale_codecvt;
    public:
      static locale::id id;
      explicit
      codecvt(size_t __refs = 0);
      explicit
      codecvt(__c_locale __cloc, size_t __refs = 0);
    protected:
      virtual
      ~codecvt();
      virtual result
      do_out(state_type& __state, const intern_type* __from,
      const intern_type* __from_end, const intern_type*& __from_next,
      extern_type* __to, extern_type* __to_end,
      extern_type*& __to_next) const;
      virtual result
      do_unshift(state_type& __state, extern_type* __to,
   extern_type* __to_end, extern_type*& __to_next) const;
      virtual result
      do_in(state_type& __state, const extern_type* __from,
     const extern_type* __from_end, const extern_type*& __from_next,
     intern_type* __to, intern_type* __to_end,
     intern_type*& __to_next) const;
      virtual int
      do_encoding() const throw();
      virtual bool
      do_always_noconv() const throw();
      virtual int
      do_length(state_type&, const extern_type* __from,
  const extern_type* __end, size_t __max) const;
      virtual int
      do_max_length() const throw();
  };
  template<>
    class codecvt<wchar_t, char, mbstate_t>
    : public __codecvt_abstract_base<wchar_t, char, mbstate_t>
    {
    public:
      typedef wchar_t intern_type;
      typedef char extern_type;
      typedef mbstate_t state_type;
    protected:
      __c_locale _M_c_locale_codecvt;
    public:
      static locale::id id;
      explicit
      codecvt(size_t __refs = 0);
      explicit
      codecvt(__c_locale __cloc, size_t __refs = 0);
    protected:
      virtual
      ~codecvt();
      virtual result
      do_out(state_type& __state, const intern_type* __from,
      const intern_type* __from_end, const intern_type*& __from_next,
      extern_type* __to, extern_type* __to_end,
      extern_type*& __to_next) const;
      virtual result
      do_unshift(state_type& __state,
   extern_type* __to, extern_type* __to_end,
   extern_type*& __to_next) const;
      virtual result
      do_in(state_type& __state,
      const extern_type* __from, const extern_type* __from_end,
      const extern_type*& __from_next,
      intern_type* __to, intern_type* __to_end,
      intern_type*& __to_next) const;
      virtual
      int do_encoding() const throw();
      virtual
      bool do_always_noconv() const throw();
      virtual
      int do_length(state_type&, const extern_type* __from,
      const extern_type* __end, size_t __max) const;
      virtual int
      do_max_length() const throw();
    };
  template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt_byname : public codecvt<_InternT, _ExternT, _StateT>
    {
    public:
      explicit
      codecvt_byname(const char* __s, size_t __refs = 0)
      : codecvt<_InternT, _ExternT, _StateT>(__refs)
      {
 if (std::strcmp(__s, "C") != 0 && std::strcmp(__s, "POSIX") != 0)
   {
     this->_S_destroy_c_locale(this->_M_c_locale_codecvt);
     this->_S_create_c_locale(this->_M_c_locale_codecvt, __s);
   }
      }
    protected:
      virtual
      ~codecvt_byname() { }
    };
  class __num_base
  {
  public:
    enum
      {
        _S_ominus,
        _S_oplus,
        _S_ox,
        _S_oX,
        _S_odigits,
        _S_odigits_end = _S_odigits + 16,
        _S_oudigits = _S_odigits_end,
        _S_oudigits_end = _S_oudigits + 16,
        _S_oe = _S_odigits + 14,
        _S_oE = _S_oudigits + 14,
 _S_oend = _S_oudigits_end
      };
    static const char* _S_atoms_out;
    static const char* _S_atoms_in;
    enum
    {
      _S_iminus,
      _S_iplus,
      _S_ix,
      _S_iX,
      _S_izero,
      _S_ie = _S_izero + 14,
      _S_iE = _S_izero + 20,
      _S_iend = 26
    };
    static void
    _S_format_float(const ios_base& __io, char* __fptr, char __mod);
  };
  template<typename _CharT>
    struct __numpunct_cache : public locale::facet
    {
      const char* _M_grouping;
      size_t _M_grouping_size;
      bool _M_use_grouping;
      const _CharT* _M_truename;
      size_t _M_truename_size;
      const _CharT* _M_falsename;
      size_t _M_falsename_size;
      _CharT _M_decimal_point;
      _CharT _M_thousands_sep;
      _CharT _M_atoms_out[__num_base::_S_oend];
      _CharT _M_atoms_in[__num_base::_S_iend];
      bool _M_allocated;
      __numpunct_cache(size_t __refs = 0) : facet(__refs),
      _M_grouping(__null), _M_grouping_size(0), _M_use_grouping(false),
      _M_truename(__null), _M_truename_size(0), _M_falsename(__null),
      _M_falsename_size(0), _M_decimal_point(_CharT()),
      _M_thousands_sep(_CharT()), _M_allocated(false)
      { }
      ~__numpunct_cache();
      void
      _M_cache(const locale& __loc);
    private:
      __numpunct_cache&
      operator=(const __numpunct_cache&);
      explicit
      __numpunct_cache(const __numpunct_cache&);
    };
  template<typename _CharT>
    __numpunct_cache<_CharT>::~__numpunct_cache()
    {
      if (_M_allocated)
 {
   delete [] _M_grouping;
   delete [] _M_truename;
   delete [] _M_falsename;
 }
    }
  template<typename _CharT>
    class numpunct : public locale::facet
    {
    public:
      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;
      typedef __numpunct_cache<_CharT> __cache_type;
    protected:
      __cache_type* _M_data;
    public:
      static locale::id id;
      explicit
      numpunct(size_t __refs = 0) : facet(__refs), _M_data(__null)
      { _M_initialize_numpunct(); }
      explicit
      numpunct(__cache_type* __cache, size_t __refs = 0)
      : facet(__refs), _M_data(__cache)
      { _M_initialize_numpunct(); }
      explicit
      numpunct(__c_locale __cloc, size_t __refs = 0)
      : facet(__refs), _M_data(__null)
      { _M_initialize_numpunct(__cloc); }
      char_type
      decimal_point() const
      { return this->do_decimal_point(); }
      char_type
      thousands_sep() const
      { return this->do_thousands_sep(); }
      string
      grouping() const
      { return this->do_grouping(); }
      string_type
      truename() const
      { return this->do_truename(); }
      string_type
      falsename() const
      { return this->do_falsename(); }
    protected:
      virtual
      ~numpunct();
      virtual char_type
      do_decimal_point() const
      { return _M_data->_M_decimal_point; }
      virtual char_type
      do_thousands_sep() const
      { return _M_data->_M_thousands_sep; }
      virtual string
      do_grouping() const
      { return _M_data->_M_grouping; }
      virtual string_type
      do_truename() const
      { return _M_data->_M_truename; }
      virtual string_type
      do_falsename() const
      { return _M_data->_M_falsename; }
      void
      _M_initialize_numpunct(__c_locale __cloc = __null);
    };
  template<typename _CharT>
    locale::id numpunct<_CharT>::id;
  template<>
    numpunct<char>::~numpunct();
  template<>
    void
    numpunct<char>::_M_initialize_numpunct(__c_locale __cloc);
  template<>
    numpunct<wchar_t>::~numpunct();
  template<>
    void
    numpunct<wchar_t>::_M_initialize_numpunct(__c_locale __cloc);
  template<typename _CharT>
    class numpunct_byname : public numpunct<_CharT>
    {
    public:
      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;
      explicit
      numpunct_byname(const char* __s, size_t __refs = 0)
      : numpunct<_CharT>(__refs)
      {
 if (std::strcmp(__s, "C") != 0 && std::strcmp(__s, "POSIX") != 0)
   {
     __c_locale __tmp;
     this->_S_create_c_locale(__tmp, __s);
     this->_M_initialize_numpunct(__tmp);
     this->_S_destroy_c_locale(__tmp);
   }
      }
    protected:
      virtual
      ~numpunct_byname() { }
    };
  template<typename _CharT, typename _InIter>
    class num_get : public locale::facet
    {
    public:
      typedef _CharT char_type;
      typedef _InIter iter_type;
      static locale::id id;
      explicit
      num_get(size_t __refs = 0) : facet(__refs) { }
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, bool& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned short& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned int& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, long long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned long long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, float& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, double& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, long double& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, void*& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }
    protected:
      virtual ~num_get() { }
      iter_type
      _M_extract_float(iter_type, iter_type, ios_base&, ios_base::iostate&,
         string& __xtrc) const;
      template<typename _ValueT>
        iter_type
        _M_extract_int(iter_type, iter_type, ios_base&, ios_base::iostate&,
         _ValueT& __v) const;
      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&, bool&) const;
      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&, long&) const;
      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,
       unsigned short&) const;
      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,
      unsigned int&) const;
      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,
      unsigned long&) const;
      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,
      long long&) const;
      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,
      unsigned long long&) const;
      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,
      float&) const;
      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,
      double&) const;
      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,
      long double&) const;
      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,
      void*&) const;
    };
  template<typename _CharT, typename _InIter>
    locale::id num_get<_CharT, _InIter>::id;
  template<typename _CharT, typename _OutIter>
    class num_put : public locale::facet
    {
    public:
      typedef _CharT char_type;
      typedef _OutIter iter_type;
      static locale::id id;
      explicit
      num_put(size_t __refs = 0) : facet(__refs) { }
      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill, bool __v) const
      { return this->do_put(__s, __f, __fill, __v); }
      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill, long __v) const
      { return this->do_put(__s, __f, __fill, __v); }
      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill,
   unsigned long __v) const
      { return this->do_put(__s, __f, __fill, __v); }
      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill, long long __v) const
      { return this->do_put(__s, __f, __fill, __v); }
      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill,
   unsigned long long __v) const
      { return this->do_put(__s, __f, __fill, __v); }
      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill, double __v) const
      { return this->do_put(__s, __f, __fill, __v); }
      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill,
   long double __v) const
      { return this->do_put(__s, __f, __fill, __v); }
      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill,
   const void* __v) const
      { return this->do_put(__s, __f, __fill, __v); }
    protected:
      template<typename _ValueT>
        iter_type
        _M_insert_float(iter_type, ios_base& __io, char_type __fill,
   char __mod, _ValueT __v) const;
      void
      _M_group_float(const char* __grouping, size_t __grouping_size,
       char_type __sep, const char_type* __p, char_type* __new,
       char_type* __cs, int& __len) const;
      template<typename _ValueT>
        iter_type
        _M_insert_int(iter_type, ios_base& __io, char_type __fill,
        _ValueT __v) const;
      void
      _M_group_int(const char* __grouping, size_t __grouping_size,
     char_type __sep, ios_base& __io, char_type* __new,
     char_type* __cs, int& __len) const;
      void
      _M_pad(char_type __fill, streamsize __w, ios_base& __io,
      char_type* __new, const char_type* __cs, int& __len) const;
      virtual
      ~num_put() { };
      virtual iter_type
      do_put(iter_type, ios_base&, char_type __fill, bool __v) const;
      virtual iter_type
      do_put(iter_type, ios_base&, char_type __fill, long __v) const;
      virtual iter_type
      do_put(iter_type, ios_base&, char_type __fill, unsigned long) const;
      virtual iter_type
      do_put(iter_type, ios_base&, char_type __fill, long long __v) const;
      virtual iter_type
      do_put(iter_type, ios_base&, char_type __fill, unsigned long long) const;
      virtual iter_type
      do_put(iter_type, ios_base&, char_type __fill, double __v) const;
      virtual iter_type
      do_put(iter_type, ios_base&, char_type __fill, long double __v) const;
      virtual iter_type
      do_put(iter_type, ios_base&, char_type __fill, const void* __v) const;
    };
  template <typename _CharT, typename _OutIter>
    locale::id num_put<_CharT, _OutIter>::id;
  template<typename _CharT>
    class collate : public locale::facet
    {
    public:
      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;
    protected:
      __c_locale _M_c_locale_collate;
    public:
      static locale::id id;
      explicit
      collate(size_t __refs = 0)
      : facet(__refs), _M_c_locale_collate(_S_get_c_locale())
      { }
      explicit
      collate(__c_locale __cloc, size_t __refs = 0)
      : facet(__refs), _M_c_locale_collate(_S_clone_c_locale(__cloc))
      { }
      int
      compare(const _CharT* __lo1, const _CharT* __hi1,
       const _CharT* __lo2, const _CharT* __hi2) const
      { return this->do_compare(__lo1, __hi1, __lo2, __hi2); }
      string_type
      transform(const _CharT* __lo, const _CharT* __hi) const
      { return this->do_transform(__lo, __hi); }
      long
      hash(const _CharT* __lo, const _CharT* __hi) const
      { return this->do_hash(__lo, __hi); }
      int
      _M_compare(const _CharT*, const _CharT*) const;
      size_t
      _M_transform(_CharT*, const _CharT*, size_t) const;
  protected:
      virtual
      ~collate()
      { _S_destroy_c_locale(_M_c_locale_collate); }
      virtual int
      do_compare(const _CharT* __lo1, const _CharT* __hi1,
   const _CharT* __lo2, const _CharT* __hi2) const;
      virtual string_type
      do_transform(const _CharT* __lo, const _CharT* __hi) const;
      virtual long
      do_hash(const _CharT* __lo, const _CharT* __hi) const;
    };
  template<typename _CharT>
    locale::id collate<_CharT>::id;
  template<>
    int
    collate<char>::_M_compare(const char*, const char*) const;
  template<>
    size_t
    collate<char>::_M_transform(char*, const char*, size_t) const;
  template<>
    int
    collate<wchar_t>::_M_compare(const wchar_t*, const wchar_t*) const;
  template<>
    size_t
    collate<wchar_t>::_M_transform(wchar_t*, const wchar_t*, size_t) const;
  template<typename _CharT>
    class collate_byname : public collate<_CharT>
    {
    public:
      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;
      explicit
      collate_byname(const char* __s, size_t __refs = 0)
      : collate<_CharT>(__refs)
      {
 if (std::strcmp(__s, "C") != 0 && std::strcmp(__s, "POSIX") != 0)
   {
     this->_S_destroy_c_locale(this->_M_c_locale_collate);
     this->_S_create_c_locale(this->_M_c_locale_collate, __s);
   }
      }
    protected:
      virtual
      ~collate_byname() { }
    };
  class time_base
  {
  public:
    enum dateorder { no_order, dmy, mdy, ymd, ydm };
  };
  template<typename _CharT>
    struct __timepunct_cache : public locale::facet
    {
      static const _CharT* _S_timezones[14];
      const _CharT* _M_date_format;
      const _CharT* _M_date_era_format;
      const _CharT* _M_time_format;
      const _CharT* _M_time_era_format;
      const _CharT* _M_date_time_format;
      const _CharT* _M_date_time_era_format;
      const _CharT* _M_am;
      const _CharT* _M_pm;
      const _CharT* _M_am_pm_format;
      const _CharT* _M_day1;
      const _CharT* _M_day2;
      const _CharT* _M_day3;
      const _CharT* _M_day4;
      const _CharT* _M_day5;
      const _CharT* _M_day6;
      const _CharT* _M_day7;
      const _CharT* _M_aday1;
      const _CharT* _M_aday2;
      const _CharT* _M_aday3;
      const _CharT* _M_aday4;
      const _CharT* _M_aday5;
      const _CharT* _M_aday6;
      const _CharT* _M_aday7;
      const _CharT* _M_month01;
      const _CharT* _M_month02;
      const _CharT* _M_month03;
      const _CharT* _M_month04;
      const _CharT* _M_month05;
      const _CharT* _M_month06;
      const _CharT* _M_month07;
      const _CharT* _M_month08;
      const _CharT* _M_month09;
      const _CharT* _M_month10;
      const _CharT* _M_month11;
      const _CharT* _M_month12;
      const _CharT* _M_amonth01;
      const _CharT* _M_amonth02;
      const _CharT* _M_amonth03;
      const _CharT* _M_amonth04;
      const _CharT* _M_amonth05;
      const _CharT* _M_amonth06;
      const _CharT* _M_amonth07;
      const _CharT* _M_amonth08;
      const _CharT* _M_amonth09;
      const _CharT* _M_amonth10;
      const _CharT* _M_amonth11;
      const _CharT* _M_amonth12;
      bool _M_allocated;
      __timepunct_cache(size_t __refs = 0) : facet(__refs),
      _M_date_format(__null), _M_date_era_format(__null), _M_time_format(__null),
      _M_time_era_format(__null), _M_date_time_format(__null),
      _M_date_time_era_format(__null), _M_am(__null), _M_pm(__null),
      _M_am_pm_format(__null), _M_day1(__null), _M_day2(__null), _M_day3(__null),
      _M_day4(__null), _M_day5(__null), _M_day6(__null), _M_day7(__null),
      _M_aday1(__null), _M_aday2(__null), _M_aday3(__null), _M_aday4(__null),
      _M_aday5(__null), _M_aday6(__null), _M_aday7(__null), _M_month01(__null),
      _M_month02(__null), _M_month03(__null), _M_month04(__null), _M_month05(__null),
      _M_month06(__null), _M_month07(__null), _M_month08(__null), _M_month09(__null),
      _M_month10(__null), _M_month11(__null), _M_month12(__null), _M_amonth01(__null),
      _M_amonth02(__null), _M_amonth03(__null), _M_amonth04(__null),
      _M_amonth05(__null), _M_amonth06(__null), _M_amonth07(__null),
      _M_amonth08(__null), _M_amonth09(__null), _M_amonth10(__null),
      _M_amonth11(__null), _M_amonth12(__null), _M_allocated(false)
      { }
      ~__timepunct_cache();
      void
      _M_cache(const locale& __loc);
    private:
      __timepunct_cache&
      operator=(const __timepunct_cache&);
      explicit
      __timepunct_cache(const __timepunct_cache&);
    };
  template<typename _CharT>
    __timepunct_cache<_CharT>::~__timepunct_cache()
    {
      if (_M_allocated)
 {
 }
    }
  template<>
    const char*
    __timepunct_cache<char>::_S_timezones[14];
  template<>
    const wchar_t*
    __timepunct_cache<wchar_t>::_S_timezones[14];
  template<typename _CharT>
    const _CharT* __timepunct_cache<_CharT>::_S_timezones[14];
  template<typename _CharT>
    class __timepunct : public locale::facet
    {
    public:
      typedef _CharT __char_type;
      typedef basic_string<_CharT> __string_type;
      typedef __timepunct_cache<_CharT> __cache_type;
    protected:
      __cache_type* _M_data;
      __c_locale _M_c_locale_timepunct;
      const char* _M_name_timepunct;
    public:
      static locale::id id;
      explicit
      __timepunct(size_t __refs = 0);
      explicit
      __timepunct(__cache_type* __cache, size_t __refs = 0);
      explicit
      __timepunct(__c_locale __cloc, const char* __s, size_t __refs = 0);
      void
      _M_put(_CharT* __s, size_t __maxlen, const _CharT* __format,
      const tm* __tm) const;
      void
      _M_date_formats(const _CharT** __date) const
      {
 __date[0] = _M_data->_M_date_format;
 __date[1] = _M_data->_M_date_era_format;
      }
      void
      _M_time_formats(const _CharT** __time) const
      {
 __time[0] = _M_data->_M_time_format;
 __time[1] = _M_data->_M_time_era_format;
      }
      void
      _M_date_time_formats(const _CharT** __dt) const
      {
 __dt[0] = _M_data->_M_date_time_format;
 __dt[1] = _M_data->_M_date_time_era_format;
      }
      void
      _M_am_pm_format(const _CharT* __ampm) const
      { __ampm = _M_data->_M_am_pm_format; }
      void
      _M_am_pm(const _CharT** __ampm) const
      {
 __ampm[0] = _M_data->_M_am;
 __ampm[1] = _M_data->_M_pm;
      }
      void
      _M_days(const _CharT** __days) const
      {
 __days[0] = _M_data->_M_day1;
 __days[1] = _M_data->_M_day2;
 __days[2] = _M_data->_M_day3;
 __days[3] = _M_data->_M_day4;
 __days[4] = _M_data->_M_day5;
 __days[5] = _M_data->_M_day6;
 __days[6] = _M_data->_M_day7;
      }
      void
      _M_days_abbreviated(const _CharT** __days) const
      {
 __days[0] = _M_data->_M_aday1;
 __days[1] = _M_data->_M_aday2;
 __days[2] = _M_data->_M_aday3;
 __days[3] = _M_data->_M_aday4;
 __days[4] = _M_data->_M_aday5;
 __days[5] = _M_data->_M_aday6;
 __days[6] = _M_data->_M_aday7;
      }
      void
      _M_months(const _CharT** __months) const
      {
 __months[0] = _M_data->_M_month01;
 __months[1] = _M_data->_M_month02;
 __months[2] = _M_data->_M_month03;
 __months[3] = _M_data->_M_month04;
 __months[4] = _M_data->_M_month05;
 __months[5] = _M_data->_M_month06;
 __months[6] = _M_data->_M_month07;
 __months[7] = _M_data->_M_month08;
 __months[8] = _M_data->_M_month09;
 __months[9] = _M_data->_M_month10;
 __months[10] = _M_data->_M_month11;
 __months[11] = _M_data->_M_month12;
      }
      void
      _M_months_abbreviated(const _CharT** __months) const
      {
 __months[0] = _M_data->_M_amonth01;
 __months[1] = _M_data->_M_amonth02;
 __months[2] = _M_data->_M_amonth03;
 __months[3] = _M_data->_M_amonth04;
 __months[4] = _M_data->_M_amonth05;
 __months[5] = _M_data->_M_amonth06;
 __months[6] = _M_data->_M_amonth07;
 __months[7] = _M_data->_M_amonth08;
 __months[8] = _M_data->_M_amonth09;
 __months[9] = _M_data->_M_amonth10;
 __months[10] = _M_data->_M_amonth11;
 __months[11] = _M_data->_M_amonth12;
      }
    protected:
      virtual
      ~__timepunct();
      void
      _M_initialize_timepunct(__c_locale __cloc = __null);
    };
  template<typename _CharT>
    locale::id __timepunct<_CharT>::id;
  template<>
    void
    __timepunct<char>::_M_initialize_timepunct(__c_locale __cloc);
  template<>
    void
    __timepunct<char>::_M_put(char*, size_t, const char*, const tm*) const;
  template<>
    void
    __timepunct<wchar_t>::_M_initialize_timepunct(__c_locale __cloc);
  template<>
    void
    __timepunct<wchar_t>::_M_put(wchar_t*, size_t, const wchar_t*,
     const tm*) const;
  template<typename _CharT>
    __timepunct<_CharT>::__timepunct(size_t __refs)
    : facet(__refs), _M_data(__null), _M_c_locale_timepunct(__null),
      _M_name_timepunct(_S_get_c_name())
    { _M_initialize_timepunct(); }
  template<typename _CharT>
    __timepunct<_CharT>::__timepunct(__cache_type* __cache, size_t __refs)
    : facet(__refs), _M_data(__cache), _M_c_locale_timepunct(__null),
      _M_name_timepunct(_S_get_c_name())
    { _M_initialize_timepunct(); }
  template<typename _CharT>
    __timepunct<_CharT>::__timepunct(__c_locale __cloc, const char* __s,
         size_t __refs)
    : facet(__refs), _M_data(__null), _M_c_locale_timepunct(__null),
      _M_name_timepunct(__null)
    {
      const size_t __len = std::strlen(__s) + 1;
      char* __tmp = new char[__len];
      std::memcpy(__tmp, __s, __len);
      _M_name_timepunct = __tmp;
      try
 { _M_initialize_timepunct(__cloc); }
      catch(...)
 {
   delete [] _M_name_timepunct;
   throw;
 }
    }
  template<typename _CharT>
    __timepunct<_CharT>::~__timepunct()
    {
      if (_M_name_timepunct != _S_get_c_name())
 delete [] _M_name_timepunct;
      delete _M_data;
      _S_destroy_c_locale(_M_c_locale_timepunct);
    }
  template<typename _CharT, typename _InIter>
    class time_get : public locale::facet, public time_base
    {
    public:
      typedef _CharT char_type;
      typedef _InIter iter_type;
      typedef basic_string<_CharT> __string_type;
      static locale::id id;
      explicit
      time_get(size_t __refs = 0)
      : facet (__refs) { }
      dateorder
      date_order() const
      { return this->do_date_order(); }
      iter_type
      get_time(iter_type __beg, iter_type __end, ios_base& __io,
        ios_base::iostate& __err, tm* __tm) const
      { return this->do_get_time(__beg, __end, __io, __err, __tm); }
      iter_type
      get_date(iter_type __beg, iter_type __end, ios_base& __io,
        ios_base::iostate& __err, tm* __tm) const
      { return this->do_get_date(__beg, __end, __io, __err, __tm); }
      iter_type
      get_weekday(iter_type __beg, iter_type __end, ios_base& __io,
    ios_base::iostate& __err, tm* __tm) const
      { return this->do_get_weekday(__beg, __end, __io, __err, __tm); }
      iter_type
      get_monthname(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, tm* __tm) const
      { return this->do_get_monthname(__beg, __end, __io, __err, __tm); }
      iter_type
      get_year(iter_type __beg, iter_type __end, ios_base& __io,
        ios_base::iostate& __err, tm* __tm) const
      { return this->do_get_year(__beg, __end, __io, __err, __tm); }
    protected:
      virtual
      ~time_get() { }
      virtual dateorder
      do_date_order() const;
      virtual iter_type
      do_get_time(iter_type __beg, iter_type __end, ios_base& __io,
    ios_base::iostate& __err, tm* __tm) const;
      virtual iter_type
      do_get_date(iter_type __beg, iter_type __end, ios_base& __io,
    ios_base::iostate& __err, tm* __tm) const;
      virtual iter_type
      do_get_weekday(iter_type __beg, iter_type __end, ios_base&,
       ios_base::iostate& __err, tm* __tm) const;
      virtual iter_type
      do_get_monthname(iter_type __beg, iter_type __end, ios_base&,
         ios_base::iostate& __err, tm* __tm) const;
      virtual iter_type
      do_get_year(iter_type __beg, iter_type __end, ios_base& __io,
    ios_base::iostate& __err, tm* __tm) const;
      iter_type
      _M_extract_num(iter_type __beg, iter_type __end, int& __member,
       int __min, int __max, size_t __len,
       ios_base& __io, ios_base::iostate& __err) const;
      iter_type
      _M_extract_name(iter_type __beg, iter_type __end, int& __member,
        const _CharT** __names, size_t __indexlen,
        ios_base& __io, ios_base::iostate& __err) const;
      iter_type
      _M_extract_via_format(iter_type __beg, iter_type __end, ios_base& __io,
       ios_base::iostate& __err, tm* __tm,
       const _CharT* __format) const;
    };
  template<typename _CharT, typename _InIter>
    locale::id time_get<_CharT, _InIter>::id;
  template<typename _CharT, typename _InIter>
    class time_get_byname : public time_get<_CharT, _InIter>
    {
    public:
      typedef _CharT char_type;
      typedef _InIter iter_type;
      explicit
      time_get_byname(const char*, size_t __refs = 0)
      : time_get<_CharT, _InIter>(__refs) { }
    protected:
      virtual
      ~time_get_byname() { }
    };
  template<typename _CharT, typename _OutIter>
    class time_put : public locale::facet
    {
    public:
      typedef _CharT char_type;
      typedef _OutIter iter_type;
      static locale::id id;
      explicit
      time_put(size_t __refs = 0)
      : facet(__refs) { }
      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill, const tm* __tm,
   const _CharT* __beg, const _CharT* __end) const;
      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill,
   const tm* __tm, char __format, char __mod = 0) const
      { return this->do_put(__s, __io, __fill, __tm, __format, __mod); }
    protected:
      virtual
      ~time_put()
      { }
      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill, const tm* __tm,
      char __format, char __mod) const;
    };
  template<typename _CharT, typename _OutIter>
    locale::id time_put<_CharT, _OutIter>::id;
  template<typename _CharT, typename _OutIter>
    class time_put_byname : public time_put<_CharT, _OutIter>
    {
    public:
      typedef _CharT char_type;
      typedef _OutIter iter_type;
      explicit
      time_put_byname(const char*, size_t __refs = 0)
      : time_put<_CharT, _OutIter>(__refs)
      { };
    protected:
      virtual
      ~time_put_byname() { }
    };
  class money_base
  {
  public:
    enum part { none, space, symbol, sign, value };
    struct pattern { char field[4]; };
    static const pattern _S_default_pattern;
    enum
    {
      _S_minus,
      _S_zero,
      _S_end = 11
    };
    static const char* _S_atoms;
    static pattern
    _S_construct_pattern(char __precedes, char __space, char __posn);
  };
  template<typename _CharT, bool _Intl>
    struct __moneypunct_cache : public locale::facet
    {
      const char* _M_grouping;
      size_t _M_grouping_size;
      bool _M_use_grouping;
      _CharT _M_decimal_point;
      _CharT _M_thousands_sep;
      const _CharT* _M_curr_symbol;
      size_t _M_curr_symbol_size;
      const _CharT* _M_positive_sign;
      size_t _M_positive_sign_size;
      const _CharT* _M_negative_sign;
      size_t _M_negative_sign_size;
      int _M_frac_digits;
      money_base::pattern _M_pos_format;
      money_base::pattern _M_neg_format;
      _CharT _M_atoms[money_base::_S_end];
      bool _M_allocated;
      __moneypunct_cache(size_t __refs = 0) : facet(__refs),
      _M_grouping(__null), _M_grouping_size(0), _M_use_grouping(false),
      _M_decimal_point(_CharT()), _M_thousands_sep(_CharT()),
      _M_curr_symbol(__null), _M_curr_symbol_size(0),
      _M_positive_sign(__null), _M_positive_sign_size(0),
      _M_negative_sign(__null), _M_negative_sign_size(0),
      _M_frac_digits(0),
      _M_pos_format(money_base::pattern()),
      _M_neg_format(money_base::pattern()), _M_allocated(false)
      { }
      ~__moneypunct_cache();
      void
      _M_cache(const locale& __loc);
    private:
      __moneypunct_cache&
      operator=(const __moneypunct_cache&);
      explicit
      __moneypunct_cache(const __moneypunct_cache&);
    };
  template<typename _CharT, bool _Intl>
    __moneypunct_cache<_CharT, _Intl>::~__moneypunct_cache()
    {
      if (_M_allocated)
 {
   delete [] _M_grouping;
   delete [] _M_curr_symbol;
   delete [] _M_positive_sign;
   delete [] _M_negative_sign;
 }
    }
  template<typename _CharT, bool _Intl>
    class moneypunct : public locale::facet, public money_base
    {
    public:
      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;
      typedef __moneypunct_cache<_CharT, _Intl> __cache_type;
    private:
      __cache_type* _M_data;
    public:
      static const bool intl = _Intl;
      static locale::id id;
      explicit
      moneypunct(size_t __refs = 0) : facet(__refs), _M_data(__null)
      { _M_initialize_moneypunct(); }
      explicit
      moneypunct(__cache_type* __cache, size_t __refs = 0)
      : facet(__refs), _M_data(__cache)
      { _M_initialize_moneypunct(); }
      explicit
      moneypunct(__c_locale __cloc, const char* __s, size_t __refs = 0)
      : facet(__refs), _M_data(__null)
      { _M_initialize_moneypunct(__cloc, __s); }
      char_type
      decimal_point() const
      { return this->do_decimal_point(); }
      char_type
      thousands_sep() const
      { return this->do_thousands_sep(); }
      string
      grouping() const
      { return this->do_grouping(); }
      string_type
      curr_symbol() const
      { return this->do_curr_symbol(); }
      string_type
      positive_sign() const
      { return this->do_positive_sign(); }
      string_type
      negative_sign() const
      { return this->do_negative_sign(); }
      int
      frac_digits() const
      { return this->do_frac_digits(); }
      pattern
      pos_format() const
      { return this->do_pos_format(); }
      pattern
      neg_format() const
      { return this->do_neg_format(); }
    protected:
      virtual
      ~moneypunct();
      virtual char_type
      do_decimal_point() const
      { return _M_data->_M_decimal_point; }
      virtual char_type
      do_thousands_sep() const
      { return _M_data->_M_thousands_sep; }
      virtual string
      do_grouping() const
      { return _M_data->_M_grouping; }
      virtual string_type
      do_curr_symbol() const
      { return _M_data->_M_curr_symbol; }
      virtual string_type
      do_positive_sign() const
      { return _M_data->_M_positive_sign; }
      virtual string_type
      do_negative_sign() const
      { return _M_data->_M_negative_sign; }
      virtual int
      do_frac_digits() const
      { return _M_data->_M_frac_digits; }
      virtual pattern
      do_pos_format() const
      { return _M_data->_M_pos_format; }
      virtual pattern
      do_neg_format() const
      { return _M_data->_M_neg_format; }
       void
       _M_initialize_moneypunct(__c_locale __cloc = __null,
    const char* __name = __null);
    };
  template<typename _CharT, bool _Intl>
    locale::id moneypunct<_CharT, _Intl>::id;
  template<typename _CharT, bool _Intl>
    const bool moneypunct<_CharT, _Intl>::intl;
  template<>
    moneypunct<char, true>::~moneypunct();
  template<>
    moneypunct<char, false>::~moneypunct();
  template<>
    void
    moneypunct<char, true>::_M_initialize_moneypunct(__c_locale, const char*);
  template<>
    void
    moneypunct<char, false>::_M_initialize_moneypunct(__c_locale, const char*);
  template<>
    moneypunct<wchar_t, true>::~moneypunct();
  template<>
    moneypunct<wchar_t, false>::~moneypunct();
  template<>
    void
    moneypunct<wchar_t, true>::_M_initialize_moneypunct(__c_locale,
       const char*);
  template<>
    void
    moneypunct<wchar_t, false>::_M_initialize_moneypunct(__c_locale,
        const char*);
  template<typename _CharT, bool _Intl>
    class moneypunct_byname : public moneypunct<_CharT, _Intl>
    {
    public:
      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;
      static const bool intl = _Intl;
      explicit
      moneypunct_byname(const char* __s, size_t __refs = 0)
      : moneypunct<_CharT, _Intl>(__refs)
      {
 if (std::strcmp(__s, "C") != 0 && std::strcmp(__s, "POSIX") != 0)
   {
     __c_locale __tmp;
     this->_S_create_c_locale(__tmp, __s);
     this->_M_initialize_moneypunct(__tmp);
     this->_S_destroy_c_locale(__tmp);
   }
      }
    protected:
      virtual
      ~moneypunct_byname() { }
    };
  template<typename _CharT, bool _Intl>
    const bool moneypunct_byname<_CharT, _Intl>::intl;
  template<typename _CharT, typename _InIter>
    class money_get : public locale::facet
    {
    public:
      typedef _CharT char_type;
      typedef _InIter iter_type;
      typedef basic_string<_CharT> string_type;
      static locale::id id;
      explicit
      money_get(size_t __refs = 0) : facet(__refs) { }
      iter_type
      get(iter_type __s, iter_type __end, bool __intl, ios_base& __io,
   ios_base::iostate& __err, long double& __units) const
      { return this->do_get(__s, __end, __intl, __io, __err, __units); }
      iter_type
      get(iter_type __s, iter_type __end, bool __intl, ios_base& __io,
   ios_base::iostate& __err, string_type& __digits) const
      { return this->do_get(__s, __end, __intl, __io, __err, __digits); }
    protected:
      virtual
      ~money_get() { }
      virtual iter_type
      do_get(iter_type __s, iter_type __end, bool __intl, ios_base& __io,
      ios_base::iostate& __err, long double& __units) const;
      virtual iter_type
      do_get(iter_type __s, iter_type __end, bool __intl, ios_base& __io,
      ios_base::iostate& __err, string_type& __digits) const;
      template<bool _Intl>
        iter_type
        _M_extract(iter_type __s, iter_type __end, ios_base& __io,
     ios_base::iostate& __err, string& __digits) const;
    };
  template<typename _CharT, typename _InIter>
    locale::id money_get<_CharT, _InIter>::id;
  template<typename _CharT, typename _OutIter>
    class money_put : public locale::facet
    {
    public:
      typedef _CharT char_type;
      typedef _OutIter iter_type;
      typedef basic_string<_CharT> string_type;
      static locale::id id;
      explicit
      money_put(size_t __refs = 0) : facet(__refs) { }
      iter_type
      put(iter_type __s, bool __intl, ios_base& __io,
   char_type __fill, long double __units) const
      { return this->do_put(__s, __intl, __io, __fill, __units); }
      iter_type
      put(iter_type __s, bool __intl, ios_base& __io,
   char_type __fill, const string_type& __digits) const
      { return this->do_put(__s, __intl, __io, __fill, __digits); }
    protected:
      virtual
      ~money_put() { }
      virtual iter_type
      do_put(iter_type __s, bool __intl, ios_base& __io, char_type __fill,
      long double __units) const;
      virtual iter_type
      do_put(iter_type __s, bool __intl, ios_base& __io, char_type __fill,
      const string_type& __digits) const;
      template<bool _Intl>
        iter_type
        _M_insert(iter_type __s, ios_base& __io, char_type __fill,
    const string_type& __digits) const;
    };
  template<typename _CharT, typename _OutIter>
    locale::id money_put<_CharT, _OutIter>::id;
  struct messages_base
  {
    typedef int catalog;
  };
  template<typename _CharT>
    class messages : public locale::facet, public messages_base
    {
    public:
      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;
    protected:
      __c_locale _M_c_locale_messages;
      const char* _M_name_messages;
    public:
      static locale::id id;
      explicit
      messages(size_t __refs = 0);
      explicit
      messages(__c_locale __cloc, const char* __s, size_t __refs = 0);
      catalog
      open(const basic_string<char>& __s, const locale& __loc) const
      { return this->do_open(__s, __loc); }
      catalog
      open(const basic_string<char>&, const locale&, const char*) const;
      string_type
      get(catalog __c, int __set, int __msgid, const string_type& __s) const
      { return this->do_get(__c, __set, __msgid, __s); }
      void
      close(catalog __c) const
      { return this->do_close(__c); }
    protected:
      virtual
      ~messages();
      virtual catalog
      do_open(const basic_string<char>&, const locale&) const;
      virtual string_type
      do_get(catalog, int, int, const string_type& __dfault) const;
      virtual void
      do_close(catalog) const;
      char*
      _M_convert_to_char(const string_type& __msg) const
      {
 return reinterpret_cast<char*>(const_cast<_CharT*>(__msg.c_str()));
      }
      string_type
      _M_convert_from_char(char*) const
      {
 return string_type();
      }
     };
  template<typename _CharT>
    locale::id messages<_CharT>::id;
  template<>
    string
    messages<char>::do_get(catalog, int, int, const string&) const;
  template<>
    wstring
    messages<wchar_t>::do_get(catalog, int, int, const wstring&) const;
   template<typename _CharT>
    class messages_byname : public messages<_CharT>
    {
    public:
      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;
      explicit
      messages_byname(const char* __s, size_t __refs = 0);
    protected:
      virtual
      ~messages_byname()
      { }
    };
  template<typename _CharT>
     messages<_CharT>::messages(size_t __refs)
     : facet(__refs), _M_c_locale_messages(_S_get_c_locale()),
       _M_name_messages(_S_get_c_name())
     { }
  template<typename _CharT>
     messages<_CharT>::messages(__c_locale __cloc, const char* __s,
    size_t __refs)
     : facet(__refs), _M_c_locale_messages(__null), _M_name_messages(__null)
     {
       const size_t __len = std::strlen(__s) + 1;
       char* __tmp = new char[__len];
       std::memcpy(__tmp, __s, __len);
       _M_name_messages = __tmp;
       _M_c_locale_messages = _S_clone_c_locale(__cloc);
     }
  template<typename _CharT>
    typename messages<_CharT>::catalog
    messages<_CharT>::open(const basic_string<char>& __s, const locale& __loc,
      const char* __dir) const
    {
      bindtextdomain(__s.c_str(), __dir);
      return this->do_open(__s, __loc);
    }
  template<typename _CharT>
    messages<_CharT>::~messages()
    {
      if (_M_name_messages != _S_get_c_name())
 delete [] _M_name_messages;
      _S_destroy_c_locale(_M_c_locale_messages);
    }
  template<typename _CharT>
    typename messages<_CharT>::catalog
    messages<_CharT>::do_open(const basic_string<char>& __s,
         const locale&) const
    {
      textdomain(__s.c_str());
      return 0;
    }
  template<typename _CharT>
    void
    messages<_CharT>::do_close(catalog) const
    { }
   template<typename _CharT>
     messages_byname<_CharT>::messages_byname(const char* __s, size_t __refs)
     : messages<_CharT>(__refs)
     {
       if (this->_M_name_messages != locale::facet::_S_get_c_name())
  delete [] this->_M_name_messages;
       char* __tmp = new char[std::strlen(__s) + 1];
       std::strcpy(__tmp, __s);
       this->_M_name_messages = __tmp;
       if (std::strcmp(__s, "C") != 0 && std::strcmp(__s, "POSIX") != 0)
  {
    this->_S_destroy_c_locale(this->_M_c_locale_messages);
    this->_S_create_c_locale(this->_M_c_locale_messages, __s);
  }
     }
  template<typename _CharT>
    inline bool
    isspace(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::space, __c); }
  template<typename _CharT>
    inline bool
    isprint(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::print, __c); }
  template<typename _CharT>
    inline bool
    iscntrl(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::cntrl, __c); }
  template<typename _CharT>
    inline bool
    isupper(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::upper, __c); }
  template<typename _CharT>
    inline bool
    islower(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::lower, __c); }
  template<typename _CharT>
    inline bool
    isalpha(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::alpha, __c); }
  template<typename _CharT>
    inline bool
    isdigit(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::digit, __c); }
  template<typename _CharT>
    inline bool
    ispunct(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::punct, __c); }
  template<typename _CharT>
    inline bool
    isxdigit(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::xdigit, __c); }
  template<typename _CharT>
    inline bool
    isalnum(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::alnum, __c); }
  template<typename _CharT>
    inline bool
    isgraph(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::graph, __c); }
  template<typename _CharT>
    inline _CharT
    toupper(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).toupper(__c); }
  template<typename _CharT>
    inline _CharT
    tolower(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).tolower(__c); }
}
namespace std
{
  template<typename _CharT, typename _Traits>
    class basic_ios : public ios_base
    {
    public:
      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;
      typedef ctype<_CharT> __ctype_type;
      typedef num_put<_CharT, ostreambuf_iterator<_CharT, _Traits> >
           __num_put_type;
      typedef num_get<_CharT, istreambuf_iterator<_CharT, _Traits> >
           __num_get_type;
    protected:
      basic_ostream<_CharT, _Traits>* _M_tie;
      mutable char_type _M_fill;
      mutable bool _M_fill_init;
      basic_streambuf<_CharT, _Traits>* _M_streambuf;
      const __ctype_type* _M_ctype;
      const __num_put_type* _M_num_put;
      const __num_get_type* _M_num_get;
    public:
      operator void*() const
      { return this->fail() ? 0 : const_cast<basic_ios*>(this); }
      bool
      operator!() const
      { return this->fail(); }
      iostate
      rdstate() const
      { return _M_streambuf_state; }
      void
      clear(iostate __state = goodbit);
      void
      setstate(iostate __state)
      { this->clear(this->rdstate() | __state); }
      void
      _M_setstate(iostate __state)
      {
 _M_streambuf_state |= __state;
 if (this->exceptions() & __state)
   throw;
      }
      bool
      good() const
      { return this->rdstate() == 0; }
      bool
      eof() const
      { return (this->rdstate() & eofbit) != 0; }
      bool
      fail() const
      { return (this->rdstate() & (badbit | failbit)) != 0; }
      bool
      bad() const
      { return (this->rdstate() & badbit) != 0; }
      iostate
      exceptions() const
      { return _M_exception; }
      void
      exceptions(iostate __except)
      {
        _M_exception = __except;
        this->clear(_M_streambuf_state);
      }
      explicit
      basic_ios(basic_streambuf<_CharT, _Traits>* __sb)
      : ios_base(), _M_tie(0), _M_fill(), _M_fill_init(false), _M_streambuf(0),
      _M_ctype(0), _M_num_put(0), _M_num_get(0)
      { this->init(__sb); }
      virtual
      ~basic_ios() { }
      basic_ostream<_CharT, _Traits>*
      tie() const
      { return _M_tie; }
      basic_ostream<_CharT, _Traits>*
      tie(basic_ostream<_CharT, _Traits>* __tiestr)
      {
        basic_ostream<_CharT, _Traits>* __old = _M_tie;
        _M_tie = __tiestr;
        return __old;
      }
      basic_streambuf<_CharT, _Traits>*
      rdbuf() const
      { return _M_streambuf; }
      basic_streambuf<_CharT, _Traits>*
      rdbuf(basic_streambuf<_CharT, _Traits>* __sb);
      basic_ios&
      copyfmt(const basic_ios& __rhs);
      char_type
      fill() const
      {
 if (!_M_fill_init)
   {
     _M_fill = this->widen(' ');
     _M_fill_init = true;
   }
 return _M_fill;
      }
      char_type
      fill(char_type __ch)
      {
 char_type __old = this->fill();
 _M_fill = __ch;
 return __old;
      }
      locale
      imbue(const locale& __loc);
      char
      narrow(char_type __c, char __dfault) const;
      char_type
      widen(char __c) const;
    protected:
      basic_ios()
      : ios_base(), _M_tie(0), _M_fill(char_type()), _M_fill_init(false),
      _M_streambuf(0), _M_ctype(0), _M_num_put(0), _M_num_get(0)
      { }
      void
      init(basic_streambuf<_CharT, _Traits>* __sb);
      void
      _M_cache_locale(const locale& __loc);
    };
}
namespace std
{
  template<typename _CharT, typename _Traits>
    void
    basic_ios<_CharT, _Traits>::clear(iostate __state)
    {
      if (this->rdbuf())
 _M_streambuf_state = __state;
      else
   _M_streambuf_state = __state | badbit;
      if (this->exceptions() & this->rdstate())
 __throw_ios_failure(("basic_ios::clear"));
    }
  template<typename _CharT, typename _Traits>
    basic_streambuf<_CharT, _Traits>*
    basic_ios<_CharT, _Traits>::rdbuf(basic_streambuf<_CharT, _Traits>* __sb)
    {
      basic_streambuf<_CharT, _Traits>* __old = _M_streambuf;
      _M_streambuf = __sb;
      this->clear();
      return __old;
    }
  template<typename _CharT, typename _Traits>
    basic_ios<_CharT, _Traits>&
    basic_ios<_CharT, _Traits>::copyfmt(const basic_ios& __rhs)
    {
      if (this != &__rhs)
 {
   _Words* __words = (__rhs._M_word_size <= _S_local_word_size) ?
                      _M_local_word : new _Words[__rhs._M_word_size];
   _Callback_list* __cb = __rhs._M_callbacks;
   if (__cb)
     __cb->_M_add_reference();
   _M_call_callbacks(erase_event);
   if (_M_word != _M_local_word)
     {
       delete [] _M_word;
       _M_word = 0;
     }
   _M_dispose_callbacks();
   _M_callbacks = __cb;
   for (int __i = 0; __i < __rhs._M_word_size; ++__i)
     __words[__i] = __rhs._M_word[__i];
   _M_word = __words;
   _M_word_size = __rhs._M_word_size;
   this->flags(__rhs.flags());
   this->width(__rhs.width());
   this->precision(__rhs.precision());
   this->tie(__rhs.tie());
   this->fill(__rhs.fill());
   _M_ios_locale = __rhs.getloc();
   _M_cache_locale(_M_ios_locale);
   _M_call_callbacks(copyfmt_event);
   this->exceptions(__rhs.exceptions());
 }
      return *this;
    }
  template<typename _CharT, typename _Traits>
    char
    basic_ios<_CharT, _Traits>::narrow(char_type __c, char __dfault) const
    { return __check_facet(_M_ctype).narrow(__c, __dfault); }
  template<typename _CharT, typename _Traits>
    _CharT
    basic_ios<_CharT, _Traits>::widen(char __c) const
    { return __check_facet(_M_ctype).widen(__c); }
  template<typename _CharT, typename _Traits>
    locale
    basic_ios<_CharT, _Traits>::imbue(const locale& __loc)
    {
      locale __old(this->getloc());
      ios_base::imbue(__loc);
      _M_cache_locale(__loc);
      if (this->rdbuf() != 0)
 this->rdbuf()->pubimbue(__loc);
      return __old;
    }
  template<typename _CharT, typename _Traits>
    void
    basic_ios<_CharT, _Traits>::init(basic_streambuf<_CharT, _Traits>* __sb)
    {
      ios_base::_M_init();
      _M_cache_locale(_M_ios_locale);
      _M_fill = _CharT();
      _M_fill_init = false;
      _M_tie = 0;
      _M_exception = goodbit;
      _M_streambuf = __sb;
      _M_streambuf_state = __sb ? goodbit : badbit;
    }
  template<typename _CharT, typename _Traits>
    void
    basic_ios<_CharT, _Traits>::_M_cache_locale(const locale& __loc)
    {
      if (__builtin_expect(has_facet<__ctype_type>(__loc), true))
 _M_ctype = &use_facet<__ctype_type>(__loc);
      else
 _M_ctype = 0;
      if (__builtin_expect(has_facet<__num_put_type>(__loc), true))
 _M_num_put = &use_facet<__num_put_type>(__loc);
      else
 _M_num_put = 0;
      if (__builtin_expect(has_facet<__num_get_type>(__loc), true))
 _M_num_get = &use_facet<__num_get_type>(__loc);
      else
 _M_num_get = 0;
    }
  extern template class basic_ios<char>;
  extern template class basic_ios<wchar_t>;
}
namespace std
{
  template<typename _CharT, typename _Traits>
    class basic_ostream : virtual public basic_ios<_CharT, _Traits>
    {
    public:
      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;
      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef basic_ios<_CharT, _Traits> __ios_type;
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef num_put<_CharT, ostreambuf_iterator<_CharT, _Traits> >
             __num_put_type;
      typedef ctype<_CharT> __ctype_type;
      template<typename _CharT2, typename _Traits2>
        friend basic_ostream<_CharT2, _Traits2>&
        operator<<(basic_ostream<_CharT2, _Traits2>&, _CharT2);
      template<typename _Traits2>
        friend basic_ostream<char, _Traits2>&
        operator<<(basic_ostream<char, _Traits2>&, char);
      template<typename _CharT2, typename _Traits2>
        friend basic_ostream<_CharT2, _Traits2>&
        operator<<(basic_ostream<_CharT2, _Traits2>&, const _CharT2*);
      template<typename _Traits2>
        friend basic_ostream<char, _Traits2>&
        operator<<(basic_ostream<char, _Traits2>&, const char*);
      template<typename _CharT2, typename _Traits2>
        friend basic_ostream<_CharT2, _Traits2>&
        operator<<(basic_ostream<_CharT2, _Traits2>&, const char*);
      explicit
      basic_ostream(__streambuf_type* __sb)
      { this->init(__sb); }
      virtual
      ~basic_ostream() { }
      class sentry;
      friend class sentry;
      inline __ostream_type&
      operator<<(__ostream_type& (*__pf)(__ostream_type&));
      inline __ostream_type&
      operator<<(__ios_type& (*__pf)(__ios_type&));
      inline __ostream_type&
      operator<<(ios_base& (*__pf) (ios_base&));
      __ostream_type&
      operator<<(long __n);
      __ostream_type&
      operator<<(unsigned long __n);
      __ostream_type&
      operator<<(bool __n);
      __ostream_type&
      operator<<(short __n);
      __ostream_type&
      operator<<(unsigned short __n);
      __ostream_type&
      operator<<(int __n);
      __ostream_type&
      operator<<(unsigned int __n);
      __ostream_type&
      operator<<(long long __n);
      __ostream_type&
      operator<<(unsigned long long __n);
      __ostream_type&
      operator<<(double __f);
      __ostream_type&
      operator<<(float __f);
      __ostream_type&
      operator<<(long double __f);
      __ostream_type&
      operator<<(const void* __p);
      __ostream_type&
      operator<<(__streambuf_type* __sb);
      __ostream_type&
      put(char_type __c);
      void
      _M_write(const char_type* __s, streamsize __n)
      {
 streamsize __put = this->rdbuf()->sputn(__s, __n);
 if (__put != __n)
   this->setstate(ios_base::badbit);
      }
      __ostream_type&
      write(const char_type* __s, streamsize __n);
      __ostream_type&
      flush();
      pos_type
      tellp();
      __ostream_type&
      seekp(pos_type);
       __ostream_type&
      seekp(off_type, ios_base::seekdir);
    protected:
      explicit
      basic_ostream() { }
    };
  template <typename _CharT, typename _Traits>
    class basic_ostream<_CharT, _Traits>::sentry
    {
      bool _M_ok;
      basic_ostream<_CharT,_Traits>& _M_os;
    public:
      explicit
      sentry(basic_ostream<_CharT,_Traits>& __os);
      ~sentry()
      {
 if (_M_os.flags() & ios_base::unitbuf && !uncaught_exception())
   {
     if (_M_os.rdbuf() && _M_os.rdbuf()->pubsync() == -1)
       _M_os.setstate(ios_base::badbit);
   }
      }
      operator bool() const
      { return _M_ok; }
    };
  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, _CharT __c);
  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, char __c)
    { return (__out << __out.widen(__c)); }
  template <class _Traits>
    basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, char __c);
  template<class _Traits>
    basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, signed char __c)
    { return (__out << static_cast<char>(__c)); }
  template<class _Traits>
    basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, unsigned char __c)
    { return (__out << static_cast<char>(__c)); }
  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, const _CharT* __s);
  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits> &
    operator<<(basic_ostream<_CharT, _Traits>& __out, const char* __s);
  template<class _Traits>
    basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, const char* __s);
  template<class _Traits>
    basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, const signed char* __s)
    { return (__out << reinterpret_cast<const char*>(__s)); }
  template<class _Traits>
    basic_ostream<char, _Traits> &
    operator<<(basic_ostream<char, _Traits>& __out, const unsigned char* __s)
    { return (__out << reinterpret_cast<const char*>(__s)); }
  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    endl(basic_ostream<_CharT, _Traits>& __os)
    { return flush(__os.put(__os.widen('\n'))); }
  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    ends(basic_ostream<_CharT, _Traits>& __os)
    { return __os.put(_CharT()); }
  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    flush(basic_ostream<_CharT, _Traits>& __os)
    { return __os.flush(); }
}
extern "C++" {
namespace __cxxabiv1
{
  class __class_type_info;
}
namespace std
{
  class type_info
  {
  public:
    virtual ~type_info();
  private:
    type_info& operator=(const type_info&);
    type_info(const type_info&);
  protected:
    const char *__name;
  protected:
    explicit type_info(const char *__n): __name(__n) { }
  public:
    const char* name() const
    { return __name; }
    bool before(const type_info& __arg) const
    { return __name < __arg.__name; }
    bool operator==(const type_info& __arg) const
    { return __name == __arg.__name; }
    bool operator!=(const type_info& __arg) const
    { return !operator==(__arg); }
  public:
    virtual bool __is_pointer_p() const;
    virtual bool __is_function_p() const;
    virtual bool __do_catch(const type_info *__thr_type, void **__thr_obj,
       unsigned __outer) const;
    virtual bool __do_upcast(const __cxxabiv1::__class_type_info *__target,
        void **__obj_ptr) const;
  };
  class bad_cast : public exception
  {
  public:
    bad_cast() throw() { }
    virtual ~bad_cast() throw();
  };
  class bad_typeid : public exception
  {
  public:
    bad_typeid () throw() { }
    virtual ~bad_typeid() throw();
  };
}
}
namespace std
{
  template<typename _Facet>
    locale
    locale::combine(const locale& __other) const
    {
      _Impl* __tmp = new _Impl(*_M_impl, 1);
      try
 {
   __tmp->_M_replace_facet(__other._M_impl, &_Facet::id);
 }
      catch(...)
 {
   __tmp->_M_remove_reference();
   throw;
 }
      return locale(__tmp);
    }
  template<typename _CharT, typename _Traits, typename _Alloc>
    bool
    locale::operator()(const basic_string<_CharT, _Traits, _Alloc>& __s1,
                       const basic_string<_CharT, _Traits, _Alloc>& __s2) const
    {
      typedef std::collate<_CharT> __collate_type;
      const __collate_type& __collate = use_facet<__collate_type>(*this);
      return (__collate.compare(__s1.data(), __s1.data() + __s1.length(),
    __s2.data(), __s2.data() + __s2.length()) < 0);
    }
  template<typename _Facet>
    inline bool
    has_facet(const locale& __loc) throw()
    {
      const size_t __i = _Facet::id._M_id();
      const locale::facet** __facets = __loc._M_impl->_M_facets;
      return (__i < __loc._M_impl->_M_facets_size && __facets[__i]);
    }
  template<typename _Facet>
    inline const _Facet&
    use_facet(const locale& __loc)
    {
      const size_t __i = _Facet::id._M_id();
      const locale::facet** __facets = __loc._M_impl->_M_facets;
      if (!(__i < __loc._M_impl->_M_facets_size && __facets[__i]))
        __throw_bad_cast();
      return static_cast<const _Facet&>(*__facets[__i]);
    }
  template<typename _Facet>
    struct __use_cache
    {
      const _Facet*
      operator() (const locale& __loc) const;
    };
  template<typename _CharT>
    struct __use_cache<__numpunct_cache<_CharT> >
    {
      const __numpunct_cache<_CharT>*
      operator() (const locale& __loc) const
      {
 const size_t __i = numpunct<_CharT>::id._M_id();
 const locale::facet** __caches = __loc._M_impl->_M_caches;
 if (!__caches[__i])
   {
     __numpunct_cache<_CharT>* __tmp = __null;
     try
       {
  __tmp = new __numpunct_cache<_CharT>;
  __tmp->_M_cache(__loc);
       }
     catch(...)
       {
  delete __tmp;
  throw;
       }
     __loc._M_impl->_M_install_cache(__tmp, __i);
   }
 return static_cast<const __numpunct_cache<_CharT>*>(__caches[__i]);
      }
    };
  template<typename _CharT, bool _Intl>
    struct __use_cache<__moneypunct_cache<_CharT, _Intl> >
    {
      const __moneypunct_cache<_CharT, _Intl>*
      operator() (const locale& __loc) const
      {
 const size_t __i = moneypunct<_CharT, _Intl>::id._M_id();
 const locale::facet** __caches = __loc._M_impl->_M_caches;
 if (!__caches[__i])
   {
     __moneypunct_cache<_CharT, _Intl>* __tmp = __null;
     try
       {
  __tmp = new __moneypunct_cache<_CharT, _Intl>;
  __tmp->_M_cache(__loc);
       }
     catch(...)
       {
  delete __tmp;
  throw;
       }
     __loc._M_impl->_M_install_cache(__tmp, __i);
   }
 return static_cast<
   const __moneypunct_cache<_CharT, _Intl>*>(__caches[__i]);
      }
    };
  template<typename _CharT>
    void
    __numpunct_cache<_CharT>::_M_cache(const locale& __loc)
    {
      _M_allocated = true;
      const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__loc);
      _M_grouping_size = __np.grouping().size();
      char* __grouping = new char[_M_grouping_size];
      __np.grouping().copy(__grouping, _M_grouping_size);
      _M_grouping = __grouping;
      _M_use_grouping = (_M_grouping_size
    && static_cast<signed char>(__np.grouping()[0]) > 0);
      _M_truename_size = __np.truename().size();
      _CharT* __truename = new _CharT[_M_truename_size];
      __np.truename().copy(__truename, _M_truename_size);
      _M_truename = __truename;
      _M_falsename_size = __np.falsename().size();
      _CharT* __falsename = new _CharT[_M_falsename_size];
      __np.falsename().copy(__falsename, _M_falsename_size);
      _M_falsename = __falsename;
      _M_decimal_point = __np.decimal_point();
      _M_thousands_sep = __np.thousands_sep();
      const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__loc);
      __ct.widen(__num_base::_S_atoms_out,
   __num_base::_S_atoms_out + __num_base::_S_oend, _M_atoms_out);
      __ct.widen(__num_base::_S_atoms_in,
   __num_base::_S_atoms_in + __num_base::_S_iend, _M_atoms_in);
    }
  template<typename _CharT, bool _Intl>
    void
    __moneypunct_cache<_CharT, _Intl>::_M_cache(const locale& __loc)
    {
      _M_allocated = true;
      const moneypunct<_CharT, _Intl>& __mp =
 use_facet<moneypunct<_CharT, _Intl> >(__loc);
      _M_grouping_size = __mp.grouping().size();
      char* __grouping = new char[_M_grouping_size];
      __mp.grouping().copy(__grouping, _M_grouping_size);
      _M_grouping = __grouping;
      _M_use_grouping = (_M_grouping_size
    && static_cast<signed char>(__mp.grouping()[0]) > 0);
      _M_decimal_point = __mp.decimal_point();
      _M_thousands_sep = __mp.thousands_sep();
      _M_frac_digits = __mp.frac_digits();
      _M_curr_symbol_size = __mp.curr_symbol().size();
      _CharT* __curr_symbol = new _CharT[_M_curr_symbol_size];
      __mp.curr_symbol().copy(__curr_symbol, _M_curr_symbol_size);
      _M_curr_symbol = __curr_symbol;
      _M_positive_sign_size = __mp.positive_sign().size();
      _CharT* __positive_sign = new _CharT[_M_positive_sign_size];
      __mp.positive_sign().copy(__positive_sign, _M_positive_sign_size);
      _M_positive_sign = __positive_sign;
      _M_negative_sign_size = __mp.negative_sign().size();
      _CharT* __negative_sign = new _CharT[_M_negative_sign_size];
      __mp.negative_sign().copy(__negative_sign, _M_negative_sign_size);
      _M_negative_sign = __negative_sign;
      _M_pos_format = __mp.pos_format();
      _M_neg_format = __mp.neg_format();
      const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__loc);
      __ct.widen(money_base::_S_atoms,
   money_base::_S_atoms + money_base::_S_end, _M_atoms);
    }
  static bool
  __verify_grouping(const char* __grouping, size_t __grouping_size,
      const string& __grouping_tmp);
  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    _M_extract_float(_InIter __beg, _InIter __end, ios_base& __io,
       ios_base::iostate& __err, string& __xtrc) const
    {
      typedef char_traits<_CharT> __traits_type;
      typedef __numpunct_cache<_CharT> __cache_type;
      __use_cache<__cache_type> __uc;
      const locale& __loc = __io._M_getloc();
      const __cache_type* __lc = __uc(__loc);
      const _CharT* __lit = __lc->_M_atoms_in;
      char_type __c = char_type();
      bool __testeof = __beg == __end;
      if (!__testeof)
 {
   __c = *__beg;
   const bool __plus = __c == __lit[__num_base::_S_iplus];
   if ((__plus || __c == __lit[__num_base::_S_iminus])
       && !(__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
       && !(__c == __lc->_M_decimal_point))
     {
       __xtrc += __plus ? '+' : '-';
       if (++__beg != __end)
  __c = *__beg;
       else
  __testeof = true;
     }
 }
      bool __found_mantissa = false;
      int __sep_pos = 0;
      while (!__testeof)
 {
   if (__lc->_M_use_grouping && __c == __lc->_M_thousands_sep
       || __c == __lc->_M_decimal_point)
     break;
   else if (__c == __lit[__num_base::_S_izero])
     {
       if (!__found_mantissa)
  {
    __xtrc += '0';
    __found_mantissa = true;
  }
       ++__sep_pos;
       if (++__beg != __end)
  __c = *__beg;
       else
  __testeof = true;
     }
   else
     break;
 }
      bool __found_dec = false;
      bool __found_sci = false;
      string __found_grouping;
      if (__lc->_M_use_grouping)
 __found_grouping.reserve(32);
      const char_type* __q;
      const char_type* __lit_zero = __lit + __num_base::_S_izero;
      while (!__testeof)
        {
          if (__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
     {
       if (!__found_dec && !__found_sci)
  {
    if (__sep_pos)
      {
        __found_grouping += static_cast<char>(__sep_pos);
        __sep_pos = 0;
      }
    else
      {
        __xtrc.clear();
        break;
      }
  }
       else
  break;
            }
   else if (__c == __lc->_M_decimal_point)
     {
       if (!__found_dec && !__found_sci)
  {
    if (__found_grouping.size())
      __found_grouping += static_cast<char>(__sep_pos);
    __xtrc += '.';
    __found_dec = true;
  }
       else
  break;
     }
          else if ((__q = __traits_type::find(__lit_zero, 10, __c)))
     {
       __xtrc += __num_base::_S_atoms_in[__q - __lit];
       __found_mantissa = true;
       ++__sep_pos;
     }
   else if ((__c == __lit[__num_base::_S_ie]
      || __c == __lit[__num_base::_S_iE])
     && !__found_sci && __found_mantissa)
     {
       if (__found_grouping.size() && !__found_dec)
  __found_grouping += static_cast<char>(__sep_pos);
       __xtrc += 'e';
       __found_sci = true;
       if (++__beg != __end)
  {
    __c = *__beg;
    const bool __plus = __c == __lit[__num_base::_S_iplus];
    if ((__plus || __c == __lit[__num_base::_S_iminus])
        && !(__lc->_M_use_grouping
      && __c == __lc->_M_thousands_sep)
        && !(__c == __lc->_M_decimal_point))
      __xtrc += __plus ? '+' : '-';
    else
      continue;
  }
       else
  {
    __testeof = true;
    break;
  }
     }
   else
     break;
   if (++__beg != __end)
     __c = *__beg;
   else
     __testeof = true;
        }
      if (__found_grouping.size())
        {
   if (!__found_dec && !__found_sci)
     __found_grouping += static_cast<char>(__sep_pos);
          if (!std::__verify_grouping(__lc->_M_grouping,
          __lc->_M_grouping_size,
          __found_grouping))
     __err |= ios_base::failbit;
        }
      if (__testeof)
        __err |= ios_base::eofbit;
      return __beg;
    }
  template<typename _ValueT>
    struct __to_unsigned_type
    { typedef _ValueT __type; };
  template<>
    struct __to_unsigned_type<long>
    { typedef unsigned long __type; };
  template<>
    struct __to_unsigned_type<long long>
    { typedef unsigned long long __type; };
  template<typename _CharT, typename _InIter>
    template<typename _ValueT>
      _InIter
      num_get<_CharT, _InIter>::
      _M_extract_int(_InIter __beg, _InIter __end, ios_base& __io,
       ios_base::iostate& __err, _ValueT& __v) const
      {
        typedef char_traits<_CharT> __traits_type;
 typedef typename __to_unsigned_type<_ValueT>::__type __unsigned_type;
 typedef __numpunct_cache<_CharT> __cache_type;
 __use_cache<__cache_type> __uc;
 const locale& __loc = __io._M_getloc();
 const __cache_type* __lc = __uc(__loc);
 const _CharT* __lit = __lc->_M_atoms_in;
 char_type __c = char_type();
 const ios_base::fmtflags __basefield = __io.flags()
                                        & ios_base::basefield;
 const bool __oct = __basefield == ios_base::oct;
 int __base = __oct ? 8 : (__basefield == ios_base::hex ? 16 : 10);
 bool __testeof = __beg == __end;
 bool __negative = false;
 if (!__testeof)
   {
     __c = *__beg;
     if (numeric_limits<_ValueT>::is_signed)
       __negative = __c == __lit[__num_base::_S_iminus];
     if ((__negative || __c == __lit[__num_base::_S_iplus])
  && !(__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
  && !(__c == __lc->_M_decimal_point))
       {
  if (++__beg != __end)
    __c = *__beg;
  else
    __testeof = true;
       }
   }
 bool __found_zero = false;
 int __sep_pos = 0;
 while (!__testeof)
   {
     if (__lc->_M_use_grouping && __c == __lc->_M_thousands_sep
  || __c == __lc->_M_decimal_point)
       break;
     else if (__c == __lit[__num_base::_S_izero]
       && (!__found_zero || __base == 10))
       {
  __found_zero = true;
  ++__sep_pos;
  if (__basefield == 0)
    __base = 8;
  if (__base == 8)
    __sep_pos = 0;
       }
     else if (__found_zero
       && (__c == __lit[__num_base::_S_ix]
    || __c == __lit[__num_base::_S_iX]))
       {
  if (__basefield == 0)
    __base = 16;
  if (__base == 16)
    {
      __found_zero = false;
      __sep_pos = 0;
    }
  else
    break;
       }
     else
       break;
     if (++__beg != __end)
       {
  __c = *__beg;
  if (!__found_zero)
    break;
       }
     else
       __testeof = true;
   }
 const size_t __len = (__base == 16 ? __num_base::_S_iend
         - __num_base::_S_izero : __base);
 string __found_grouping;
 if (__lc->_M_use_grouping)
   __found_grouping.reserve(32);
 bool __testfail = false;
 const __unsigned_type __max = __negative ?
   -numeric_limits<_ValueT>::min() : numeric_limits<_ValueT>::max();
 const __unsigned_type __smax = __max / __base;
 __unsigned_type __result = 0;
 const char_type* __q;
 const char_type* __lit_zero = __lit + __num_base::_S_izero;
 while (!__testeof)
   {
     if (__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
       {
  if (__sep_pos)
    {
      __found_grouping += static_cast<char>(__sep_pos);
      __sep_pos = 0;
    }
  else
    {
      __testfail = true;
      break;
    }
       }
     else if (__c == __lc->_M_decimal_point)
       break;
     else if ((__q = __traits_type::find(__lit_zero, __len, __c)))
       {
  int __digit = __q - __lit_zero;
  if (__digit > 15)
    __digit -= 6;
  if (__result > __smax)
    __testfail = true;
  else
    {
      __result *= __base;
      __testfail |= __result > __max - __digit;
      __result += __digit;
      ++__sep_pos;
    }
       }
     else
       break;
     if (++__beg != __end)
       __c = *__beg;
     else
       __testeof = true;
   }
 if (__found_grouping.size())
   {
     __found_grouping += static_cast<char>(__sep_pos);
     if (!std::__verify_grouping(__lc->_M_grouping,
     __lc->_M_grouping_size,
     __found_grouping))
       __err |= ios_base::failbit;
   }
 if (!__testfail && (__sep_pos || __found_zero
       || __found_grouping.size()))
   __v = __negative ? -__result : __result;
 else
   __err |= ios_base::failbit;
 if (__testeof)
   __err |= ios_base::eofbit;
 return __beg;
      }
  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, bool& __v) const
    {
      if (!(__io.flags() & ios_base::boolalpha))
        {
   long __l = -1;
          __beg = _M_extract_int(__beg, __end, __io, __err, __l);
   if (__l == 0 || __l == 1)
     __v = __l;
   else
            __err |= ios_base::failbit;
        }
      else
        {
   typedef __numpunct_cache<_CharT> __cache_type;
   __use_cache<__cache_type> __uc;
   const locale& __loc = __io._M_getloc();
   const __cache_type* __lc = __uc(__loc);
   bool __testf = true;
   bool __testt = true;
   size_t __n;
   bool __testeof = __beg == __end;
          for (__n = 0; !__testeof; ++__n)
            {
       const char_type __c = *__beg;
       if (__testf)
  if (__n < __lc->_M_falsename_size)
    __testf = __c == __lc->_M_falsename[__n];
  else
    break;
       if (__testt)
  if (__n < __lc->_M_truename_size)
    __testt = __c == __lc->_M_truename[__n];
  else
    break;
       if (!__testf && !__testt)
  break;
       if (++__beg == __end)
  __testeof = true;
            }
   if (__testf && __n == __lc->_M_falsename_size)
     __v = 0;
   else if (__testt && __n == __lc->_M_truename_size)
     __v = 1;
   else
     __err |= ios_base::failbit;
          if (__testeof)
            __err |= ios_base::eofbit;
        }
      return __beg;
    }
  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, long& __v) const
    { return _M_extract_int(__beg, __end, __io, __err, __v); }
  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, unsigned short& __v) const
    { return _M_extract_int(__beg, __end, __io, __err, __v); }
  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, unsigned int& __v) const
    { return _M_extract_int(__beg, __end, __io, __err, __v); }
  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, unsigned long& __v) const
    { return _M_extract_int(__beg, __end, __io, __err, __v); }
  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, long long& __v) const
    { return _M_extract_int(__beg, __end, __io, __err, __v); }
  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, unsigned long long& __v) const
    { return _M_extract_int(__beg, __end, __io, __err, __v); }
  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
    ios_base::iostate& __err, float& __v) const
    {
      string __xtrc;
      __xtrc.reserve(32);
      __beg = _M_extract_float(__beg, __end, __io, __err, __xtrc);
      std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());
      return __beg;
    }
  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, double& __v) const
    {
      string __xtrc;
      __xtrc.reserve(32);
      __beg = _M_extract_float(__beg, __end, __io, __err, __xtrc);
      std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());
      return __beg;
    }
  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, long double& __v) const
    {
      string __xtrc;
      __xtrc.reserve(32);
      __beg = _M_extract_float(__beg, __end, __io, __err, __xtrc);
      std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());
      return __beg;
    }
  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, void*& __v) const
    {
      typedef ios_base::fmtflags fmtflags;
      const fmtflags __fmt = __io.flags();
      __io.flags(__fmt & ~ios_base::basefield | ios_base::hex);
      unsigned long __ul;
      __beg = _M_extract_int(__beg, __end, __io, __err, __ul);
      __io.flags(__fmt);
      if (!(__err & ios_base::failbit))
 __v = reinterpret_cast<void*>(__ul);
      return __beg;
    }
  template<typename _CharT, typename _OutIter>
    void
    num_put<_CharT, _OutIter>::
    _M_pad(_CharT __fill, streamsize __w, ios_base& __io,
    _CharT* __new, const _CharT* __cs, int& __len) const
    {
      __pad<_CharT, char_traits<_CharT> >::_S_pad(__io, __fill, __new, __cs,
        __w, __len, true);
      __len = static_cast<int>(__w);
    }
  template<typename _CharT>
    inline int
    __int_to_char(_CharT* __bufend, long __v, const _CharT* __lit,
    ios_base::fmtflags __flags)
    {
      unsigned long __ul = __v;
      const ios_base::fmtflags __basefield = __flags & ios_base::basefield;
      if (__builtin_expect(__basefield != ios_base::oct
      && __basefield != ios_base::hex, true))
 __ul = __v < 0 ? -__v : __ul;
      return __int_to_char(__bufend, __ul, __lit, __flags, false);
    }
  template<typename _CharT>
    inline int
    __int_to_char(_CharT* __bufend, unsigned long __v, const _CharT* __lit,
    ios_base::fmtflags __flags)
    { return __int_to_char(__bufend, __v, __lit, __flags, false); }
  template<typename _CharT>
    inline int
    __int_to_char(_CharT* __bufend, long long __v, const _CharT* __lit,
    ios_base::fmtflags __flags)
    {
      unsigned long long __ull = __v;
      const ios_base::fmtflags __basefield = __flags & ios_base::basefield;
      if (__builtin_expect(__basefield != ios_base::oct
      && __basefield != ios_base::hex, true))
 __ull = __v < 0 ? -__v : __ull;
      return __int_to_char(__bufend, __ull, __lit, __flags, false);
    }
  template<typename _CharT>
    inline int
    __int_to_char(_CharT* __bufend, unsigned long long __v,
    const _CharT* __lit, ios_base::fmtflags __flags)
    { return __int_to_char(__bufend, __v, __lit, __flags, false); }
  template<typename _CharT, typename _ValueT>
    int
    __int_to_char(_CharT* __bufend, _ValueT __v, const _CharT* __lit,
    ios_base::fmtflags __flags, bool)
    {
      const ios_base::fmtflags __basefield = __flags & ios_base::basefield;
      _CharT* __buf = __bufend;
      if (__builtin_expect(__basefield != ios_base::oct
      && __basefield != ios_base::hex, true))
 {
   do
     {
       *--__buf = __lit[(__v % 10) + __num_base::_S_odigits];
       __v /= 10;
     }
   while (__v != 0);
 }
      else if (__basefield == ios_base::oct)
 {
   do
     {
       *--__buf = __lit[(__v & 0x7) + __num_base::_S_odigits];
       __v >>= 3;
     }
   while (__v != 0);
 }
      else
 {
   const bool __uppercase = __flags & ios_base::uppercase;
   const int __case_offset = __uppercase ? __num_base::_S_oudigits
                                         : __num_base::_S_odigits;
   do
     {
       *--__buf = __lit[(__v & 0xf) + __case_offset];
       __v >>= 4;
     }
   while (__v != 0);
 }
      return __bufend - __buf;
    }
  template<typename _CharT, typename _OutIter>
    void
    num_put<_CharT, _OutIter>::
    _M_group_int(const char* __grouping, size_t __grouping_size, _CharT __sep,
   ios_base&, _CharT* __new, _CharT* __cs, int& __len) const
    {
      _CharT* __p = std::__add_grouping(__new, __sep, __grouping,
     __grouping_size, __cs, __cs + __len);
      __len = __p - __new;
    }
  template<typename _CharT, typename _OutIter>
    template<typename _ValueT>
      _OutIter
      num_put<_CharT, _OutIter>::
      _M_insert_int(_OutIter __s, ios_base& __io, _CharT __fill,
      _ValueT __v) const
      {
 typedef __numpunct_cache<_CharT> __cache_type;
 __use_cache<__cache_type> __uc;
 const locale& __loc = __io._M_getloc();
 const __cache_type* __lc = __uc(__loc);
 const _CharT* __lit = __lc->_M_atoms_out;
 const ios_base::fmtflags __flags = __io.flags();
 const int __ilen = 5 * sizeof(_ValueT);
 _CharT* __cs = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
            * __ilen));
 int __len = __int_to_char(__cs + __ilen, __v, __lit, __flags);
 __cs += __ilen - __len;
 if (__lc->_M_use_grouping)
   {
     _CharT* __cs2 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * (__len + 1)
          * 2));
     _M_group_int(__lc->_M_grouping, __lc->_M_grouping_size,
    __lc->_M_thousands_sep, __io, __cs2 + 2, __cs, __len);
     __cs = __cs2 + 2;
   }
 const ios_base::fmtflags __basefield = __flags & ios_base::basefield;
 if (__builtin_expect(__basefield != ios_base::oct
        && __basefield != ios_base::hex, true))
   {
     if (__v > 0)
       {
  if (__flags & ios_base::showpos
      && numeric_limits<_ValueT>::is_signed)
    *--__cs = __lit[__num_base::_S_oplus], ++__len;
       }
     else if (__v)
       *--__cs = __lit[__num_base::_S_ominus], ++__len;
   }
 else if (__flags & ios_base::showbase && __v)
   {
     if (__basefield == ios_base::oct)
       *--__cs = __lit[__num_base::_S_odigits], ++__len;
     else
       {
  const bool __uppercase = __flags & ios_base::uppercase;
  *--__cs = __lit[__num_base::_S_ox + __uppercase];
  *--__cs = __lit[__num_base::_S_odigits];
  __len += 2;
       }
   }
 const streamsize __w = __io.width();
 if (__w > static_cast<streamsize>(__len))
   {
     _CharT* __cs3 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * __w));
     _M_pad(__fill, __w, __io, __cs3, __cs, __len);
     __cs = __cs3;
   }
 __io.width(0);
 return std::__write(__s, __cs, __len);
      }
  template<typename _CharT, typename _OutIter>
    void
    num_put<_CharT, _OutIter>::
    _M_group_float(const char* __grouping, size_t __grouping_size,
     _CharT __sep, const _CharT* __p, _CharT* __new,
     _CharT* __cs, int& __len) const
    {
      const int __declen = __p ? __p - __cs : __len;
      _CharT* __p2 = std::__add_grouping(__new, __sep, __grouping,
      __grouping_size,
      __cs, __cs + __declen);
      int __newlen = __p2 - __new;
      if (__p)
 {
   char_traits<_CharT>::copy(__p2, __p, __len - __declen);
   __newlen += __len - __declen;
 }
      __len = __newlen;
    }
  template<typename _CharT, typename _OutIter>
    template<typename _ValueT>
      _OutIter
      num_put<_CharT, _OutIter>::
      _M_insert_float(_OutIter __s, ios_base& __io, _CharT __fill, char __mod,
         _ValueT __v) const
      {
 typedef __numpunct_cache<_CharT> __cache_type;
 __use_cache<__cache_type> __uc;
 const locale& __loc = __io._M_getloc();
 const __cache_type* __lc = __uc(__loc);
 streamsize __prec = __io.precision();
 if (__prec < static_cast<streamsize>(0))
   __prec = static_cast<streamsize>(6);
 const int __max_digits = numeric_limits<_ValueT>::digits10;
 int __len;
 char __fbuf[16];
 int __cs_size = __max_digits * 3;
 char* __cs = static_cast<char*>(__builtin_alloca(__cs_size));
 __num_base::_S_format_float(__io, __fbuf, __mod);
 __len = std::__convert_from_v(__cs, __cs_size, __fbuf, __v,
          _S_get_c_locale(), __prec);
 if (__len >= __cs_size)
   {
     __cs_size = __len + 1;
     __cs = static_cast<char*>(__builtin_alloca(__cs_size));
     __len = std::__convert_from_v(__cs, __cs_size, __fbuf, __v,
       _S_get_c_locale(), __prec);
   }
 const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);
 _CharT* __ws = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
            * __len));
 __ctype.widen(__cs, __cs + __len, __ws);
 const _CharT __cdec = __ctype.widen('.');
 const _CharT __dec = __lc->_M_decimal_point;
 const _CharT* __p = char_traits<_CharT>::find(__ws, __len, __cdec);
 if (__p)
   __ws[__p - __ws] = __dec;
 if (__lc->_M_use_grouping
     && (__p || __len < 3 || (__cs[1] <= '9' && __cs[2] <= '9'
         && __cs[1] >= '0' && __cs[2] >= '0')))
   {
     _CharT* __ws2 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * __len * 2));
     streamsize __off = 0;
     if (__cs[0] == '-' || __cs[0] == '+')
       {
  __off = 1;
  __ws2[0] = __ws[0];
  __len -= 1;
       }
     _M_group_float(__lc->_M_grouping, __lc->_M_grouping_size,
      __lc->_M_thousands_sep, __p, __ws2 + __off,
      __ws + __off, __len);
     __len += __off;
     __ws = __ws2;
   }
 const streamsize __w = __io.width();
 if (__w > static_cast<streamsize>(__len))
   {
     _CharT* __ws3 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * __w));
     _M_pad(__fill, __w, __io, __ws3, __ws, __len);
     __ws = __ws3;
   }
 __io.width(0);
 return std::__write(__s, __ws, __len);
      }
  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill, bool __v) const
    {
      const ios_base::fmtflags __flags = __io.flags();
      if ((__flags & ios_base::boolalpha) == 0)
        {
          const long __l = __v;
          __s = _M_insert_int(__s, __io, __fill, __l);
        }
      else
        {
   typedef __numpunct_cache<_CharT> __cache_type;
   __use_cache<__cache_type> __uc;
   const locale& __loc = __io._M_getloc();
   const __cache_type* __lc = __uc(__loc);
   const _CharT* __name = __v ? __lc->_M_truename
                              : __lc->_M_falsename;
   int __len = __v ? __lc->_M_truename_size
                   : __lc->_M_falsename_size;
   const streamsize __w = __io.width();
   if (__w > static_cast<streamsize>(__len))
     {
       _CharT* __cs
  = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
       * __w));
       _M_pad(__fill, __w, __io, __cs, __name, __len);
       __name = __cs;
     }
   __io.width(0);
   __s = std::__write(__s, __name, __len);
 }
      return __s;
    }
  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill, long __v) const
    { return _M_insert_int(__s, __io, __fill, __v); }
  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill,
           unsigned long __v) const
    { return _M_insert_int(__s, __io, __fill, __v); }
  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill, long long __v) const
    { return _M_insert_int(__s, __io, __fill, __v); }
  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill,
           unsigned long long __v) const
    { return _M_insert_int(__s, __io, __fill, __v); }
  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill, double __v) const
    { return _M_insert_float(__s, __io, __fill, char(), __v); }
  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill,
    long double __v) const
    { return _M_insert_float(__s, __io, __fill, 'L', __v); }
  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill,
           const void* __v) const
    {
      const ios_base::fmtflags __flags = __io.flags();
      const ios_base::fmtflags __fmt = ~(ios_base::basefield
      | ios_base::uppercase
      | ios_base::internal);
      __io.flags(__flags & __fmt | (ios_base::hex | ios_base::showbase));
      __s = _M_insert_int(__s, __io, __fill,
     reinterpret_cast<unsigned long>(__v));
      __io.flags(__flags);
      return __s;
    }
  template<typename _CharT, typename _InIter>
    template<bool _Intl>
      _InIter
      money_get<_CharT, _InIter>::
      _M_extract(iter_type __beg, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, string& __units) const
      {
 typedef char_traits<_CharT> __traits_type;
 typedef typename string_type::size_type size_type;
 typedef money_base::part part;
 typedef __moneypunct_cache<_CharT, _Intl> __cache_type;
 const locale& __loc = __io._M_getloc();
 const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);
 __use_cache<__cache_type> __uc;
 const __cache_type* __lc = __uc(__loc);
 const char_type* __lit = __lc->_M_atoms;
 bool __negative = false;
 size_type __sign_size = 0;
 const bool __mandatory_sign = (__lc->_M_positive_sign_size
           && __lc->_M_negative_sign_size);
 string __grouping_tmp;
 if (__lc->_M_use_grouping)
   __grouping_tmp.reserve(32);
 int __last_pos = 0;
 int __n = 0;
 bool __testvalid = true;
 bool __testdecfound = false;
 string __res;
 __res.reserve(32);
 const char_type* __lit_zero = __lit + money_base::_S_zero;
 const money_base::pattern __p = __lc->_M_neg_format;
 for (int __i = 0; __i < 4 && __testvalid; ++__i)
   {
     const part __which = static_cast<part>(__p.field[__i]);
     switch (__which)
       {
       case money_base::symbol:
  if (__io.flags() & ios_base::showbase || __sign_size > 1
      || __i == 0
      || (__i == 1 && (__mandatory_sign
         || (static_cast<part>(__p.field[0])
      == money_base::sign)
         || (static_cast<part>(__p.field[2])
      == money_base::space)))
      || (__i == 2 && ((static_cast<part>(__p.field[3])
          == money_base::value)
         || __mandatory_sign
         && (static_cast<part>(__p.field[3])
      == money_base::sign))))
    {
      const size_type __len = __lc->_M_curr_symbol_size;
      size_type __j = 0;
      for (; __beg != __end && __j < __len
      && *__beg == __lc->_M_curr_symbol[__j];
    ++__beg, ++__j);
      if (__j != __len
   && (__j || __io.flags() & ios_base::showbase))
        __testvalid = false;
    }
  break;
       case money_base::sign:
  if (__lc->_M_positive_sign_size && __beg != __end
      && *__beg == __lc->_M_positive_sign[0])
    {
      __sign_size = __lc->_M_positive_sign_size;
      ++__beg;
    }
  else if (__lc->_M_negative_sign_size && __beg != __end
    && *__beg == __lc->_M_negative_sign[0])
    {
      __negative = true;
      __sign_size = __lc->_M_negative_sign_size;
      ++__beg;
    }
  else if (__lc->_M_positive_sign_size
    && !__lc->_M_negative_sign_size)
    __negative = true;
  else if (__mandatory_sign)
    __testvalid = false;
  break;
       case money_base::value:
  for (; __beg != __end; ++__beg)
    {
      const char_type __c = *__beg;
      const char_type* __q = __traits_type::find(__lit_zero,
              10, __c);
      if (__q != 0)
        {
   __res += money_base::_S_atoms[__q - __lit];
   ++__n;
        }
      else if (__c == __lc->_M_decimal_point
        && !__testdecfound)
        {
   __last_pos = __n;
   __n = 0;
   __testdecfound = true;
        }
      else if (__lc->_M_use_grouping
        && __c == __lc->_M_thousands_sep
        && !__testdecfound)
        {
   if (__n)
     {
       __grouping_tmp += static_cast<char>(__n);
       __n = 0;
     }
   else
     {
       __testvalid = false;
       break;
     }
        }
      else
        break;
    }
  if (__res.empty())
    __testvalid = false;
  break;
       case money_base::space:
  if (__beg != __end && __ctype.is(ctype_base::space, *__beg))
    ++__beg;
  else
    __testvalid = false;
       case money_base::none:
  if (__i != 3)
    for (; __beg != __end
    && __ctype.is(ctype_base::space, *__beg); ++__beg);
  break;
       }
   }
 if (__sign_size > 1 && __testvalid)
   {
     const char_type* __sign = __negative ? __lc->_M_negative_sign
                                          : __lc->_M_positive_sign;
     size_type __i = 1;
     for (; __beg != __end && __i < __sign_size
     && *__beg == __sign[__i]; ++__beg, ++__i);
     if (__i != __sign_size)
       __testvalid = false;
   }
 if (__testvalid)
   {
     if (__res.size() > 1)
       {
  const size_type __first = __res.find_first_not_of('0');
  const bool __only_zeros = __first == string::npos;
  if (__first)
    __res.erase(0, __only_zeros ? __res.size() - 1 : __first);
       }
     if (__negative && __res[0] != '0')
       __res.insert(__res.begin(), '-');
     if (__grouping_tmp.size())
       {
  __grouping_tmp += static_cast<char>(__testdecfound ? __last_pos
                         : __n);
  if (!std::__verify_grouping(__lc->_M_grouping,
         __lc->_M_grouping_size,
         __grouping_tmp))
    __err |= ios_base::failbit;
       }
     if (__testdecfound && __lc->_M_frac_digits > 0
  && __n != __lc->_M_frac_digits)
       __testvalid = false;
   }
 if (!__testvalid)
   __err |= ios_base::failbit;
 else
   __units.swap(__res);
 if (__beg == __end)
   __err |= ios_base::eofbit;
 return __beg;
      }
  template<typename _CharT, typename _InIter>
    _InIter
    money_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, bool __intl, ios_base& __io,
    ios_base::iostate& __err, long double& __units) const
    {
      string __str;
      if (__intl)
 __beg = _M_extract<true>(__beg, __end, __io, __err, __str);
      else
 __beg = _M_extract<false>(__beg, __end, __io, __err, __str);
      std::__convert_to_v(__str.c_str(), __units, __err, _S_get_c_locale());
      return __beg;
    }
  template<typename _CharT, typename _InIter>
    _InIter
    money_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, bool __intl, ios_base& __io,
    ios_base::iostate& __err, string_type& __units) const
    {
      typedef typename string::size_type size_type;
      const locale& __loc = __io._M_getloc();
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);
      string __str;
      const iter_type __ret = __intl ? _M_extract<true>(__beg, __end, __io,
       __err, __str)
                              : _M_extract<false>(__beg, __end, __io,
        __err, __str);
      const size_type __len = __str.size();
      if (__len)
 {
   _CharT* __ws = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
              * __len));
   __ctype.widen(__str.data(), __str.data() + __len, __ws);
   __units.assign(__ws, __len);
 }
      return __ret;
    }
  template<typename _CharT, typename _OutIter>
    template<bool _Intl>
      _OutIter
      money_put<_CharT, _OutIter>::
      _M_insert(iter_type __s, ios_base& __io, char_type __fill,
  const string_type& __digits) const
      {
 typedef typename string_type::size_type size_type;
 typedef money_base::part part;
 typedef __moneypunct_cache<_CharT, _Intl> __cache_type;
 const locale& __loc = __io._M_getloc();
 const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);
 __use_cache<__cache_type> __uc;
 const __cache_type* __lc = __uc(__loc);
 const char_type* __lit = __lc->_M_atoms;
 const char_type* __beg = __digits.data();
 money_base::pattern __p;
 const char_type* __sign;
 size_type __sign_size;
 if (!(*__beg == __lit[money_base::_S_minus]))
   {
     __p = __lc->_M_pos_format;
     __sign = __lc->_M_positive_sign;
     __sign_size = __lc->_M_positive_sign_size;
   }
 else
   {
     __p = __lc->_M_neg_format;
     __sign = __lc->_M_negative_sign;
     __sign_size = __lc->_M_negative_sign_size;
     if (__digits.size())
       ++__beg;
   }
 size_type __len = __ctype.scan_not(ctype_base::digit, __beg,
        __beg + __digits.size()) - __beg;
 if (__len)
   {
     string_type __value;
     __value.reserve(2 * __len);
     int __paddec = __len - __lc->_M_frac_digits;
     if (__paddec > 0)
         {
  if (__lc->_M_frac_digits < 0)
    __paddec = __len;
    if (__lc->_M_grouping_size)
      {
      _CharT* __ws =
          static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
             * 2 * __len));
        _CharT* __ws_end =
        std::__add_grouping(__ws, __lc->_M_thousands_sep,
       __lc->_M_grouping,
       __lc->_M_grouping_size,
       __beg, __beg + __paddec);
      __value.assign(__ws, __ws_end - __ws);
      }
    else
    __value.assign(__beg, __paddec);
       }
     if (__lc->_M_frac_digits > 0)
       {
  __value += __lc->_M_decimal_point;
  if (__paddec >= 0)
    __value.append(__beg + __paddec, __lc->_M_frac_digits);
  else
    {
      __value.append(-__paddec, __lit[money_base::_S_zero]);
      __value.append(__beg, __len);
    }
         }
     const ios_base::fmtflags __f = __io.flags()
                                    & ios_base::adjustfield;
     __len = __value.size() + __sign_size;
     __len += ((__io.flags() & ios_base::showbase)
        ? __lc->_M_curr_symbol_size : 0);
     string_type __res;
     __res.reserve(2 * __len);
     const size_type __width = static_cast<size_type>(__io.width());
     const bool __testipad = (__f == ios_base::internal
         && __len < __width);
     for (int __i = 0; __i < 4; ++__i)
       {
  const part __which = static_cast<part>(__p.field[__i]);
  switch (__which)
    {
    case money_base::symbol:
      if (__io.flags() & ios_base::showbase)
        __res.append(__lc->_M_curr_symbol,
       __lc->_M_curr_symbol_size);
      break;
    case money_base::sign:
      if (__sign_size)
        __res += __sign[0];
      break;
    case money_base::value:
      __res += __value;
      break;
    case money_base::space:
      if (__testipad)
        __res.append(__width - __len, __fill);
      else
        __res += __fill;
      break;
    case money_base::none:
      if (__testipad)
        __res.append(__width - __len, __fill);
      break;
    }
       }
     if (__sign_size > 1)
       __res.append(__sign + 1, __sign_size - 1);
     __len = __res.size();
     if (__width > __len)
       {
  if (__f == ios_base::left)
    __res.append(__width - __len, __fill);
  else
    __res.insert(0, __width - __len, __fill);
  __len = __width;
       }
     __s = std::__write(__s, __res.data(), __len);
   }
 __io.width(0);
 return __s;
      }
  template<typename _CharT, typename _OutIter>
    _OutIter
    money_put<_CharT, _OutIter>::
    do_put(iter_type __s, bool __intl, ios_base& __io, char_type __fill,
    long double __units) const
    {
      const locale __loc = __io.getloc();
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);
      int __cs_size = 64;
      char* __cs = static_cast<char*>(__builtin_alloca(__cs_size));
      int __len = std::__convert_from_v(__cs, __cs_size, "%.*Lf", __units,
     _S_get_c_locale(), 0);
      if (__len >= __cs_size)
 {
   __cs_size = __len + 1;
   __cs = static_cast<char*>(__builtin_alloca(__cs_size));
   __len = std::__convert_from_v(__cs, __cs_size, "%.*Lf", __units,
     _S_get_c_locale(), 0);
 }
      _CharT* __ws = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * __cs_size));
      __ctype.widen(__cs, __cs + __len, __ws);
      const string_type __digits(__ws, __len);
      return __intl ? _M_insert<true>(__s, __io, __fill, __digits)
             : _M_insert<false>(__s, __io, __fill, __digits);
    }
  template<typename _CharT, typename _OutIter>
    _OutIter
    money_put<_CharT, _OutIter>::
    do_put(iter_type __s, bool __intl, ios_base& __io, char_type __fill,
    const string_type& __digits) const
    { return __intl ? _M_insert<true>(__s, __io, __fill, __digits)
             : _M_insert<false>(__s, __io, __fill, __digits); }
  template<typename _CharT, typename _InIter>
    time_base::dateorder
    time_get<_CharT, _InIter>::do_date_order() const
    { return time_base::no_order; }
  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    _M_extract_via_format(iter_type __beg, iter_type __end, ios_base& __io,
     ios_base::iostate& __err, tm* __tm,
     const _CharT* __format) const
    {
      const locale& __loc = __io._M_getloc();
      const __timepunct<_CharT>& __tp = use_facet<__timepunct<_CharT> >(__loc);
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);
      const size_t __len = char_traits<_CharT>::length(__format);
      for (size_t __i = 0; __beg != __end && __i < __len && !__err; ++__i)
 {
   if (__ctype.narrow(__format[__i], 0) == '%')
     {
       char __c = __ctype.narrow(__format[++__i], 0);
       int __mem = 0;
       if (__c == 'E' || __c == 'O')
  __c = __ctype.narrow(__format[++__i], 0);
       switch (__c)
  {
    const char* __cs;
    _CharT __wcs[10];
  case 'a':
    const char_type* __days1[7];
    __tp._M_days_abbreviated(__days1);
    __beg = _M_extract_name(__beg, __end, __tm->tm_wday, __days1,
       7, __io, __err);
    break;
  case 'A':
    const char_type* __days2[7];
    __tp._M_days(__days2);
    __beg = _M_extract_name(__beg, __end, __tm->tm_wday, __days2,
       7, __io, __err);
    break;
  case 'h':
  case 'b':
    const char_type* __months1[12];
    __tp._M_months_abbreviated(__months1);
    __beg = _M_extract_name(__beg, __end, __tm->tm_mon,
       __months1, 12, __io, __err);
    break;
  case 'B':
    const char_type* __months2[12];
    __tp._M_months(__months2);
    __beg = _M_extract_name(__beg, __end, __tm->tm_mon,
       __months2, 12, __io, __err);
    break;
  case 'c':
    const char_type* __dt[2];
    __tp._M_date_time_formats(__dt);
    __beg = _M_extract_via_format(__beg, __end, __io, __err,
      __tm, __dt[0]);
    break;
  case 'd':
    __beg = _M_extract_num(__beg, __end, __tm->tm_mday, 1, 31, 2,
      __io, __err);
    break;
  case 'e':
    if (__ctype.is(ctype_base::space, *__beg))
      __beg = _M_extract_num(++__beg, __end, __tm->tm_mday, 1, 9,
        1, __io, __err);
    else
      __beg = _M_extract_num(__beg, __end, __tm->tm_mday, 10, 31,
        2, __io, __err);
    break;
  case 'D':
    __cs = "%m/%d/%y";
    __ctype.widen(__cs, __cs + 9, __wcs);
    __beg = _M_extract_via_format(__beg, __end, __io, __err,
      __tm, __wcs);
    break;
  case 'H':
    __beg = _M_extract_num(__beg, __end, __tm->tm_hour, 0, 23, 2,
      __io, __err);
    break;
  case 'I':
    __beg = _M_extract_num(__beg, __end, __tm->tm_hour, 1, 12, 2,
      __io, __err);
    break;
  case 'm':
    __beg = _M_extract_num(__beg, __end, __mem, 1, 12, 2,
      __io, __err);
    if (!__err)
      __tm->tm_mon = __mem - 1;
    break;
  case 'M':
    __beg = _M_extract_num(__beg, __end, __tm->tm_min, 0, 59, 2,
      __io, __err);
    break;
  case 'n':
    if (__ctype.narrow(*__beg, 0) == '\n')
      ++__beg;
    else
      __err |= ios_base::failbit;
    break;
  case 'R':
    __cs = "%H:%M";
    __ctype.widen(__cs, __cs + 6, __wcs);
    __beg = _M_extract_via_format(__beg, __end, __io, __err,
      __tm, __wcs);
    break;
  case 'S':
    __beg = _M_extract_num(__beg, __end, __tm->tm_sec, 0, 60, 2,
      __io, __err);
    break;
  case 't':
    if (__ctype.narrow(*__beg, 0) == '\t')
      ++__beg;
    else
      __err |= ios_base::failbit;
    break;
  case 'T':
    __cs = "%H:%M:%S";
    __ctype.widen(__cs, __cs + 9, __wcs);
    __beg = _M_extract_via_format(__beg, __end, __io, __err,
      __tm, __wcs);
    break;
  case 'x':
    const char_type* __dates[2];
    __tp._M_date_formats(__dates);
    __beg = _M_extract_via_format(__beg, __end, __io, __err,
      __tm, __dates[0]);
    break;
  case 'X':
    const char_type* __times[2];
    __tp._M_time_formats(__times);
    __beg = _M_extract_via_format(__beg, __end, __io, __err,
      __tm, __times[0]);
    break;
  case 'y':
  case 'C':
    __beg = _M_extract_num(__beg, __end, __tm->tm_year, 0, 99, 2,
      __io, __err);
    break;
  case 'Y':
    __beg = _M_extract_num(__beg, __end, __mem, 0, 9999, 4,
      __io, __err);
    if (!__err)
      __tm->tm_year = __mem - 1900;
    break;
  case 'Z':
    if (__ctype.is(ctype_base::upper, *__beg))
      {
        int __tmp;
        __beg = _M_extract_name(__beg, __end, __tmp,
           __timepunct_cache<_CharT>::_S_timezones,
           14, __io, __err);
        if (__beg != __end && !__err && __tmp == 0
     && (*__beg == __ctype.widen('-')
         || *__beg == __ctype.widen('+')))
   {
     __beg = _M_extract_num(__beg, __end, __tmp, 0, 23, 2,
       __io, __err);
     __beg = _M_extract_num(__beg, __end, __tmp, 0, 59, 2,
       __io, __err);
   }
      }
    else
      __err |= ios_base::failbit;
    break;
  default:
    __err |= ios_base::failbit;
  }
     }
   else
     {
       if (__format[__i] == *__beg)
  ++__beg;
       else
  __err |= ios_base::failbit;
     }
 }
      return __beg;
    }
  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    _M_extract_num(iter_type __beg, iter_type __end, int& __member,
     int __min, int __max, size_t __len,
     ios_base& __io, ios_base::iostate& __err) const
    {
      const locale& __loc = __io._M_getloc();
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);
      int __mult = __len == 2 ? 10 : (__len == 4 ? 1000 : 1);
      ++__min;
      size_t __i = 0;
      int __value = 0;
      for (; __beg != __end && __i < __len; ++__beg, ++__i)
 {
   const char __c = __ctype.narrow(*__beg, '*');
   if (__c >= '0' && __c <= '9')
     {
       __value = __value * 10 + (__c - '0');
       const int __valuec = __value * __mult;
       if (__valuec > __max || __valuec + __mult < __min)
  break;
       __mult /= 10;
     }
   else
     break;
 }
      if (__i == __len)
 __member = __value;
      else
 __err |= ios_base::failbit;
      return __beg;
    }
  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    _M_extract_name(iter_type __beg, iter_type __end, int& __member,
      const _CharT** __names, size_t __indexlen,
      ios_base& __io, ios_base::iostate& __err) const
    {
      typedef char_traits<_CharT> __traits_type;
      const locale& __loc = __io._M_getloc();
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);
      int* __matches = static_cast<int*>(__builtin_alloca(sizeof(int)
         * __indexlen));
      size_t __nmatches = 0;
      size_t __pos = 0;
      bool __testvalid = true;
      const char_type* __name;
      if (__beg != __end)
 {
   const char_type __c = *__beg;
   for (size_t __i1 = 0; __i1 < __indexlen; ++__i1)
     if (__c == __names[__i1][0]
  || __c == __ctype.toupper(__names[__i1][0]))
       __matches[__nmatches++] = __i1;
 }
      while (__nmatches > 1)
 {
   size_t __minlen = __traits_type::length(__names[__matches[0]]);
   for (size_t __i2 = 1; __i2 < __nmatches; ++__i2)
     __minlen = std::min(__minlen,
         __traits_type::length(__names[__matches[__i2]]));
   ++__beg, ++__pos;
   if (__pos < __minlen && __beg != __end)
     for (size_t __i3 = 0; __i3 < __nmatches;)
       {
  __name = __names[__matches[__i3]];
  if (!(__name[__pos] == *__beg))
    __matches[__i3] = __matches[--__nmatches];
  else
    ++__i3;
       }
   else
     break;
 }
      if (__nmatches == 1)
 {
   ++__beg, ++__pos;
   __name = __names[__matches[0]];
   const size_t __len = __traits_type::length(__name);
   while (__pos < __len && __beg != __end && __name[__pos] == *__beg)
     ++__beg, ++__pos;
   if (__len == __pos)
     __member = __matches[0];
   else
     __testvalid = false;
 }
      else
 __testvalid = false;
      if (!__testvalid)
 __err |= ios_base::failbit;
      return __beg;
    }
  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    do_get_time(iter_type __beg, iter_type __end, ios_base& __io,
  ios_base::iostate& __err, tm* __tm) const
    {
      const locale& __loc = __io._M_getloc();
      const __timepunct<_CharT>& __tp = use_facet<__timepunct<_CharT> >(__loc);
      const char_type* __times[2];
      __tp._M_time_formats(__times);
      __beg = _M_extract_via_format(__beg, __end, __io, __err,
        __tm, __times[0]);
      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }
  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    do_get_date(iter_type __beg, iter_type __end, ios_base& __io,
  ios_base::iostate& __err, tm* __tm) const
    {
      const locale& __loc = __io._M_getloc();
      const __timepunct<_CharT>& __tp = use_facet<__timepunct<_CharT> >(__loc);
      const char_type* __dates[2];
      __tp._M_date_formats(__dates);
      __beg = _M_extract_via_format(__beg, __end, __io, __err,
        __tm, __dates[0]);
      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }
  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    do_get_weekday(iter_type __beg, iter_type __end, ios_base& __io,
     ios_base::iostate& __err, tm* __tm) const
    {
      typedef char_traits<_CharT> __traits_type;
      const locale& __loc = __io._M_getloc();
      const __timepunct<_CharT>& __tp = use_facet<__timepunct<_CharT> >(__loc);
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);
      const char_type* __days[7];
      __tp._M_days_abbreviated(__days);
      int __tmpwday;
      __beg = _M_extract_name(__beg, __end, __tmpwday, __days, 7, __io, __err);
      if (!__err && __beg != __end)
 {
   size_t __pos = __traits_type::length(__days[__tmpwday]);
   __tp._M_days(__days);
   const char_type* __name = __days[__tmpwday];
   if (__name[__pos] == *__beg)
     {
       const size_t __len = __traits_type::length(__name);
       while (__pos < __len && __beg != __end
       && __name[__pos] == *__beg)
  ++__beg, ++__pos;
       if (__len != __pos)
  __err |= ios_base::failbit;
     }
 }
      if (!__err)
 __tm->tm_wday = __tmpwday;
      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
     }
  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    do_get_monthname(iter_type __beg, iter_type __end,
                     ios_base& __io, ios_base::iostate& __err, tm* __tm) const
    {
      typedef char_traits<_CharT> __traits_type;
      const locale& __loc = __io._M_getloc();
      const __timepunct<_CharT>& __tp = use_facet<__timepunct<_CharT> >(__loc);
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);
      const char_type* __months[12];
      __tp._M_months_abbreviated(__months);
      int __tmpmon;
      __beg = _M_extract_name(__beg, __end, __tmpmon, __months, 12,
         __io, __err);
      if (!__err && __beg != __end)
 {
   size_t __pos = __traits_type::length(__months[__tmpmon]);
   __tp._M_months(__months);
   const char_type* __name = __months[__tmpmon];
   if (__name[__pos] == *__beg)
     {
       const size_t __len = __traits_type::length(__name);
       while (__pos < __len && __beg != __end
       && __name[__pos] == *__beg)
  ++__beg, ++__pos;
       if (__len != __pos)
  __err |= ios_base::failbit;
     }
 }
      if (!__err)
 __tm->tm_mon = __tmpmon;
      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }
  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    do_get_year(iter_type __beg, iter_type __end, ios_base& __io,
  ios_base::iostate& __err, tm* __tm) const
    {
      const locale& __loc = __io._M_getloc();
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);
      size_t __i = 0;
      int __value = 0;
      for (; __beg != __end && __i < 4; ++__beg, ++__i)
 {
   const char __c = __ctype.narrow(*__beg, '*');
   if (__c >= '0' && __c <= '9')
     __value = __value * 10 + (__c - '0');
   else
     break;
 }
      if (__i == 2 || __i == 4)
 __tm->tm_year = __i == 2 ? __value : __value - 1900;
      else
 __err |= ios_base::failbit;
      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }
  template<typename _CharT, typename _OutIter>
    _OutIter
    time_put<_CharT, _OutIter>::
    put(iter_type __s, ios_base& __io, char_type __fill, const tm* __tm,
 const _CharT* __beg, const _CharT* __end) const
    {
      const locale& __loc = __io._M_getloc();
      ctype<_CharT> const& __ctype = use_facet<ctype<_CharT> >(__loc);
      for (; __beg != __end; ++__beg)
 if (__ctype.narrow(*__beg, 0) != '%')
   {
     *__s = *__beg;
     ++__s;
   }
 else if (++__beg != __end)
   {
     char __format;
     char __mod = 0;
     const char __c = __ctype.narrow(*__beg, 0);
     if (__c != 'E' && __c != 'O')
       __format = __c;
     else if (++__beg != __end)
       {
  __mod = __c;
  __format = __ctype.narrow(*__beg, 0);
       }
     else
       break;
     __s = this->do_put(__s, __io, __fill, __tm, __format, __mod);
   }
 else
   break;
      return __s;
    }
  template<typename _CharT, typename _OutIter>
    _OutIter
    time_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type, const tm* __tm,
    char __format, char __mod) const
    {
      const locale& __loc = __io._M_getloc();
      ctype<_CharT> const& __ctype = use_facet<ctype<_CharT> >(__loc);
      __timepunct<_CharT> const& __tp = use_facet<__timepunct<_CharT> >(__loc);
      const size_t __maxlen = 128;
      char_type* __res =
       static_cast<char_type*>(__builtin_alloca(sizeof(char_type) * __maxlen));
      char_type __fmt[4];
      __fmt[0] = __ctype.widen('%');
      if (!__mod)
 {
   __fmt[1] = __format;
   __fmt[2] = char_type();
 }
      else
 {
   __fmt[1] = __mod;
   __fmt[2] = __format;
   __fmt[3] = char_type();
 }
      __tp._M_put(__res, __maxlen, __fmt, __tm);
      return std::__write(__s, __res, char_traits<char_type>::length(__res));
    }
  template<typename _CharT>
    int
    collate<_CharT>::_M_compare(const _CharT*, const _CharT*) const
    { return 0; }
  template<typename _CharT>
    size_t
    collate<_CharT>::_M_transform(_CharT*, const _CharT*, size_t) const
    { return 0; }
  template<typename _CharT>
    int
    collate<_CharT>::
    do_compare(const _CharT* __lo1, const _CharT* __hi1,
        const _CharT* __lo2, const _CharT* __hi2) const
    {
      const string_type __one(__lo1, __hi1);
      const string_type __two(__lo2, __hi2);
      const _CharT* __p = __one.c_str();
      const _CharT* __pend = __one.data() + __one.length();
      const _CharT* __q = __two.c_str();
      const _CharT* __qend = __two.data() + __two.length();
      for (;;)
 {
   const int __res = _M_compare(__p, __q);
   if (__res)
     return __res;
   __p += char_traits<_CharT>::length(__p);
   __q += char_traits<_CharT>::length(__q);
   if (__p == __pend && __q == __qend)
     return 0;
   else if (__p == __pend)
     return -1;
   else if (__q == __qend)
     return 1;
   __p++;
   __q++;
 }
    }
  template<typename _CharT>
    typename collate<_CharT>::string_type
    collate<_CharT>::
    do_transform(const _CharT* __lo, const _CharT* __hi) const
    {
      string_type __str(__lo, __hi);
      const _CharT* __p = __str.c_str();
      const _CharT* __pend = __str.data() + __str.length();
      size_t __len = (__hi - __lo) * 2;
      string_type __ret;
      for (;;)
 {
   _CharT* __c =
     static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT) * __len));
   size_t __res = _M_transform(__c, __p, __len);
   if (__res >= __len)
     {
       __len = __res + 1;
       __c = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
         * __len));
       __res = _M_transform(__c, __p, __len);
     }
   __ret.append(__c, __res);
   __p += char_traits<_CharT>::length(__p);
   if (__p == __pend)
     return __ret;
   __p++;
   __ret.push_back(_CharT());
 }
    }
  template<typename _CharT>
    long
    collate<_CharT>::
    do_hash(const _CharT* __lo, const _CharT* __hi) const
    {
      unsigned long __val = 0;
      for (; __lo < __hi; ++__lo)
 __val = *__lo + ((__val << 7) |
         (__val >> (numeric_limits<unsigned long>::digits - 7)));
      return static_cast<long>(__val);
    }
  template<typename _CharT, typename _Traits>
    void
    __pad<_CharT, _Traits>::_S_pad(ios_base& __io, _CharT __fill,
       _CharT* __news, const _CharT* __olds,
       const streamsize __newlen,
       const streamsize __oldlen, const bool __num)
    {
      const size_t __plen = static_cast<size_t>(__newlen - __oldlen);
      const ios_base::fmtflags __adjust = __io.flags() & ios_base::adjustfield;
      if (__adjust == ios_base::left)
 {
   _Traits::copy(__news, const_cast<_CharT*>(__olds), __oldlen);
   _Traits::assign(__news + __oldlen, __plen, __fill);
   return;
 }
      size_t __mod = 0;
      if (__adjust == ios_base::internal && __num)
 {
          const locale& __loc = __io._M_getloc();
   const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);
   const bool __testsign = (__ctype.widen('-') == __olds[0]
       || __ctype.widen('+') == __olds[0]);
   const bool __testhex = (__ctype.widen('0') == __olds[0]
      && __oldlen > 1
      && (__ctype.widen('x') == __olds[1]
          || __ctype.widen('X') == __olds[1]));
   if (__testhex)
     {
       __news[0] = __olds[0];
       __news[1] = __olds[1];
       __mod = 2;
       __news += 2;
     }
   else if (__testsign)
     {
       __news[0] = __olds[0];
       __mod = 1;
       ++__news;
     }
 }
      _Traits::assign(__news, __plen, __fill);
      _Traits::copy(__news + __plen, const_cast<_CharT*>(__olds + __mod),
      __oldlen - __mod);
    }
  bool
  __verify_grouping(const char* __grouping, size_t __grouping_size,
      const string& __grouping_tmp)
  {
    const size_t __n = __grouping_tmp.size() - 1;
    const size_t __min = std::min(__n, size_t(__grouping_size - 1));
    size_t __i = __n;
    bool __test = true;
    for (size_t __j = 0; __j < __min && __test; --__i, ++__j)
      __test = __grouping_tmp[__i] == __grouping[__j];
    for (; __i && __test; --__i)
      __test = __grouping_tmp[__i] == __grouping[__min];
    if (static_cast<signed char>(__grouping[__min]) > 0)
      __test &= __grouping_tmp[0] <= __grouping[__min];
    return __test;
  }
  template<typename _CharT>
    _CharT*
    __add_grouping(_CharT* __s, _CharT __sep,
     const char* __gbeg, size_t __gsize,
     const _CharT* __first, const _CharT* __last)
    {
      if (__last - __first > *__gbeg
   && static_cast<signed char>(*__gbeg) > 0)
 {
   const bool __bump = __gsize != 1;
   __s = std::__add_grouping(__s, __sep, __gbeg + __bump,
        __gsize - __bump, __first,
        __last - *__gbeg);
   __first = __last - *__gbeg;
   *__s++ = __sep;
 }
      do
 *__s++ = *__first++;
      while (__first != __last);
      return __s;
    }
  extern template class moneypunct<char, false>;
  extern template class moneypunct<char, true>;
  extern template class moneypunct_byname<char, false>;
  extern template class moneypunct_byname<char, true>;
  extern template class money_get<char>;
  extern template class money_put<char>;
  extern template class numpunct<char>;
  extern template class numpunct_byname<char>;
  extern template class num_get<char>;
  extern template class num_put<char>;
  extern template class __timepunct<char>;
  extern template class time_put<char>;
  extern template class time_put_byname<char>;
  extern template class time_get<char>;
  extern template class time_get_byname<char>;
  extern template class messages<char>;
  extern template class messages_byname<char>;
  extern template class ctype_byname<char>;
  extern template class codecvt_byname<char, char, mbstate_t>;
  extern template class collate<char>;
  extern template class collate_byname<char>;
  extern template
    const codecvt<char, char, mbstate_t>&
    use_facet<codecvt<char, char, mbstate_t> >(const locale&);
  extern template
    const collate<char>&
    use_facet<collate<char> >(const locale&);
  extern template
    const numpunct<char>&
    use_facet<numpunct<char> >(const locale&);
  extern template
    const num_put<char>&
    use_facet<num_put<char> >(const locale&);
  extern template
    const num_get<char>&
    use_facet<num_get<char> >(const locale&);
  extern template
    const moneypunct<char, true>&
    use_facet<moneypunct<char, true> >(const locale&);
  extern template
    const moneypunct<char, false>&
    use_facet<moneypunct<char, false> >(const locale&);
  extern template
    const money_put<char>&
    use_facet<money_put<char> >(const locale&);
  extern template
    const money_get<char>&
    use_facet<money_get<char> >(const locale&);
  extern template
    const __timepunct<char>&
    use_facet<__timepunct<char> >(const locale&);
  extern template
    const time_put<char>&
    use_facet<time_put<char> >(const locale&);
  extern template
    const time_get<char>&
    use_facet<time_get<char> >(const locale&);
  extern template
    const messages<char>&
    use_facet<messages<char> >(const locale&);
  extern template
    bool
    has_facet<ctype<char> >(const locale&);
  extern template
    bool
    has_facet<codecvt<char, char, mbstate_t> >(const locale&);
  extern template
    bool
    has_facet<collate<char> >(const locale&);
  extern template
    bool
    has_facet<numpunct<char> >(const locale&);
  extern template
    bool
    has_facet<num_put<char> >(const locale&);
  extern template
    bool
    has_facet<num_get<char> >(const locale&);
  extern template
    bool
    has_facet<moneypunct<char> >(const locale&);
  extern template
    bool
    has_facet<money_put<char> >(const locale&);
  extern template
    bool
    has_facet<money_get<char> >(const locale&);
  extern template
    bool
    has_facet<__timepunct<char> >(const locale&);
  extern template
    bool
    has_facet<time_put<char> >(const locale&);
  extern template
    bool
    has_facet<time_get<char> >(const locale&);
  extern template
    bool
    has_facet<messages<char> >(const locale&);
  extern template class moneypunct<wchar_t, false>;
  extern template class moneypunct<wchar_t, true>;
  extern template class moneypunct_byname<wchar_t, false>;
  extern template class moneypunct_byname<wchar_t, true>;
  extern template class money_get<wchar_t>;
  extern template class money_put<wchar_t>;
  extern template class numpunct<wchar_t>;
  extern template class numpunct_byname<wchar_t>;
  extern template class num_get<wchar_t>;
  extern template class num_put<wchar_t>;
  extern template class __timepunct<wchar_t>;
  extern template class time_put<wchar_t>;
  extern template class time_put_byname<wchar_t>;
  extern template class time_get<wchar_t>;
  extern template class time_get_byname<wchar_t>;
  extern template class messages<wchar_t>;
  extern template class messages_byname<wchar_t>;
  extern template class ctype_byname<wchar_t>;
  extern template class codecvt_byname<wchar_t, char, mbstate_t>;
  extern template class collate<wchar_t>;
  extern template class collate_byname<wchar_t>;
  extern template
    const codecvt<wchar_t, char, mbstate_t>&
    use_facet<codecvt<wchar_t, char, mbstate_t> >(locale const&);
  extern template
    const collate<wchar_t>&
    use_facet<collate<wchar_t> >(const locale&);
  extern template
    const numpunct<wchar_t>&
    use_facet<numpunct<wchar_t> >(const locale&);
  extern template
    const num_put<wchar_t>&
    use_facet<num_put<wchar_t> >(const locale&);
  extern template
    const num_get<wchar_t>&
    use_facet<num_get<wchar_t> >(const locale&);
  extern template
    const moneypunct<wchar_t, true>&
    use_facet<moneypunct<wchar_t, true> >(const locale&);
  extern template
    const moneypunct<wchar_t, false>&
    use_facet<moneypunct<wchar_t, false> >(const locale&);
  extern template
    const money_put<wchar_t>&
    use_facet<money_put<wchar_t> >(const locale&);
  extern template
    const money_get<wchar_t>&
    use_facet<money_get<wchar_t> >(const locale&);
  extern template
    const __timepunct<wchar_t>&
    use_facet<__timepunct<wchar_t> >(const locale&);
  extern template
    const time_put<wchar_t>&
    use_facet<time_put<wchar_t> >(const locale&);
  extern template
    const time_get<wchar_t>&
    use_facet<time_get<wchar_t> >(const locale&);
  extern template
    const messages<wchar_t>&
    use_facet<messages<wchar_t> >(const locale&);
 extern template
    bool
    has_facet<ctype<wchar_t> >(const locale&);
  extern template
    bool
    has_facet<codecvt<wchar_t, char, mbstate_t> >(const locale&);
  extern template
    bool
    has_facet<collate<wchar_t> >(const locale&);
  extern template
    bool
    has_facet<numpunct<wchar_t> >(const locale&);
  extern template
    bool
    has_facet<num_put<wchar_t> >(const locale&);
  extern template
    bool
    has_facet<num_get<wchar_t> >(const locale&);
  extern template
    bool
    has_facet<moneypunct<wchar_t> >(const locale&);
  extern template
    bool
    has_facet<money_put<wchar_t> >(const locale&);
  extern template
    bool
    has_facet<money_get<wchar_t> >(const locale&);
  extern template
    bool
    has_facet<__timepunct<wchar_t> >(const locale&);
  extern template
    bool
    has_facet<time_put<wchar_t> >(const locale&);
  extern template
    bool
    has_facet<time_get<wchar_t> >(const locale&);
  extern template
    bool
    has_facet<messages<wchar_t> >(const locale&);
}
namespace std
{
  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>::sentry::
    sentry(basic_ostream<_CharT, _Traits>& __os)
    : _M_ok(false), _M_os(__os)
    {
      if (__os.tie() && __os.good())
 __os.tie()->flush();
      if (__os.good())
 _M_ok = true;
      else
 __os.setstate(ios_base::failbit);
    }
  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(__ostream_type& (*__pf)(__ostream_type&))
    {
      return __pf(*this);
    }
  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(__ios_type& (*__pf)(__ios_type&))
    {
      __pf(*this);
      return *this;
    }
  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(ios_base& (*__pf)(ios_base&))
    {
      __pf(*this);
      return *this;
    }
  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(bool __n)
    {
      sentry __cerb(*this);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       const __num_put_type& __np = __check_facet(this->_M_num_put);
       if (__np.put(*this, *this, this->fill(), __n).failed())
  __err |= ios_base::badbit;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }
  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(short __n)
    {
      sentry __cerb(*this);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       long __l;
       const ios_base::fmtflags __fmt = (this->flags()
      & ios_base::basefield);
       if (__fmt == ios_base::oct || __fmt == ios_base::hex)
  __l = static_cast<long>(static_cast<unsigned short>(__n));
       else
  __l = static_cast<long>(__n);
       const __num_put_type& __np = __check_facet(this->_M_num_put);
       if (__np.put(*this, *this, this->fill(), __l).failed())
  __err |= ios_base::badbit;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }
  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(unsigned short __n)
    {
      sentry __cerb(*this);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       const __num_put_type& __np = __check_facet(this->_M_num_put);
       if (__np.put(*this, *this, this->fill(),
      static_cast<unsigned long>(__n)).failed())
  __err |= ios_base::badbit;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }
  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(int __n)
    {
      sentry __cerb(*this);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       long __l;
       const ios_base::fmtflags __fmt = (this->flags()
      & ios_base::basefield);
       if (__fmt == ios_base::oct || __fmt == ios_base::hex)
  __l = static_cast<long>(static_cast<unsigned int>(__n));
       else
  __l = static_cast<long>(__n);
       const __num_put_type& __np = __check_facet(this->_M_num_put);
       if (__np.put(*this, *this, this->fill(), __l).failed())
  __err |= ios_base::badbit;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }
  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(unsigned int __n)
    {
      sentry __cerb(*this);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       const __num_put_type& __np = __check_facet(this->_M_num_put);
       if (__np.put(*this, *this, this->fill(),
      static_cast<unsigned long>(__n)).failed())
  __err |= ios_base::badbit;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }
  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(long __n)
    {
      sentry __cerb(*this);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       const __num_put_type& __np = __check_facet(this->_M_num_put);
       if (__np.put(*this, *this, this->fill(), __n).failed())
  __err |= ios_base::badbit;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }
  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(unsigned long __n)
    {
      sentry __cerb(*this);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       const __num_put_type& __np = __check_facet(this->_M_num_put);
       if (__np.put(*this, *this, this->fill(), __n).failed())
  __err |= ios_base::badbit;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }
  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(long long __n)
    {
      sentry __cerb(*this);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       const __num_put_type& __np = __check_facet(this->_M_num_put);
       if (__np.put(*this, *this, this->fill(), __n).failed())
  __err |= ios_base::badbit;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }
  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(unsigned long long __n)
    {
      sentry __cerb(*this);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       const __num_put_type& __np = __check_facet(this->_M_num_put);
       if (__np.put(*this, *this, this->fill(), __n).failed())
  __err |= ios_base::badbit;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }
  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(float __n)
    {
      sentry __cerb(*this);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       const __num_put_type& __np = __check_facet(this->_M_num_put);
       if (__np.put(*this, *this, this->fill(),
      static_cast<double>(__n)).failed())
  __err |= ios_base::badbit;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }
  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(double __n)
    {
      sentry __cerb(*this);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       const __num_put_type& __np = __check_facet(this->_M_num_put);
       if (__np.put(*this, *this, this->fill(), __n).failed())
  __err |= ios_base::badbit;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }
  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(long double __n)
    {
      sentry __cerb(*this);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       const __num_put_type& __np = __check_facet(this->_M_num_put);
       if (__np.put(*this, *this, this->fill(), __n).failed())
  __err |= ios_base::badbit;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }
  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(const void* __n)
    {
      sentry __cerb(*this);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       const __num_put_type& __np = __check_facet(this->_M_num_put);
       if (__np.put(*this, *this, this->fill(), __n).failed())
  __err |= ios_base::badbit;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }
  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(__streambuf_type* __sbin)
    {
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      sentry __cerb(*this);
      if (__cerb && __sbin)
 {
   try
     {
       if (!__copy_streambufs(__sbin, this->rdbuf()))
  __err |= ios_base::failbit;
     }
   catch(...)
     { this->_M_setstate(ios_base::failbit); }
 }
      else if (!__sbin)
 __err |= ios_base::badbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }
  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    put(char_type __c)
    {
      sentry __cerb(*this);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       const int_type __put = this->rdbuf()->sputc(__c);
       if (traits_type::eq_int_type(__put, traits_type::eof()))
  __err |= ios_base::badbit;
     }
   catch (...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }
  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    write(const _CharT* __s, streamsize __n)
    {
      sentry __cerb(*this);
      if (__cerb)
 {
   try
     { _M_write(__s, __n); }
   catch (...)
     { this->_M_setstate(ios_base::badbit); }
 }
      return *this;
    }
  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    flush()
    {
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      try
 {
   if (this->rdbuf() && this->rdbuf()->pubsync() == -1)
     __err |= ios_base::badbit;
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      if (__err)
 this->setstate(__err);
      return *this;
    }
  template<typename _CharT, typename _Traits>
    typename basic_ostream<_CharT, _Traits>::pos_type
    basic_ostream<_CharT, _Traits>::
    tellp()
    {
      pos_type __ret = pos_type(-1);
      try
 {
   if (!this->fail())
     __ret = this->rdbuf()->pubseekoff(0, ios_base::cur, ios_base::out);
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      return __ret;
    }
  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    seekp(pos_type __pos)
    {
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      try
 {
   if (!this->fail())
     {
       const pos_type __p = this->rdbuf()->pubseekpos(__pos,
            ios_base::out);
       if (__p == pos_type(off_type(-1)))
  __err |= ios_base::failbit;
     }
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      if (__err)
 this->setstate(__err);
      return *this;
    }
  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    seekp(off_type __off, ios_base::seekdir __dir)
    {
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      try
 {
   if (!this->fail())
     {
       const pos_type __p = this->rdbuf()->pubseekoff(__off, __dir,
            ios_base::out);
       if (__p == pos_type(off_type(-1)))
  __err |= ios_base::failbit;
     }
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      if (__err)
 this->setstate(__err);
      return *this;
    }
  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, _CharT __c)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typename __ostream_type::sentry __cerb(__out);
      if (__cerb)
 {
   try
     {
       const streamsize __w = __out.width();
       streamsize __len = 1;
       _CharT* __cs = &__c;
       if (__w > __len)
  {
    __cs = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
              * __w));
    __pad<_CharT, _Traits>::_S_pad(__out, __out.fill(), __cs,
       &__c, __w, __len, false);
    __len = __w;
  }
       __out._M_write(__cs, __len);
       __out.width(0);
     }
   catch(...)
     { __out._M_setstate(ios_base::badbit); }
 }
      return __out;
    }
  template <class _Traits>
    basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, char __c)
    {
      typedef basic_ostream<char, _Traits> __ostream_type;
      typename __ostream_type::sentry __cerb(__out);
      if (__cerb)
 {
   try
     {
       const streamsize __w = __out.width();
       streamsize __len = 1;
       char* __cs = &__c;
       if (__w > __len)
  {
    __cs = static_cast<char*>(__builtin_alloca(__w));
    __pad<char, _Traits>::_S_pad(__out, __out.fill(), __cs,
            &__c, __w, __len, false);
    __len = __w;
  }
       __out._M_write(__cs, __len);
       __out.width(0);
     }
   catch(...)
     { __out._M_setstate(ios_base::badbit); }
 }
      return __out;
     }
  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, const _CharT* __s)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typename __ostream_type::sentry __cerb(__out);
      if (__cerb && __s)
 {
   try
     {
       const streamsize __w = __out.width();
       streamsize __len = static_cast<streamsize>(_Traits::length(__s));
       if (__w > __len)
  {
    _CharT* __cs = (static_cast<
      _CharT*>(__builtin_alloca(sizeof(_CharT)
           * __w)));
    __pad<_CharT, _Traits>::_S_pad(__out, __out.fill(), __cs,
       __s, __w, __len, false);
    __s = __cs;
    __len = __w;
  }
       __out._M_write(__s, __len);
       __out.width(0);
     }
   catch(...)
     { __out._M_setstate(ios_base::badbit); }
 }
      else if (!__s)
 __out.setstate(ios_base::badbit);
      return __out;
    }
  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, const char* __s)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef char_traits<char> __traits_type;
      typename __ostream_type::sentry __cerb(__out);
      if (__cerb && __s)
 {
   size_t __clen = __traits_type::length(__s);
   _CharT* __ws = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
              * __clen));
   for (size_t __i = 0; __i < __clen; ++__i)
     __ws[__i] = __out.widen(__s[__i]);
   _CharT* __str = __ws;
   try
     {
       const streamsize __w = __out.width();
       streamsize __len = static_cast<streamsize>(__clen);
       if (__w > __len)
  {
    _CharT* __cs = (static_cast<
      _CharT*>(__builtin_alloca(sizeof(_CharT)
           * __w)));
    __pad<_CharT, _Traits>::_S_pad(__out, __out.fill(), __cs,
       __ws, __w, __len, false);
    __str = __cs;
    __len = __w;
  }
       __out._M_write(__str, __len);
       __out.width(0);
     }
   catch(...)
     { __out._M_setstate(ios_base::badbit); }
 }
      else if (!__s)
 __out.setstate(ios_base::badbit);
      return __out;
    }
  template<class _Traits>
    basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, const char* __s)
    {
      typedef basic_ostream<char, _Traits> __ostream_type;
      typename __ostream_type::sentry __cerb(__out);
      if (__cerb && __s)
 {
   try
     {
       const streamsize __w = __out.width();
       streamsize __len = static_cast<streamsize>(_Traits::length(__s));
       if (__w > __len)
  {
    char* __cs = static_cast<char*>(__builtin_alloca(__w));
    __pad<char, _Traits>::_S_pad(__out, __out.fill(), __cs,
       __s, __w, __len, false);
    __s = __cs;
    __len = __w;
  }
       __out._M_write(__s, __len);
       __out.width(0);
     }
   catch(...)
     { __out._M_setstate(ios_base::badbit); }
 }
      else if (!__s)
 __out.setstate(ios_base::badbit);
      return __out;
    }
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out,
        const basic_string<_CharT, _Traits, _Alloc>& __str)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typename __ostream_type::sentry __cerb(__out);
      if (__cerb)
 {
   const streamsize __w = __out.width();
   streamsize __len = static_cast<streamsize>(__str.size());
   const _CharT* __s = __str.data();
   if (__w > __len)
     {
       _CharT* __cs = (static_cast<
         _CharT*>(__builtin_alloca(sizeof(_CharT) * __w)));
       __pad<_CharT, _Traits>::_S_pad(__out, __out.fill(), __cs, __s,
          __w, __len, false);
       __s = __cs;
       __len = __w;
     }
   __out._M_write(__s, __len);
   __out.width(0);
 }
      return __out;
    }
  extern template class basic_ostream<char>;
  extern template ostream& endl(ostream&);
  extern template ostream& ends(ostream&);
  extern template ostream& flush(ostream&);
  extern template ostream& operator<<(ostream&, char);
  extern template ostream& operator<<(ostream&, unsigned char);
  extern template ostream& operator<<(ostream&, signed char);
  extern template ostream& operator<<(ostream&, const char*);
  extern template ostream& operator<<(ostream&, const unsigned char*);
  extern template ostream& operator<<(ostream&, const signed char*);
  extern template class basic_ostream<wchar_t>;
  extern template wostream& endl(wostream&);
  extern template wostream& ends(wostream&);
  extern template wostream& flush(wostream&);
  extern template wostream& operator<<(wostream&, wchar_t);
  extern template wostream& operator<<(wostream&, char);
  extern template wostream& operator<<(wostream&, const wchar_t*);
  extern template wostream& operator<<(wostream&, const char*);
}
namespace std
{
  template<typename _CharT, typename _Traits>
    class basic_istream : virtual public basic_ios<_CharT, _Traits>
    {
    public:
      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;
      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef basic_ios<_CharT, _Traits> __ios_type;
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef num_get<_CharT, istreambuf_iterator<_CharT, _Traits> >
        __num_get_type;
      typedef ctype<_CharT> __ctype_type;
      template<typename _CharT2, typename _Traits2>
        friend basic_istream<_CharT2, _Traits2>&
        operator>>(basic_istream<_CharT2, _Traits2>&, _CharT2&);
      template<typename _CharT2, typename _Traits2>
        friend basic_istream<_CharT2, _Traits2>&
        operator>>(basic_istream<_CharT2, _Traits2>&, _CharT2*);
    protected:
      streamsize _M_gcount;
    public:
      explicit
      basic_istream(__streambuf_type* __sb): _M_gcount(streamsize(0))
      { this->init(__sb); }
      virtual
      ~basic_istream()
      { _M_gcount = streamsize(0); }
      class sentry;
      friend class sentry;
      inline __istream_type&
      operator>>(__istream_type& (*__pf)(__istream_type&));
      inline __istream_type&
      operator>>(__ios_type& (*__pf)(__ios_type&));
      inline __istream_type&
      operator>>(ios_base& (*__pf)(ios_base&));
      __istream_type&
      operator>>(bool& __n);
      __istream_type&
      operator>>(short& __n);
      __istream_type&
      operator>>(unsigned short& __n);
      __istream_type&
      operator>>(int& __n);
      __istream_type&
      operator>>(unsigned int& __n);
      __istream_type&
      operator>>(long& __n);
      __istream_type&
      operator>>(unsigned long& __n);
      __istream_type&
      operator>>(long long& __n);
      __istream_type&
      operator>>(unsigned long long& __n);
      __istream_type&
      operator>>(float& __f);
      __istream_type&
      operator>>(double& __f);
      __istream_type&
      operator>>(long double& __f);
      __istream_type&
      operator>>(void*& __p);
      __istream_type&
      operator>>(__streambuf_type* __sb);
      inline streamsize
      gcount() const
      { return _M_gcount; }
      int_type
      get();
      __istream_type&
      get(char_type& __c);
      __istream_type&
      get(char_type* __s, streamsize __n, char_type __delim);
      inline __istream_type&
      get(char_type* __s, streamsize __n)
      { return this->get(__s, __n, this->widen('\n')); }
      __istream_type&
      get(__streambuf_type& __sb, char_type __delim);
      inline __istream_type&
      get(__streambuf_type& __sb)
      { return this->get(__sb, this->widen('\n')); }
      __istream_type&
      getline(char_type* __s, streamsize __n, char_type __delim);
      inline __istream_type&
      getline(char_type* __s, streamsize __n)
      { return this->getline(__s, __n, this->widen('\n')); }
      __istream_type&
      ignore();
      __istream_type&
      ignore(streamsize __n);
      __istream_type&
      ignore(streamsize __n, int_type __delim);
      int_type
      peek();
      __istream_type&
      read(char_type* __s, streamsize __n);
      streamsize
      readsome(char_type* __s, streamsize __n);
      __istream_type&
      putback(char_type __c);
      __istream_type&
      unget();
      int
      sync();
      pos_type
      tellg();
      __istream_type&
      seekg(pos_type);
      __istream_type&
      seekg(off_type, ios_base::seekdir);
    protected:
      explicit
      basic_istream(): _M_gcount(streamsize(0)) { }
    };
  template<>
    basic_istream<char>&
    basic_istream<char>::
    getline(char_type* __s, streamsize __n, char_type __delim);
  template<>
    basic_istream<char>&
    basic_istream<char>::
    ignore(streamsize __n);
  template<>
    basic_istream<char>&
    basic_istream<char>::
    ignore(streamsize __n, int_type __delim);
  template<>
    basic_istream<wchar_t>&
    basic_istream<wchar_t>::
    getline(char_type* __s, streamsize __n, char_type __delim);
  template<>
    basic_istream<wchar_t>&
    basic_istream<wchar_t>::
    ignore(streamsize __n);
  template<>
    basic_istream<wchar_t>&
    basic_istream<wchar_t>::
    ignore(streamsize __n, int_type __delim);
  template<typename _CharT, typename _Traits>
    class basic_istream<_CharT, _Traits>::sentry
    {
    public:
      typedef _Traits traits_type;
      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::__ctype_type __ctype_type;
      typedef typename _Traits::int_type __int_type;
      explicit
      sentry(basic_istream<_CharT, _Traits>& __is, bool __noskipws = false);
      operator bool() const { return _M_ok; }
    private:
      bool _M_ok;
    };
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT& __c);
  template<class _Traits>
    basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, unsigned char& __c)
    { return (__in >> reinterpret_cast<char&>(__c)); }
  template<class _Traits>
    basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, signed char& __c)
    { return (__in >> reinterpret_cast<char&>(__c)); }
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT* __s);
  template<>
    basic_istream<char>&
    operator>>(basic_istream<char>& __in, char* __s);
  template<class _Traits>
    basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, unsigned char* __s)
    { return (__in >> reinterpret_cast<char*>(__s)); }
  template<class _Traits>
    basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, signed char* __s)
    { return (__in >> reinterpret_cast<char*>(__s)); }
  template<typename _CharT, typename _Traits>
    class basic_iostream
    : public basic_istream<_CharT, _Traits>,
      public basic_ostream<_CharT, _Traits>
    {
    public:
      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      explicit
      basic_iostream(basic_streambuf<_CharT, _Traits>* __sb)
      : __istream_type(), __ostream_type()
      { this->init(__sb); }
      virtual
      ~basic_iostream() { }
    protected:
      explicit
      basic_iostream() : __istream_type(), __ostream_type()
      { }
    };
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    ws(basic_istream<_CharT, _Traits>& __is);
}
namespace std
{
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>::sentry::
    sentry(basic_istream<_CharT, _Traits>& __in, bool __noskip) : _M_ok(false)
    {
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      if (__in.good())
 {
   if (__in.tie())
     __in.tie()->flush();
   if (!__noskip && (__in.flags() & ios_base::skipws))
     {
       const __int_type __eof = traits_type::eof();
       __streambuf_type* __sb = __in.rdbuf();
       __int_type __c = __sb->sgetc();
       const __ctype_type& __ct = __check_facet(__in._M_ctype);
       while (!traits_type::eq_int_type(__c, __eof)
       && __ct.is(ctype_base::space,
    traits_type::to_char_type(__c)))
  __c = __sb->snextc();
       if (traits_type::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;
     }
 }
      if (__in.good() && __err == ios_base::goodbit)
 _M_ok = true;
      else
 {
   __err |= ios_base::failbit;
   __in.setstate(__err);
 }
    }
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(__istream_type& (*__pf)(__istream_type&))
    { return __pf(*this); }
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(__ios_type& (*__pf)(__ios_type&))
    {
      __pf(*this);
      return *this;
    }
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(ios_base& (*__pf)(ios_base&))
    {
      __pf(*this);
      return *this;
    }
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(bool& __n)
    {
      sentry __cerb(*this, false);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       const __num_get_type& __ng = __check_facet(this->_M_num_get);
       __ng.get(*this, 0, *this, __err, __n);
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(short& __n)
    {
      sentry __cerb(*this, false);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       long __l;
       const __num_get_type& __ng = __check_facet(this->_M_num_get);
       __ng.get(*this, 0, *this, __err, __l);
       if (!(__err & ios_base::failbit)
    && (numeric_limits<short>::min() <= __l
        && __l <= numeric_limits<short>::max()))
  __n = __l;
       else
                __err |= ios_base::failbit;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(unsigned short& __n)
    {
      sentry __cerb(*this, false);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       const __num_get_type& __ng = __check_facet(this->_M_num_get);
       __ng.get(*this, 0, *this, __err, __n);
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(int& __n)
    {
      sentry __cerb(*this, false);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       long __l;
       const __num_get_type& __ng = __check_facet(this->_M_num_get);
       __ng.get(*this, 0, *this, __err, __l);
       if (!(__err & ios_base::failbit)
    && (numeric_limits<int>::min() <= __l
        && __l <= numeric_limits<int>::max()))
  __n = __l;
       else
                __err |= ios_base::failbit;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(unsigned int& __n)
    {
      sentry __cerb(*this, false);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       const __num_get_type& __ng = __check_facet(this->_M_num_get);
       __ng.get(*this, 0, *this, __err, __n);
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(long& __n)
    {
      sentry __cerb(*this, false);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       const __num_get_type& __ng = __check_facet(this->_M_num_get);
       __ng.get(*this, 0, *this, __err, __n);
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(unsigned long& __n)
    {
      sentry __cerb(*this, false);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       const __num_get_type& __ng = __check_facet(this->_M_num_get);
       __ng.get(*this, 0, *this, __err, __n);
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(long long& __n)
    {
      sentry __cerb(*this, false);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       const __num_get_type& __ng = __check_facet(this->_M_num_get);
       __ng.get(*this, 0, *this, __err, __n);
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(unsigned long long& __n)
    {
      sentry __cerb(*this, false);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       const __num_get_type& __ng = __check_facet(this->_M_num_get);
       __ng.get(*this, 0, *this, __err, __n);
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(float& __n)
    {
      sentry __cerb(*this, false);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       const __num_get_type& __ng = __check_facet(this->_M_num_get);
       __ng.get(*this, 0, *this, __err, __n);
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(double& __n)
    {
      sentry __cerb(*this, false);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       const __num_get_type& __ng = __check_facet(this->_M_num_get);
       __ng.get(*this, 0, *this, __err, __n);
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(long double& __n)
    {
      sentry __cerb(*this, false);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       const __num_get_type& __ng = __check_facet(this->_M_num_get);
       __ng.get(*this, 0, *this, __err, __n);
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(void*& __n)
    {
      sentry __cerb(*this, false);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       const __num_get_type& __ng = __check_facet(this->_M_num_get);
       __ng.get(*this, 0, *this, __err, __n);
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(__streambuf_type* __sbout)
    {
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      sentry __cerb(*this, false);
      if (__cerb && __sbout)
 {
   try
     {
       if (!__copy_streambufs(this->rdbuf(), __sbout))
  __err |= ios_base::failbit;
     }
   catch(...)
     { this->_M_setstate(ios_base::failbit); }
 }
      else if (!__sbout)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }
  template<typename _CharT, typename _Traits>
    typename basic_istream<_CharT, _Traits>::int_type
    basic_istream<_CharT, _Traits>::
    get(void)
    {
      const int_type __eof = traits_type::eof();
      int_type __c = __eof;
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       __c = this->rdbuf()->sbumpc();
       if (!traits_type::eq_int_type(__c, __eof))
  _M_gcount = 1;
       else
  __err |= ios_base::eofbit;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return __c;
    }
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    get(char_type& __c)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       const int_type __cb = this->rdbuf()->sbumpc();
       if (!traits_type::eq_int_type(__cb, traits_type::eof()))
  {
    _M_gcount = 1;
    __c = traits_type::to_char_type(__cb);
  }
       else
  __err |= ios_base::eofbit;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    get(char_type* __s, streamsize __n, char_type __delim)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       const int_type __idelim = traits_type::to_int_type(__delim);
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();
       int_type __c = __sb->sgetc();
       while (_M_gcount + 1 < __n
       && !traits_type::eq_int_type(__c, __eof)
       && !traits_type::eq_int_type(__c, __idelim))
  {
    *__s++ = traits_type::to_char_type(__c);
    ++_M_gcount;
    __c = __sb->snextc();
  }
       if (traits_type::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      if (__n > 0)
 *__s = char_type();
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    get(__streambuf_type& __sb, char_type __delim)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       const int_type __idelim = traits_type::to_int_type(__delim);
       const int_type __eof = traits_type::eof();
       __streambuf_type* __this_sb = this->rdbuf();
       int_type __c = __this_sb->sgetc();
       char_type __c2 = traits_type::to_char_type(__c);
       while (!traits_type::eq_int_type(__c, __eof)
       && !traits_type::eq_int_type(__c, __idelim)
       && !traits_type::eq_int_type(__sb.sputc(__c2), __eof))
  {
    ++_M_gcount;
    __c = __this_sb->snextc();
    __c2 = traits_type::to_char_type(__c);
  }
       if (traits_type::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    getline(char_type* __s, streamsize __n, char_type __delim)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      sentry __cerb(*this, true);
      if (__cerb)
        {
          try
            {
              const int_type __idelim = traits_type::to_int_type(__delim);
              const int_type __eof = traits_type::eof();
              __streambuf_type* __sb = this->rdbuf();
              int_type __c = __sb->sgetc();
              while (_M_gcount + 1 < __n
                     && !traits_type::eq_int_type(__c, __eof)
                     && !traits_type::eq_int_type(__c, __idelim))
                {
                  *__s++ = traits_type::to_char_type(__c);
                  __c = __sb->snextc();
                  ++_M_gcount;
                }
              if (traits_type::eq_int_type(__c, __eof))
                __err |= ios_base::eofbit;
              else
                {
                  if (traits_type::eq_int_type(__c, __idelim))
                    {
                      __sb->sbumpc();
                      ++_M_gcount;
                    }
                  else
                    __err |= ios_base::failbit;
                }
            }
          catch(...)
            { this->_M_setstate(ios_base::badbit); }
        }
      if (__n > 0)
 *__s = char_type();
      if (!_M_gcount)
        __err |= ios_base::failbit;
      if (__err)
        this->setstate(__err);
      return *this;
    }
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    ignore(void)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();
       if (traits_type::eq_int_type(__sb->sbumpc(), __eof))
  __err |= ios_base::eofbit;
       else
  _M_gcount = 1;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    ignore(streamsize __n)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb && __n > 0)
        {
          ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
          try
            {
              const int_type __eof = traits_type::eof();
              __streambuf_type* __sb = this->rdbuf();
              int_type __c = __sb->sgetc();
       bool __large_ignore = false;
       while (true)
  {
    while (_M_gcount < __n
    && !traits_type::eq_int_type(__c, __eof))
      {
        ++_M_gcount;
        __c = __sb->snextc();
      }
    if (__n == numeric_limits<streamsize>::max()
        && !traits_type::eq_int_type(__c, __eof))
      {
        _M_gcount = numeric_limits<streamsize>::min();
        __large_ignore = true;
      }
    else
      break;
  }
       if (__large_ignore)
  _M_gcount = numeric_limits<streamsize>::max();
       if (traits_type::eq_int_type(__c, __eof))
                __err |= ios_base::eofbit;
            }
          catch(...)
            { this->_M_setstate(ios_base::badbit); }
          if (__err)
            this->setstate(__err);
        }
      return *this;
    }
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    ignore(streamsize __n, int_type __delim)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb && __n > 0)
        {
          ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
          try
            {
              const int_type __eof = traits_type::eof();
              __streambuf_type* __sb = this->rdbuf();
              int_type __c = __sb->sgetc();
       bool __large_ignore = false;
       while (true)
  {
    while (_M_gcount < __n
    && !traits_type::eq_int_type(__c, __eof)
    && !traits_type::eq_int_type(__c, __delim))
      {
        ++_M_gcount;
        __c = __sb->snextc();
      }
    if (__n == numeric_limits<streamsize>::max()
        && !traits_type::eq_int_type(__c, __eof)
        && !traits_type::eq_int_type(__c, __delim))
      {
        _M_gcount = numeric_limits<streamsize>::min();
        __large_ignore = true;
      }
    else
      break;
  }
       if (__large_ignore)
  _M_gcount = numeric_limits<streamsize>::max();
              if (traits_type::eq_int_type(__c, __eof))
                __err |= ios_base::eofbit;
       else if (traits_type::eq_int_type(__c, __delim))
  {
    if (_M_gcount < numeric_limits<streamsize>::max())
      ++_M_gcount;
    __sb->sbumpc();
  }
            }
          catch(...)
            { this->_M_setstate(ios_base::badbit); }
          if (__err)
            this->setstate(__err);
        }
      return *this;
    }
  template<typename _CharT, typename _Traits>
    typename basic_istream<_CharT, _Traits>::int_type
    basic_istream<_CharT, _Traits>::
    peek(void)
    {
      int_type __c = traits_type::eof();
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       __c = this->rdbuf()->sgetc();
       if (traits_type::eq_int_type(__c, traits_type::eof()))
  __err |= ios_base::eofbit;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return __c;
    }
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    read(char_type* __s, streamsize __n)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       _M_gcount = this->rdbuf()->sgetn(__s, __n);
       if (_M_gcount != __n)
  __err |= (ios_base::eofbit | ios_base::failbit);
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }
  template<typename _CharT, typename _Traits>
    streamsize
    basic_istream<_CharT, _Traits>::
    readsome(char_type* __s, streamsize __n)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       const streamsize __num = this->rdbuf()->in_avail();
       if (__num > 0)
  _M_gcount = this->rdbuf()->sgetn(__s, std::min(__num, __n));
       else if (__num == -1)
  __err |= ios_base::eofbit;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return _M_gcount;
    }
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    putback(char_type __c)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();
       if (!__sb
    || traits_type::eq_int_type(__sb->sputbackc(__c), __eof))
  __err |= ios_base::badbit;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    unget(void)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();
       if (!__sb
    || traits_type::eq_int_type(__sb->sungetc(), __eof))
  __err |= ios_base::badbit;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }
  template<typename _CharT, typename _Traits>
    int
    basic_istream<_CharT, _Traits>::
    sync(void)
    {
      int __ret = -1;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       __streambuf_type* __sb = this->rdbuf();
       if (__sb)
  {
    if (__sb->pubsync() == -1)
      __err |= ios_base::badbit;
    else
      __ret = 0;
  }
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return __ret;
    }
  template<typename _CharT, typename _Traits>
    typename basic_istream<_CharT, _Traits>::pos_type
    basic_istream<_CharT, _Traits>::
    tellg(void)
    {
      pos_type __ret = pos_type(-1);
      try
 {
   if (!this->fail())
     __ret = this->rdbuf()->pubseekoff(0, ios_base::cur, ios_base::in);
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      return __ret;
    }
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    seekg(pos_type __pos)
    {
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      try
 {
   if (!this->fail())
     {
       const pos_type __p = this->rdbuf()->pubseekpos(__pos,
            ios_base::in);
       if (__p == pos_type(off_type(-1)))
  __err |= ios_base::failbit;
     }
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      if (__err)
 this->setstate(__err);
      return *this;
    }
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    seekg(off_type __off, ios_base::seekdir __dir)
    {
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      try
 {
   if (!this->fail())
     {
       const pos_type __p = this->rdbuf()->pubseekoff(__off, __dir,
            ios_base::in);
       if (__p == pos_type(off_type(-1)))
  __err |= ios_base::failbit;
     }
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      if (__err)
 this->setstate(__err);
      return *this;
    }
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT& __c)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::int_type __int_type;
      typename __istream_type::sentry __cerb(__in, false);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       const __int_type __cb = __in.rdbuf()->sbumpc();
       if (!_Traits::eq_int_type(__cb, _Traits::eof()))
  __c = _Traits::to_char_type(__cb);
       else
  __err |= (ios_base::eofbit | ios_base::failbit);
     }
   catch(...)
     { __in._M_setstate(ios_base::badbit); }
   if (__err)
     __in.setstate(__err);
 }
      return __in;
    }
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT* __s)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::__streambuf_type __streambuf_type;
      typedef typename _Traits::int_type int_type;
      typedef _CharT char_type;
      typedef ctype<_CharT> __ctype_type;
      streamsize __extracted = 0;
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      typename __istream_type::sentry __cerb(__in, false);
      if (__cerb)
 {
   try
     {
       streamsize __num = __in.width();
       if (__num <= 0)
  __num = numeric_limits<streamsize>::max();
       const __ctype_type& __ct = use_facet<__ctype_type>(__in.getloc());
       const int_type __eof = _Traits::eof();
       __streambuf_type* __sb = __in.rdbuf();
       int_type __c = __sb->sgetc();
       while (__extracted < __num - 1
       && !_Traits::eq_int_type(__c, __eof)
       && !__ct.is(ctype_base::space,
     _Traits::to_char_type(__c)))
  {
    *__s++ = _Traits::to_char_type(__c);
    ++__extracted;
    __c = __sb->snextc();
  }
       if (_Traits::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;
       *__s = char_type();
       __in.width(0);
     }
   catch(...)
     { __in._M_setstate(ios_base::badbit); }
 }
      if (!__extracted)
 __err |= ios_base::failbit;
      if (__err)
 __in.setstate(__err);
      return __in;
    }
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT,_Traits>&
    ws(basic_istream<_CharT,_Traits>& __in)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::__streambuf_type __streambuf_type;
      typedef typename __istream_type::__ctype_type __ctype_type;
      typedef typename __istream_type::int_type __int_type;
      const __ctype_type& __ct = use_facet<__ctype_type>(__in.getloc());
      const __int_type __eof = _Traits::eof();
      __streambuf_type* __sb = __in.rdbuf();
      __int_type __c = __sb->sgetc();
      while (!_Traits::eq_int_type(__c, __eof)
      && __ct.is(ctype_base::space, _Traits::to_char_type(__c)))
 __c = __sb->snextc();
       if (_Traits::eq_int_type(__c, __eof))
  __in.setstate(ios_base::eofbit);
      return __in;
    }
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in,
        basic_string<_CharT, _Traits, _Alloc>& __str)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::int_type __int_type;
      typedef typename __istream_type::__streambuf_type __streambuf_type;
      typedef typename __istream_type::__ctype_type __ctype_type;
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;
      __size_type __extracted = 0;
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      typename __istream_type::sentry __cerb(__in, false);
      if (__cerb)
 {
   try
     {
       __str.erase();
       _CharT __buf[128];
       __size_type __len = 0;
       const streamsize __w = __in.width();
       const __size_type __n = __w > 0 ? static_cast<__size_type>(__w)
                                : __str.max_size();
       const __ctype_type& __ct = use_facet<__ctype_type>(__in.getloc());
       const __int_type __eof = _Traits::eof();
       __streambuf_type* __sb = __in.rdbuf();
       __int_type __c = __sb->sgetc();
       while (__extracted < __n
       && !_Traits::eq_int_type(__c, __eof)
       && !__ct.is(ctype_base::space, _Traits::to_char_type(__c)))
  {
    if (__len == sizeof(__buf) / sizeof(_CharT))
      {
        __str.append(__buf, sizeof(__buf) / sizeof(_CharT));
        __len = 0;
      }
    __buf[__len++] = _Traits::to_char_type(__c);
    ++__extracted;
    __c = __sb->snextc();
  }
       __str.append(__buf, __len);
       if (_Traits::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;
       __in.width(0);
     }
   catch(...)
     {
       __in._M_setstate(ios_base::badbit);
     }
 }
      if (!__extracted)
 __err |= ios_base::failbit;
      if (__err)
 __in.setstate(__err);
      return __in;
    }
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>& __in,
     basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::int_type __int_type;
      typedef typename __istream_type::__streambuf_type __streambuf_type;
      typedef typename __istream_type::__ctype_type __ctype_type;
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;
      __size_type __extracted = 0;
      const __size_type __n = __str.max_size();
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      typename __istream_type::sentry __cerb(__in, true);
      if (__cerb)
 {
   try
     {
       __str.erase();
       const __int_type __idelim = _Traits::to_int_type(__delim);
       const __int_type __eof = _Traits::eof();
       __streambuf_type* __sb = __in.rdbuf();
       __int_type __c = __sb->sgetc();
       while (__extracted < __n
       && !_Traits::eq_int_type(__c, __eof)
       && !_Traits::eq_int_type(__c, __idelim))
  {
    __str += _Traits::to_char_type(__c);
    ++__extracted;
    __c = __sb->snextc();
  }
       if (_Traits::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;
       else if (_Traits::eq_int_type(__c, __idelim))
  {
    ++__extracted;
    __sb->sbumpc();
  }
       else
  __err |= ios_base::failbit;
     }
   catch(...)
     {
       __in._M_setstate(ios_base::badbit);
     }
 }
      if (!__extracted)
 __err |= ios_base::failbit;
      if (__err)
 __in.setstate(__err);
      return __in;
    }
  template<class _CharT, class _Traits, class _Alloc>
    inline basic_istream<_CharT,_Traits>&
    getline(basic_istream<_CharT, _Traits>& __in,
     basic_string<_CharT,_Traits,_Alloc>& __str)
    { return getline(__in, __str, __in.widen('\n')); }
  extern template class basic_istream<char>;
  extern template istream& ws(istream&);
  extern template istream& operator>>(istream&, char&);
  extern template istream& operator>>(istream&, char*);
  extern template istream& operator>>(istream&, unsigned char&);
  extern template istream& operator>>(istream&, signed char&);
  extern template istream& operator>>(istream&, unsigned char*);
  extern template istream& operator>>(istream&, signed char*);
  extern template class basic_iostream<char>;
  extern template class basic_istream<wchar_t>;
  extern template wistream& ws(wistream&);
  extern template wistream& operator>>(wistream&, wchar_t&);
  extern template wistream& operator>>(wistream&, wchar_t*);
  extern template class basic_iostream<wchar_t>;
}
namespace std
{
  template<typename _Tp, typename _CharT = char,
           typename _Traits = char_traits<_CharT>, typename _Dist = ptrdiff_t>
    class istream_iterator
    : public iterator<input_iterator_tag, _Tp, _Dist, const _Tp*, const _Tp&>
    {
    public:
      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef basic_istream<_CharT, _Traits> istream_type;
    private:
      istream_type* _M_stream;
      _Tp _M_value;
      bool _M_ok;
    public:
      istream_iterator()
      : _M_stream(0), _M_value(), _M_ok(false) {}
      istream_iterator(istream_type& __s)
      : _M_stream(&__s)
      { _M_read(); }
      istream_iterator(const istream_iterator& __obj)
      : _M_stream(__obj._M_stream), _M_value(__obj._M_value),
        _M_ok(__obj._M_ok)
      { }
      const _Tp&
      operator*() const
      {
 ;
 return _M_value;
      }
      const _Tp*
      operator->() const { return &(operator*()); }
      istream_iterator&
      operator++()
      {
 ;
 _M_read();
 return *this;
      }
      istream_iterator
      operator++(int)
      {
 ;
 istream_iterator __tmp = *this;
 _M_read();
 return __tmp;
      }
      bool
      _M_equal(const istream_iterator& __x) const
      { return (_M_ok == __x._M_ok) && (!_M_ok || _M_stream == __x._M_stream); }
    private:
      void
      _M_read()
      {
 _M_ok = (_M_stream && *_M_stream) ? true : false;
 if (_M_ok)
   {
     *_M_stream >> _M_value;
     _M_ok = *_M_stream ? true : false;
   }
      }
    };
  template<typename _Tp, typename _CharT, typename _Traits, typename _Dist>
    inline bool
    operator==(const istream_iterator<_Tp, _CharT, _Traits, _Dist>& __x,
        const istream_iterator<_Tp, _CharT, _Traits, _Dist>& __y)
    { return __x._M_equal(__y); }
  template <class _Tp, class _CharT, class _Traits, class _Dist>
    inline bool
    operator!=(const istream_iterator<_Tp, _CharT, _Traits, _Dist>& __x,
        const istream_iterator<_Tp, _CharT, _Traits, _Dist>& __y)
    { return !__x._M_equal(__y); }
  template<typename _Tp, typename _CharT = char,
           typename _Traits = char_traits<_CharT> >
    class ostream_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    public:
      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef basic_ostream<_CharT, _Traits> ostream_type;
    private:
      ostream_type* _M_stream;
      const _CharT* _M_string;
    public:
      ostream_iterator(ostream_type& __s) : _M_stream(&__s), _M_string(0) {}
      ostream_iterator(ostream_type& __s, const _CharT* __c)
      : _M_stream(&__s), _M_string(__c) { }
      ostream_iterator(const ostream_iterator& __obj)
      : _M_stream(__obj._M_stream), _M_string(__obj._M_string) { }
      ostream_iterator&
      operator=(const _Tp& __value)
      {
 ;
 *_M_stream << __value;
 if (_M_string) *_M_stream << _M_string;
 return *this;
      }
      ostream_iterator&
      operator*()
      { return *this; }
      ostream_iterator&
      operator++()
      { return *this; }
      ostream_iterator&
      operator++(int)
      { return *this; }
    };
}
namespace std
{
  template<typename _Tp, typename _Alloc>
    struct _Vector_base
    {
      typedef typename _Alloc::template rebind<_Tp>::other _Tp_alloc_type;
      struct _Vector_impl
      : public _Tp_alloc_type
      {
 _Tp* _M_start;
 _Tp* _M_finish;
 _Tp* _M_end_of_storage;
 _Vector_impl(_Tp_alloc_type const& __a)
 : _Tp_alloc_type(__a), _M_start(0), _M_finish(0), _M_end_of_storage(0)
 { }
      };
    public:
      typedef _Alloc allocator_type;
      _Tp_alloc_type&
      _M_get_Tp_allocator()
      { return *static_cast<_Tp_alloc_type*>(&this->_M_impl); }
      const _Tp_alloc_type&
      _M_get_Tp_allocator() const
      { return *static_cast<const _Tp_alloc_type*>(&this->_M_impl); }
      allocator_type
      get_allocator() const
      { return _M_get_Tp_allocator(); }
      _Vector_base(const allocator_type& __a)
      : _M_impl(__a)
      { }
      _Vector_base(size_t __n, const allocator_type& __a)
      : _M_impl(__a)
      {
 this->_M_impl._M_start = this->_M_allocate(__n);
 this->_M_impl._M_finish = this->_M_impl._M_start;
 this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
      }
      ~_Vector_base()
      { _M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage
        - this->_M_impl._M_start); }
    public:
      _Vector_impl _M_impl;
      _Tp*
      _M_allocate(size_t __n)
      { return _M_impl.allocate(__n); }
      void
      _M_deallocate(_Tp* __p, size_t __n)
      {
 if (__p)
   _M_impl.deallocate(__p, __n);
      }
    };
  template<typename _Tp, typename _Alloc = std::allocator<_Tp> >
    class vector : protected _Vector_base<_Tp, _Alloc>
    {
      typedef typename _Alloc::value_type _Alloc_value_type;
      typedef _Vector_base<_Tp, _Alloc> _Base;
      typedef vector<_Tp, _Alloc> vector_type;
      typedef typename _Base::_Tp_alloc_type _Tp_alloc_type;
    public:
      typedef _Tp value_type;
      typedef typename _Tp_alloc_type::pointer pointer;
      typedef typename _Tp_alloc_type::const_pointer const_pointer;
      typedef typename _Tp_alloc_type::reference reference;
      typedef typename _Tp_alloc_type::const_reference const_reference;
      typedef __gnu_cxx::__normal_iterator<pointer, vector_type> iterator;
      typedef __gnu_cxx::__normal_iterator<const_pointer, vector_type>
      const_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
      typedef std::reverse_iterator<iterator> reverse_iterator;
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Alloc allocator_type;
    protected:
      using _Base::_M_allocate;
      using _Base::_M_deallocate;
      using _Base::_M_impl;
      using _Base::_M_get_Tp_allocator;
    public:
      explicit
      vector(const allocator_type& __a = allocator_type())
      : _Base(__a)
      { }
      explicit
      vector(size_type __n, const value_type& __value = value_type(),
      const allocator_type& __a = allocator_type())
      : _Base(__n, __a)
      {
 std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value,
          _M_get_Tp_allocator());
 this->_M_impl._M_finish = this->_M_impl._M_start + __n;
      }
      vector(const vector& __x)
      : _Base(__x.size(), __x.get_allocator())
      { this->_M_impl._M_finish =
   std::__uninitialized_copy_a(__x.begin(), __x.end(),
          this->_M_impl._M_start,
          _M_get_Tp_allocator());
      }
      template<typename _InputIterator>
        vector(_InputIterator __first, _InputIterator __last,
        const allocator_type& __a = allocator_type())
 : _Base(__a)
        {
   typedef typename std::__is_integer<_InputIterator>::__type _Integral;
   _M_initialize_dispatch(__first, __last, _Integral());
 }
      ~vector()
      { std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
        _M_get_Tp_allocator());
      }
      vector&
      operator=(const vector& __x);
      void
      assign(size_type __n, const value_type& __val)
      { _M_fill_assign(__n, __val); }
      template<typename _InputIterator>
        void
        assign(_InputIterator __first, _InputIterator __last)
        {
   typedef typename std::__is_integer<_InputIterator>::__type _Integral;
   _M_assign_dispatch(__first, __last, _Integral());
 }
      using _Base::get_allocator;
      iterator
      begin()
      { return iterator (this->_M_impl._M_start); }
      const_iterator
      begin() const
      { return const_iterator (this->_M_impl._M_start); }
      iterator
      end()
      { return iterator (this->_M_impl._M_finish); }
      const_iterator
      end() const
      { return const_iterator (this->_M_impl._M_finish); }
      reverse_iterator
      rbegin()
      { return reverse_iterator(end()); }
      const_reverse_iterator
      rbegin() const
      { return const_reverse_iterator(end()); }
      reverse_iterator
      rend()
      { return reverse_iterator(begin()); }
      const_reverse_iterator
      rend() const
      { return const_reverse_iterator(begin()); }
      size_type
      size() const
      { return size_type(end() - begin()); }
      size_type
      max_size() const
      { return size_type(-1) / sizeof(value_type); }
      void
      resize(size_type __new_size, value_type __x = value_type())
      {
 if (__new_size < size())
   erase(begin() + __new_size, end());
 else
   insert(end(), __new_size - size(), __x);
      }
      size_type
      capacity() const
      { return size_type(const_iterator(this->_M_impl._M_end_of_storage)
    - begin()); }
      bool
      empty() const
      { return begin() == end(); }
      void
      reserve(size_type __n);
      reference
      operator[](size_type __n)
      { return *(begin() + __n); }
      const_reference
      operator[](size_type __n) const
      { return *(begin() + __n); }
    protected:
      void
      _M_range_check(size_type __n) const
      {
 if (__n >= this->size())
   __throw_out_of_range(("vector::_M_range_check"));
      }
    public:
      reference
      at(size_type __n)
      {
 _M_range_check(__n);
 return (*this)[__n];
      }
      const_reference
      at(size_type __n) const
      {
 _M_range_check(__n);
 return (*this)[__n];
      }
      reference
      front()
      { return *begin(); }
      const_reference
      front() const
      { return *begin(); }
      reference
      back()
      { return *(end() - 1); }
      const_reference
      back() const
      { return *(end() - 1); }
      pointer
      data()
      { return pointer(this->_M_impl._M_start); }
      const_pointer
      data() const
      { return const_pointer(this->_M_impl._M_start); }
      void
      push_back(const value_type& __x)
      {
 if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
   {
     this->_M_impl.construct(this->_M_impl._M_finish, __x);
     ++this->_M_impl._M_finish;
   }
 else
   _M_insert_aux(end(), __x);
      }
      void
      pop_back()
      {
 --this->_M_impl._M_finish;
 this->_M_impl.destroy(this->_M_impl._M_finish);
      }
      iterator
      insert(iterator __position, const value_type& __x);
      void
      insert(iterator __position, size_type __n, const value_type& __x)
      { _M_fill_insert(__position, __n, __x); }
      template<typename _InputIterator>
        void
        insert(iterator __position, _InputIterator __first,
        _InputIterator __last)
        {
   typedef typename std::__is_integer<_InputIterator>::__type _Integral;
   _M_insert_dispatch(__position, __first, __last, _Integral());
 }
      iterator
      erase(iterator __position);
      iterator
      erase(iterator __first, iterator __last);
      void
      swap(vector& __x)
      {
 std::swap(this->_M_impl._M_start, __x._M_impl._M_start);
 std::swap(this->_M_impl._M_finish, __x._M_impl._M_finish);
 std::swap(this->_M_impl._M_end_of_storage,
    __x._M_impl._M_end_of_storage);
      }
      void
      clear()
      {
 std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
        _M_get_Tp_allocator());
 this->_M_impl._M_finish = this->_M_impl._M_start;
      }
    protected:
      template<typename _ForwardIterator>
        pointer
        _M_allocate_and_copy(size_type __n,
        _ForwardIterator __first, _ForwardIterator __last)
        {
   pointer __result = this->_M_allocate(__n);
   try
     {
       std::__uninitialized_copy_a(__first, __last, __result,
       _M_get_Tp_allocator());
       return __result;
     }
   catch(...)
     {
       _M_deallocate(__result, __n);
       throw;
     }
 }
      template<typename _Integer>
        void
        _M_initialize_dispatch(_Integer __n, _Integer __value, __true_type)
        {
   this->_M_impl._M_start = _M_allocate(__n);
   this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
   std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value,
     _M_get_Tp_allocator());
   this->_M_impl._M_finish = this->_M_impl._M_end_of_storage;
 }
      template<typename _InputIterator>
        void
        _M_initialize_dispatch(_InputIterator __first, _InputIterator __last,
          __false_type)
        {
   typedef typename std::iterator_traits<_InputIterator>::
     iterator_category _IterCategory;
   _M_range_initialize(__first, __last, _IterCategory());
 }
      template<typename _InputIterator>
        void
        _M_range_initialize(_InputIterator __first,
       _InputIterator __last, std::input_iterator_tag)
        {
   for (; __first != __last; ++__first)
     push_back(*__first);
 }
      template<typename _ForwardIterator>
        void
        _M_range_initialize(_ForwardIterator __first,
       _ForwardIterator __last, std::forward_iterator_tag)
        {
   const size_type __n = std::distance(__first, __last);
   this->_M_impl._M_start = this->_M_allocate(__n);
   this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
   this->_M_impl._M_finish =
     std::__uninitialized_copy_a(__first, __last,
     this->_M_impl._M_start,
     _M_get_Tp_allocator());
 }
      template<typename _Integer>
        void
        _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)
        {
   _M_fill_assign(static_cast<size_type>(__n),
    static_cast<value_type>(__val));
 }
      template<typename _InputIterator>
        void
        _M_assign_dispatch(_InputIterator __first, _InputIterator __last,
      __false_type)
        {
   typedef typename std::iterator_traits<_InputIterator>::
     iterator_category _IterCategory;
   _M_assign_aux(__first, __last, _IterCategory());
 }
      template<typename _InputIterator>
        void
        _M_assign_aux(_InputIterator __first, _InputIterator __last,
        std::input_iterator_tag);
      template<typename _ForwardIterator>
        void
        _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
        std::forward_iterator_tag);
      void
      _M_fill_assign(size_type __n, const value_type& __val);
      template<typename _Integer>
        void
        _M_insert_dispatch(iterator __pos, _Integer __n, _Integer __val,
      __true_type)
        {
   _M_fill_insert(__pos, static_cast<size_type>(__n),
    static_cast<value_type>(__val));
 }
      template<typename _InputIterator>
        void
        _M_insert_dispatch(iterator __pos, _InputIterator __first,
      _InputIterator __last, __false_type)
        {
   typedef typename std::iterator_traits<_InputIterator>::
     iterator_category _IterCategory;
   _M_range_insert(__pos, __first, __last, _IterCategory());
 }
      template<typename _InputIterator>
        void
        _M_range_insert(iterator __pos, _InputIterator __first,
   _InputIterator __last, std::input_iterator_tag);
      template<typename _ForwardIterator>
        void
        _M_range_insert(iterator __pos, _ForwardIterator __first,
   _ForwardIterator __last, std::forward_iterator_tag);
      void
      _M_fill_insert(iterator __pos, size_type __n, const value_type& __x);
      void
      _M_insert_aux(iterator __position, const value_type& __x);
    };
  template<typename _Tp, typename _Alloc>
    inline bool
    operator==(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return (__x.size() == __y.size()
       && std::equal(__x.begin(), __x.end(), __y.begin())); }
  template<typename _Tp, typename _Alloc>
    inline bool
    operator<(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return std::lexicographical_compare(__x.begin(), __x.end(),
       __y.begin(), __y.end()); }
  template<typename _Tp, typename _Alloc>
    inline bool
    operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return !(__x == __y); }
  template<typename _Tp, typename _Alloc>
    inline bool
    operator>(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return __y < __x; }
  template<typename _Tp, typename _Alloc>
    inline bool
    operator<=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return !(__y < __x); }
  template<typename _Tp, typename _Alloc>
    inline bool
    operator>=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return !(__x < __y); }
  template<typename _Tp, typename _Alloc>
    inline void
    swap(vector<_Tp, _Alloc>& __x, vector<_Tp, _Alloc>& __y)
    { __x.swap(__y); }
}
namespace std
{
  typedef unsigned long _Bit_type;
  enum { _S_word_bit = int(8 * sizeof(_Bit_type)) };
  struct _Bit_reference
  {
    _Bit_type * _M_p;
    _Bit_type _M_mask;
    _Bit_reference(_Bit_type * __x, _Bit_type __y)
    : _M_p(__x), _M_mask(__y) { }
    _Bit_reference() : _M_p(0), _M_mask(0) { }
    operator bool() const
    { return !!(*_M_p & _M_mask); }
    _Bit_reference&
    operator=(bool __x)
    {
      if (__x)
 *_M_p |= _M_mask;
      else
 *_M_p &= ~_M_mask;
      return *this;
    }
    _Bit_reference&
    operator=(const _Bit_reference& __x)
    { return *this = bool(__x); }
    bool
    operator==(const _Bit_reference& __x) const
    { return bool(*this) == bool(__x); }
    bool
    operator<(const _Bit_reference& __x) const
    { return !bool(*this) && bool(__x); }
    void
    flip()
    { *_M_p ^= _M_mask; }
  };
  struct _Bit_iterator_base
  : public std::iterator<std::random_access_iterator_tag, bool>
  {
    _Bit_type * _M_p;
    unsigned int _M_offset;
    _Bit_iterator_base(_Bit_type * __x, unsigned int __y)
    : _M_p(__x), _M_offset(__y) { }
    void
    _M_bump_up()
    {
      if (_M_offset++ == int(_S_word_bit) - 1)
 {
   _M_offset = 0;
   ++_M_p;
 }
    }
    void
    _M_bump_down()
    {
      if (_M_offset-- == 0)
 {
   _M_offset = int(_S_word_bit) - 1;
   --_M_p;
 }
    }
    void
    _M_incr(ptrdiff_t __i)
    {
      difference_type __n = __i + _M_offset;
      _M_p += __n / int(_S_word_bit);
      __n = __n % int(_S_word_bit);
      if (__n < 0)
 {
   _M_offset = static_cast<unsigned int>(__n + int(_S_word_bit));
   --_M_p;
 }
      else
 _M_offset = static_cast<unsigned int>(__n);
    }
    bool
    operator==(const _Bit_iterator_base& __i) const
    { return _M_p == __i._M_p && _M_offset == __i._M_offset; }
    bool
    operator<(const _Bit_iterator_base& __i) const
    {
      return _M_p < __i._M_p
      || (_M_p == __i._M_p && _M_offset < __i._M_offset);
    }
    bool
    operator!=(const _Bit_iterator_base& __i) const
    { return !(*this == __i); }
    bool
    operator>(const _Bit_iterator_base& __i) const
    { return __i < *this; }
    bool
    operator<=(const _Bit_iterator_base& __i) const
    { return !(__i < *this); }
    bool
    operator>=(const _Bit_iterator_base& __i) const
    { return !(*this < __i); }
  };
  inline ptrdiff_t
  operator-(const _Bit_iterator_base& __x, const _Bit_iterator_base& __y)
  {
    return (int(_S_word_bit) * (__x._M_p - __y._M_p)
     + __x._M_offset - __y._M_offset);
  }
  struct _Bit_iterator : public _Bit_iterator_base
  {
    typedef _Bit_reference reference;
    typedef _Bit_reference* pointer;
    typedef _Bit_iterator iterator;
    _Bit_iterator() : _Bit_iterator_base(0, 0) { }
    _Bit_iterator(_Bit_type * __x, unsigned int __y)
    : _Bit_iterator_base(__x, __y) { }
    reference
    operator*() const
    { return reference(_M_p, 1UL << _M_offset); }
    iterator&
    operator++()
    {
      _M_bump_up();
      return *this;
    }
    iterator
    operator++(int)
    {
      iterator __tmp = *this;
      _M_bump_up();
      return __tmp;
    }
    iterator&
    operator--()
    {
      _M_bump_down();
      return *this;
    }
    iterator
    operator--(int)
    {
      iterator __tmp = *this;
      _M_bump_down();
      return __tmp;
    }
    iterator&
    operator+=(difference_type __i)
    {
      _M_incr(__i);
      return *this;
    }
    iterator&
    operator-=(difference_type __i)
    {
      *this += -__i;
      return *this;
    }
    iterator
    operator+(difference_type __i) const
    {
      iterator __tmp = *this;
      return __tmp += __i;
    }
    iterator
    operator-(difference_type __i) const
    {
      iterator __tmp = *this;
      return __tmp -= __i;
    }
    reference
    operator[](difference_type __i) const
    { return *(*this + __i); }
  };
  inline _Bit_iterator
  operator+(ptrdiff_t __n, const _Bit_iterator& __x)
  { return __x + __n; }
  struct _Bit_const_iterator : public _Bit_iterator_base
  {
    typedef bool reference;
    typedef bool const_reference;
    typedef const bool* pointer;
    typedef _Bit_const_iterator const_iterator;
    _Bit_const_iterator() : _Bit_iterator_base(0, 0) { }
    _Bit_const_iterator(_Bit_type * __x, unsigned int __y)
    : _Bit_iterator_base(__x, __y) { }
    _Bit_const_iterator(const _Bit_iterator& __x)
    : _Bit_iterator_base(__x._M_p, __x._M_offset) { }
    const_reference
    operator*() const
    { return _Bit_reference(_M_p, 1UL << _M_offset); }
    const_iterator&
    operator++()
    {
      _M_bump_up();
      return *this;
    }
    const_iterator
    operator++(int)
    {
      const_iterator __tmp = *this;
      _M_bump_up();
      return __tmp;
    }
    const_iterator&
    operator--()
    {
      _M_bump_down();
      return *this;
    }
    const_iterator
    operator--(int)
    {
      const_iterator __tmp = *this;
      _M_bump_down();
      return __tmp;
    }
    const_iterator&
    operator+=(difference_type __i)
    {
      _M_incr(__i);
      return *this;
    }
    const_iterator&
    operator-=(difference_type __i)
    {
      *this += -__i;
      return *this;
    }
    const_iterator
    operator+(difference_type __i) const
    {
      const_iterator __tmp = *this;
      return __tmp += __i;
    }
    const_iterator
    operator-(difference_type __i) const
    {
      const_iterator __tmp = *this;
      return __tmp -= __i;
    }
    const_reference
    operator[](difference_type __i) const
    { return *(*this + __i); }
  };
  inline _Bit_const_iterator
  operator+(ptrdiff_t __n, const _Bit_const_iterator& __x)
  { return __x + __n; }
  template<class _Alloc>
    class _Bvector_base
    {
      typedef typename _Alloc::template rebind<_Bit_type>::other
        _Bit_alloc_type;
      struct _Bvector_impl : public _Bit_alloc_type
      {
 _Bit_iterator _M_start;
 _Bit_iterator _M_finish;
 _Bit_type* _M_end_of_storage;
 _Bvector_impl(const _Bit_alloc_type& __a)
 : _Bit_alloc_type(__a), _M_start(), _M_finish(), _M_end_of_storage(0)
 { }
      };
    public:
      typedef _Alloc allocator_type;
      allocator_type
      get_allocator() const
      { return *static_cast<const _Bit_alloc_type*>(&this->_M_impl); }
      _Bvector_base(const allocator_type& __a) : _M_impl(__a) { }
      ~_Bvector_base()
      { this->_M_deallocate(); }
    protected:
      _Bvector_impl _M_impl;
      _Bit_type*
      _M_allocate(size_t __n)
      { return _M_impl.allocate((__n + int(_S_word_bit) - 1)
    / int(_S_word_bit)); }
      void
      _M_deallocate()
      {
 if (_M_impl._M_start._M_p)
   _M_impl.deallocate(_M_impl._M_start._M_p,
        _M_impl._M_end_of_storage - _M_impl._M_start._M_p);
      }
    };
}
namespace std
{
template<typename _Alloc>
  class vector<bool, _Alloc> : public _Bvector_base<_Alloc>
  {
  public:
    typedef bool value_type;
    typedef size_t size_type;
    typedef ptrdiff_t difference_type;
    typedef _Bit_reference reference;
    typedef bool const_reference;
    typedef _Bit_reference* pointer;
    typedef const bool* const_pointer;
    typedef _Bit_iterator iterator;
    typedef _Bit_const_iterator const_iterator;
    typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
    typedef std::reverse_iterator<iterator> reverse_iterator;
    typedef typename _Bvector_base<_Alloc>::allocator_type allocator_type;
    allocator_type get_allocator() const
    { return _Bvector_base<_Alloc>::get_allocator(); }
  protected:
    using _Bvector_base<_Alloc>::_M_allocate;
    using _Bvector_base<_Alloc>::_M_deallocate;
  protected:
    void
    _M_initialize(size_type __n)
    {
      _Bit_type* __q = this->_M_allocate(__n);
      this->_M_impl._M_end_of_storage = (__q
      + ((__n + int(_S_word_bit) - 1)
         / int(_S_word_bit)));
      this->_M_impl._M_start = iterator(__q, 0);
      this->_M_impl._M_finish = this->_M_impl._M_start + difference_type(__n);
    }
    void
    _M_insert_aux(iterator __position, bool __x)
    {
      if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_of_storage)
 {
   std::copy_backward(__position, this->_M_impl._M_finish,
        this->_M_impl._M_finish + 1);
   *__position = __x;
   ++this->_M_impl._M_finish;
 }
      else
 {
   const size_type __len = size() ? 2 * size()
                                  : static_cast<size_type>(_S_word_bit);
   _Bit_type * __q = this->_M_allocate(__len);
   iterator __i = std::copy(begin(), __position, iterator(__q, 0));
   *__i++ = __x;
   this->_M_impl._M_finish = std::copy(__position, end(), __i);
   this->_M_deallocate();
   this->_M_impl._M_end_of_storage = (__q + ((__len
           + int(_S_word_bit) - 1)
          / int(_S_word_bit)));
   this->_M_impl._M_start = iterator(__q, 0);
 }
    }
    template<class _InputIterator>
      void
      _M_initialize_range(_InputIterator __first, _InputIterator __last,
     std::input_iterator_tag)
      {
 this->_M_impl._M_start = iterator();
 this->_M_impl._M_finish = iterator();
 this->_M_impl._M_end_of_storage = 0;
 for (; __first != __last; ++__first)
   push_back(*__first);
      }
    template<class _ForwardIterator>
      void
      _M_initialize_range(_ForwardIterator __first, _ForwardIterator __last,
     std::forward_iterator_tag)
      {
 const size_type __n = std::distance(__first, __last);
 _M_initialize(__n);
 std::copy(__first, __last, this->_M_impl._M_start);
      }
    template<class _InputIterator>
      void
      _M_insert_range(iterator __pos, _InputIterator __first,
        _InputIterator __last, std::input_iterator_tag)
      {
 for (; __first != __last; ++__first)
   {
     __pos = insert(__pos, *__first);
     ++__pos;
   }
      }
    template<class _ForwardIterator>
      void
      _M_insert_range(iterator __position, _ForwardIterator __first,
        _ForwardIterator __last, std::forward_iterator_tag)
      {
 if (__first != __last)
   {
     size_type __n = std::distance(__first, __last);
     if (capacity() - size() >= __n)
       {
  std::copy_backward(__position, end(),
       this->_M_impl._M_finish
       + difference_type(__n));
  std::copy(__first, __last, __position);
  this->_M_impl._M_finish += difference_type(__n);
       }
     else
       {
  const size_type __len = size() + std::max(size(), __n);
  _Bit_type * __q = this->_M_allocate(__len);
  iterator __i = std::copy(begin(), __position,
      iterator(__q, 0));
  __i = std::copy(__first, __last, __i);
  this->_M_impl._M_finish = std::copy(__position, end(), __i);
  this->_M_deallocate();
  this->_M_impl._M_end_of_storage = (__q
         + ((__len
             + int(_S_word_bit) - 1)
            / int(_S_word_bit)));
  this->_M_impl._M_start = iterator(__q, 0);
       }
   }
      }
  public:
    iterator
    begin()
    { return this->_M_impl._M_start; }
    const_iterator
    begin() const
    { return this->_M_impl._M_start; }
    iterator
    end()
    { return this->_M_impl._M_finish; }
    const_iterator
    end() const
    { return this->_M_impl._M_finish; }
    reverse_iterator
    rbegin()
    { return reverse_iterator(end()); }
    const_reverse_iterator
    rbegin() const
    { return const_reverse_iterator(end()); }
    reverse_iterator
    rend()
    { return reverse_iterator(begin()); }
    const_reverse_iterator
    rend() const
    { return const_reverse_iterator(begin()); }
    size_type
    size() const
    { return size_type(end() - begin()); }
    size_type
    max_size() const
    { return size_type(-1); }
    size_type
    capacity() const
    { return size_type(const_iterator(this->_M_impl._M_end_of_storage, 0)
         - begin()); }
    bool
    empty() const
    { return begin() == end(); }
    reference
    operator[](size_type __n)
    { return *(begin() + difference_type(__n)); }
    const_reference
    operator[](size_type __n) const
    { return *(begin() + difference_type(__n)); }
    void
    _M_range_check(size_type __n) const
    {
      if (__n >= this->size())
        __throw_out_of_range(("vector<bool>::_M_range_check"));
    }
    reference
    at(size_type __n)
    { _M_range_check(__n); return (*this)[__n]; }
    const_reference
    at(size_type __n) const
    { _M_range_check(__n); return (*this)[__n]; }
    explicit
    vector(const allocator_type& __a = allocator_type())
    : _Bvector_base<_Alloc>(__a) { }
    vector(size_type __n, bool __value,
    const allocator_type& __a = allocator_type())
    : _Bvector_base<_Alloc>(__a)
    {
      _M_initialize(__n);
      std::fill(this->_M_impl._M_start._M_p, this->_M_impl._M_end_of_storage,
  __value ? ~0 : 0);
    }
    explicit
    vector(size_type __n)
    : _Bvector_base<_Alloc>(allocator_type())
    {
      _M_initialize(__n);
      std::fill(this->_M_impl._M_start._M_p,
  this->_M_impl._M_end_of_storage, 0);
    }
    vector(const vector& __x)
    : _Bvector_base<_Alloc>(__x.get_allocator())
    {
      _M_initialize(__x.size());
      std::copy(__x.begin(), __x.end(), this->_M_impl._M_start);
    }
    template<class _Integer>
      void
      _M_initialize_dispatch(_Integer __n, _Integer __x, __true_type)
      {
 _M_initialize(__n);
 std::fill(this->_M_impl._M_start._M_p,
    this->_M_impl._M_end_of_storage, __x ? ~0 : 0);
      }
    template<class _InputIterator>
      void
      _M_initialize_dispatch(_InputIterator __first, _InputIterator __last,
        __false_type)
      { _M_initialize_range(__first, __last,
       std::__iterator_category(__first)); }
    template<class _InputIterator>
      vector(_InputIterator __first, _InputIterator __last,
      const allocator_type& __a = allocator_type())
      : _Bvector_base<_Alloc>(__a)
      {
 typedef typename std::__is_integer<_InputIterator>::__type _Integral;
 _M_initialize_dispatch(__first, __last, _Integral());
      }
    ~vector() { }
    vector&
    operator=(const vector& __x)
    {
      if (&__x == this)
 return *this;
      if (__x.size() > capacity())
 {
   this->_M_deallocate();
   _M_initialize(__x.size());
 }
      std::copy(__x.begin(), __x.end(), begin());
      this->_M_impl._M_finish = begin() + difference_type(__x.size());
      return *this;
    }
    void
    _M_fill_assign(size_t __n, bool __x)
    {
      if (__n > size())
 {
   std::fill(this->_M_impl._M_start._M_p,
      this->_M_impl._M_end_of_storage, __x ? ~0 : 0);
   insert(end(), __n - size(), __x);
 }
      else
 {
   erase(begin() + __n, end());
   std::fill(this->_M_impl._M_start._M_p,
      this->_M_impl._M_end_of_storage, __x ? ~0 : 0);
 }
    }
    void
    assign(size_t __n, bool __x)
    { _M_fill_assign(__n, __x); }
    template<class _InputIterator>
      void
      assign(_InputIterator __first, _InputIterator __last)
      {
 typedef typename std::__is_integer<_InputIterator>::__type _Integral;
 _M_assign_dispatch(__first, __last, _Integral());
      }
    template<class _Integer>
      void
      _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)
      { _M_fill_assign((size_t) __n, (bool) __val); }
    template<class _InputIterator>
      void
      _M_assign_dispatch(_InputIterator __first, _InputIterator __last,
    __false_type)
      { _M_assign_aux(__first, __last, std::__iterator_category(__first)); }
    template<class _InputIterator>
      void
      _M_assign_aux(_InputIterator __first, _InputIterator __last,
      std::input_iterator_tag)
      {
 iterator __cur = begin();
 for (; __first != __last && __cur != end(); ++__cur, ++__first)
   *__cur = *__first;
 if (__first == __last)
   erase(__cur, end());
 else
   insert(end(), __first, __last);
      }
    template<class _ForwardIterator>
      void
      _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
      std::forward_iterator_tag)
      {
 const size_type __len = std::distance(__first, __last);
 if (__len < size())
   erase(std::copy(__first, __last, begin()), end());
 else
   {
     _ForwardIterator __mid = __first;
     std::advance(__mid, size());
     std::copy(__first, __mid, begin());
     insert(end(), __mid, __last);
   }
      }
    void
    reserve(size_type __n)
    {
      if (__n > this->max_size())
 __throw_length_error(("vector::reserve"));
      if (this->capacity() < __n)
 {
   _Bit_type* __q = this->_M_allocate(__n);
   this->_M_impl._M_finish = std::copy(begin(), end(),
           iterator(__q, 0));
   this->_M_deallocate();
   this->_M_impl._M_start = iterator(__q, 0);
   this->_M_impl._M_end_of_storage = (__q + (__n + int(_S_word_bit) - 1)
          / int(_S_word_bit));
 }
    }
    reference
    front()
    { return *begin(); }
    const_reference
    front() const
    { return *begin(); }
    reference
    back()
    { return *(end() - 1); }
    const_reference
    back() const
    { return *(end() - 1); }
    void
    data() { }
    void
    push_back(bool __x)
    {
      if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_of_storage)
        *this->_M_impl._M_finish++ = __x;
      else
        _M_insert_aux(end(), __x);
    }
    void
    swap(vector<bool, _Alloc>& __x)
    {
      std::swap(this->_M_impl._M_start, __x._M_impl._M_start);
      std::swap(this->_M_impl._M_finish, __x._M_impl._M_finish);
      std::swap(this->_M_impl._M_end_of_storage,
  __x._M_impl._M_end_of_storage);
    }
    static void
    swap(reference __x, reference __y)
    {
      bool __tmp = __x;
      __x = __y;
      __y = __tmp;
    }
    iterator
    insert(iterator __position, bool __x = bool())
    {
      const difference_type __n = __position - begin();
      if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_of_storage
   && __position == end())
        *this->_M_impl._M_finish++ = __x;
      else
        _M_insert_aux(__position, __x);
      return begin() + __n;
    }
    template<class _Integer>
      void
      _M_insert_dispatch(iterator __pos, _Integer __n, _Integer __x,
    __true_type)
      { _M_fill_insert(__pos, __n, __x); }
    template<class _InputIterator>
      void
      _M_insert_dispatch(iterator __pos,
    _InputIterator __first, _InputIterator __last,
    __false_type)
      { _M_insert_range(__pos, __first, __last,
   std::__iterator_category(__first)); }
    template<class _InputIterator>
      void
      insert(iterator __position,
      _InputIterator __first, _InputIterator __last)
      {
 typedef typename std::__is_integer<_InputIterator>::__type _Integral;
 _M_insert_dispatch(__position, __first, __last, _Integral());
      }
    void
    _M_fill_insert(iterator __position, size_type __n, bool __x)
    {
      if (__n == 0)
 return;
      if (capacity() - size() >= __n)
 {
   std::copy_backward(__position, end(),
        this->_M_impl._M_finish + difference_type(__n));
   std::fill(__position, __position + difference_type(__n), __x);
   this->_M_impl._M_finish += difference_type(__n);
 }
      else
 {
   const size_type __len = size() + std::max(size(), __n);
   _Bit_type * __q = this->_M_allocate(__len);
   iterator __i = std::copy(begin(), __position, iterator(__q, 0));
   std::fill_n(__i, __n, __x);
   this->_M_impl._M_finish = std::copy(__position, end(),
           __i + difference_type(__n));
   this->_M_deallocate();
   this->_M_impl._M_end_of_storage = (__q + ((__len
           + int(_S_word_bit) - 1)
          / int(_S_word_bit)));
   this->_M_impl._M_start = iterator(__q, 0);
 }
    }
    void
    insert(iterator __position, size_type __n, bool __x)
    { _M_fill_insert(__position, __n, __x); }
    void
    pop_back()
    { --this->_M_impl._M_finish; }
    iterator
    erase(iterator __position)
    {
      if (__position + 1 != end())
        std::copy(__position + 1, end(), __position);
      --this->_M_impl._M_finish;
      return __position;
    }
    iterator
    erase(iterator __first, iterator __last)
    {
      this->_M_impl._M_finish = std::copy(__last, end(), __first);
      return __first;
    }
    void
    resize(size_type __new_size, bool __x = bool())
    {
      if (__new_size < size())
        erase(begin() + difference_type(__new_size), end());
      else
        insert(end(), __new_size - size(), __x);
    }
    void
    flip()
    {
      for (_Bit_type * __p = this->_M_impl._M_start._M_p;
    __p != this->_M_impl._M_end_of_storage; ++__p)
        *__p = ~*__p;
    }
    void
    clear()
    { erase(begin(), end()); }
  };
}
namespace std
{
  template<typename _Tp, typename _Alloc>
    void
    vector<_Tp, _Alloc>::
    reserve(size_type __n)
    {
      if (__n > this->max_size())
 __throw_length_error(("vector::reserve"));
      if (this->capacity() < __n)
 {
   const size_type __old_size = size();
   pointer __tmp = _M_allocate_and_copy(__n,
            this->_M_impl._M_start,
            this->_M_impl._M_finish);
   std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
   _M_get_Tp_allocator());
   _M_deallocate(this->_M_impl._M_start,
   this->_M_impl._M_end_of_storage
   - this->_M_impl._M_start);
   this->_M_impl._M_start = __tmp;
   this->_M_impl._M_finish = __tmp + __old_size;
   this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
 }
    }
  template<typename _Tp, typename _Alloc>
    typename vector<_Tp, _Alloc>::iterator
    vector<_Tp, _Alloc>::
    insert(iterator __position, const value_type& __x)
    {
      const size_type __n = __position - begin();
      if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage
   && __position == end())
 {
   this->_M_impl.construct(this->_M_impl._M_finish, __x);
   ++this->_M_impl._M_finish;
 }
      else
        _M_insert_aux(__position, __x);
      return begin() + __n;
    }
  template<typename _Tp, typename _Alloc>
    typename vector<_Tp, _Alloc>::iterator
    vector<_Tp, _Alloc>::
    erase(iterator __position)
    {
      if (__position + 1 != end())
        std::copy(__position + 1, end(), __position);
      --this->_M_impl._M_finish;
      this->_M_impl.destroy(this->_M_impl._M_finish);
      return __position;
    }
  template<typename _Tp, typename _Alloc>
    typename vector<_Tp, _Alloc>::iterator
    vector<_Tp, _Alloc>::
    erase(iterator __first, iterator __last)
    {
      iterator __i(std::copy(__last, end(), __first));
      std::_Destroy(__i, end(), _M_get_Tp_allocator());
      this->_M_impl._M_finish = this->_M_impl._M_finish - (__last - __first);
      return __first;
    }
  template<typename _Tp, typename _Alloc>
    vector<_Tp, _Alloc>&
    vector<_Tp, _Alloc>::
    operator=(const vector<_Tp, _Alloc>& __x)
    {
      if (&__x != this)
 {
   const size_type __xlen = __x.size();
   if (__xlen > capacity())
     {
       pointer __tmp = _M_allocate_and_copy(__xlen, __x.begin(),
         __x.end());
       std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
       _M_get_Tp_allocator());
       _M_deallocate(this->_M_impl._M_start,
       this->_M_impl._M_end_of_storage
       - this->_M_impl._M_start);
       this->_M_impl._M_start = __tmp;
       this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __xlen;
     }
   else if (size() >= __xlen)
     {
       iterator __i(std::copy(__x.begin(), __x.end(), begin()));
       std::_Destroy(__i, end(), _M_get_Tp_allocator());
     }
   else
     {
       std::copy(__x.begin(), __x.begin() + size(),
   this->_M_impl._M_start);
       std::__uninitialized_copy_a(__x.begin() + size(),
       __x.end(), this->_M_impl._M_finish,
       _M_get_Tp_allocator());
     }
   this->_M_impl._M_finish = this->_M_impl._M_start + __xlen;
 }
      return *this;
    }
  template<typename _Tp, typename _Alloc>
    void
    vector<_Tp, _Alloc>::
    _M_fill_assign(size_t __n, const value_type& __val)
    {
      if (__n > capacity())
 {
   vector __tmp(__n, __val, _M_get_Tp_allocator());
   __tmp.swap(*this);
 }
      else if (__n > size())
 {
   std::fill(begin(), end(), __val);
   std::__uninitialized_fill_n_a(this->_M_impl._M_finish,
     __n - size(), __val,
     _M_get_Tp_allocator());
   this->_M_impl._M_finish += __n - size();
 }
      else
        erase(std::fill_n(begin(), __n, __val), end());
    }
  template<typename _Tp, typename _Alloc>
    template<typename _InputIterator>
      void
      vector<_Tp, _Alloc>::
      _M_assign_aux(_InputIterator __first, _InputIterator __last,
      std::input_iterator_tag)
      {
 iterator __cur(begin());
 for (; __first != __last && __cur != end(); ++__cur, ++__first)
   *__cur = *__first;
 if (__first == __last)
   erase(__cur, end());
 else
   insert(end(), __first, __last);
      }
  template<typename _Tp, typename _Alloc>
    template<typename _ForwardIterator>
      void
      vector<_Tp, _Alloc>::
      _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
      std::forward_iterator_tag)
      {
 const size_type __len = std::distance(__first, __last);
 if (__len > capacity())
   {
     pointer __tmp(_M_allocate_and_copy(__len, __first, __last));
     std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
     _M_get_Tp_allocator());
     _M_deallocate(this->_M_impl._M_start,
     this->_M_impl._M_end_of_storage
     - this->_M_impl._M_start);
     this->_M_impl._M_start = __tmp;
     this->_M_impl._M_finish = this->_M_impl._M_start + __len;
     this->_M_impl._M_end_of_storage = this->_M_impl._M_finish;
   }
 else if (size() >= __len)
   {
     iterator __new_finish(std::copy(__first, __last,
           this->_M_impl._M_start));
     std::_Destroy(__new_finish, end(), _M_get_Tp_allocator());
     this->_M_impl._M_finish = __new_finish.base();
   }
 else
   {
     _ForwardIterator __mid = __first;
     std::advance(__mid, size());
     std::copy(__first, __mid, this->_M_impl._M_start);
     this->_M_impl._M_finish =
       std::__uninitialized_copy_a(__mid, __last,
       this->_M_impl._M_finish,
       _M_get_Tp_allocator());
   }
      }
  template<typename _Tp, typename _Alloc>
    void
    vector<_Tp, _Alloc>::
    _M_insert_aux(iterator __position, const _Tp& __x)
    {
      if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
 {
   this->_M_impl.construct(this->_M_impl._M_finish,
      *(this->_M_impl._M_finish - 1));
   ++this->_M_impl._M_finish;
   _Tp __x_copy = __x;
   std::copy_backward(__position,
        iterator(this->_M_impl._M_finish-2),
        iterator(this->_M_impl._M_finish-1));
   *__position = __x_copy;
 }
      else
 {
   const size_type __old_size = size();
   if (__old_size == this->max_size())
     __throw_length_error(("vector::_M_insert_aux"));
   size_type __len = __old_size != 0 ? 2 * __old_size : 1;
   if (__len < __old_size)
     __len = this->max_size();
   iterator __new_start(this->_M_allocate(__len));
   iterator __new_finish(__new_start);
   try
     {
       __new_finish =
  std::__uninitialized_copy_a(iterator(this->_M_impl._M_start),
         __position,
         __new_start,
         _M_get_Tp_allocator());
       this->_M_impl.construct(__new_finish.base(), __x);
       ++__new_finish;
       __new_finish =
  std::__uninitialized_copy_a(__position,
         iterator(this->_M_impl._M_finish),
         __new_finish,
         _M_get_Tp_allocator());
     }
   catch(...)
     {
       std::_Destroy(__new_start, __new_finish, _M_get_Tp_allocator());
       _M_deallocate(__new_start.base(),__len);
       throw;
     }
   std::_Destroy(begin(), end(), _M_get_Tp_allocator());
   _M_deallocate(this->_M_impl._M_start,
   this->_M_impl._M_end_of_storage
   - this->_M_impl._M_start);
   this->_M_impl._M_start = __new_start.base();
   this->_M_impl._M_finish = __new_finish.base();
   this->_M_impl._M_end_of_storage = __new_start.base() + __len;
 }
    }
  template<typename _Tp, typename _Alloc>
    void
    vector<_Tp, _Alloc>::
    _M_fill_insert(iterator __position, size_type __n, const value_type& __x)
    {
      if (__n != 0)
 {
   if (size_type(this->_M_impl._M_end_of_storage
   - this->_M_impl._M_finish) >= __n)
     {
       value_type __x_copy = __x;
       const size_type __elems_after = end() - __position;
       iterator __old_finish(this->_M_impl._M_finish);
       if (__elems_after > __n)
  {
    std::__uninitialized_copy_a(this->_M_impl._M_finish - __n,
           this->_M_impl._M_finish,
           this->_M_impl._M_finish,
           _M_get_Tp_allocator());
    this->_M_impl._M_finish += __n;
    std::copy_backward(__position, __old_finish - __n,
         __old_finish);
    std::fill(__position, __position + __n, __x_copy);
  }
       else
  {
    std::__uninitialized_fill_n_a(this->_M_impl._M_finish,
      __n - __elems_after,
      __x_copy,
      _M_get_Tp_allocator());
    this->_M_impl._M_finish += __n - __elems_after;
    std::__uninitialized_copy_a(__position, __old_finish,
           this->_M_impl._M_finish,
           _M_get_Tp_allocator());
    this->_M_impl._M_finish += __elems_after;
    std::fill(__position, __old_finish, __x_copy);
  }
     }
   else
     {
       const size_type __old_size = size();
       if (this->max_size() - __old_size < __n)
  __throw_length_error(("vector::_M_fill_insert"));
       size_type __len = __old_size + std::max(__old_size, __n);
       if (__len < __old_size)
  __len = this->max_size();
       iterator __new_start(this->_M_allocate(__len));
       iterator __new_finish(__new_start);
       try
  {
    __new_finish =
      std::__uninitialized_copy_a(begin(), __position,
      __new_start,
      _M_get_Tp_allocator());
    std::__uninitialized_fill_n_a(__new_finish, __n, __x,
      _M_get_Tp_allocator());
    __new_finish += __n;
    __new_finish =
      std::__uninitialized_copy_a(__position, end(), __new_finish,
      _M_get_Tp_allocator());
  }
       catch(...)
  {
    std::_Destroy(__new_start, __new_finish,
    _M_get_Tp_allocator());
    _M_deallocate(__new_start.base(), __len);
    throw;
  }
       std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
       _M_get_Tp_allocator());
       _M_deallocate(this->_M_impl._M_start,
       this->_M_impl._M_end_of_storage
       - this->_M_impl._M_start);
       this->_M_impl._M_start = __new_start.base();
       this->_M_impl._M_finish = __new_finish.base();
       this->_M_impl._M_end_of_storage = __new_start.base() + __len;
     }
 }
    }
  template<typename _Tp, typename _Alloc> template<typename _InputIterator>
    void
    vector<_Tp, _Alloc>::
    _M_range_insert(iterator __pos, _InputIterator __first,
      _InputIterator __last, std::input_iterator_tag)
    {
      for (; __first != __last; ++__first)
 {
   __pos = insert(__pos, *__first);
   ++__pos;
 }
    }
  template<typename _Tp, typename _Alloc>
    template<typename _ForwardIterator>
      void
      vector<_Tp, _Alloc>::
      _M_range_insert(iterator __position, _ForwardIterator __first,
        _ForwardIterator __last, std::forward_iterator_tag)
      {
 if (__first != __last)
   {
     const size_type __n = std::distance(__first, __last);
     if (size_type(this->_M_impl._M_end_of_storage
     - this->_M_impl._M_finish) >= __n)
       {
  const size_type __elems_after = end() - __position;
  iterator __old_finish(this->_M_impl._M_finish);
  if (__elems_after > __n)
    {
      std::__uninitialized_copy_a(this->_M_impl._M_finish - __n,
      this->_M_impl._M_finish,
      this->_M_impl._M_finish,
      _M_get_Tp_allocator());
      this->_M_impl._M_finish += __n;
      std::copy_backward(__position, __old_finish - __n,
           __old_finish);
      std::copy(__first, __last, __position);
    }
  else
    {
      _ForwardIterator __mid = __first;
      std::advance(__mid, __elems_after);
      std::__uninitialized_copy_a(__mid, __last,
      this->_M_impl._M_finish,
      _M_get_Tp_allocator());
      this->_M_impl._M_finish += __n - __elems_after;
      std::__uninitialized_copy_a(__position, __old_finish,
      this->_M_impl._M_finish,
      _M_get_Tp_allocator());
      this->_M_impl._M_finish += __elems_after;
      std::copy(__first, __mid, __position);
    }
       }
     else
       {
  const size_type __old_size = size();
  if (this->max_size() - __old_size < __n)
    __throw_length_error(("vector::_M_range_insert"));
  size_type __len = __old_size + std::max(__old_size, __n);
  if (__len < __old_size)
    __len = this->max_size();
  iterator __new_start(this->_M_allocate(__len));
  iterator __new_finish(__new_start);
  try
    {
      __new_finish =
        std::__uninitialized_copy_a(iterator(this->_M_impl._M_start),
        __position,
        __new_start,
        _M_get_Tp_allocator());
      __new_finish =
        std::__uninitialized_copy_a(__first, __last, __new_finish,
        _M_get_Tp_allocator());
      __new_finish =
        std::__uninitialized_copy_a(__position,
        iterator(this->_M_impl._M_finish),
        __new_finish,
        _M_get_Tp_allocator());
    }
  catch(...)
    {
      std::_Destroy(__new_start,__new_finish,
      _M_get_Tp_allocator());
      _M_deallocate(__new_start.base(), __len);
      throw;
    }
  std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
         _M_get_Tp_allocator());
  _M_deallocate(this->_M_impl._M_start,
         this->_M_impl._M_end_of_storage
         - this->_M_impl._M_start);
  this->_M_impl._M_start = __new_start.base();
  this->_M_impl._M_finish = __new_finish.base();
  this->_M_impl._M_end_of_storage = __new_start.base() + __len;
       }
   }
      }
}
namespace std
{
  inline size_t
  __deque_buf_size(size_t __size)
  { return __size < 512 ? size_t(512 / __size) : size_t(1); }
  template<typename _Tp, typename _Ref, typename _Ptr>
    struct _Deque_iterator
    {
      typedef _Deque_iterator<_Tp, _Tp&, _Tp*> iterator;
      typedef _Deque_iterator<_Tp, const _Tp&, const _Tp*> const_iterator;
      static size_t _S_buffer_size()
      { return __deque_buf_size(sizeof(_Tp)); }
      typedef std::random_access_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef _Ptr pointer;
      typedef _Ref reference;
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp** _Map_pointer;
      typedef _Deque_iterator _Self;
      _Tp* _M_cur;
      _Tp* _M_first;
      _Tp* _M_last;
      _Map_pointer _M_node;
      _Deque_iterator(_Tp* __x, _Map_pointer __y)
      : _M_cur(__x), _M_first(*__y),
        _M_last(*__y + _S_buffer_size()), _M_node(__y) {}
      _Deque_iterator() : _M_cur(0), _M_first(0), _M_last(0), _M_node(0) {}
      _Deque_iterator(const iterator& __x)
      : _M_cur(__x._M_cur), _M_first(__x._M_first),
        _M_last(__x._M_last), _M_node(__x._M_node) {}
      reference
      operator*() const
      { return *_M_cur; }
      pointer
      operator->() const
      { return _M_cur; }
      _Self&
      operator++()
      {
 ++_M_cur;
 if (_M_cur == _M_last)
   {
     _M_set_node(_M_node + 1);
     _M_cur = _M_first;
   }
 return *this;
      }
      _Self
      operator++(int)
      {
 _Self __tmp = *this;
 ++*this;
 return __tmp;
      }
      _Self&
      operator--()
      {
 if (_M_cur == _M_first)
   {
     _M_set_node(_M_node - 1);
     _M_cur = _M_last;
   }
 --_M_cur;
 return *this;
      }
      _Self
      operator--(int)
      {
 _Self __tmp = *this;
 --*this;
 return __tmp;
      }
      _Self&
      operator+=(difference_type __n)
      {
 const difference_type __offset = __n + (_M_cur - _M_first);
 if (__offset >= 0 && __offset < difference_type(_S_buffer_size()))
   _M_cur += __n;
 else
   {
     const difference_type __node_offset =
       __offset > 0 ? __offset / difference_type(_S_buffer_size())
                    : -difference_type((-__offset - 1)
           / _S_buffer_size()) - 1;
     _M_set_node(_M_node + __node_offset);
     _M_cur = _M_first + (__offset - __node_offset
     * difference_type(_S_buffer_size()));
   }
 return *this;
      }
      _Self
      operator+(difference_type __n) const
      {
 _Self __tmp = *this;
 return __tmp += __n;
      }
      _Self&
      operator-=(difference_type __n)
      { return *this += -__n; }
      _Self
      operator-(difference_type __n) const
      {
 _Self __tmp = *this;
 return __tmp -= __n;
      }
      reference
      operator[](difference_type __n) const
      { return *(*this + __n); }
      void
      _M_set_node(_Map_pointer __new_node)
      {
 _M_node = __new_node;
 _M_first = *__new_node;
 _M_last = _M_first + difference_type(_S_buffer_size());
      }
    };
  template<typename _Tp, typename _Ref, typename _Ptr>
    inline bool
    operator==(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
        const _Deque_iterator<_Tp, _Ref, _Ptr>& __y)
    { return __x._M_cur == __y._M_cur; }
  template<typename _Tp, typename _RefL, typename _PtrL,
    typename _RefR, typename _PtrR>
    inline bool
    operator==(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,
        const _Deque_iterator<_Tp, _RefR, _PtrR>& __y)
    { return __x._M_cur == __y._M_cur; }
  template<typename _Tp, typename _Ref, typename _Ptr>
    inline bool
    operator!=(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
        const _Deque_iterator<_Tp, _Ref, _Ptr>& __y)
    { return !(__x == __y); }
  template<typename _Tp, typename _RefL, typename _PtrL,
    typename _RefR, typename _PtrR>
    inline bool
    operator!=(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,
        const _Deque_iterator<_Tp, _RefR, _PtrR>& __y)
    { return !(__x == __y); }
  template<typename _Tp, typename _Ref, typename _Ptr>
    inline bool
    operator<(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
       const _Deque_iterator<_Tp, _Ref, _Ptr>& __y)
    { return (__x._M_node == __y._M_node) ? (__x._M_cur < __y._M_cur)
                                          : (__x._M_node < __y._M_node); }
  template<typename _Tp, typename _RefL, typename _PtrL,
    typename _RefR, typename _PtrR>
    inline bool
    operator<(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,
       const _Deque_iterator<_Tp, _RefR, _PtrR>& __y)
    { return (__x._M_node == __y._M_node) ? (__x._M_cur < __y._M_cur)
                                   : (__x._M_node < __y._M_node); }
  template<typename _Tp, typename _Ref, typename _Ptr>
    inline bool
    operator>(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
       const _Deque_iterator<_Tp, _Ref, _Ptr>& __y)
    { return __y < __x; }
  template<typename _Tp, typename _RefL, typename _PtrL,
    typename _RefR, typename _PtrR>
    inline bool
    operator>(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,
       const _Deque_iterator<_Tp, _RefR, _PtrR>& __y)
    { return __y < __x; }
  template<typename _Tp, typename _Ref, typename _Ptr>
    inline bool
    operator<=(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
        const _Deque_iterator<_Tp, _Ref, _Ptr>& __y)
    { return !(__y < __x); }
  template<typename _Tp, typename _RefL, typename _PtrL,
    typename _RefR, typename _PtrR>
    inline bool
    operator<=(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,
        const _Deque_iterator<_Tp, _RefR, _PtrR>& __y)
    { return !(__y < __x); }
  template<typename _Tp, typename _Ref, typename _Ptr>
    inline bool
    operator>=(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
        const _Deque_iterator<_Tp, _Ref, _Ptr>& __y)
    { return !(__x < __y); }
  template<typename _Tp, typename _RefL, typename _PtrL,
    typename _RefR, typename _PtrR>
    inline bool
    operator>=(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,
        const _Deque_iterator<_Tp, _RefR, _PtrR>& __y)
    { return !(__x < __y); }
  template<typename _Tp, typename _RefL, typename _PtrL,
    typename _RefR, typename _PtrR>
    inline typename _Deque_iterator<_Tp, _RefL, _PtrL>::difference_type
    operator-(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,
       const _Deque_iterator<_Tp, _RefR, _PtrR>& __y)
    {
      return typename _Deque_iterator<_Tp, _RefL, _PtrL>::difference_type
 (_Deque_iterator<_Tp, _RefL, _PtrL>::_S_buffer_size())
 * (__x._M_node - __y._M_node - 1) + (__x._M_cur - __x._M_first)
 + (__y._M_last - __y._M_cur);
    }
  template<typename _Tp, typename _Ref, typename _Ptr>
    inline _Deque_iterator<_Tp, _Ref, _Ptr>
    operator+(ptrdiff_t __n, const _Deque_iterator<_Tp, _Ref, _Ptr>& __x)
    { return __x + __n; }
  template<typename _Tp, typename _Alloc>
    class _Deque_base
    {
    public:
      typedef _Alloc allocator_type;
      allocator_type
      get_allocator() const
      { return _M_get_Tp_allocator(); }
      typedef _Deque_iterator<_Tp, _Tp&, _Tp*> iterator;
      typedef _Deque_iterator<_Tp, const _Tp&, const _Tp*> const_iterator;
      _Deque_base(const allocator_type& __a, size_t __num_elements)
      : _M_impl(__a)
      { _M_initialize_map(__num_elements); }
      _Deque_base(const allocator_type& __a)
      : _M_impl(__a)
      { }
      ~_Deque_base();
    protected:
      typedef typename _Alloc::template rebind<_Tp*>::other _Map_alloc_type;
      typedef typename _Alloc::template rebind<_Tp>::other _Tp_alloc_type;
      struct _Deque_impl
      : public _Tp_alloc_type
      {
 _Tp** _M_map;
 size_t _M_map_size;
 iterator _M_start;
 iterator _M_finish;
 _Deque_impl(const _Tp_alloc_type& __a)
 : _Tp_alloc_type(__a), _M_map(0), _M_map_size(0),
   _M_start(), _M_finish()
 { }
      };
      _Tp_alloc_type&
      _M_get_Tp_allocator()
      { return *static_cast<_Tp_alloc_type*>(&this->_M_impl); }
      const _Tp_alloc_type&
      _M_get_Tp_allocator() const
      { return *static_cast<const _Tp_alloc_type*>(&this->_M_impl); }
      _Map_alloc_type
      _M_get_map_allocator() const
      { return _M_get_Tp_allocator(); }
      _Tp*
      _M_allocate_node()
      {
 return _M_impl._Tp_alloc_type::allocate(__deque_buf_size(sizeof(_Tp)));
      }
      void
      _M_deallocate_node(_Tp* __p)
      {
 _M_impl._Tp_alloc_type::deallocate(__p, __deque_buf_size(sizeof(_Tp)));
      }
      _Tp**
      _M_allocate_map(size_t __n)
      { return _M_get_map_allocator().allocate(__n); }
      void
      _M_deallocate_map(_Tp** __p, size_t __n)
      { _M_get_map_allocator().deallocate(__p, __n); }
    protected:
      void _M_initialize_map(size_t);
      void _M_create_nodes(_Tp** __nstart, _Tp** __nfinish);
      void _M_destroy_nodes(_Tp** __nstart, _Tp** __nfinish);
      enum { _S_initial_map_size = 8 };
      _Deque_impl _M_impl;
    };
  template<typename _Tp, typename _Alloc>
    _Deque_base<_Tp, _Alloc>::
    ~_Deque_base()
    {
      if (this->_M_impl._M_map)
 {
   _M_destroy_nodes(this->_M_impl._M_start._M_node,
      this->_M_impl._M_finish._M_node + 1);
   _M_deallocate_map(this->_M_impl._M_map, this->_M_impl._M_map_size);
 }
    }
  template<typename _Tp, typename _Alloc>
    void
    _Deque_base<_Tp, _Alloc>::
    _M_initialize_map(size_t __num_elements)
    {
      const size_t __num_nodes = (__num_elements/ __deque_buf_size(sizeof(_Tp))
      + 1);
      this->_M_impl._M_map_size = std::max((size_t) _S_initial_map_size,
        size_t(__num_nodes + 2));
      this->_M_impl._M_map = _M_allocate_map(this->_M_impl._M_map_size);
      _Tp** __nstart = (this->_M_impl._M_map
   + (this->_M_impl._M_map_size - __num_nodes) / 2);
      _Tp** __nfinish = __nstart + __num_nodes;
      try
 { _M_create_nodes(__nstart, __nfinish); }
      catch(...)
 {
   _M_deallocate_map(this->_M_impl._M_map, this->_M_impl._M_map_size);
   this->_M_impl._M_map = 0;
   this->_M_impl._M_map_size = 0;
   throw;
 }
      this->_M_impl._M_start._M_set_node(__nstart);
      this->_M_impl._M_finish._M_set_node(__nfinish - 1);
      this->_M_impl._M_start._M_cur = _M_impl._M_start._M_first;
      this->_M_impl._M_finish._M_cur = (this->_M_impl._M_finish._M_first
     + __num_elements
     % __deque_buf_size(sizeof(_Tp)));
    }
  template<typename _Tp, typename _Alloc>
    void
    _Deque_base<_Tp, _Alloc>::
    _M_create_nodes(_Tp** __nstart, _Tp** __nfinish)
    {
      _Tp** __cur;
      try
 {
   for (__cur = __nstart; __cur < __nfinish; ++__cur)
     *__cur = this->_M_allocate_node();
 }
      catch(...)
 {
   _M_destroy_nodes(__nstart, __cur);
   throw;
 }
    }
  template<typename _Tp, typename _Alloc>
    void
    _Deque_base<_Tp, _Alloc>::
    _M_destroy_nodes(_Tp** __nstart, _Tp** __nfinish)
    {
      for (_Tp** __n = __nstart; __n < __nfinish; ++__n)
 _M_deallocate_node(*__n);
    }
  template<typename _Tp, typename _Alloc = std::allocator<_Tp> >
    class deque : protected _Deque_base<_Tp, _Alloc>
    {
      typedef typename _Alloc::value_type _Alloc_value_type;
      typedef _Deque_base<_Tp, _Alloc> _Base;
      typedef typename _Base::_Tp_alloc_type _Tp_alloc_type;
    public:
      typedef _Tp value_type;
      typedef typename _Tp_alloc_type::pointer pointer;
      typedef typename _Tp_alloc_type::const_pointer const_pointer;
      typedef typename _Tp_alloc_type::reference reference;
      typedef typename _Tp_alloc_type::const_reference const_reference;
      typedef typename _Base::iterator iterator;
      typedef typename _Base::const_iterator const_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
      typedef std::reverse_iterator<iterator> reverse_iterator;
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Alloc allocator_type;
    protected:
      typedef pointer* _Map_pointer;
      static size_t _S_buffer_size()
      { return __deque_buf_size(sizeof(_Tp)); }
      using _Base::_M_initialize_map;
      using _Base::_M_create_nodes;
      using _Base::_M_destroy_nodes;
      using _Base::_M_allocate_node;
      using _Base::_M_deallocate_node;
      using _Base::_M_allocate_map;
      using _Base::_M_deallocate_map;
      using _Base::_M_get_Tp_allocator;
      using _Base::_M_impl;
    public:
      explicit
      deque(const allocator_type& __a = allocator_type())
      : _Base(__a, 0) {}
      explicit
      deque(size_type __n, const value_type& __value = value_type(),
     const allocator_type& __a = allocator_type())
      : _Base(__a, __n)
      { _M_fill_initialize(__value); }
      deque(const deque& __x)
      : _Base(__x.get_allocator(), __x.size())
      { std::__uninitialized_copy_a(__x.begin(), __x.end(),
        this->_M_impl._M_start,
        _M_get_Tp_allocator()); }
      template<typename _InputIterator>
        deque(_InputIterator __first, _InputIterator __last,
       const allocator_type& __a = allocator_type())
 : _Base(__a)
        {
   typedef typename std::__is_integer<_InputIterator>::__type _Integral;
   _M_initialize_dispatch(__first, __last, _Integral());
 }
      ~deque()
      { std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
        _M_get_Tp_allocator()); }
      deque&
      operator=(const deque& __x);
      void
      assign(size_type __n, const value_type& __val)
      { _M_fill_assign(__n, __val); }
      template<typename _InputIterator>
        void
        assign(_InputIterator __first, _InputIterator __last)
        {
   typedef typename std::__is_integer<_InputIterator>::__type _Integral;
   _M_assign_dispatch(__first, __last, _Integral());
 }
      allocator_type
      get_allocator() const
      { return _Base::get_allocator(); }
      iterator
      begin()
      { return this->_M_impl._M_start; }
      const_iterator
      begin() const
      { return this->_M_impl._M_start; }
      iterator
      end()
      { return this->_M_impl._M_finish; }
      const_iterator
      end() const
      { return this->_M_impl._M_finish; }
      reverse_iterator
      rbegin()
      { return reverse_iterator(this->_M_impl._M_finish); }
      const_reverse_iterator
      rbegin() const
      { return const_reverse_iterator(this->_M_impl._M_finish); }
      reverse_iterator
      rend() { return reverse_iterator(this->_M_impl._M_start); }
      const_reverse_iterator
      rend() const
      { return const_reverse_iterator(this->_M_impl._M_start); }
      size_type
      size() const
      { return this->_M_impl._M_finish - this->_M_impl._M_start; }
      size_type
      max_size() const
      { return size_type(-1); }
      void
      resize(size_type __new_size, value_type __x = value_type())
      {
 const size_type __len = size();
 if (__new_size < __len)
   erase(this->_M_impl._M_start + __new_size, this->_M_impl._M_finish);
 else
   insert(this->_M_impl._M_finish, __new_size - __len, __x);
      }
      bool
      empty() const
      { return this->_M_impl._M_finish == this->_M_impl._M_start; }
      reference
      operator[](size_type __n)
      { return this->_M_impl._M_start[difference_type(__n)]; }
      const_reference
      operator[](size_type __n) const
      { return this->_M_impl._M_start[difference_type(__n)]; }
    protected:
      void
      _M_range_check(size_type __n) const
      {
 if (__n >= this->size())
   __throw_out_of_range(("deque::_M_range_check"));
      }
    public:
      reference
      at(size_type __n)
      {
 _M_range_check(__n);
 return (*this)[__n];
      }
      const_reference
      at(size_type __n) const
      {
 _M_range_check(__n);
 return (*this)[__n];
      }
      reference
      front()
      { return *begin(); }
      const_reference
      front() const
      { return *begin(); }
      reference
      back()
      {
 iterator __tmp = end();
 --__tmp;
 return *__tmp;
      }
      const_reference
      back() const
      {
 const_iterator __tmp = end();
 --__tmp;
 return *__tmp;
      }
      void
      push_front(const value_type& __x)
      {
 if (this->_M_impl._M_start._M_cur != this->_M_impl._M_start._M_first)
   {
     this->_M_impl.construct(this->_M_impl._M_start._M_cur - 1, __x);
     --this->_M_impl._M_start._M_cur;
   }
 else
   _M_push_front_aux(__x);
      }
      void
      push_back(const value_type& __x)
      {
 if (this->_M_impl._M_finish._M_cur
     != this->_M_impl._M_finish._M_last - 1)
   {
     this->_M_impl.construct(this->_M_impl._M_finish._M_cur, __x);
     ++this->_M_impl._M_finish._M_cur;
   }
 else
   _M_push_back_aux(__x);
      }
      void
      pop_front()
      {
 if (this->_M_impl._M_start._M_cur
     != this->_M_impl._M_start._M_last - 1)
   {
     this->_M_impl.destroy(this->_M_impl._M_start._M_cur);
     ++this->_M_impl._M_start._M_cur;
   }
 else
   _M_pop_front_aux();
      }
      void
      pop_back()
      {
 if (this->_M_impl._M_finish._M_cur
     != this->_M_impl._M_finish._M_first)
   {
     --this->_M_impl._M_finish._M_cur;
     this->_M_impl.destroy(this->_M_impl._M_finish._M_cur);
   }
 else
   _M_pop_back_aux();
      }
      iterator
      insert(iterator position, const value_type& __x);
      void
      insert(iterator __position, size_type __n, const value_type& __x)
      { _M_fill_insert(__position, __n, __x); }
      template<typename _InputIterator>
        void
        insert(iterator __position, _InputIterator __first,
        _InputIterator __last)
        {
   typedef typename std::__is_integer<_InputIterator>::__type _Integral;
   _M_insert_dispatch(__position, __first, __last, _Integral());
 }
      iterator
      erase(iterator __position);
      iterator
      erase(iterator __first, iterator __last);
      void
      swap(deque& __x)
      {
 std::swap(this->_M_impl._M_start, __x._M_impl._M_start);
 std::swap(this->_M_impl._M_finish, __x._M_impl._M_finish);
 std::swap(this->_M_impl._M_map, __x._M_impl._M_map);
 std::swap(this->_M_impl._M_map_size, __x._M_impl._M_map_size);
      }
      void clear();
    protected:
      template<typename _Integer>
        void
        _M_initialize_dispatch(_Integer __n, _Integer __x, __true_type)
        {
   _M_initialize_map(__n);
   _M_fill_initialize(__x);
 }
      template<typename _InputIterator>
        void
        _M_initialize_dispatch(_InputIterator __first, _InputIterator __last,
          __false_type)
        {
   typedef typename std::iterator_traits<_InputIterator>::
     iterator_category _IterCategory;
   _M_range_initialize(__first, __last, _IterCategory());
 }
      template<typename _InputIterator>
        void
        _M_range_initialize(_InputIterator __first, _InputIterator __last,
       std::input_iterator_tag);
      template<typename _ForwardIterator>
        void
        _M_range_initialize(_ForwardIterator __first, _ForwardIterator __last,
       std::forward_iterator_tag);
      void
      _M_fill_initialize(const value_type& __value);
      template<typename _Integer>
        void
        _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)
        {
   _M_fill_assign(static_cast<size_type>(__n),
    static_cast<value_type>(__val));
 }
      template<typename _InputIterator>
        void
        _M_assign_dispatch(_InputIterator __first, _InputIterator __last,
      __false_type)
        {
   typedef typename std::iterator_traits<_InputIterator>::
     iterator_category _IterCategory;
   _M_assign_aux(__first, __last, _IterCategory());
 }
      template<typename _InputIterator>
        void
        _M_assign_aux(_InputIterator __first, _InputIterator __last,
        std::input_iterator_tag);
      template<typename _ForwardIterator>
        void
        _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
        std::forward_iterator_tag)
        {
   const size_type __len = std::distance(__first, __last);
   if (__len > size())
     {
       _ForwardIterator __mid = __first;
       std::advance(__mid, size());
       std::copy(__first, __mid, begin());
       insert(end(), __mid, __last);
     }
   else
     erase(std::copy(__first, __last, begin()), end());
 }
      void
      _M_fill_assign(size_type __n, const value_type& __val)
      {
 if (__n > size())
   {
     std::fill(begin(), end(), __val);
     insert(end(), __n - size(), __val);
   }
 else
   {
     erase(begin() + __n, end());
     std::fill(begin(), end(), __val);
   }
      }
      void _M_push_back_aux(const value_type&);
      void _M_push_front_aux(const value_type&);
      void _M_pop_back_aux();
      void _M_pop_front_aux();
      template<typename _Integer>
        void
        _M_insert_dispatch(iterator __pos,
      _Integer __n, _Integer __x, __true_type)
        {
   _M_fill_insert(__pos, static_cast<size_type>(__n),
    static_cast<value_type>(__x));
 }
      template<typename _InputIterator>
        void
        _M_insert_dispatch(iterator __pos,
      _InputIterator __first, _InputIterator __last,
      __false_type)
        {
   typedef typename std::iterator_traits<_InputIterator>::
     iterator_category _IterCategory;
          _M_range_insert_aux(__pos, __first, __last, _IterCategory());
 }
      template<typename _InputIterator>
        void
        _M_range_insert_aux(iterator __pos, _InputIterator __first,
       _InputIterator __last, std::input_iterator_tag);
      template<typename _ForwardIterator>
        void
        _M_range_insert_aux(iterator __pos, _ForwardIterator __first,
       _ForwardIterator __last, std::forward_iterator_tag);
      void
      _M_fill_insert(iterator __pos, size_type __n, const value_type& __x);
      iterator
      _M_insert_aux(iterator __pos, const value_type& __x);
      void
      _M_insert_aux(iterator __pos, size_type __n, const value_type& __x);
      template<typename _ForwardIterator>
        void
        _M_insert_aux(iterator __pos,
        _ForwardIterator __first, _ForwardIterator __last,
        size_type __n);
      iterator
      _M_reserve_elements_at_front(size_type __n)
      {
 const size_type __vacancies = this->_M_impl._M_start._M_cur
                               - this->_M_impl._M_start._M_first;
 if (__n > __vacancies)
   _M_new_elements_at_front(__n - __vacancies);
 return this->_M_impl._M_start - difference_type(__n);
      }
      iterator
      _M_reserve_elements_at_back(size_type __n)
      {
 const size_type __vacancies = (this->_M_impl._M_finish._M_last
           - this->_M_impl._M_finish._M_cur) - 1;
 if (__n > __vacancies)
   _M_new_elements_at_back(__n - __vacancies);
 return this->_M_impl._M_finish + difference_type(__n);
      }
      void
      _M_new_elements_at_front(size_type __new_elements);
      void
      _M_new_elements_at_back(size_type __new_elements);
      void
      _M_reserve_map_at_back (size_type __nodes_to_add = 1)
      {
 if (__nodes_to_add + 1 > this->_M_impl._M_map_size
     - (this->_M_impl._M_finish._M_node - this->_M_impl._M_map))
   _M_reallocate_map(__nodes_to_add, false);
      }
      void
      _M_reserve_map_at_front (size_type __nodes_to_add = 1)
      {
 if (__nodes_to_add > size_type(this->_M_impl._M_start._M_node
           - this->_M_impl._M_map))
   _M_reallocate_map(__nodes_to_add, true);
      }
      void
      _M_reallocate_map(size_type __nodes_to_add, bool __add_at_front);
    };
  template<typename _Tp, typename _Alloc>
    inline bool
    operator==(const deque<_Tp, _Alloc>& __x,
                         const deque<_Tp, _Alloc>& __y)
    { return __x.size() == __y.size()
             && std::equal(__x.begin(), __x.end(), __y.begin()); }
  template<typename _Tp, typename _Alloc>
    inline bool
    operator<(const deque<_Tp, _Alloc>& __x,
       const deque<_Tp, _Alloc>& __y)
    { return lexicographical_compare(__x.begin(), __x.end(),
         __y.begin(), __y.end()); }
  template<typename _Tp, typename _Alloc>
    inline bool
    operator!=(const deque<_Tp, _Alloc>& __x,
        const deque<_Tp, _Alloc>& __y)
    { return !(__x == __y); }
  template<typename _Tp, typename _Alloc>
    inline bool
    operator>(const deque<_Tp, _Alloc>& __x,
       const deque<_Tp, _Alloc>& __y)
    { return __y < __x; }
  template<typename _Tp, typename _Alloc>
    inline bool
    operator<=(const deque<_Tp, _Alloc>& __x,
        const deque<_Tp, _Alloc>& __y)
    { return !(__y < __x); }
  template<typename _Tp, typename _Alloc>
    inline bool
    operator>=(const deque<_Tp, _Alloc>& __x,
        const deque<_Tp, _Alloc>& __y)
    { return !(__x < __y); }
  template<typename _Tp, typename _Alloc>
    inline void
    swap(deque<_Tp,_Alloc>& __x, deque<_Tp,_Alloc>& __y)
    { __x.swap(__y); }
}
namespace std
{
  template <typename _Tp, typename _Alloc>
    deque<_Tp, _Alloc>&
    deque<_Tp, _Alloc>::
    operator=(const deque& __x)
    {
      const size_type __len = size();
      if (&__x != this)
 {
   if (__len >= __x.size())
     erase(std::copy(__x.begin(), __x.end(), this->_M_impl._M_start),
    this->_M_impl._M_finish);
   else
     {
       const_iterator __mid = __x.begin() + difference_type(__len);
       std::copy(__x.begin(), __mid, this->_M_impl._M_start);
       insert(this->_M_impl._M_finish, __mid, __x.end());
     }
 }
      return *this;
    }
  template <typename _Tp, typename _Alloc>
    typename deque<_Tp, _Alloc>::iterator
    deque<_Tp, _Alloc>::
    insert(iterator position, const value_type& __x)
    {
      if (position._M_cur == this->_M_impl._M_start._M_cur)
 {
   push_front(__x);
   return this->_M_impl._M_start;
 }
      else if (position._M_cur == this->_M_impl._M_finish._M_cur)
 {
   push_back(__x);
   iterator __tmp = this->_M_impl._M_finish;
   --__tmp;
   return __tmp;
 }
      else
        return _M_insert_aux(position, __x);
    }
  template <typename _Tp, typename _Alloc>
    typename deque<_Tp, _Alloc>::iterator
    deque<_Tp, _Alloc>::
    erase(iterator __position)
    {
      iterator __next = __position;
      ++__next;
      const size_type __index = __position - this->_M_impl._M_start;
      if (__index < (size() >> 1))
 {
   std::copy_backward(this->_M_impl._M_start, __position, __next);
   pop_front();
 }
      else
 {
   std::copy(__next, this->_M_impl._M_finish, __position);
   pop_back();
 }
      return this->_M_impl._M_start + __index;
    }
  template <typename _Tp, typename _Alloc>
    typename deque<_Tp, _Alloc>::iterator
    deque<_Tp, _Alloc>::
    erase(iterator __first, iterator __last)
    {
      if (__first == this->_M_impl._M_start
   && __last == this->_M_impl._M_finish)
 {
   clear();
   return this->_M_impl._M_finish;
 }
      else
 {
   const difference_type __n = __last - __first;
   const difference_type __elems_before = (__first
        - this->_M_impl._M_start);
   if (static_cast<size_type>(__elems_before) < (size() - __n) / 2)
     {
       std::copy_backward(this->_M_impl._M_start, __first, __last);
       iterator __new_start = this->_M_impl._M_start + __n;
       std::_Destroy(this->_M_impl._M_start, __new_start,
       _M_get_Tp_allocator());
       _M_destroy_nodes(this->_M_impl._M_start._M_node,
          __new_start._M_node);
       this->_M_impl._M_start = __new_start;
     }
   else
     {
       std::copy(__last, this->_M_impl._M_finish, __first);
       iterator __new_finish = this->_M_impl._M_finish - __n;
       std::_Destroy(__new_finish, this->_M_impl._M_finish,
       _M_get_Tp_allocator());
       _M_destroy_nodes(__new_finish._M_node + 1,
          this->_M_impl._M_finish._M_node + 1);
       this->_M_impl._M_finish = __new_finish;
     }
   return this->_M_impl._M_start + __elems_before;
 }
    }
  template <typename _Tp, typename _Alloc>
    void
    deque<_Tp, _Alloc>::
    clear()
    {
      for (_Map_pointer __node = this->_M_impl._M_start._M_node + 1;
           __node < this->_M_impl._M_finish._M_node;
           ++__node)
 {
   std::_Destroy(*__node, *__node + _S_buffer_size(),
   _M_get_Tp_allocator());
   _M_deallocate_node(*__node);
 }
      if (this->_M_impl._M_start._M_node != this->_M_impl._M_finish._M_node)
 {
   std::_Destroy(this->_M_impl._M_start._M_cur,
   this->_M_impl._M_start._M_last,
   _M_get_Tp_allocator());
   std::_Destroy(this->_M_impl._M_finish._M_first,
   this->_M_impl._M_finish._M_cur,
   _M_get_Tp_allocator());
   _M_deallocate_node(this->_M_impl._M_finish._M_first);
 }
      else
        std::_Destroy(this->_M_impl._M_start._M_cur,
        this->_M_impl._M_finish._M_cur,
        _M_get_Tp_allocator());
      this->_M_impl._M_finish = this->_M_impl._M_start;
    }
  template <typename _Tp, class _Alloc>
    template <typename _InputIterator>
      void
      deque<_Tp, _Alloc>::
      _M_assign_aux(_InputIterator __first, _InputIterator __last,
      std::input_iterator_tag)
      {
        iterator __cur = begin();
        for (; __first != __last && __cur != end(); ++__cur, ++__first)
          *__cur = *__first;
        if (__first == __last)
          erase(__cur, end());
        else
          insert(end(), __first, __last);
      }
  template <typename _Tp, typename _Alloc>
    void
    deque<_Tp, _Alloc>::
    _M_fill_insert(iterator __pos, size_type __n, const value_type& __x)
    {
      if (__pos._M_cur == this->_M_impl._M_start._M_cur)
 {
   iterator __new_start = _M_reserve_elements_at_front(__n);
   try
     {
       std::__uninitialized_fill_a(__new_start, this->_M_impl._M_start,
       __x,
       _M_get_Tp_allocator());
       this->_M_impl._M_start = __new_start;
     }
   catch(...)
     {
       _M_destroy_nodes(__new_start._M_node,
          this->_M_impl._M_start._M_node);
       throw;
     }
 }
      else if (__pos._M_cur == this->_M_impl._M_finish._M_cur)
 {
   iterator __new_finish = _M_reserve_elements_at_back(__n);
   try
     {
       std::__uninitialized_fill_a(this->_M_impl._M_finish,
       __new_finish, __x,
       _M_get_Tp_allocator());
       this->_M_impl._M_finish = __new_finish;
     }
   catch(...)
     {
       _M_destroy_nodes(this->_M_impl._M_finish._M_node + 1,
          __new_finish._M_node + 1);
       throw;
     }
 }
      else
        _M_insert_aux(__pos, __n, __x);
    }
  template <typename _Tp, typename _Alloc>
    void
    deque<_Tp, _Alloc>::
    _M_fill_initialize(const value_type& __value)
    {
      _Map_pointer __cur;
      try
        {
          for (__cur = this->_M_impl._M_start._M_node;
        __cur < this->_M_impl._M_finish._M_node;
        ++__cur)
            std::__uninitialized_fill_a(*__cur, *__cur + _S_buffer_size(),
     __value, _M_get_Tp_allocator());
          std::__uninitialized_fill_a(this->_M_impl._M_finish._M_first,
          this->_M_impl._M_finish._M_cur,
          __value, _M_get_Tp_allocator());
        }
      catch(...)
        {
          std::_Destroy(this->_M_impl._M_start, iterator(*__cur, __cur),
   _M_get_Tp_allocator());
          throw;
        }
    }
  template <typename _Tp, typename _Alloc>
    template <typename _InputIterator>
      void
      deque<_Tp, _Alloc>::
      _M_range_initialize(_InputIterator __first, _InputIterator __last,
                          std::input_iterator_tag)
      {
        this->_M_initialize_map(0);
        try
          {
            for (; __first != __last; ++__first)
              push_back(*__first);
          }
        catch(...)
          {
            clear();
            throw;
          }
      }
  template <typename _Tp, typename _Alloc>
    template <typename _ForwardIterator>
      void
      deque<_Tp, _Alloc>::
      _M_range_initialize(_ForwardIterator __first, _ForwardIterator __last,
                          std::forward_iterator_tag)
      {
        const size_type __n = std::distance(__first, __last);
        this->_M_initialize_map(__n);
        _Map_pointer __cur_node;
        try
          {
            for (__cur_node = this->_M_impl._M_start._M_node;
                 __cur_node < this->_M_impl._M_finish._M_node;
                 ++__cur_node)
            {
              _ForwardIterator __mid = __first;
              std::advance(__mid, _S_buffer_size());
              std::__uninitialized_copy_a(__first, __mid, *__cur_node,
       _M_get_Tp_allocator());
              __first = __mid;
            }
            std::__uninitialized_copy_a(__first, __last,
     this->_M_impl._M_finish._M_first,
     _M_get_Tp_allocator());
          }
        catch(...)
          {
            std::_Destroy(this->_M_impl._M_start,
     iterator(*__cur_node, __cur_node),
     _M_get_Tp_allocator());
            throw;
          }
      }
  template <typename _Tp, typename _Alloc>
    void
    deque<_Tp, _Alloc>::
    _M_push_back_aux(const value_type& __t)
    {
      value_type __t_copy = __t;
      _M_reserve_map_at_back();
      *(this->_M_impl._M_finish._M_node + 1) = this->_M_allocate_node();
      try
        {
          this->_M_impl.construct(this->_M_impl._M_finish._M_cur, __t_copy);
          this->_M_impl._M_finish._M_set_node(this->_M_impl._M_finish._M_node
           + 1);
          this->_M_impl._M_finish._M_cur = this->_M_impl._M_finish._M_first;
        }
      catch(...)
        {
          _M_deallocate_node(*(this->_M_impl._M_finish._M_node + 1));
          throw;
        }
    }
  template <typename _Tp, typename _Alloc>
    void
    deque<_Tp, _Alloc>::
    _M_push_front_aux(const value_type& __t)
    {
      value_type __t_copy = __t;
      _M_reserve_map_at_front();
      *(this->_M_impl._M_start._M_node - 1) = this->_M_allocate_node();
      try
        {
          this->_M_impl._M_start._M_set_node(this->_M_impl._M_start._M_node
          - 1);
          this->_M_impl._M_start._M_cur = this->_M_impl._M_start._M_last - 1;
          this->_M_impl.construct(this->_M_impl._M_start._M_cur, __t_copy);
        }
      catch(...)
        {
          ++this->_M_impl._M_start;
          _M_deallocate_node(*(this->_M_impl._M_start._M_node - 1));
          throw;
        }
    }
  template <typename _Tp, typename _Alloc>
    void deque<_Tp, _Alloc>::
    _M_pop_back_aux()
    {
      _M_deallocate_node(this->_M_impl._M_finish._M_first);
      this->_M_impl._M_finish._M_set_node(this->_M_impl._M_finish._M_node - 1);
      this->_M_impl._M_finish._M_cur = this->_M_impl._M_finish._M_last - 1;
      this->_M_impl.destroy(this->_M_impl._M_finish._M_cur);
    }
  template <typename _Tp, typename _Alloc>
    void deque<_Tp, _Alloc>::
    _M_pop_front_aux()
    {
      this->_M_impl.destroy(this->_M_impl._M_start._M_cur);
      _M_deallocate_node(this->_M_impl._M_start._M_first);
      this->_M_impl._M_start._M_set_node(this->_M_impl._M_start._M_node + 1);
      this->_M_impl._M_start._M_cur = this->_M_impl._M_start._M_first;
    }
  template <typename _Tp, typename _Alloc>
    template <typename _InputIterator>
      void
      deque<_Tp, _Alloc>::
      _M_range_insert_aux(iterator __pos,
                          _InputIterator __first, _InputIterator __last,
                          std::input_iterator_tag)
      { std::copy(__first, __last, std::inserter(*this, __pos)); }
  template <typename _Tp, typename _Alloc>
    template <typename _ForwardIterator>
      void
      deque<_Tp, _Alloc>::
      _M_range_insert_aux(iterator __pos,
                          _ForwardIterator __first, _ForwardIterator __last,
                          std::forward_iterator_tag)
      {
        const size_type __n = std::distance(__first, __last);
        if (__pos._M_cur == this->_M_impl._M_start._M_cur)
   {
     iterator __new_start = _M_reserve_elements_at_front(__n);
     try
       {
  std::__uninitialized_copy_a(__first, __last, __new_start,
         _M_get_Tp_allocator());
  this->_M_impl._M_start = __new_start;
       }
     catch(...)
       {
  _M_destroy_nodes(__new_start._M_node,
     this->_M_impl._M_start._M_node);
  throw;
       }
   }
        else if (__pos._M_cur == this->_M_impl._M_finish._M_cur)
   {
     iterator __new_finish = _M_reserve_elements_at_back(__n);
     try
       {
  std::__uninitialized_copy_a(__first, __last,
         this->_M_impl._M_finish,
         _M_get_Tp_allocator());
  this->_M_impl._M_finish = __new_finish;
       }
     catch(...)
       {
  _M_destroy_nodes(this->_M_impl._M_finish._M_node + 1,
     __new_finish._M_node + 1);
  throw;
       }
   }
        else
          _M_insert_aux(__pos, __first, __last, __n);
      }
  template <typename _Tp, typename _Alloc>
    typename deque<_Tp, _Alloc>::iterator
    deque<_Tp, _Alloc>::
    _M_insert_aux(iterator __pos, const value_type& __x)
    {
      difference_type __index = __pos - this->_M_impl._M_start;
      value_type __x_copy = __x;
      if (static_cast<size_type>(__index) < size() / 2)
 {
   push_front(front());
   iterator __front1 = this->_M_impl._M_start;
   ++__front1;
   iterator __front2 = __front1;
   ++__front2;
   __pos = this->_M_impl._M_start + __index;
   iterator __pos1 = __pos;
   ++__pos1;
   std::copy(__front2, __pos1, __front1);
 }
      else
 {
   push_back(back());
   iterator __back1 = this->_M_impl._M_finish;
   --__back1;
   iterator __back2 = __back1;
   --__back2;
   __pos = this->_M_impl._M_start + __index;
   std::copy_backward(__pos, __back2, __back1);
 }
      *__pos = __x_copy;
      return __pos;
    }
  template <typename _Tp, typename _Alloc>
    void
    deque<_Tp, _Alloc>::
    _M_insert_aux(iterator __pos, size_type __n, const value_type& __x)
    {
      const difference_type __elems_before = __pos - this->_M_impl._M_start;
      const size_type __length = this->size();
      value_type __x_copy = __x;
      if (__elems_before < difference_type(__length / 2))
 {
   iterator __new_start = _M_reserve_elements_at_front(__n);
   iterator __old_start = this->_M_impl._M_start;
   __pos = this->_M_impl._M_start + __elems_before;
   try
     {
       if (__elems_before >= difference_type(__n))
  {
    iterator __start_n = (this->_M_impl._M_start
     + difference_type(__n));
    std::__uninitialized_copy_a(this->_M_impl._M_start,
           __start_n, __new_start,
           _M_get_Tp_allocator());
    this->_M_impl._M_start = __new_start;
    std::copy(__start_n, __pos, __old_start);
    fill(__pos - difference_type(__n), __pos, __x_copy);
  }
       else
  {
    std::__uninitialized_copy_fill(this->_M_impl._M_start,
       __pos, __new_start,
       this->_M_impl._M_start,
       __x_copy,
       _M_get_Tp_allocator());
    this->_M_impl._M_start = __new_start;
    std::fill(__old_start, __pos, __x_copy);
  }
     }
   catch(...)
     {
       _M_destroy_nodes(__new_start._M_node,
          this->_M_impl._M_start._M_node);
       throw;
     }
 }
      else
 {
   iterator __new_finish = _M_reserve_elements_at_back(__n);
   iterator __old_finish = this->_M_impl._M_finish;
   const difference_type __elems_after =
     difference_type(__length) - __elems_before;
   __pos = this->_M_impl._M_finish - __elems_after;
   try
     {
       if (__elems_after > difference_type(__n))
  {
    iterator __finish_n = (this->_M_impl._M_finish
      - difference_type(__n));
    std::__uninitialized_copy_a(__finish_n,
           this->_M_impl._M_finish,
           this->_M_impl._M_finish,
           _M_get_Tp_allocator());
    this->_M_impl._M_finish = __new_finish;
    std::copy_backward(__pos, __finish_n, __old_finish);
    std::fill(__pos, __pos + difference_type(__n), __x_copy);
  }
       else
  {
    std::__uninitialized_fill_copy(this->_M_impl._M_finish,
       __pos + difference_type(__n),
       __x_copy, __pos,
       this->_M_impl._M_finish,
       _M_get_Tp_allocator());
    this->_M_impl._M_finish = __new_finish;
    std::fill(__pos, __old_finish, __x_copy);
  }
     }
   catch(...)
     {
       _M_destroy_nodes(this->_M_impl._M_finish._M_node + 1,
          __new_finish._M_node + 1);
       throw;
     }
 }
    }
  template <typename _Tp, typename _Alloc>
    template <typename _ForwardIterator>
      void
      deque<_Tp, _Alloc>::
      _M_insert_aux(iterator __pos,
                    _ForwardIterator __first, _ForwardIterator __last,
                    size_type __n)
      {
        const difference_type __elemsbefore = __pos - this->_M_impl._M_start;
        const size_type __length = size();
        if (static_cast<size_type>(__elemsbefore) < __length / 2)
   {
     iterator __new_start = _M_reserve_elements_at_front(__n);
     iterator __old_start = this->_M_impl._M_start;
     __pos = this->_M_impl._M_start + __elemsbefore;
     try
       {
  if (__elemsbefore >= difference_type(__n))
    {
      iterator __start_n = (this->_M_impl._M_start
       + difference_type(__n));
      std::__uninitialized_copy_a(this->_M_impl._M_start,
      __start_n, __new_start,
      _M_get_Tp_allocator());
      this->_M_impl._M_start = __new_start;
      std::copy(__start_n, __pos, __old_start);
      std::copy(__first, __last, __pos - difference_type(__n));
    }
  else
    {
      _ForwardIterator __mid = __first;
      std::advance(__mid, difference_type(__n) - __elemsbefore);
      std::__uninitialized_copy_copy(this->_M_impl._M_start,
         __pos, __first, __mid,
         __new_start,
         _M_get_Tp_allocator());
      this->_M_impl._M_start = __new_start;
      std::copy(__mid, __last, __old_start);
    }
       }
     catch(...)
       {
  _M_destroy_nodes(__new_start._M_node,
     this->_M_impl._M_start._M_node);
  throw;
       }
   }
        else
        {
          iterator __new_finish = _M_reserve_elements_at_back(__n);
          iterator __old_finish = this->_M_impl._M_finish;
          const difference_type __elemsafter =
            difference_type(__length) - __elemsbefore;
          __pos = this->_M_impl._M_finish - __elemsafter;
          try
            {
              if (__elemsafter > difference_type(__n))
  {
    iterator __finish_n = (this->_M_impl._M_finish
      - difference_type(__n));
    std::__uninitialized_copy_a(__finish_n,
           this->_M_impl._M_finish,
           this->_M_impl._M_finish,
           _M_get_Tp_allocator());
    this->_M_impl._M_finish = __new_finish;
    std::copy_backward(__pos, __finish_n, __old_finish);
    std::copy(__first, __last, __pos);
  }
              else
  {
    _ForwardIterator __mid = __first;
    std::advance(__mid, __elemsafter);
    std::__uninitialized_copy_copy(__mid, __last, __pos,
       this->_M_impl._M_finish,
       this->_M_impl._M_finish,
       _M_get_Tp_allocator());
    this->_M_impl._M_finish = __new_finish;
    std::copy(__first, __mid, __pos);
  }
            }
          catch(...)
            {
              _M_destroy_nodes(this->_M_impl._M_finish._M_node + 1,
          __new_finish._M_node + 1);
              throw;
            }
        }
      }
  template <typename _Tp, typename _Alloc>
    void
    deque<_Tp, _Alloc>::
    _M_new_elements_at_front(size_type __new_elems)
    {
      const size_type __new_nodes
 = (__new_elems + _S_buffer_size() - 1) / _S_buffer_size();
      _M_reserve_map_at_front(__new_nodes);
      size_type __i;
      try
        {
          for (__i = 1; __i <= __new_nodes; ++__i)
            *(this->_M_impl._M_start._M_node - __i) = this->_M_allocate_node();
        }
      catch(...)
        {
          for (size_type __j = 1; __j < __i; ++__j)
            _M_deallocate_node(*(this->_M_impl._M_start._M_node - __j));
          throw;
        }
    }
  template <typename _Tp, typename _Alloc>
    void
    deque<_Tp, _Alloc>::
    _M_new_elements_at_back(size_type __new_elems)
    {
      const size_type __new_nodes
 = (__new_elems + _S_buffer_size() - 1) / _S_buffer_size();
      _M_reserve_map_at_back(__new_nodes);
      size_type __i;
      try
        {
          for (__i = 1; __i <= __new_nodes; ++__i)
            *(this->_M_impl._M_finish._M_node + __i) = this->_M_allocate_node();
        }
      catch(...)
        {
          for (size_type __j = 1; __j < __i; ++__j)
            _M_deallocate_node(*(this->_M_impl._M_finish._M_node + __j));
          throw;
        }
    }
  template <typename _Tp, typename _Alloc>
    void
    deque<_Tp, _Alloc>::
    _M_reallocate_map(size_type __nodes_to_add, bool __add_at_front)
    {
      const size_type __old_num_nodes
 = this->_M_impl._M_finish._M_node - this->_M_impl._M_start._M_node + 1;
      const size_type __new_num_nodes = __old_num_nodes + __nodes_to_add;
      _Map_pointer __new_nstart;
      if (this->_M_impl._M_map_size > 2 * __new_num_nodes)
 {
   __new_nstart = this->_M_impl._M_map + (this->_M_impl._M_map_size
      - __new_num_nodes) / 2
                  + (__add_at_front ? __nodes_to_add : 0);
   if (__new_nstart < this->_M_impl._M_start._M_node)
     std::copy(this->_M_impl._M_start._M_node,
      this->_M_impl._M_finish._M_node + 1,
      __new_nstart);
   else
     std::copy_backward(this->_M_impl._M_start._M_node,
          this->_M_impl._M_finish._M_node + 1,
          __new_nstart + __old_num_nodes);
 }
      else
 {
   size_type __new_map_size = this->_M_impl._M_map_size
                              + std::max(this->_M_impl._M_map_size,
      __nodes_to_add) + 2;
   _Map_pointer __new_map = this->_M_allocate_map(__new_map_size);
   __new_nstart = __new_map + (__new_map_size - __new_num_nodes) / 2
                  + (__add_at_front ? __nodes_to_add : 0);
   std::copy(this->_M_impl._M_start._M_node,
      this->_M_impl._M_finish._M_node + 1,
      __new_nstart);
   _M_deallocate_map(this->_M_impl._M_map, this->_M_impl._M_map_size);
   this->_M_impl._M_map = __new_map;
   this->_M_impl._M_map_size = __new_map_size;
 }
      this->_M_impl._M_start._M_set_node(__new_nstart);
      this->_M_impl._M_finish._M_set_node(__new_nstart + __old_num_nodes - 1);
    }
}
namespace std
{
  struct _List_node_base
  {
    _List_node_base* _M_next;
    _List_node_base* _M_prev;
    static void
    swap(_List_node_base& __x, _List_node_base& __y);
    void
    transfer(_List_node_base * const __first,
      _List_node_base * const __last);
    void
    reverse();
    void
    hook(_List_node_base * const __position);
    void
    unhook();
  };
  template<typename _Tp>
    struct _List_node : public _List_node_base
    {
      _Tp _M_data;
    };
  template<typename _Tp>
    struct _List_iterator
    {
      typedef _List_iterator<_Tp> _Self;
      typedef _List_node<_Tp> _Node;
      typedef ptrdiff_t difference_type;
      typedef std::bidirectional_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef _Tp* pointer;
      typedef _Tp& reference;
      _List_iterator()
      : _M_node() { }
      explicit
      _List_iterator(_List_node_base* __x)
      : _M_node(__x) { }
      reference
      operator*() const
      { return static_cast<_Node*>(_M_node)->_M_data; }
      pointer
      operator->() const
      { return &static_cast<_Node*>(_M_node)->_M_data; }
      _Self&
      operator++()
      {
 _M_node = _M_node->_M_next;
 return *this;
      }
      _Self
      operator++(int)
      {
 _Self __tmp = *this;
 _M_node = _M_node->_M_next;
 return __tmp;
      }
      _Self&
      operator--()
      {
 _M_node = _M_node->_M_prev;
 return *this;
      }
      _Self
      operator--(int)
      {
 _Self __tmp = *this;
 _M_node = _M_node->_M_prev;
 return __tmp;
      }
      bool
      operator==(const _Self& __x) const
      { return _M_node == __x._M_node; }
      bool
      operator!=(const _Self& __x) const
      { return _M_node != __x._M_node; }
      _List_node_base* _M_node;
    };
  template<typename _Tp>
    struct _List_const_iterator
    {
      typedef _List_const_iterator<_Tp> _Self;
      typedef const _List_node<_Tp> _Node;
      typedef _List_iterator<_Tp> iterator;
      typedef ptrdiff_t difference_type;
      typedef std::bidirectional_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef const _Tp* pointer;
      typedef const _Tp& reference;
      _List_const_iterator()
      : _M_node() { }
      explicit
      _List_const_iterator(const _List_node_base* __x)
      : _M_node(__x) { }
      _List_const_iterator(const iterator& __x)
      : _M_node(__x._M_node) { }
      reference
      operator*() const
      { return static_cast<_Node*>(_M_node)->_M_data; }
      pointer
      operator->() const
      { return &static_cast<_Node*>(_M_node)->_M_data; }
      _Self&
      operator++()
      {
 _M_node = _M_node->_M_next;
 return *this;
      }
      _Self
      operator++(int)
      {
 _Self __tmp = *this;
 _M_node = _M_node->_M_next;
 return __tmp;
      }
      _Self&
      operator--()
      {
 _M_node = _M_node->_M_prev;
 return *this;
      }
      _Self
      operator--(int)
      {
 _Self __tmp = *this;
 _M_node = _M_node->_M_prev;
 return __tmp;
      }
      bool
      operator==(const _Self& __x) const
      { return _M_node == __x._M_node; }
      bool
      operator!=(const _Self& __x) const
      { return _M_node != __x._M_node; }
      const _List_node_base* _M_node;
    };
  template<typename _Val>
    inline bool
    operator==(const _List_iterator<_Val>& __x,
        const _List_const_iterator<_Val>& __y)
    { return __x._M_node == __y._M_node; }
  template<typename _Val>
    inline bool
    operator!=(const _List_iterator<_Val>& __x,
               const _List_const_iterator<_Val>& __y)
    { return __x._M_node != __y._M_node; }
  template<typename _Tp, typename _Alloc>
    class _List_base
    {
    protected:
      typedef typename _Alloc::template rebind<_List_node<_Tp> >::other
        _Node_alloc_type;
      typedef typename _Alloc::template rebind<_Tp>::other _Tp_alloc_type;
      struct _List_impl
      : public _Node_alloc_type
      {
 _List_node_base _M_node;
 _List_impl(const _Node_alloc_type& __a)
 : _Node_alloc_type(__a), _M_node()
 { }
      };
      _List_impl _M_impl;
      _List_node<_Tp>*
      _M_get_node()
      { return _M_impl._Node_alloc_type::allocate(1); }
      void
      _M_put_node(_List_node<_Tp>* __p)
      { _M_impl._Node_alloc_type::deallocate(__p, 1); }
  public:
      typedef _Alloc allocator_type;
      _Tp_alloc_type
      _M_get_Tp_allocator() const
      { return *static_cast<const _Node_alloc_type*>(&this->_M_impl); }
      allocator_type
      get_allocator() const
      { return _M_get_Tp_allocator(); }
      _List_base(const allocator_type& __a)
      : _M_impl(__a)
      { _M_init(); }
      ~_List_base()
      { _M_clear(); }
      void
      _M_clear();
      void
      _M_init()
      {
        this->_M_impl._M_node._M_next = &this->_M_impl._M_node;
        this->_M_impl._M_node._M_prev = &this->_M_impl._M_node;
      }
    };
  template<typename _Tp, typename _Alloc = std::allocator<_Tp> >
    class list : protected _List_base<_Tp, _Alloc>
    {
      typedef typename _Alloc::value_type _Alloc_value_type;
      typedef _List_base<_Tp, _Alloc> _Base;
      typedef typename _Base::_Tp_alloc_type _Tp_alloc_type;
    public:
      typedef _Tp value_type;
      typedef typename _Tp_alloc_type::pointer pointer;
      typedef typename _Tp_alloc_type::const_pointer const_pointer;
      typedef typename _Tp_alloc_type::reference reference;
      typedef typename _Tp_alloc_type::const_reference const_reference;
      typedef _List_iterator<_Tp> iterator;
      typedef _List_const_iterator<_Tp> const_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
      typedef std::reverse_iterator<iterator> reverse_iterator;
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Alloc allocator_type;
    protected:
      typedef _List_node<_Tp> _Node;
      using _Base::_M_impl;
      using _Base::_M_put_node;
      using _Base::_M_get_node;
      using _Base::_M_get_Tp_allocator;
      _Node*
      _M_create_node(const value_type& __x)
      {
 _Node* __p = this->_M_get_node();
 try
   {
     _M_get_Tp_allocator().construct(&__p->_M_data, __x);
   }
 catch(...)
   {
     _M_put_node(__p);
     throw;
   }
 return __p;
      }
    public:
      explicit
      list(const allocator_type& __a = allocator_type())
      : _Base(__a) { }
      explicit
      list(size_type __n, const value_type& __value = value_type(),
    const allocator_type& __a = allocator_type())
      : _Base(__a)
      { this->insert(begin(), __n, __value); }
      list(const list& __x)
      : _Base(__x.get_allocator())
      { this->insert(begin(), __x.begin(), __x.end()); }
      template<typename _InputIterator>
        list(_InputIterator __first, _InputIterator __last,
      const allocator_type& __a = allocator_type())
        : _Base(__a)
        { this->insert(begin(), __first, __last); }
      list&
      operator=(const list& __x);
      void
      assign(size_type __n, const value_type& __val)
      { _M_fill_assign(__n, __val); }
      template<typename _InputIterator>
        void
        assign(_InputIterator __first, _InputIterator __last)
        {
   typedef typename std::__is_integer<_InputIterator>::__type _Integral;
   _M_assign_dispatch(__first, __last, _Integral());
 }
      allocator_type
      get_allocator() const
      { return _Base::get_allocator(); }
      iterator
      begin()
      { return iterator(this->_M_impl._M_node._M_next); }
      const_iterator
      begin() const
      { return const_iterator(this->_M_impl._M_node._M_next); }
      iterator
      end()
      { return iterator(&this->_M_impl._M_node); }
      const_iterator
      end() const
      { return const_iterator(&this->_M_impl._M_node); }
      reverse_iterator
      rbegin()
      { return reverse_iterator(end()); }
      const_reverse_iterator
      rbegin() const
      { return const_reverse_iterator(end()); }
      reverse_iterator
      rend()
      { return reverse_iterator(begin()); }
      const_reverse_iterator
      rend() const
      { return const_reverse_iterator(begin()); }
      bool
      empty() const
      { return this->_M_impl._M_node._M_next == &this->_M_impl._M_node; }
      size_type
      size() const
      { return std::distance(begin(), end()); }
      size_type
      max_size() const
      { return size_type(-1); }
      void
      resize(size_type __new_size, value_type __x = value_type());
      reference
      front()
      { return *begin(); }
      const_reference
      front() const
      { return *begin(); }
      reference
      back()
      {
 iterator __tmp = end();
 --__tmp;
 return *__tmp;
      }
      const_reference
      back() const
      {
 const_iterator __tmp = end();
 --__tmp;
 return *__tmp;
      }
      void
      push_front(const value_type& __x)
      { this->_M_insert(begin(), __x); }
      void
      pop_front()
      { this->_M_erase(begin()); }
      void
      push_back(const value_type& __x)
      { this->_M_insert(end(), __x); }
      void
      pop_back()
      { this->_M_erase(iterator(this->_M_impl._M_node._M_prev)); }
      iterator
      insert(iterator __position, const value_type& __x);
      void
      insert(iterator __position, size_type __n, const value_type& __x)
      { _M_fill_insert(__position, __n, __x); }
      template<typename _InputIterator>
        void
        insert(iterator __position, _InputIterator __first,
        _InputIterator __last)
        {
   typedef typename std::__is_integer<_InputIterator>::__type _Integral;
   _M_insert_dispatch(__position, __first, __last, _Integral());
 }
      iterator
      erase(iterator __position);
      iterator
      erase(iterator __first, iterator __last)
      {
 while (__first != __last)
   __first = erase(__first);
 return __last;
      }
      void
      swap(list& __x)
      { _List_node_base::swap(this->_M_impl._M_node, __x._M_impl._M_node); }
      void
      clear()
      {
        _Base::_M_clear();
        _Base::_M_init();
      }
      void
      splice(iterator __position, list& __x)
      {
 if (!__x.empty())
   this->_M_transfer(__position, __x.begin(), __x.end());
      }
      void
      splice(iterator __position, list&, iterator __i)
      {
 iterator __j = __i;
 ++__j;
 if (__position == __i || __position == __j)
   return;
 this->_M_transfer(__position, __i, __j);
      }
      void
      splice(iterator __position, list&, iterator __first, iterator __last)
      {
 if (__first != __last)
   this->_M_transfer(__position, __first, __last);
      }
      void
      remove(const _Tp& __value);
      template<typename _Predicate>
      void
      remove_if(_Predicate);
      void
      unique();
      template<typename _BinaryPredicate>
        void
        unique(_BinaryPredicate);
      void
      merge(list& __x);
      template<typename _StrictWeakOrdering>
        void
        merge(list&, _StrictWeakOrdering);
      void
      reverse()
      { this->_M_impl._M_node.reverse(); }
      void
      sort();
      template<typename _StrictWeakOrdering>
        void
        sort(_StrictWeakOrdering);
    protected:
      template<typename _Integer>
        void
        _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)
        {
   _M_fill_assign(static_cast<size_type>(__n),
    static_cast<value_type>(__val));
 }
      template<typename _InputIterator>
        void
        _M_assign_dispatch(_InputIterator __first, _InputIterator __last,
      __false_type);
      void
      _M_fill_assign(size_type __n, const value_type& __val);
      template<typename _Integer>
        void
        _M_insert_dispatch(iterator __pos, _Integer __n, _Integer __x,
      __true_type)
        {
   _M_fill_insert(__pos, static_cast<size_type>(__n),
    static_cast<value_type>(__x));
 }
      template<typename _InputIterator>
        void
        _M_insert_dispatch(iterator __pos,
      _InputIterator __first, _InputIterator __last,
      __false_type)
        {
   for (; __first != __last; ++__first)
     _M_insert(__pos, *__first);
 }
      void
      _M_fill_insert(iterator __pos, size_type __n, const value_type& __x)
      {
 for (; __n > 0; --__n)
   _M_insert(__pos, __x);
      }
      void
      _M_transfer(iterator __position, iterator __first, iterator __last)
      { __position._M_node->transfer(__first._M_node, __last._M_node); }
      void
      _M_insert(iterator __position, const value_type& __x)
      {
        _Node* __tmp = _M_create_node(__x);
        __tmp->hook(__position._M_node);
      }
      void
      _M_erase(iterator __position)
      {
        __position._M_node->unhook();
        _Node* __n = static_cast<_Node*>(__position._M_node);
        _M_get_Tp_allocator().destroy(&__n->_M_data);
        _M_put_node(__n);
      }
    };
  template<typename _Tp, typename _Alloc>
    inline bool
    operator==(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
    {
      typedef typename list<_Tp, _Alloc>::const_iterator const_iterator;
      const_iterator __end1 = __x.end();
      const_iterator __end2 = __y.end();
      const_iterator __i1 = __x.begin();
      const_iterator __i2 = __y.begin();
      while (__i1 != __end1 && __i2 != __end2 && *__i1 == *__i2)
 {
   ++__i1;
   ++__i2;
 }
      return __i1 == __end1 && __i2 == __end2;
    }
  template<typename _Tp, typename _Alloc>
    inline bool
    operator<(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
    { return std::lexicographical_compare(__x.begin(), __x.end(),
       __y.begin(), __y.end()); }
  template<typename _Tp, typename _Alloc>
    inline bool
    operator!=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
    { return !(__x == __y); }
  template<typename _Tp, typename _Alloc>
    inline bool
    operator>(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
    { return __y < __x; }
  template<typename _Tp, typename _Alloc>
    inline bool
    operator<=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
    { return !(__y < __x); }
  template<typename _Tp, typename _Alloc>
    inline bool
    operator>=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
    { return !(__x < __y); }
  template<typename _Tp, typename _Alloc>
    inline void
    swap(list<_Tp, _Alloc>& __x, list<_Tp, _Alloc>& __y)
    { __x.swap(__y); }
}
namespace std
{
  template<typename _Tp, typename _Alloc>
    void
    _List_base<_Tp, _Alloc>::
    _M_clear()
    {
      typedef _List_node<_Tp> _Node;
      _Node* __cur = static_cast<_Node*>(this->_M_impl._M_node._M_next);
      while (__cur != &this->_M_impl._M_node)
 {
   _Node* __tmp = __cur;
   __cur = static_cast<_Node*>(__cur->_M_next);
   _M_get_Tp_allocator().destroy(&__tmp->_M_data);
   _M_put_node(__tmp);
 }
    }
  template<typename _Tp, typename _Alloc>
    typename list<_Tp, _Alloc>::iterator
    list<_Tp, _Alloc>::
    insert(iterator __position, const value_type& __x)
    {
      _Node* __tmp = _M_create_node(__x);
      __tmp->hook(__position._M_node);
      return iterator(__tmp);
    }
  template<typename _Tp, typename _Alloc>
    typename list<_Tp, _Alloc>::iterator
    list<_Tp, _Alloc>::
    erase(iterator __position)
    {
      iterator __ret = iterator(__position._M_node->_M_next);
      _M_erase(__position);
      return __ret;
    }
  template<typename _Tp, typename _Alloc>
    void
    list<_Tp, _Alloc>::
    resize(size_type __new_size, value_type __x)
    {
      iterator __i = begin();
      size_type __len = 0;
      for (; __i != end() && __len < __new_size; ++__i, ++__len)
        ;
      if (__len == __new_size)
        erase(__i, end());
      else
        insert(end(), __new_size - __len, __x);
    }
  template<typename _Tp, typename _Alloc>
    list<_Tp, _Alloc>&
    list<_Tp, _Alloc>::
    operator=(const list& __x)
    {
      if (this != &__x)
 {
   iterator __first1 = begin();
   iterator __last1 = end();
   const_iterator __first2 = __x.begin();
   const_iterator __last2 = __x.end();
   for (; __first1 != __last1 && __first2 != __last2;
        ++__first1, ++__first2)
     *__first1 = *__first2;
   if (__first2 == __last2)
     erase(__first1, __last1);
   else
     insert(__last1, __first2, __last2);
 }
      return *this;
    }
  template<typename _Tp, typename _Alloc>
    void
    list<_Tp, _Alloc>::
    _M_fill_assign(size_type __n, const value_type& __val)
    {
      iterator __i = begin();
      for (; __i != end() && __n > 0; ++__i, --__n)
        *__i = __val;
      if (__n > 0)
        insert(end(), __n, __val);
      else
        erase(__i, end());
    }
  template<typename _Tp, typename _Alloc>
    template <typename _InputIterator>
      void
      list<_Tp, _Alloc>::
      _M_assign_dispatch(_InputIterator __first2, _InputIterator __last2,
    __false_type)
      {
        iterator __first1 = begin();
        iterator __last1 = end();
        for (; __first1 != __last1 && __first2 != __last2;
      ++__first1, ++__first2)
          *__first1 = *__first2;
        if (__first2 == __last2)
          erase(__first1, __last1);
        else
          insert(__last1, __first2, __last2);
      }
  template<typename _Tp, typename _Alloc>
    void
    list<_Tp, _Alloc>::
    remove(const value_type& __value)
    {
      iterator __first = begin();
      iterator __last = end();
      while (__first != __last)
 {
   iterator __next = __first;
   ++__next;
   if (*__first == __value)
     _M_erase(__first);
   __first = __next;
 }
    }
  template<typename _Tp, typename _Alloc>
    void
    list<_Tp, _Alloc>::
    unique()
    {
      iterator __first = begin();
      iterator __last = end();
      if (__first == __last)
 return;
      iterator __next = __first;
      while (++__next != __last)
 {
   if (*__first == *__next)
     _M_erase(__next);
   else
     __first = __next;
   __next = __first;
 }
    }
  template<typename _Tp, typename _Alloc>
    void
    list<_Tp, _Alloc>::
    merge(list& __x)
    {
      if (this != &__x)
 {
   iterator __first1 = begin();
   iterator __last1 = end();
   iterator __first2 = __x.begin();
   iterator __last2 = __x.end();
   while (__first1 != __last1 && __first2 != __last2)
     if (*__first2 < *__first1)
       {
  iterator __next = __first2;
  _M_transfer(__first1, __first2, ++__next);
  __first2 = __next;
       }
     else
       ++__first1;
   if (__first2 != __last2)
     _M_transfer(__last1, __first2, __last2);
 }
    }
  template<typename _Tp, typename _Alloc>
    void
    list<_Tp, _Alloc>::
    sort()
    {
      if (this->_M_impl._M_node._M_next != &this->_M_impl._M_node
   && this->_M_impl._M_node._M_next->_M_next != &this->_M_impl._M_node)
      {
        list __carry;
        list __tmp[64];
        list * __fill = &__tmp[0];
        list * __counter;
        do
   {
     __carry.splice(__carry.begin(), *this, begin());
     for(__counter = &__tmp[0];
  __counter != __fill && !__counter->empty();
  ++__counter)
       {
  __counter->merge(__carry);
  __carry.swap(*__counter);
       }
     __carry.swap(*__counter);
     if (__counter == __fill)
       ++__fill;
   }
 while ( !empty() );
        for (__counter = &__tmp[1]; __counter != __fill; ++__counter)
          __counter->merge(*(__counter - 1));
        swap( *(__fill - 1) );
      }
    }
  template<typename _Tp, typename _Alloc>
    template <typename _Predicate>
      void
      list<_Tp, _Alloc>::
      remove_if(_Predicate __pred)
      {
        iterator __first = begin();
        iterator __last = end();
        while (__first != __last)
   {
     iterator __next = __first;
     ++__next;
     if (__pred(*__first))
       _M_erase(__first);
     __first = __next;
   }
      }
  template<typename _Tp, typename _Alloc>
    template <typename _BinaryPredicate>
      void
      list<_Tp, _Alloc>::
      unique(_BinaryPredicate __binary_pred)
      {
        iterator __first = begin();
        iterator __last = end();
        if (__first == __last)
   return;
        iterator __next = __first;
        while (++__next != __last)
   {
     if (__binary_pred(*__first, *__next))
       _M_erase(__next);
     else
       __first = __next;
     __next = __first;
   }
      }
  template<typename _Tp, typename _Alloc>
    template <typename _StrictWeakOrdering>
      void
      list<_Tp, _Alloc>::
      merge(list& __x, _StrictWeakOrdering __comp)
      {
 if (this != &__x)
   {
     iterator __first1 = begin();
     iterator __last1 = end();
     iterator __first2 = __x.begin();
     iterator __last2 = __x.end();
     while (__first1 != __last1 && __first2 != __last2)
       if (__comp(*__first2, *__first1))
  {
    iterator __next = __first2;
    _M_transfer(__first1, __first2, ++__next);
    __first2 = __next;
  }
       else
  ++__first1;
     if (__first2 != __last2)
       _M_transfer(__last1, __first2, __last2);
   }
      }
  template<typename _Tp, typename _Alloc>
    template <typename _StrictWeakOrdering>
      void
      list<_Tp, _Alloc>::
      sort(_StrictWeakOrdering __comp)
      {
 if (this->_M_impl._M_node._M_next != &this->_M_impl._M_node
     && this->_M_impl._M_node._M_next->_M_next != &this->_M_impl._M_node)
   {
     list __carry;
     list __tmp[64];
     list * __fill = &__tmp[0];
     list * __counter;
     do
       {
  __carry.splice(__carry.begin(), *this, begin());
  for(__counter = &__tmp[0];
      __counter != __fill && !__counter->empty();
      ++__counter)
    {
      __counter->merge(__carry, __comp);
      __carry.swap(*__counter);
    }
  __carry.swap(*__counter);
  if (__counter == __fill)
    ++__fill;
       }
     while ( !empty() );
     for (__counter = &__tmp[1]; __counter != __fill; ++__counter)
       __counter->merge(*(__counter - 1), __comp);
     swap(*(__fill - 1));
   }
      }
}
extern "C" {
typedef signed char gint8;
typedef unsigned char guint8;
typedef signed short gint16;
typedef unsigned short guint16;
typedef signed int gint32;
typedef unsigned int guint32;
__extension__ typedef signed long long gint64;
__extension__ typedef unsigned long long guint64;
typedef signed int gssize;
typedef unsigned int gsize;
typedef gint64 goffset;
typedef struct _GStaticMutex GStaticMutex;
struct _GStaticMutex
{
  struct _GMutex *runtime_mutex;
  union {
    char pad[24];
    double dummy_double;
    void *dummy_pointer;
    long dummy_long;
  } static_mutex;
};
typedef union _GSystemThread GSystemThread;
union _GSystemThread
{
  char data[4];
  double dummy_double;
  void *dummy_pointer;
  long dummy_long;
};
typedef int GPid;
}
extern "C" {
typedef char gchar;
typedef short gshort;
typedef long glong;
typedef int gint;
typedef gint gboolean;
typedef unsigned char guchar;
typedef unsigned short gushort;
typedef unsigned long gulong;
typedef unsigned int guint;
typedef float gfloat;
typedef double gdouble;
typedef void* gpointer;
typedef const void *gconstpointer;
typedef gint (*GCompareFunc) (gconstpointer a,
                                                 gconstpointer b);
typedef gint (*GCompareDataFunc) (gconstpointer a,
                                                 gconstpointer b,
       gpointer user_data);
typedef gboolean (*GEqualFunc) (gconstpointer a,
                                                 gconstpointer b);
typedef void (*GDestroyNotify) (gpointer data);
typedef void (*GFunc) (gpointer data,
                                                 gpointer user_data);
typedef guint (*GHashFunc) (gconstpointer key);
typedef void (*GHFunc) (gpointer key,
                                                 gpointer value,
                                                 gpointer user_data);
typedef void (*GFreeFunc) (gpointer data);
typedef const gchar * (*GTranslateFunc) (const gchar *str,
       gpointer data);
typedef union _GDoubleIEEE754 GDoubleIEEE754;
typedef union _GFloatIEEE754 GFloatIEEE754;
union _GFloatIEEE754
{
  gfloat v_float;
  struct {
    guint mantissa : 23;
    guint biased_exponent : 8;
    guint sign : 1;
  } mpn;
};
union _GDoubleIEEE754
{
  gdouble v_double;
  struct {
    guint mantissa_low : 32;
    guint mantissa_high : 20;
    guint biased_exponent : 11;
    guint sign : 1;
  } mpn;
};
typedef struct _GTimeVal GTimeVal;
struct _GTimeVal
{
  glong tv_sec;
  glong tv_usec;
};
}
extern "C" {
typedef struct _GArray GArray;
typedef struct _GByteArray GByteArray;
typedef struct _GPtrArray GPtrArray;
struct _GArray
{
  gchar *data;
  guint len;
};
struct _GByteArray
{
  guint8 *data;
  guint len;
};
struct _GPtrArray
{
  gpointer *pdata;
  guint len;
};
GArray* g_array_new (gboolean zero_terminated,
       gboolean clear_,
       guint element_size);
GArray* g_array_sized_new (gboolean zero_terminated,
       gboolean clear_,
       guint element_size,
       guint reserved_size);
gchar* g_array_free (GArray *array,
       gboolean free_segment);
GArray* g_array_append_vals (GArray *array,
       gconstpointer data,
       guint len);
GArray* g_array_prepend_vals (GArray *array,
       gconstpointer data,
       guint len);
GArray* g_array_insert_vals (GArray *array,
       guint index_,
       gconstpointer data,
       guint len);
GArray* g_array_set_size (GArray *array,
       guint length);
GArray* g_array_remove_index (GArray *array,
       guint index_);
GArray* g_array_remove_index_fast (GArray *array,
       guint index_);
GArray* g_array_remove_range (GArray *array,
       guint index_,
       guint length);
void g_array_sort (GArray *array,
       GCompareFunc compare_func);
void g_array_sort_with_data (GArray *array,
       GCompareDataFunc compare_func,
       gpointer user_data);
GPtrArray* g_ptr_array_new (void);
GPtrArray* g_ptr_array_sized_new (guint reserved_size);
gpointer* g_ptr_array_free (GPtrArray *array,
        gboolean free_seg);
void g_ptr_array_set_size (GPtrArray *array,
        gint length);
gpointer g_ptr_array_remove_index (GPtrArray *array,
        guint index_);
gpointer g_ptr_array_remove_index_fast (GPtrArray *array,
        guint index_);
gboolean g_ptr_array_remove (GPtrArray *array,
        gpointer data);
gboolean g_ptr_array_remove_fast (GPtrArray *array,
        gpointer data);
void g_ptr_array_remove_range (GPtrArray *array,
        guint index_,
        guint length);
void g_ptr_array_add (GPtrArray *array,
        gpointer data);
void g_ptr_array_sort (GPtrArray *array,
        GCompareFunc compare_func);
void g_ptr_array_sort_with_data (GPtrArray *array,
        GCompareDataFunc compare_func,
        gpointer user_data);
void g_ptr_array_foreach (GPtrArray *array,
        GFunc func,
        gpointer user_data);
GByteArray* g_byte_array_new (void);
GByteArray* g_byte_array_sized_new (guint reserved_size);
guint8* g_byte_array_free (GByteArray *array,
         gboolean free_segment);
GByteArray* g_byte_array_append (GByteArray *array,
         const guint8 *data,
         guint len);
GByteArray* g_byte_array_prepend (GByteArray *array,
         const guint8 *data,
         guint len);
GByteArray* g_byte_array_set_size (GByteArray *array,
         guint length);
GByteArray* g_byte_array_remove_index (GByteArray *array,
         guint index_);
GByteArray* g_byte_array_remove_index_fast (GByteArray *array,
         guint index_);
GByteArray* g_byte_array_remove_range (GByteArray *array,
         guint index_,
         guint length);
void g_byte_array_sort (GByteArray *array,
         GCompareFunc compare_func);
void g_byte_array_sort_with_data (GByteArray *array,
         GCompareDataFunc compare_func,
         gpointer user_data);
}
extern "C" {
typedef guint32 GQuark;
GQuark g_quark_try_string (const gchar *string);
GQuark g_quark_from_static_string (const gchar *string);
GQuark g_quark_from_string (const gchar *string);
const gchar* g_quark_to_string (GQuark quark) __attribute__((__const__));
const gchar* g_intern_string (const gchar *string);
const gchar* g_intern_static_string (const gchar *string);
}
extern "C" {
typedef struct _GError GError;
struct _GError
{
  GQuark domain;
  gint code;
  gchar *message;
};
GError* g_error_new (GQuark domain,
                                gint code,
                                const gchar *format,
                                ...) __attribute__((__format__ (__printf__, 3, 4)));
GError* g_error_new_literal (GQuark domain,
                                gint code,
                                const gchar *message);
void g_error_free (GError *error);
GError* g_error_copy (const GError *error);
gboolean g_error_matches (const GError *error,
                                GQuark domain,
                                gint code);
void g_set_error (GError **err,
                                GQuark domain,
                                gint code,
                                const gchar *format,
                                ...) __attribute__((__format__ (__printf__, 4, 5)));
void g_propagate_error (GError **dest,
    GError *src);
void g_clear_error (GError **err);
}
extern "C" {
const gchar* g_get_user_name (void);
const gchar* g_get_real_name (void);
const gchar* g_get_home_dir (void);
const gchar* g_get_tmp_dir (void);
const gchar* g_get_host_name (void);
gchar* g_get_prgname (void);
void g_set_prgname (const gchar *prgname);
const gchar* g_get_application_name (void);
void g_set_application_name (const gchar *application_name);
const gchar* g_get_user_data_dir (void);
const gchar* g_get_user_config_dir (void);
const gchar* g_get_user_cache_dir (void);
const gchar* const * g_get_system_data_dirs (void);
const gchar* const * g_get_system_config_dirs (void);
const gchar* const * g_get_language_names (void);
typedef enum {
  G_USER_DIRECTORY_DESKTOP,
  G_USER_DIRECTORY_DOCUMENTS,
  G_USER_DIRECTORY_DOWNLOAD,
  G_USER_DIRECTORY_MUSIC,
  G_USER_DIRECTORY_PICTURES,
  G_USER_DIRECTORY_PUBLIC_SHARE,
  G_USER_DIRECTORY_TEMPLATES,
  G_USER_DIRECTORY_VIDEOS,
  G_USER_N_DIRECTORIES
} GUserDirectory;
const gchar* g_get_user_special_dir (GUserDirectory directory);
typedef struct _GDebugKey GDebugKey;
struct _GDebugKey
{
  gchar *key;
  guint value;
};
guint g_parse_debug_string (const gchar *string,
         const GDebugKey *keys,
         guint nkeys);
gint g_snprintf (gchar *string,
         gulong n,
         gchar const *format,
         ...) __attribute__((__format__ (__printf__, 3, 4)));
gint g_vsnprintf (gchar *string,
         gulong n,
         gchar const *format,
         va_list args);
gboolean g_path_is_absolute (const gchar *file_name);
const gchar* g_path_skip_root (const gchar *file_name);
const gchar* g_basename (const gchar *file_name);
gchar* g_get_current_dir (void);
gchar* g_path_get_basename (const gchar *file_name) __attribute__((__malloc__));
gchar* g_path_get_dirname (const gchar *file_name) __attribute__((__malloc__));
void g_nullify_pointer (gpointer *nullify_location);
const gchar* g_getenv (const gchar *variable);
gboolean g_setenv (const gchar *variable,
         const gchar *value,
         gboolean overwrite);
void g_unsetenv (const gchar *variable);
gchar** g_listenv (void);
const gchar* _g_getenv_nomalloc (const gchar *variable,
         gchar buffer[1024]);
typedef void (*GVoidFunc) (void);
void g_atexit (GVoidFunc func);
gchar* g_find_program_in_path (const gchar *program);
extern inline gint g_bit_nth_lsf (gulong mask,
           gint nth_bit) __attribute__((__const__));
extern inline gint g_bit_nth_msf (gulong mask,
           gint nth_bit) __attribute__((__const__));
extern inline guint g_bit_storage (gulong number) __attribute__((__const__));
typedef struct _GTrashStack GTrashStack;
struct _GTrashStack
{
  GTrashStack *next;
};
extern inline void g_trash_stack_push (GTrashStack **stack_p,
       gpointer data_p);
extern inline gpointer g_trash_stack_pop (GTrashStack **stack_p);
extern inline gpointer g_trash_stack_peek (GTrashStack **stack_p);
extern inline guint g_trash_stack_height (GTrashStack **stack_p);
extern inline gint
g_bit_nth_lsf (gulong mask,
        gint nth_bit)
{
  if ((nth_bit < -1))
    nth_bit = -1;
  while (nth_bit < ((4 * 8) - 1))
    {
      nth_bit++;
      if (mask & (1UL << nth_bit))
 return nth_bit;
    }
  return -1;
}
extern inline gint
g_bit_nth_msf (gulong mask,
        gint nth_bit)
{
  if (nth_bit < 0 || (nth_bit > 4 * 8))
    nth_bit = 4 * 8;
  while (nth_bit > 0)
    {
      nth_bit--;
      if (mask & (1UL << nth_bit))
 return nth_bit;
    }
  return -1;
}
extern inline guint
g_bit_storage (gulong number)
{
  register guint n_bits = 0;
  do
    {
      n_bits++;
      number >>= 1;
    }
  while (number);
  return n_bits;
}
extern inline void
g_trash_stack_push (GTrashStack **stack_p,
      gpointer data_p)
{
  GTrashStack *data = (GTrashStack *) data_p;
  data->next = *stack_p;
  *stack_p = data;
}
extern inline gpointer
g_trash_stack_pop (GTrashStack **stack_p)
{
  GTrashStack *data;
  data = *stack_p;
  if (data)
    {
      *stack_p = data->next;
      data->next = __null;
    }
  return data;
}
extern inline gpointer
g_trash_stack_peek (GTrashStack **stack_p)
{
  GTrashStack *data;
  data = *stack_p;
  return data;
}
extern inline guint
g_trash_stack_height (GTrashStack **stack_p)
{
  GTrashStack *data;
  guint i = 0;
  for (data = *stack_p; data; data = data->next)
    i++;
  return i;
}
extern const guint glib_major_version;
extern const guint glib_minor_version;
extern const guint glib_micro_version;
extern const guint glib_interface_age;
extern const guint glib_binary_age;
const gchar * glib_check_version (guint required_major,
                                  guint required_minor,
                                  guint required_micro);
}
extern "C" {
gint g_atomic_int_exchange_and_add (volatile gint *atomic,
      gint val);
void g_atomic_int_add (volatile gint *atomic,
      gint val);
gboolean g_atomic_int_compare_and_exchange (volatile gint *atomic,
      gint oldval,
      gint newval);
gboolean g_atomic_pointer_compare_and_exchange (volatile gpointer *atomic,
      gpointer oldval,
      gpointer newval);
gint g_atomic_int_get (volatile gint *atomic);
void g_atomic_int_set (volatile gint *atomic,
      gint newval);
gpointer g_atomic_pointer_get (volatile gpointer *atomic);
void g_atomic_pointer_set (volatile gpointer *atomic,
      gpointer newval);
}
extern "C" {
extern GQuark g_thread_error_quark (void);
typedef enum
{
  G_THREAD_ERROR_AGAIN
} GThreadError;
typedef gpointer (*GThreadFunc) (gpointer data);
typedef enum
{
  G_THREAD_PRIORITY_LOW,
  G_THREAD_PRIORITY_NORMAL,
  G_THREAD_PRIORITY_HIGH,
  G_THREAD_PRIORITY_URGENT
} GThreadPriority;
typedef struct _GThread GThread;
struct _GThread
{
  GThreadFunc func;
  gpointer data;
  gboolean joinable;
  GThreadPriority priority;
};
typedef struct _GMutex GMutex;
typedef struct _GCond GCond;
typedef struct _GPrivate GPrivate;
typedef struct _GStaticPrivate GStaticPrivate;
typedef struct _GThreadFunctions GThreadFunctions;
struct _GThreadFunctions
{
  GMutex* (*mutex_new) (void);
  void (*mutex_lock) (GMutex *mutex);
  gboolean (*mutex_trylock) (GMutex *mutex);
  void (*mutex_unlock) (GMutex *mutex);
  void (*mutex_free) (GMutex *mutex);
  GCond* (*cond_new) (void);
  void (*cond_signal) (GCond *cond);
  void (*cond_broadcast) (GCond *cond);
  void (*cond_wait) (GCond *cond,
                                   GMutex *mutex);
  gboolean (*cond_timed_wait) (GCond *cond,
                                   GMutex *mutex,
                                   GTimeVal *end_time);
  void (*cond_free) (GCond *cond);
  GPrivate* (*private_new) (GDestroyNotify destructor);
  gpointer (*private_get) (GPrivate *private_key);
  void (*private_set) (GPrivate *private_key,
                                   gpointer data);
  void (*thread_create) (GThreadFunc func,
                                   gpointer data,
                                   gulong stack_size,
                                   gboolean joinable,
                                   gboolean bound,
                                   GThreadPriority priority,
                                   gpointer thread,
                                   GError **error);
  void (*thread_yield) (void);
  void (*thread_join) (gpointer thread);
  void (*thread_exit) (void);
  void (*thread_set_priority)(gpointer thread,
                                   GThreadPriority priority);
  void (*thread_self) (gpointer thread);
  gboolean (*thread_equal) (gpointer thread1,
       gpointer thread2);
};
extern GThreadFunctions g_thread_functions_for_glib_use;
extern gboolean g_thread_use_default_impl;
extern gboolean g_threads_got_initialized;
extern guint64 (*g_thread_gettime) (void);
void g_thread_init (GThreadFunctions *vtable);
void g_thread_init_with_errorcheck_mutexes (GThreadFunctions* vtable);
GMutex* g_static_mutex_get_mutex_impl (GMutex **mutex);
GThread* g_thread_create_full (GThreadFunc func,
                                gpointer data,
                                gulong stack_size,
                                gboolean joinable,
                                gboolean bound,
                                GThreadPriority priority,
                                GError **error);
GThread* g_thread_self (void);
void g_thread_exit (gpointer retval);
gpointer g_thread_join (GThread *thread);
void g_thread_set_priority (GThread *thread,
                                GThreadPriority priority);
void g_static_mutex_init (GStaticMutex *mutex);
void g_static_mutex_free (GStaticMutex *mutex);
struct _GStaticPrivate
{
  guint index;
};
void g_static_private_init (GStaticPrivate *private_key);
gpointer g_static_private_get (GStaticPrivate *private_key);
void g_static_private_set (GStaticPrivate *private_key,
       gpointer data,
       GDestroyNotify notify);
void g_static_private_free (GStaticPrivate *private_key);
typedef struct _GStaticRecMutex GStaticRecMutex;
struct _GStaticRecMutex
{
  GStaticMutex mutex;
  guint depth;
  GSystemThread owner;
};
void g_static_rec_mutex_init (GStaticRecMutex *mutex);
void g_static_rec_mutex_lock (GStaticRecMutex *mutex);
gboolean g_static_rec_mutex_trylock (GStaticRecMutex *mutex);
void g_static_rec_mutex_unlock (GStaticRecMutex *mutex);
void g_static_rec_mutex_lock_full (GStaticRecMutex *mutex,
                                         guint depth);
guint g_static_rec_mutex_unlock_full (GStaticRecMutex *mutex);
void g_static_rec_mutex_free (GStaticRecMutex *mutex);
typedef struct _GStaticRWLock GStaticRWLock;
struct _GStaticRWLock
{
  GStaticMutex mutex;
  GCond *read_cond;
  GCond *write_cond;
  guint read_counter;
  gboolean have_writer;
  guint want_to_read;
  guint want_to_write;
};
void g_static_rw_lock_init (GStaticRWLock* lock);
void g_static_rw_lock_reader_lock (GStaticRWLock* lock);
gboolean g_static_rw_lock_reader_trylock (GStaticRWLock* lock);
void g_static_rw_lock_reader_unlock (GStaticRWLock* lock);
void g_static_rw_lock_writer_lock (GStaticRWLock* lock);
gboolean g_static_rw_lock_writer_trylock (GStaticRWLock* lock);
void g_static_rw_lock_writer_unlock (GStaticRWLock* lock);
void g_static_rw_lock_free (GStaticRWLock* lock);
void g_thread_foreach (GFunc thread_func,
        gpointer user_data);
typedef enum
{
  G_ONCE_STATUS_NOTCALLED,
  G_ONCE_STATUS_PROGRESS,
  G_ONCE_STATUS_READY
} GOnceStatus;
typedef struct _GOnce GOnce;
struct _GOnce
{
  volatile GOnceStatus status;
  volatile gpointer retval;
};
gpointer g_once_impl (GOnce *once, GThreadFunc func, gpointer arg);
extern inline gboolean g_once_init_enter (volatile gsize *value_location);
gboolean g_once_init_enter_impl (volatile gsize *value_location);
void g_once_init_leave (volatile gsize *value_location,
                                                 gsize initialization_value);
extern inline gboolean
g_once_init_enter (volatile gsize *value_location)
{
  if ((*((void*volatile*) value_location)) != __null)
    return (0);
  else
    return g_once_init_enter_impl (value_location);
}
extern void glib_dummy_decl (void);
}
extern "C" {
typedef struct _GAsyncQueue GAsyncQueue;
GAsyncQueue* g_async_queue_new (void);
void g_async_queue_lock (GAsyncQueue *queue);
void g_async_queue_unlock (GAsyncQueue *queue);
GAsyncQueue* g_async_queue_ref (GAsyncQueue *queue);
void g_async_queue_unref (GAsyncQueue *queue);
void g_async_queue_ref_unlocked (GAsyncQueue *queue);
void g_async_queue_unref_and_unlock (GAsyncQueue *queue);
void g_async_queue_push (GAsyncQueue *queue,
       gpointer data);
void g_async_queue_push_unlocked (GAsyncQueue *queue,
       gpointer data);
void g_async_queue_push_sorted (GAsyncQueue *queue,
       gpointer data,
       GCompareDataFunc func,
       gpointer user_data);
void g_async_queue_push_sorted_unlocked (GAsyncQueue *queue,
       gpointer data,
       GCompareDataFunc func,
       gpointer user_data);
gpointer g_async_queue_pop (GAsyncQueue *queue);
gpointer g_async_queue_pop_unlocked (GAsyncQueue *queue);
gpointer g_async_queue_try_pop (GAsyncQueue *queue);
gpointer g_async_queue_try_pop_unlocked (GAsyncQueue *queue);
gpointer g_async_queue_timed_pop (GAsyncQueue *queue,
       GTimeVal *end_time);
gpointer g_async_queue_timed_pop_unlocked (GAsyncQueue *queue,
       GTimeVal *end_time);
gint g_async_queue_length (GAsyncQueue *queue);
gint g_async_queue_length_unlocked (GAsyncQueue *queue);
void g_async_queue_sort (GAsyncQueue *queue,
       GCompareDataFunc func,
       gpointer user_data);
void g_async_queue_sort_unlocked (GAsyncQueue *queue,
       GCompareDataFunc func,
       gpointer user_data);
GMutex* _g_async_queue_get_mutex (GAsyncQueue *queue);
}
extern "C" {
void g_on_error_query (const gchar *prg_name);
void g_on_error_stack_trace (const gchar *prg_name);
}
extern "C" {
gsize g_base64_encode_step (const guchar *in,
          gsize len,
          gboolean break_lines,
          gchar *out,
          gint *state,
          gint *save);
gsize g_base64_encode_close (gboolean break_lines,
          gchar *out,
          gint *state,
          gint *save);
gchar* g_base64_encode (const guchar *data,
          gsize len) __attribute__((__malloc__));
gsize g_base64_decode_step (const gchar *in,
          gsize len,
          guchar *out,
          gint *state,
          guint *save);
guchar *g_base64_decode (const gchar *text,
          gsize *out_len) __attribute__((__malloc__));
}
extern "C" {
typedef enum
{
  G_BOOKMARK_FILE_ERROR_INVALID_URI,
  G_BOOKMARK_FILE_ERROR_INVALID_VALUE,
  G_BOOKMARK_FILE_ERROR_APP_NOT_REGISTERED,
  G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND,
  G_BOOKMARK_FILE_ERROR_READ,
  G_BOOKMARK_FILE_ERROR_UNKNOWN_ENCODING,
  G_BOOKMARK_FILE_ERROR_WRITE,
  G_BOOKMARK_FILE_ERROR_FILE_NOT_FOUND
} GBookmarkFileError;
GQuark g_bookmark_file_error_quark (void);
typedef struct _GBookmarkFile GBookmarkFile;
GBookmarkFile *g_bookmark_file_new (void);
void g_bookmark_file_free (GBookmarkFile *bookmark);
gboolean g_bookmark_file_load_from_file (GBookmarkFile *bookmark,
          const gchar *filename,
          GError **error);
gboolean g_bookmark_file_load_from_data (GBookmarkFile *bookmark,
          const gchar *data,
          gsize length,
          GError **error);
gboolean g_bookmark_file_load_from_data_dirs (GBookmarkFile *bookmark,
          const gchar *file,
          gchar **full_path,
          GError **error);
gchar * g_bookmark_file_to_data (GBookmarkFile *bookmark,
          gsize *length,
          GError **error) __attribute__((__malloc__));
gboolean g_bookmark_file_to_file (GBookmarkFile *bookmark,
          const gchar *filename,
          GError **error);
void g_bookmark_file_set_title (GBookmarkFile *bookmark,
          const gchar *uri,
          const gchar *title);
gchar * g_bookmark_file_get_title (GBookmarkFile *bookmark,
          const gchar *uri,
          GError **error) __attribute__((__malloc__));
void g_bookmark_file_set_description (GBookmarkFile *bookmark,
          const gchar *uri,
          const gchar *description);
gchar * g_bookmark_file_get_description (GBookmarkFile *bookmark,
          const gchar *uri,
          GError **error) __attribute__((__malloc__));
void g_bookmark_file_set_mime_type (GBookmarkFile *bookmark,
          const gchar *uri,
          const gchar *mime_type);
gchar * g_bookmark_file_get_mime_type (GBookmarkFile *bookmark,
          const gchar *uri,
          GError **error) __attribute__((__malloc__));
void g_bookmark_file_set_groups (GBookmarkFile *bookmark,
          const gchar *uri,
          const gchar **groups,
          gsize length);
void g_bookmark_file_add_group (GBookmarkFile *bookmark,
          const gchar *uri,
          const gchar *group);
gboolean g_bookmark_file_has_group (GBookmarkFile *bookmark,
          const gchar *uri,
          const gchar *group,
          GError **error);
gchar ** g_bookmark_file_get_groups (GBookmarkFile *bookmark,
          const gchar *uri,
          gsize *length,
          GError **error) __attribute__((__malloc__));
void g_bookmark_file_add_application (GBookmarkFile *bookmark,
          const gchar *uri,
          const gchar *name,
          const gchar *exec);
gboolean g_bookmark_file_has_application (GBookmarkFile *bookmark,
          const gchar *uri,
          const gchar *name,
          GError **error);
gchar ** g_bookmark_file_get_applications (GBookmarkFile *bookmark,
          const gchar *uri,
          gsize *length,
          GError **error) __attribute__((__malloc__));
gboolean g_bookmark_file_set_app_info (GBookmarkFile *bookmark,
          const gchar *uri,
          const gchar *name,
          const gchar *exec,
          gint count,
          time_t stamp,
          GError **error);
gboolean g_bookmark_file_get_app_info (GBookmarkFile *bookmark,
          const gchar *uri,
          const gchar *name,
          gchar **exec,
          guint *count,
          time_t *stamp,
          GError **error);
void g_bookmark_file_set_is_private (GBookmarkFile *bookmark,
          const gchar *uri,
          gboolean is_private);
gboolean g_bookmark_file_get_is_private (GBookmarkFile *bookmark,
          const gchar *uri,
          GError **error);
void g_bookmark_file_set_icon (GBookmarkFile *bookmark,
          const gchar *uri,
          const gchar *href,
          const gchar *mime_type);
gboolean g_bookmark_file_get_icon (GBookmarkFile *bookmark,
          const gchar *uri,
          gchar **href,
          gchar **mime_type,
          GError **error);
void g_bookmark_file_set_added (GBookmarkFile *bookmark,
          const gchar *uri,
          time_t added);
time_t g_bookmark_file_get_added (GBookmarkFile *bookmark,
          const gchar *uri,
          GError **error);
void g_bookmark_file_set_modified (GBookmarkFile *bookmark,
          const gchar *uri,
          time_t modified);
time_t g_bookmark_file_get_modified (GBookmarkFile *bookmark,
          const gchar *uri,
          GError **error);
void g_bookmark_file_set_visited (GBookmarkFile *bookmark,
          const gchar *uri,
          time_t visited);
time_t g_bookmark_file_get_visited (GBookmarkFile *bookmark,
          const gchar *uri,
          GError **error);
gboolean g_bookmark_file_has_item (GBookmarkFile *bookmark,
          const gchar *uri);
gint g_bookmark_file_get_size (GBookmarkFile *bookmark);
gchar ** g_bookmark_file_get_uris (GBookmarkFile *bookmark,
          gsize *length) __attribute__((__malloc__));
gboolean g_bookmark_file_remove_group (GBookmarkFile *bookmark,
          const gchar *uri,
          const gchar *group,
          GError **error);
gboolean g_bookmark_file_remove_application (GBookmarkFile *bookmark,
          const gchar *uri,
          const gchar *name,
          GError **error);
gboolean g_bookmark_file_remove_item (GBookmarkFile *bookmark,
          const gchar *uri,
          GError **error);
gboolean g_bookmark_file_move_item (GBookmarkFile *bookmark,
          const gchar *old_uri,
          const gchar *new_uri,
          GError **error);
}
extern "C" {
gpointer g_slice_alloc (gsize block_size) __attribute__((__malloc__));
gpointer g_slice_alloc0 (gsize block_size) __attribute__((__malloc__));
gpointer g_slice_copy (gsize block_size,
                                         gconstpointer mem_block) __attribute__((__malloc__));
void g_slice_free1 (gsize block_size,
      gpointer mem_block);
void g_slice_free_chain_with_offset (gsize block_size,
      gpointer mem_chain,
      gsize next_offset);
typedef enum {
  G_SLICE_CONFIG_ALWAYS_MALLOC = 1,
  G_SLICE_CONFIG_BYPASS_MAGAZINES,
  G_SLICE_CONFIG_WORKING_SET_MSECS,
  G_SLICE_CONFIG_COLOR_INCREMENT,
  G_SLICE_CONFIG_CHUNK_SIZES,
  G_SLICE_CONFIG_CONTENTION_COUNTER
} GSliceConfig;
void g_slice_set_config (GSliceConfig ckey, gint64 value);
gint64 g_slice_get_config (GSliceConfig ckey);
gint64* g_slice_get_config_state (GSliceConfig ckey, gint64 address, guint *n_values);
}
extern "C" {
typedef struct _GMemVTable GMemVTable;
gpointer g_malloc (gulong n_bytes) __attribute__((__malloc__));
gpointer g_malloc0 (gulong n_bytes) __attribute__((__malloc__));
gpointer g_realloc (gpointer mem,
      gulong n_bytes) __attribute__((warn_unused_result));
void g_free (gpointer mem);
gpointer g_try_malloc (gulong n_bytes) __attribute__((__malloc__));
gpointer g_try_malloc0 (gulong n_bytes) __attribute__((__malloc__));
gpointer g_try_realloc (gpointer mem,
      gulong n_bytes) __attribute__((warn_unused_result));
struct _GMemVTable
{
  gpointer (*malloc) (gsize n_bytes);
  gpointer (*realloc) (gpointer mem,
      gsize n_bytes);
  void (*free) (gpointer mem);
  gpointer (*calloc) (gsize n_blocks,
      gsize n_block_bytes);
  gpointer (*try_malloc) (gsize n_bytes);
  gpointer (*try_realloc) (gpointer mem,
      gsize n_bytes);
};
void g_mem_set_vtable (GMemVTable *vtable);
gboolean g_mem_is_system_malloc (void);
extern gboolean g_mem_gc_friendly;
extern GMemVTable *glib_mem_profiler_table;
void g_mem_profile (void);
typedef struct _GAllocator GAllocator;
typedef struct _GMemChunk GMemChunk;
GMemChunk* g_mem_chunk_new (const gchar *name,
    gint atom_size,
    gulong area_size,
    gint type);
void g_mem_chunk_destroy (GMemChunk *mem_chunk);
gpointer g_mem_chunk_alloc (GMemChunk *mem_chunk);
gpointer g_mem_chunk_alloc0 (GMemChunk *mem_chunk);
void g_mem_chunk_free (GMemChunk *mem_chunk,
    gpointer mem);
void g_mem_chunk_clean (GMemChunk *mem_chunk);
void g_mem_chunk_reset (GMemChunk *mem_chunk);
void g_mem_chunk_print (GMemChunk *mem_chunk);
void g_mem_chunk_info (void);
void g_blow_chunks (void);
GAllocator*g_allocator_new (const gchar *name,
    guint n_preallocs);
void g_allocator_free (GAllocator *allocator);
}
extern "C" {
typedef struct _GList GList;
struct _GList
{
  gpointer data;
  GList *next;
  GList *prev;
};
GList* g_list_alloc (void) __attribute__((warn_unused_result));
void g_list_free (GList *list);
void g_list_free_1 (GList *list);
GList* g_list_append (GList *list,
      gpointer data) __attribute__((warn_unused_result));
GList* g_list_prepend (GList *list,
      gpointer data) __attribute__((warn_unused_result));
GList* g_list_insert (GList *list,
      gpointer data,
      gint position) __attribute__((warn_unused_result));
GList* g_list_insert_sorted (GList *list,
      gpointer data,
      GCompareFunc func) __attribute__((warn_unused_result));
GList* g_list_insert_sorted_with_data (GList *list,
      gpointer data,
      GCompareDataFunc func,
      gpointer user_data) __attribute__((warn_unused_result));
GList* g_list_insert_before (GList *list,
      GList *sibling,
      gpointer data) __attribute__((warn_unused_result));
GList* g_list_concat (GList *list1,
      GList *list2) __attribute__((warn_unused_result));
GList* g_list_remove (GList *list,
      gconstpointer data) __attribute__((warn_unused_result));
GList* g_list_remove_all (GList *list,
      gconstpointer data) __attribute__((warn_unused_result));
GList* g_list_remove_link (GList *list,
      GList *llink) __attribute__((warn_unused_result));
GList* g_list_delete_link (GList *list,
      GList *link_) __attribute__((warn_unused_result));
GList* g_list_reverse (GList *list) __attribute__((warn_unused_result));
GList* g_list_copy (GList *list) __attribute__((warn_unused_result));
GList* g_list_nth (GList *list,
      guint n);
GList* g_list_nth_prev (GList *list,
      guint n);
GList* g_list_find (GList *list,
      gconstpointer data);
GList* g_list_find_custom (GList *list,
      gconstpointer data,
      GCompareFunc func);
gint g_list_position (GList *list,
      GList *llink);
gint g_list_index (GList *list,
      gconstpointer data);
GList* g_list_last (GList *list);
GList* g_list_first (GList *list);
guint g_list_length (GList *list);
void g_list_foreach (GList *list,
      GFunc func,
      gpointer user_data);
GList* g_list_sort (GList *list,
      GCompareFunc compare_func) __attribute__((warn_unused_result));
GList* g_list_sort_with_data (GList *list,
      GCompareDataFunc compare_func,
      gpointer user_data) __attribute__((warn_unused_result));
gpointer g_list_nth_data (GList *list,
      guint n);
void g_list_push_allocator (gpointer allocator);
void g_list_pop_allocator (void);
}
extern "C" {
typedef struct _GCache GCache;
typedef gpointer (*GCacheNewFunc) (gpointer key);
typedef gpointer (*GCacheDupFunc) (gpointer value);
typedef void (*GCacheDestroyFunc) (gpointer value);
GCache* g_cache_new (GCacheNewFunc value_new_func,
                                GCacheDestroyFunc value_destroy_func,
                                GCacheDupFunc key_dup_func,
                                GCacheDestroyFunc key_destroy_func,
                                GHashFunc hash_key_func,
                                GHashFunc hash_value_func,
                                GEqualFunc key_equal_func);
void g_cache_destroy (GCache *cache);
gpointer g_cache_insert (GCache *cache,
                                gpointer key);
void g_cache_remove (GCache *cache,
                                gconstpointer value);
void g_cache_key_foreach (GCache *cache,
                                GHFunc func,
                                gpointer user_data);
void g_cache_value_foreach (GCache *cache,
                                GHFunc func,
                                gpointer user_data);
}
extern "C" {
typedef struct _GCompletion GCompletion;
typedef gchar* (*GCompletionFunc) (gpointer);
typedef gint (*GCompletionStrncmpFunc) (const gchar *s1,
     const gchar *s2,
     gsize n);
struct _GCompletion
{
  GList* items;
  GCompletionFunc func;
  gchar* prefix;
  GList* cache;
  GCompletionStrncmpFunc strncmp_func;
};
GCompletion* g_completion_new (GCompletionFunc func);
void g_completion_add_items (GCompletion* cmp,
                                         GList* items);
void g_completion_remove_items (GCompletion* cmp,
                                         GList* items);
void g_completion_clear_items (GCompletion* cmp);
GList* g_completion_complete (GCompletion* cmp,
                                         const gchar* prefix,
                                         gchar** new_prefix);
GList* g_completion_complete_utf8 (GCompletion *cmp,
                                         const gchar* prefix,
                                         gchar** new_prefix);
void g_completion_set_compare (GCompletion *cmp,
             GCompletionStrncmpFunc strncmp_func);
void g_completion_free (GCompletion* cmp);
}
extern "C" {
typedef enum
{
  G_CONVERT_ERROR_NO_CONVERSION,
  G_CONVERT_ERROR_ILLEGAL_SEQUENCE,
  G_CONVERT_ERROR_FAILED,
  G_CONVERT_ERROR_PARTIAL_INPUT,
  G_CONVERT_ERROR_BAD_URI,
  G_CONVERT_ERROR_NOT_ABSOLUTE_PATH
} GConvertError;
GQuark g_convert_error_quark (void);
typedef struct _GIConv *GIConv;
GIConv g_iconv_open (const gchar *to_codeset,
         const gchar *from_codeset);
gsize g_iconv (GIConv converter,
         gchar **inbuf,
         gsize *inbytes_left,
         gchar **outbuf,
         gsize *outbytes_left);
gint g_iconv_close (GIConv converter);
gchar* g_convert (const gchar *str,
    gssize len,
    const gchar *to_codeset,
    const gchar *from_codeset,
    gsize *bytes_read,
    gsize *bytes_written,
    GError **error) __attribute__((__malloc__));
gchar* g_convert_with_iconv (const gchar *str,
    gssize len,
    GIConv converter,
    gsize *bytes_read,
    gsize *bytes_written,
    GError **error) __attribute__((__malloc__));
gchar* g_convert_with_fallback (const gchar *str,
    gssize len,
    const gchar *to_codeset,
    const gchar *from_codeset,
    gchar *fallback,
    gsize *bytes_read,
    gsize *bytes_written,
    GError **error) __attribute__((__malloc__));
gchar* g_locale_to_utf8 (const gchar *opsysstring,
      gssize len,
      gsize *bytes_read,
      gsize *bytes_written,
      GError **error) __attribute__((__malloc__));
gchar* g_locale_from_utf8 (const gchar *utf8string,
      gssize len,
      gsize *bytes_read,
      gsize *bytes_written,
      GError **error) __attribute__((__malloc__));
gchar* g_filename_to_utf8 (const gchar *opsysstring,
        gssize len,
        gsize *bytes_read,
        gsize *bytes_written,
        GError **error) __attribute__((__malloc__));
gchar* g_filename_from_utf8 (const gchar *utf8string,
        gssize len,
        gsize *bytes_read,
        gsize *bytes_written,
        GError **error) __attribute__((__malloc__));
gchar *g_filename_from_uri (const gchar *uri,
       gchar **hostname,
       GError **error) __attribute__((__malloc__));
gchar *g_filename_to_uri (const gchar *filename,
       const gchar *hostname,
       GError **error) __attribute__((__malloc__));
gchar *g_filename_display_name (const gchar *filename) __attribute__((__malloc__));
gboolean g_get_filename_charsets (const gchar ***charsets);
gchar *g_filename_display_basename (const gchar *filename) __attribute__((__malloc__));
gchar **g_uri_list_extract_uris (const gchar *uri_list) __attribute__((__malloc__));
}
extern "C" {
typedef struct _GData GData;
typedef void (*GDataForeachFunc) (GQuark key_id,
                                                 gpointer data,
                                                 gpointer user_data);
void g_datalist_init (GData **datalist);
void g_datalist_clear (GData **datalist);
gpointer g_datalist_id_get_data (GData **datalist,
      GQuark key_id);
void g_datalist_id_set_data_full (GData **datalist,
      GQuark key_id,
      gpointer data,
      GDestroyNotify destroy_func);
gpointer g_datalist_id_remove_no_notify (GData **datalist,
      GQuark key_id);
void g_datalist_foreach (GData **datalist,
      GDataForeachFunc func,
      gpointer user_data);
void g_datalist_set_flags (GData **datalist,
      guint flags);
void g_datalist_unset_flags (GData **datalist,
      guint flags);
guint g_datalist_get_flags (GData **datalist);
void g_dataset_destroy (gconstpointer dataset_location);
gpointer g_dataset_id_get_data (gconstpointer dataset_location,
                                         GQuark key_id);
void g_dataset_id_set_data_full (gconstpointer dataset_location,
                                         GQuark key_id,
                                         gpointer data,
                                         GDestroyNotify destroy_func);
gpointer g_dataset_id_remove_no_notify (gconstpointer dataset_location,
                                         GQuark key_id);
void g_dataset_foreach (gconstpointer dataset_location,
                                         GDataForeachFunc func,
                                         gpointer user_data);
}
extern "C" {
typedef gint32 GTime;
typedef guint16 GDateYear;
typedef guint8 GDateDay;
typedef struct _GDate GDate;
typedef enum
{
  G_DATE_DAY = 0,
  G_DATE_MONTH = 1,
  G_DATE_YEAR = 2
} GDateDMY;
typedef enum
{
  G_DATE_BAD_WEEKDAY = 0,
  G_DATE_MONDAY = 1,
  G_DATE_TUESDAY = 2,
  G_DATE_WEDNESDAY = 3,
  G_DATE_THURSDAY = 4,
  G_DATE_FRIDAY = 5,
  G_DATE_SATURDAY = 6,
  G_DATE_SUNDAY = 7
} GDateWeekday;
typedef enum
{
  G_DATE_BAD_MONTH = 0,
  G_DATE_JANUARY = 1,
  G_DATE_FEBRUARY = 2,
  G_DATE_MARCH = 3,
  G_DATE_APRIL = 4,
  G_DATE_MAY = 5,
  G_DATE_JUNE = 6,
  G_DATE_JULY = 7,
  G_DATE_AUGUST = 8,
  G_DATE_SEPTEMBER = 9,
  G_DATE_OCTOBER = 10,
  G_DATE_NOVEMBER = 11,
  G_DATE_DECEMBER = 12
} GDateMonth;
struct _GDate
{
  guint julian_days : 32;
  guint julian : 1;
  guint dmy : 1;
  guint day : 6;
  guint month : 4;
  guint year : 16;
};
GDate* g_date_new (void);
GDate* g_date_new_dmy (GDateDay day,
                                           GDateMonth month,
                                           GDateYear year);
GDate* g_date_new_julian (guint32 julian_day);
void g_date_free (GDate *date);
gboolean g_date_valid (const GDate *date);
gboolean g_date_valid_day (GDateDay day) __attribute__((__const__));
gboolean g_date_valid_month (GDateMonth month) __attribute__((__const__));
gboolean g_date_valid_year (GDateYear year) __attribute__((__const__));
gboolean g_date_valid_weekday (GDateWeekday weekday) __attribute__((__const__));
gboolean g_date_valid_julian (guint32 julian_date) __attribute__((__const__));
gboolean g_date_valid_dmy (GDateDay day,
                                           GDateMonth month,
                                           GDateYear year) __attribute__((__const__));
GDateWeekday g_date_get_weekday (const GDate *date);
GDateMonth g_date_get_month (const GDate *date);
GDateYear g_date_get_year (const GDate *date);
GDateDay g_date_get_day (const GDate *date);
guint32 g_date_get_julian (const GDate *date);
guint g_date_get_day_of_year (const GDate *date);
guint g_date_get_monday_week_of_year (const GDate *date);
guint g_date_get_sunday_week_of_year (const GDate *date);
guint g_date_get_iso8601_week_of_year (const GDate *date);
void g_date_clear (GDate *date,
                                           guint n_dates);
void g_date_set_parse (GDate *date,
                                           const gchar *str);
void g_date_set_time_t (GDate *date,
        time_t timet);
void g_date_set_time_val (GDate *date,
        GTimeVal *timeval);
void g_date_set_time (GDate *date,
                                           GTime time_);
void g_date_set_month (GDate *date,
                                           GDateMonth month);
void g_date_set_day (GDate *date,
                                           GDateDay day);
void g_date_set_year (GDate *date,
                                           GDateYear year);
void g_date_set_dmy (GDate *date,
                                           GDateDay day,
                                           GDateMonth month,
                                           GDateYear y);
void g_date_set_julian (GDate *date,
                                           guint32 julian_date);
gboolean g_date_is_first_of_month (const GDate *date);
gboolean g_date_is_last_of_month (const GDate *date);
void g_date_add_days (GDate *date,
                                           guint n_days);
void g_date_subtract_days (GDate *date,
                                           guint n_days);
void g_date_add_months (GDate *date,
                                           guint n_months);
void g_date_subtract_months (GDate *date,
                                           guint n_months);
void g_date_add_years (GDate *date,
                                           guint n_years);
void g_date_subtract_years (GDate *date,
                                           guint n_years);
gboolean g_date_is_leap_year (GDateYear year) __attribute__((__const__));
guint8 g_date_get_days_in_month (GDateMonth month,
                                           GDateYear year) __attribute__((__const__));
guint8 g_date_get_monday_weeks_in_year (GDateYear year) __attribute__((__const__));
guint8 g_date_get_sunday_weeks_in_year (GDateYear year) __attribute__((__const__));
gint g_date_days_between (const GDate *date1,
        const GDate *date2);
gint g_date_compare (const GDate *lhs,
                                           const GDate *rhs);
void g_date_to_struct_tm (const GDate *date,
                                           struct tm *tm);
void g_date_clamp (GDate *date,
        const GDate *min_date,
        const GDate *max_date);
void g_date_order (GDate *date1, GDate *date2);
gsize g_date_strftime (gchar *s,
                                           gsize slen,
                                           const gchar *format,
                                           const GDate *date);
}
extern "C" {
typedef struct _GDir GDir;
GDir * g_dir_open (const gchar *path,
            guint flags,
            GError **error);
const gchar *g_dir_read_name (GDir *dir);
void g_dir_rewind (GDir *dir);
void g_dir_close (GDir *dir);
}
extern "C" {
typedef enum
{
  G_FILE_ERROR_EXIST,
  G_FILE_ERROR_ISDIR,
  G_FILE_ERROR_ACCES,
  G_FILE_ERROR_NAMETOOLONG,
  G_FILE_ERROR_NOENT,
  G_FILE_ERROR_NOTDIR,
  G_FILE_ERROR_NXIO,
  G_FILE_ERROR_NODEV,
  G_FILE_ERROR_ROFS,
  G_FILE_ERROR_TXTBSY,
  G_FILE_ERROR_FAULT,
  G_FILE_ERROR_LOOP,
  G_FILE_ERROR_NOSPC,
  G_FILE_ERROR_NOMEM,
  G_FILE_ERROR_MFILE,
  G_FILE_ERROR_NFILE,
  G_FILE_ERROR_BADF,
  G_FILE_ERROR_INVAL,
  G_FILE_ERROR_PIPE,
  G_FILE_ERROR_AGAIN,
  G_FILE_ERROR_INTR,
  G_FILE_ERROR_IO,
  G_FILE_ERROR_PERM,
  G_FILE_ERROR_NOSYS,
  G_FILE_ERROR_FAILED
} GFileError;
typedef enum
{
  G_FILE_TEST_IS_REGULAR = 1 << 0,
  G_FILE_TEST_IS_SYMLINK = 1 << 1,
  G_FILE_TEST_IS_DIR = 1 << 2,
  G_FILE_TEST_IS_EXECUTABLE = 1 << 3,
  G_FILE_TEST_EXISTS = 1 << 4
} GFileTest;
GQuark g_file_error_quark (void);
GFileError g_file_error_from_errno (gint err_no);
gboolean g_file_test (const gchar *filename,
                              GFileTest test);
gboolean g_file_get_contents (const gchar *filename,
                              gchar **contents,
                              gsize *length,
                              GError **error);
gboolean g_file_set_contents (const gchar *filename,
         const gchar *contents,
         gssize length,
         GError **error);
gchar *g_file_read_link (const gchar *filename,
         GError **error);
gint g_mkstemp (gchar *tmpl);
gint g_file_open_tmp (const gchar *tmpl,
         gchar **name_used,
         GError **error);
gchar *g_build_path (const gchar *separator,
    const gchar *first_element,
    ...) __attribute__((__malloc__)) __attribute__((__sentinel__));
gchar *g_build_pathv (const gchar *separator,
    gchar **args) __attribute__((__malloc__));
gchar *g_build_filename (const gchar *first_element,
    ...) __attribute__((__malloc__)) __attribute__((__sentinel__));
gchar *g_build_filenamev (gchar **args) __attribute__((__malloc__));
int g_mkdir_with_parents (const gchar *pathname,
        int mode);
}
extern "C" {
typedef struct _GHashTable GHashTable;
typedef gboolean (*GHRFunc) (gpointer key,
                               gpointer value,
                               gpointer user_data);
GHashTable* g_hash_table_new (GHashFunc hash_func,
         GEqualFunc key_equal_func);
GHashTable* g_hash_table_new_full (GHashFunc hash_func,
         GEqualFunc key_equal_func,
         GDestroyNotify key_destroy_func,
         GDestroyNotify value_destroy_func);
void g_hash_table_destroy (GHashTable *hash_table);
void g_hash_table_insert (GHashTable *hash_table,
         gpointer key,
         gpointer value);
void g_hash_table_replace (GHashTable *hash_table,
         gpointer key,
         gpointer value);
gboolean g_hash_table_remove (GHashTable *hash_table,
         gconstpointer key);
void g_hash_table_remove_all (GHashTable *hash_table);
gboolean g_hash_table_steal (GHashTable *hash_table,
         gconstpointer key);
void g_hash_table_steal_all (GHashTable *hash_table);
gpointer g_hash_table_lookup (GHashTable *hash_table,
         gconstpointer key);
gboolean g_hash_table_lookup_extended (GHashTable *hash_table,
         gconstpointer lookup_key,
         gpointer *orig_key,
         gpointer *value);
void g_hash_table_foreach (GHashTable *hash_table,
         GHFunc func,
         gpointer user_data);
gpointer g_hash_table_find (GHashTable *hash_table,
         GHRFunc predicate,
         gpointer user_data);
guint g_hash_table_foreach_remove (GHashTable *hash_table,
         GHRFunc func,
         gpointer user_data);
guint g_hash_table_foreach_steal (GHashTable *hash_table,
         GHRFunc func,
         gpointer user_data);
guint g_hash_table_size (GHashTable *hash_table);
GList * g_hash_table_get_keys (GHashTable *hash_table);
GList * g_hash_table_get_values (GHashTable *hash_table);
GHashTable* g_hash_table_ref (GHashTable *hash_table);
void g_hash_table_unref (GHashTable *hash_table);
gboolean g_str_equal (gconstpointer v1,
                      gconstpointer v2);
guint g_str_hash (gconstpointer v);
gboolean g_int_equal (gconstpointer v1,
                      gconstpointer v2);
guint g_int_hash (gconstpointer v);
guint g_direct_hash (gconstpointer v) __attribute__((__const__));
gboolean g_direct_equal (gconstpointer v1,
                         gconstpointer v2) __attribute__((__const__));
}
extern "C" {
typedef struct _GHook GHook;
typedef struct _GHookList GHookList;
typedef gint (*GHookCompareFunc) (GHook *new_hook,
       GHook *sibling);
typedef gboolean (*GHookFindFunc) (GHook *hook,
       gpointer data);
typedef void (*GHookMarshaller) (GHook *hook,
       gpointer marshal_data);
typedef gboolean (*GHookCheckMarshaller) (GHook *hook,
       gpointer marshal_data);
typedef void (*GHookFunc) (gpointer data);
typedef gboolean (*GHookCheckFunc) (gpointer data);
typedef void (*GHookFinalizeFunc) (GHookList *hook_list,
       GHook *hook);
typedef enum
{
  G_HOOK_FLAG_ACTIVE = 1 << 0,
  G_HOOK_FLAG_IN_CALL = 1 << 1,
  G_HOOK_FLAG_MASK = 0x0f
} GHookFlagMask;
struct _GHookList
{
  gulong seq_id;
  guint hook_size : 16;
  guint is_setup : 1;
  GHook *hooks;
  gpointer dummy3;
  GHookFinalizeFunc finalize_hook;
  gpointer dummy[2];
};
struct _GHook
{
  gpointer data;
  GHook *next;
  GHook *prev;
  guint ref_count;
  gulong hook_id;
  guint flags;
  gpointer func;
  GDestroyNotify destroy;
};
void g_hook_list_init (GHookList *hook_list,
      guint hook_size);
void g_hook_list_clear (GHookList *hook_list);
GHook* g_hook_alloc (GHookList *hook_list);
void g_hook_free (GHookList *hook_list,
      GHook *hook);
GHook * g_hook_ref (GHookList *hook_list,
      GHook *hook);
void g_hook_unref (GHookList *hook_list,
      GHook *hook);
gboolean g_hook_destroy (GHookList *hook_list,
      gulong hook_id);
void g_hook_destroy_link (GHookList *hook_list,
      GHook *hook);
void g_hook_prepend (GHookList *hook_list,
      GHook *hook);
void g_hook_insert_before (GHookList *hook_list,
      GHook *sibling,
      GHook *hook);
void g_hook_insert_sorted (GHookList *hook_list,
      GHook *hook,
      GHookCompareFunc func);
GHook* g_hook_get (GHookList *hook_list,
      gulong hook_id);
GHook* g_hook_find (GHookList *hook_list,
      gboolean need_valids,
      GHookFindFunc func,
      gpointer data);
GHook* g_hook_find_data (GHookList *hook_list,
      gboolean need_valids,
      gpointer data);
GHook* g_hook_find_func (GHookList *hook_list,
      gboolean need_valids,
      gpointer func);
GHook* g_hook_find_func_data (GHookList *hook_list,
      gboolean need_valids,
      gpointer func,
      gpointer data);
GHook* g_hook_first_valid (GHookList *hook_list,
      gboolean may_be_in_call);
GHook* g_hook_next_valid (GHookList *hook_list,
      GHook *hook,
      gboolean may_be_in_call);
gint g_hook_compare_ids (GHook *new_hook,
      GHook *sibling);
void g_hook_list_invoke (GHookList *hook_list,
      gboolean may_recurse);
void g_hook_list_invoke_check (GHookList *hook_list,
      gboolean may_recurse);
void g_hook_list_marshal (GHookList *hook_list,
      gboolean may_recurse,
      GHookMarshaller marshaller,
      gpointer marshal_data);
void g_hook_list_marshal_check (GHookList *hook_list,
      gboolean may_recurse,
      GHookCheckMarshaller marshaller,
      gpointer marshal_data);
}
extern "C" {
typedef struct _GSList GSList;
struct _GSList
{
  gpointer data;
  GSList *next;
};
GSList* g_slist_alloc (void) __attribute__((warn_unused_result));
void g_slist_free (GSList *list);
void g_slist_free_1 (GSList *list);
GSList* g_slist_append (GSList *list,
       gpointer data) __attribute__((warn_unused_result));
GSList* g_slist_prepend (GSList *list,
       gpointer data) __attribute__((warn_unused_result));
GSList* g_slist_insert (GSList *list,
       gpointer data,
       gint position) __attribute__((warn_unused_result));
GSList* g_slist_insert_sorted (GSList *list,
       gpointer data,
       GCompareFunc func) __attribute__((warn_unused_result));
GSList* g_slist_insert_sorted_with_data (GSList *list,
       gpointer data,
       GCompareDataFunc func,
       gpointer user_data) __attribute__((warn_unused_result));
GSList* g_slist_insert_before (GSList *slist,
       GSList *sibling,
       gpointer data) __attribute__((warn_unused_result));
GSList* g_slist_concat (GSList *list1,
       GSList *list2) __attribute__((warn_unused_result));
GSList* g_slist_remove (GSList *list,
       gconstpointer data) __attribute__((warn_unused_result));
GSList* g_slist_remove_all (GSList *list,
       gconstpointer data) __attribute__((warn_unused_result));
GSList* g_slist_remove_link (GSList *list,
       GSList *link_) __attribute__((warn_unused_result));
GSList* g_slist_delete_link (GSList *list,
       GSList *link_) __attribute__((warn_unused_result));
GSList* g_slist_reverse (GSList *list) __attribute__((warn_unused_result));
GSList* g_slist_copy (GSList *list) __attribute__((warn_unused_result));
GSList* g_slist_nth (GSList *list,
       guint n);
GSList* g_slist_find (GSList *list,
       gconstpointer data);
GSList* g_slist_find_custom (GSList *list,
       gconstpointer data,
       GCompareFunc func);
gint g_slist_position (GSList *list,
       GSList *llink);
gint g_slist_index (GSList *list,
       gconstpointer data);
GSList* g_slist_last (GSList *list);
guint g_slist_length (GSList *list);
void g_slist_foreach (GSList *list,
       GFunc func,
       gpointer user_data);
GSList* g_slist_sort (GSList *list,
       GCompareFunc compare_func) __attribute__((warn_unused_result));
GSList* g_slist_sort_with_data (GSList *list,
       GCompareDataFunc compare_func,
       gpointer user_data) __attribute__((warn_unused_result));
gpointer g_slist_nth_data (GSList *list,
       guint n);
void g_slist_push_allocator (gpointer dummy);
void g_slist_pop_allocator (void);
}
extern "C" {
typedef struct _GMainContext GMainContext;
typedef struct _GMainLoop GMainLoop;
typedef struct _GSource GSource;
typedef struct _GSourceCallbackFuncs GSourceCallbackFuncs;
typedef struct _GSourceFuncs GSourceFuncs;
typedef gboolean (*GSourceFunc) (gpointer data);
typedef void (*GChildWatchFunc) (GPid pid,
           gint status,
           gpointer data);
struct _GSource
{
  gpointer callback_data;
  GSourceCallbackFuncs *callback_funcs;
  GSourceFuncs *source_funcs;
  guint ref_count;
  GMainContext *context;
  gint priority;
  guint flags;
  guint source_id;
  GSList *poll_fds;
  GSource *prev;
  GSource *next;
  gpointer reserved1;
  gpointer reserved2;
};
struct _GSourceCallbackFuncs
{
  void (*ref) (gpointer cb_data);
  void (*unref) (gpointer cb_data);
  void (*get) (gpointer cb_data,
   GSource *source,
   GSourceFunc *func,
   gpointer *data);
};
typedef void (*GSourceDummyMarshal) (void);
struct _GSourceFuncs
{
  gboolean (*prepare) (GSource *source,
   gint *timeout_);
  gboolean (*check) (GSource *source);
  gboolean (*dispatch) (GSource *source,
   GSourceFunc callback,
   gpointer user_data);
  void (*finalize) (GSource *source);
  GSourceFunc closure_callback;
  GSourceDummyMarshal closure_marshal;
};
typedef struct _GPollFD GPollFD;
typedef gint (*GPollFunc) (GPollFD *ufds,
     guint nfsd,
     gint timeout_);
struct _GPollFD
{
  gint fd;
  gushort events;
  gushort revents;
};
GMainContext *g_main_context_new (void);
GMainContext *g_main_context_ref (GMainContext *context);
void g_main_context_unref (GMainContext *context);
GMainContext *g_main_context_default (void);
gboolean g_main_context_iteration (GMainContext *context,
     gboolean may_block);
gboolean g_main_context_pending (GMainContext *context);
GSource *g_main_context_find_source_by_id (GMainContext *context,
            guint source_id);
GSource *g_main_context_find_source_by_user_data (GMainContext *context,
            gpointer user_data);
GSource *g_main_context_find_source_by_funcs_user_data (GMainContext *context,
             GSourceFuncs *funcs,
            gpointer user_data);
void g_main_context_wakeup (GMainContext *context);
gboolean g_main_context_acquire (GMainContext *context);
void g_main_context_release (GMainContext *context);
gboolean g_main_context_is_owner (GMainContext *context);
gboolean g_main_context_wait (GMainContext *context,
     GCond *cond,
     GMutex *mutex);
gboolean g_main_context_prepare (GMainContext *context,
      gint *priority);
gint g_main_context_query (GMainContext *context,
      gint max_priority,
      gint *timeout_,
      GPollFD *fds,
      gint n_fds);
gint g_main_context_check (GMainContext *context,
      gint max_priority,
      GPollFD *fds,
      gint n_fds);
void g_main_context_dispatch (GMainContext *context);
void g_main_context_set_poll_func (GMainContext *context,
           GPollFunc func);
GPollFunc g_main_context_get_poll_func (GMainContext *context);
void g_main_context_add_poll (GMainContext *context,
         GPollFD *fd,
         gint priority);
void g_main_context_remove_poll (GMainContext *context,
         GPollFD *fd);
gint g_main_depth (void);
GSource *g_main_current_source (void);
GMainLoop *g_main_loop_new (GMainContext *context,
           gboolean is_running);
void g_main_loop_run (GMainLoop *loop);
void g_main_loop_quit (GMainLoop *loop);
GMainLoop *g_main_loop_ref (GMainLoop *loop);
void g_main_loop_unref (GMainLoop *loop);
gboolean g_main_loop_is_running (GMainLoop *loop);
GMainContext *g_main_loop_get_context (GMainLoop *loop);
GSource *g_source_new (GSourceFuncs *source_funcs,
       guint struct_size);
GSource *g_source_ref (GSource *source);
void g_source_unref (GSource *source);
guint g_source_attach (GSource *source,
       GMainContext *context);
void g_source_destroy (GSource *source);
void g_source_set_priority (GSource *source,
       gint priority);
gint g_source_get_priority (GSource *source);
void g_source_set_can_recurse (GSource *source,
       gboolean can_recurse);
gboolean g_source_get_can_recurse (GSource *source);
guint g_source_get_id (GSource *source);
GMainContext *g_source_get_context (GSource *source);
void g_source_set_callback (GSource *source,
       GSourceFunc func,
       gpointer data,
       GDestroyNotify notify);
void g_source_set_funcs (GSource *source,
                                   GSourceFuncs *funcs);
gboolean g_source_is_destroyed (GSource *source);
void g_source_set_callback_indirect (GSource *source,
         gpointer callback_data,
         GSourceCallbackFuncs *callback_funcs);
void g_source_add_poll (GSource *source,
        GPollFD *fd);
void g_source_remove_poll (GSource *source,
        GPollFD *fd);
void g_source_get_current_time (GSource *source,
        GTimeVal *timeval);
GSource *g_idle_source_new (void);
GSource *g_child_watch_source_new (GPid pid);
GSource *g_timeout_source_new (guint interval);
GSource *g_timeout_source_new_seconds (guint interval);
void g_get_current_time (GTimeVal *result);
gboolean g_source_remove (guint tag);
gboolean g_source_remove_by_user_data (gpointer user_data);
gboolean g_source_remove_by_funcs_user_data (GSourceFuncs *funcs,
           gpointer user_data);
guint g_timeout_add_full (gint priority,
         guint interval,
         GSourceFunc function,
         gpointer data,
         GDestroyNotify notify);
guint g_timeout_add (guint interval,
         GSourceFunc function,
         gpointer data);
guint g_timeout_add_seconds_full (gint priority,
                                     guint interval,
                                     GSourceFunc function,
                                     gpointer data,
                                     GDestroyNotify notify);
guint g_timeout_add_seconds (guint interval,
         GSourceFunc function,
         gpointer data);
guint g_child_watch_add_full (gint priority,
         GPid pid,
         GChildWatchFunc function,
         gpointer data,
         GDestroyNotify notify);
guint g_child_watch_add (GPid pid,
         GChildWatchFunc function,
         gpointer data);
guint g_idle_add (GSourceFunc function,
         gpointer data);
guint g_idle_add_full (gint priority,
         GSourceFunc function,
         gpointer data,
         GDestroyNotify notify);
gboolean g_idle_remove_by_data (gpointer data);
extern GSourceFuncs g_timeout_funcs;
extern GSourceFuncs g_child_watch_funcs;
extern GSourceFuncs g_idle_funcs;
}
extern "C" {
typedef guint32 gunichar;
typedef guint16 gunichar2;
typedef enum
{
  G_UNICODE_CONTROL,
  G_UNICODE_FORMAT,
  G_UNICODE_UNASSIGNED,
  G_UNICODE_PRIVATE_USE,
  G_UNICODE_SURROGATE,
  G_UNICODE_LOWERCASE_LETTER,
  G_UNICODE_MODIFIER_LETTER,
  G_UNICODE_OTHER_LETTER,
  G_UNICODE_TITLECASE_LETTER,
  G_UNICODE_UPPERCASE_LETTER,
  G_UNICODE_COMBINING_MARK,
  G_UNICODE_ENCLOSING_MARK,
  G_UNICODE_NON_SPACING_MARK,
  G_UNICODE_DECIMAL_NUMBER,
  G_UNICODE_LETTER_NUMBER,
  G_UNICODE_OTHER_NUMBER,
  G_UNICODE_CONNECT_PUNCTUATION,
  G_UNICODE_DASH_PUNCTUATION,
  G_UNICODE_CLOSE_PUNCTUATION,
  G_UNICODE_FINAL_PUNCTUATION,
  G_UNICODE_INITIAL_PUNCTUATION,
  G_UNICODE_OTHER_PUNCTUATION,
  G_UNICODE_OPEN_PUNCTUATION,
  G_UNICODE_CURRENCY_SYMBOL,
  G_UNICODE_MODIFIER_SYMBOL,
  G_UNICODE_MATH_SYMBOL,
  G_UNICODE_OTHER_SYMBOL,
  G_UNICODE_LINE_SEPARATOR,
  G_UNICODE_PARAGRAPH_SEPARATOR,
  G_UNICODE_SPACE_SEPARATOR
} GUnicodeType;
typedef enum
{
  G_UNICODE_BREAK_MANDATORY,
  G_UNICODE_BREAK_CARRIAGE_RETURN,
  G_UNICODE_BREAK_LINE_FEED,
  G_UNICODE_BREAK_COMBINING_MARK,
  G_UNICODE_BREAK_SURROGATE,
  G_UNICODE_BREAK_ZERO_WIDTH_SPACE,
  G_UNICODE_BREAK_INSEPARABLE,
  G_UNICODE_BREAK_NON_BREAKING_GLUE,
  G_UNICODE_BREAK_CONTINGENT,
  G_UNICODE_BREAK_SPACE,
  G_UNICODE_BREAK_AFTER,
  G_UNICODE_BREAK_BEFORE,
  G_UNICODE_BREAK_BEFORE_AND_AFTER,
  G_UNICODE_BREAK_HYPHEN,
  G_UNICODE_BREAK_NON_STARTER,
  G_UNICODE_BREAK_OPEN_PUNCTUATION,
  G_UNICODE_BREAK_CLOSE_PUNCTUATION,
  G_UNICODE_BREAK_QUOTATION,
  G_UNICODE_BREAK_EXCLAMATION,
  G_UNICODE_BREAK_IDEOGRAPHIC,
  G_UNICODE_BREAK_NUMERIC,
  G_UNICODE_BREAK_INFIX_SEPARATOR,
  G_UNICODE_BREAK_SYMBOL,
  G_UNICODE_BREAK_ALPHABETIC,
  G_UNICODE_BREAK_PREFIX,
  G_UNICODE_BREAK_POSTFIX,
  G_UNICODE_BREAK_COMPLEX_CONTEXT,
  G_UNICODE_BREAK_AMBIGUOUS,
  G_UNICODE_BREAK_UNKNOWN,
  G_UNICODE_BREAK_NEXT_LINE,
  G_UNICODE_BREAK_WORD_JOINER,
  G_UNICODE_BREAK_HANGUL_L_JAMO,
  G_UNICODE_BREAK_HANGUL_V_JAMO,
  G_UNICODE_BREAK_HANGUL_T_JAMO,
  G_UNICODE_BREAK_HANGUL_LV_SYLLABLE,
  G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE
} GUnicodeBreakType;
typedef enum
{
  G_UNICODE_SCRIPT_INVALID_CODE = -1,
  G_UNICODE_SCRIPT_COMMON = 0,
  G_UNICODE_SCRIPT_INHERITED,
  G_UNICODE_SCRIPT_ARABIC,
  G_UNICODE_SCRIPT_ARMENIAN,
  G_UNICODE_SCRIPT_BENGALI,
  G_UNICODE_SCRIPT_BOPOMOFO,
  G_UNICODE_SCRIPT_CHEROKEE,
  G_UNICODE_SCRIPT_COPTIC,
  G_UNICODE_SCRIPT_CYRILLIC,
  G_UNICODE_SCRIPT_DESERET,
  G_UNICODE_SCRIPT_DEVANAGARI,
  G_UNICODE_SCRIPT_ETHIOPIC,
  G_UNICODE_SCRIPT_GEORGIAN,
  G_UNICODE_SCRIPT_GOTHIC,
  G_UNICODE_SCRIPT_GREEK,
  G_UNICODE_SCRIPT_GUJARATI,
  G_UNICODE_SCRIPT_GURMUKHI,
  G_UNICODE_SCRIPT_HAN,
  G_UNICODE_SCRIPT_HANGUL,
  G_UNICODE_SCRIPT_HEBREW,
  G_UNICODE_SCRIPT_HIRAGANA,
  G_UNICODE_SCRIPT_KANNADA,
  G_UNICODE_SCRIPT_KATAKANA,
  G_UNICODE_SCRIPT_KHMER,
  G_UNICODE_SCRIPT_LAO,
  G_UNICODE_SCRIPT_LATIN,
  G_UNICODE_SCRIPT_MALAYALAM,
  G_UNICODE_SCRIPT_MONGOLIAN,
  G_UNICODE_SCRIPT_MYANMAR,
  G_UNICODE_SCRIPT_OGHAM,
  G_UNICODE_SCRIPT_OLD_ITALIC,
  G_UNICODE_SCRIPT_ORIYA,
  G_UNICODE_SCRIPT_RUNIC,
  G_UNICODE_SCRIPT_SINHALA,
  G_UNICODE_SCRIPT_SYRIAC,
  G_UNICODE_SCRIPT_TAMIL,
  G_UNICODE_SCRIPT_TELUGU,
  G_UNICODE_SCRIPT_THAANA,
  G_UNICODE_SCRIPT_THAI,
  G_UNICODE_SCRIPT_TIBETAN,
  G_UNICODE_SCRIPT_CANADIAN_ABORIGINAL,
  G_UNICODE_SCRIPT_YI,
  G_UNICODE_SCRIPT_TAGALOG,
  G_UNICODE_SCRIPT_HANUNOO,
  G_UNICODE_SCRIPT_BUHID,
  G_UNICODE_SCRIPT_TAGBANWA,
  G_UNICODE_SCRIPT_BRAILLE,
  G_UNICODE_SCRIPT_CYPRIOT,
  G_UNICODE_SCRIPT_LIMBU,
  G_UNICODE_SCRIPT_OSMANYA,
  G_UNICODE_SCRIPT_SHAVIAN,
  G_UNICODE_SCRIPT_LINEAR_B,
  G_UNICODE_SCRIPT_TAI_LE,
  G_UNICODE_SCRIPT_UGARITIC,
  G_UNICODE_SCRIPT_NEW_TAI_LUE,
  G_UNICODE_SCRIPT_BUGINESE,
  G_UNICODE_SCRIPT_GLAGOLITIC,
  G_UNICODE_SCRIPT_TIFINAGH,
  G_UNICODE_SCRIPT_SYLOTI_NAGRI,
  G_UNICODE_SCRIPT_OLD_PERSIAN,
  G_UNICODE_SCRIPT_KHAROSHTHI,
  G_UNICODE_SCRIPT_UNKNOWN,
  G_UNICODE_SCRIPT_BALINESE,
  G_UNICODE_SCRIPT_CUNEIFORM,
  G_UNICODE_SCRIPT_PHOENICIAN,
  G_UNICODE_SCRIPT_PHAGS_PA,
  G_UNICODE_SCRIPT_NKO
} GUnicodeScript;
gboolean g_get_charset (const char **charset);
gboolean g_unichar_isalnum (gunichar c) __attribute__((__const__));
gboolean g_unichar_isalpha (gunichar c) __attribute__((__const__));
gboolean g_unichar_iscntrl (gunichar c) __attribute__((__const__));
gboolean g_unichar_isdigit (gunichar c) __attribute__((__const__));
gboolean g_unichar_isgraph (gunichar c) __attribute__((__const__));
gboolean g_unichar_islower (gunichar c) __attribute__((__const__));
gboolean g_unichar_isprint (gunichar c) __attribute__((__const__));
gboolean g_unichar_ispunct (gunichar c) __attribute__((__const__));
gboolean g_unichar_isspace (gunichar c) __attribute__((__const__));
gboolean g_unichar_isupper (gunichar c) __attribute__((__const__));
gboolean g_unichar_isxdigit (gunichar c) __attribute__((__const__));
gboolean g_unichar_istitle (gunichar c) __attribute__((__const__));
gboolean g_unichar_isdefined (gunichar c) __attribute__((__const__));
gboolean g_unichar_iswide (gunichar c) __attribute__((__const__));
gboolean g_unichar_iswide_cjk(gunichar c) __attribute__((__const__));
gboolean g_unichar_iszerowidth(gunichar c) __attribute__((__const__));
gboolean g_unichar_ismark (gunichar c) __attribute__((__const__));
gunichar g_unichar_toupper (gunichar c) __attribute__((__const__));
gunichar g_unichar_tolower (gunichar c) __attribute__((__const__));
gunichar g_unichar_totitle (gunichar c) __attribute__((__const__));
gint g_unichar_digit_value (gunichar c) __attribute__((__const__));
gint g_unichar_xdigit_value (gunichar c) __attribute__((__const__));
GUnicodeType g_unichar_type (gunichar c) __attribute__((__const__));
GUnicodeBreakType g_unichar_break_type (gunichar c) __attribute__((__const__));
gint g_unichar_combining_class (gunichar uc) __attribute__((__const__));
void g_unicode_canonical_ordering (gunichar *string,
       gsize len);
gunichar *g_unicode_canonical_decomposition (gunichar ch,
          gsize *result_len) __attribute__((__malloc__));
extern const gchar * const g_utf8_skip;
gunichar g_utf8_get_char (const gchar *p) __attribute__((__pure__));
gunichar g_utf8_get_char_validated (const gchar *p,
        gssize max_len) __attribute__((__pure__));
gchar* g_utf8_offset_to_pointer (const gchar *str,
                                   glong offset) __attribute__((__pure__));
glong g_utf8_pointer_to_offset (const gchar *str,
       const gchar *pos) __attribute__((__pure__));
gchar* g_utf8_prev_char (const gchar *p) __attribute__((__pure__));
gchar* g_utf8_find_next_char (const gchar *p,
       const gchar *end) __attribute__((__pure__));
gchar* g_utf8_find_prev_char (const gchar *str,
       const gchar *p) __attribute__((__pure__));
glong g_utf8_strlen (const gchar *p,
       gssize max) __attribute__((__pure__));
gchar* g_utf8_strncpy (gchar *dest,
         const gchar *src,
         gsize n);
gchar* g_utf8_strchr (const gchar *p,
         gssize len,
         gunichar c);
gchar* g_utf8_strrchr (const gchar *p,
         gssize len,
         gunichar c);
gchar* g_utf8_strreverse (const gchar *str,
     gssize len);
gunichar2 *g_utf8_to_utf16 (const gchar *str,
    glong len,
    glong *items_read,
    glong *items_written,
    GError **error) __attribute__((__malloc__));
gunichar * g_utf8_to_ucs4 (const gchar *str,
    glong len,
    glong *items_read,
    glong *items_written,
    GError **error) __attribute__((__malloc__));
gunichar * g_utf8_to_ucs4_fast (const gchar *str,
    glong len,
    glong *items_written) __attribute__((__malloc__));
gunichar * g_utf16_to_ucs4 (const gunichar2 *str,
    glong len,
    glong *items_read,
    glong *items_written,
    GError **error) __attribute__((__malloc__));
gchar* g_utf16_to_utf8 (const gunichar2 *str,
    glong len,
    glong *items_read,
    glong *items_written,
    GError **error) __attribute__((__malloc__));
gunichar2 *g_ucs4_to_utf16 (const gunichar *str,
    glong len,
    glong *items_read,
    glong *items_written,
    GError **error) __attribute__((__malloc__));
gchar* g_ucs4_to_utf8 (const gunichar *str,
    glong len,
    glong *items_read,
    glong *items_written,
    GError **error) __attribute__((__malloc__));
gint g_unichar_to_utf8 (gunichar c,
        gchar *outbuf);
gboolean g_utf8_validate (const gchar *str,
                          gssize max_len,
                          const gchar **end);
gboolean g_unichar_validate (gunichar ch) __attribute__((__const__));
gchar *g_utf8_strup (const gchar *str,
         gssize len) __attribute__((__malloc__));
gchar *g_utf8_strdown (const gchar *str,
         gssize len) __attribute__((__malloc__));
gchar *g_utf8_casefold (const gchar *str,
   gssize len) __attribute__((__malloc__));
typedef enum {
  G_NORMALIZE_DEFAULT,
  G_NORMALIZE_NFD = G_NORMALIZE_DEFAULT,
  G_NORMALIZE_DEFAULT_COMPOSE,
  G_NORMALIZE_NFC = G_NORMALIZE_DEFAULT_COMPOSE,
  G_NORMALIZE_ALL,
  G_NORMALIZE_NFKD = G_NORMALIZE_ALL,
  G_NORMALIZE_ALL_COMPOSE,
  G_NORMALIZE_NFKC = G_NORMALIZE_ALL_COMPOSE
} GNormalizeMode;
gchar *g_utf8_normalize (const gchar *str,
    gssize len,
    GNormalizeMode mode) __attribute__((__malloc__));
gint g_utf8_collate (const gchar *str1,
      const gchar *str2) __attribute__((__pure__));
gchar *g_utf8_collate_key (const gchar *str,
      gssize len) __attribute__((__malloc__));
gchar *g_utf8_collate_key_for_filename (const gchar *str,
                   gssize len) __attribute__((__malloc__));
gboolean g_unichar_get_mirror_char (gunichar ch,
                                    gunichar *mirrored_ch);
GUnicodeScript g_unichar_get_script (gunichar ch) __attribute__((__const__));
gchar *_g_utf8_make_valid (const gchar *name);
}
extern "C" {
typedef struct _GString GString;
typedef struct _GStringChunk GStringChunk;
struct _GString
{
  gchar *str;
  gsize len;
  gsize allocated_len;
};
GStringChunk* g_string_chunk_new (gsize size);
void g_string_chunk_free (GStringChunk *chunk);
void g_string_chunk_clear (GStringChunk *chunk);
gchar* g_string_chunk_insert (GStringChunk *chunk,
         const gchar *string);
gchar* g_string_chunk_insert_len (GStringChunk *chunk,
         const gchar *string,
         gssize len);
gchar* g_string_chunk_insert_const (GStringChunk *chunk,
         const gchar *string);
GString* g_string_new (const gchar *init);
GString* g_string_new_len (const gchar *init,
                                         gssize len);
GString* g_string_sized_new (gsize dfl_size);
gchar* g_string_free (GString *string,
      gboolean free_segment);
gboolean g_string_equal (const GString *v,
      const GString *v2);
guint g_string_hash (const GString *str);
GString* g_string_assign (GString *string,
      const gchar *rval);
GString* g_string_truncate (GString *string,
      gsize len);
GString* g_string_set_size (GString *string,
      gsize len);
GString* g_string_insert_len (GString *string,
                                         gssize pos,
                                         const gchar *val,
                                         gssize len);
GString* g_string_append (GString *string,
                    const gchar *val);
GString* g_string_append_len (GString *string,
                    const gchar *val,
                                         gssize len);
GString* g_string_append_c (GString *string,
      gchar c);
GString* g_string_append_unichar (GString *string,
      gunichar wc);
GString* g_string_prepend (GString *string,
      const gchar *val);
GString* g_string_prepend_c (GString *string,
      gchar c);
GString* g_string_prepend_unichar (GString *string,
      gunichar wc);
GString* g_string_prepend_len (GString *string,
                    const gchar *val,
                                         gssize len);
GString* g_string_insert (GString *string,
      gssize pos,
      const gchar *val);
GString* g_string_insert_c (GString *string,
      gssize pos,
      gchar c);
GString* g_string_insert_unichar (GString *string,
      gssize pos,
      gunichar wc);
GString* g_string_overwrite (GString *string,
      gsize pos,
      const gchar *val);
GString* g_string_overwrite_len (GString *string,
      gsize pos,
      const gchar *val,
      gssize len);
GString* g_string_erase (GString *string,
      gssize pos,
      gssize len);
GString* g_string_ascii_down (GString *string);
GString* g_string_ascii_up (GString *string);
void g_string_vprintf (GString *string,
      const gchar *format,
      va_list args);
void g_string_printf (GString *string,
      const gchar *format,
      ...) __attribute__((__format__ (__printf__, 2, 3)));
void g_string_append_vprintf (GString *string,
      const gchar *format,
      va_list args);
void g_string_append_printf (GString *string,
      const gchar *format,
      ...) __attribute__((__format__ (__printf__, 2, 3)));
static inline GString*
g_string_append_c_inline (GString *gstring,
                          gchar c)
{
  if (gstring->len + 1 < gstring->allocated_len)
    {
      gstring->str[gstring->len++] = c;
      gstring->str[gstring->len] = 0;
    }
  else
    g_string_insert_c (gstring, -1, c);
  return gstring;
}
GString* g_string_down (GString *string);
GString* g_string_up (GString *string);
}
extern "C" {
typedef struct _GIOChannel GIOChannel;
typedef struct _GIOFuncs GIOFuncs;
typedef enum
{
  G_IO_ERROR_NONE,
  G_IO_ERROR_AGAIN,
  G_IO_ERROR_INVAL,
  G_IO_ERROR_UNKNOWN
} GIOError;
typedef enum
{
  G_IO_CHANNEL_ERROR_FBIG,
  G_IO_CHANNEL_ERROR_INVAL,
  G_IO_CHANNEL_ERROR_IO,
  G_IO_CHANNEL_ERROR_ISDIR,
  G_IO_CHANNEL_ERROR_NOSPC,
  G_IO_CHANNEL_ERROR_NXIO,
  G_IO_CHANNEL_ERROR_OVERFLOW,
  G_IO_CHANNEL_ERROR_PIPE,
  G_IO_CHANNEL_ERROR_FAILED
} GIOChannelError;
typedef enum
{
  G_IO_STATUS_ERROR,
  G_IO_STATUS_NORMAL,
  G_IO_STATUS_EOF,
  G_IO_STATUS_AGAIN
} GIOStatus;
typedef enum
{
  G_SEEK_CUR,
  G_SEEK_SET,
  G_SEEK_END
} GSeekType;
typedef enum
{
  G_IO_IN =1,
  G_IO_OUT =4,
  G_IO_PRI =2,
  G_IO_ERR =8,
  G_IO_HUP =16,
  G_IO_NVAL =32
} GIOCondition;
typedef enum
{
  G_IO_FLAG_APPEND = 1 << 0,
  G_IO_FLAG_NONBLOCK = 1 << 1,
  G_IO_FLAG_IS_READABLE = 1 << 2,
  G_IO_FLAG_IS_WRITEABLE = 1 << 3,
  G_IO_FLAG_IS_SEEKABLE = 1 << 4,
  G_IO_FLAG_MASK = (1 << 5) - 1,
  G_IO_FLAG_GET_MASK = G_IO_FLAG_MASK,
  G_IO_FLAG_SET_MASK = G_IO_FLAG_APPEND | G_IO_FLAG_NONBLOCK
} GIOFlags;
struct _GIOChannel
{
  gint ref_count;
  GIOFuncs *funcs;
  gchar *encoding;
  GIConv read_cd;
  GIConv write_cd;
  gchar *line_term;
  guint line_term_len;
  gsize buf_size;
  GString *read_buf;
  GString *encoded_read_buf;
  GString *write_buf;
  gchar partial_write_buf[6];
  guint use_buffer : 1;
  guint do_encode : 1;
  guint close_on_unref : 1;
  guint is_readable : 1;
  guint is_writeable : 1;
  guint is_seekable : 1;
  gpointer reserved1;
  gpointer reserved2;
};
typedef gboolean (*GIOFunc) (GIOChannel *source,
        GIOCondition condition,
        gpointer data);
struct _GIOFuncs
{
  GIOStatus (*io_read) (GIOChannel *channel,
             gchar *buf,
      gsize count,
      gsize *bytes_read,
      GError **err);
  GIOStatus (*io_write) (GIOChannel *channel,
      const gchar *buf,
      gsize count,
      gsize *bytes_written,
      GError **err);
  GIOStatus (*io_seek) (GIOChannel *channel,
      gint64 offset,
      GSeekType type,
      GError **err);
  GIOStatus (*io_close) (GIOChannel *channel,
      GError **err);
  GSource* (*io_create_watch) (GIOChannel *channel,
      GIOCondition condition);
  void (*io_free) (GIOChannel *channel);
  GIOStatus (*io_set_flags) (GIOChannel *channel,
                                  GIOFlags flags,
      GError **err);
  GIOFlags (*io_get_flags) (GIOChannel *channel);
};
void g_io_channel_init (GIOChannel *channel);
GIOChannel *g_io_channel_ref (GIOChannel *channel);
void g_io_channel_unref (GIOChannel *channel);
GIOError g_io_channel_read (GIOChannel *channel,
            gchar *buf,
            gsize count,
            gsize *bytes_read);
GIOError g_io_channel_write (GIOChannel *channel,
            const gchar *buf,
            gsize count,
            gsize *bytes_written);
GIOError g_io_channel_seek (GIOChannel *channel,
            gint64 offset,
            GSeekType type);
void g_io_channel_close (GIOChannel *channel);
GIOStatus g_io_channel_shutdown (GIOChannel *channel,
     gboolean flush,
     GError **err);
guint g_io_add_watch_full (GIOChannel *channel,
     gint priority,
     GIOCondition condition,
     GIOFunc func,
     gpointer user_data,
     GDestroyNotify notify);
GSource * g_io_create_watch (GIOChannel *channel,
     GIOCondition condition);
guint g_io_add_watch (GIOChannel *channel,
     GIOCondition condition,
     GIOFunc func,
     gpointer user_data);
void g_io_channel_set_buffer_size (GIOChannel *channel,
        gsize size);
gsize g_io_channel_get_buffer_size (GIOChannel *channel);
GIOCondition g_io_channel_get_buffer_condition (GIOChannel *channel);
GIOStatus g_io_channel_set_flags (GIOChannel *channel,
        GIOFlags flags,
        GError **error);
GIOFlags g_io_channel_get_flags (GIOChannel *channel);
void g_io_channel_set_line_term (GIOChannel *channel,
        const gchar *line_term,
        gint length);
const gchar* g_io_channel_get_line_term (GIOChannel *channel,
        gint *length);
void g_io_channel_set_buffered (GIOChannel *channel,
        gboolean buffered);
gboolean g_io_channel_get_buffered (GIOChannel *channel);
GIOStatus g_io_channel_set_encoding (GIOChannel *channel,
        const gchar *encoding,
        GError **error);
const gchar* g_io_channel_get_encoding (GIOChannel *channel);
void g_io_channel_set_close_on_unref (GIOChannel *channel,
        gboolean do_close);
gboolean g_io_channel_get_close_on_unref (GIOChannel *channel);
GIOStatus g_io_channel_flush (GIOChannel *channel,
        GError **error);
GIOStatus g_io_channel_read_line (GIOChannel *channel,
        gchar **str_return,
        gsize *length,
        gsize *terminator_pos,
        GError **error);
GIOStatus g_io_channel_read_line_string (GIOChannel *channel,
        GString *buffer,
        gsize *terminator_pos,
        GError **error);
GIOStatus g_io_channel_read_to_end (GIOChannel *channel,
        gchar **str_return,
        gsize *length,
        GError **error);
GIOStatus g_io_channel_read_chars (GIOChannel *channel,
        gchar *buf,
        gsize count,
        gsize *bytes_read,
        GError **error);
GIOStatus g_io_channel_read_unichar (GIOChannel *channel,
        gunichar *thechar,
        GError **error);
GIOStatus g_io_channel_write_chars (GIOChannel *channel,
        const gchar *buf,
        gssize count,
        gsize *bytes_written,
        GError **error);
GIOStatus g_io_channel_write_unichar (GIOChannel *channel,
        gunichar thechar,
        GError **error);
GIOStatus g_io_channel_seek_position (GIOChannel *channel,
        gint64 offset,
        GSeekType type,
        GError **error);
GIOChannel* g_io_channel_new_file (const gchar *filename,
        const gchar *mode,
        GError **error);
GQuark g_io_channel_error_quark (void);
GIOChannelError g_io_channel_error_from_errno (gint en);
GIOChannel* g_io_channel_unix_new (int fd);
gint g_io_channel_unix_get_fd (GIOChannel *channel);
extern GSourceFuncs g_io_watch_funcs;
}
extern "C" {
typedef enum
{
  G_KEY_FILE_ERROR_UNKNOWN_ENCODING,
  G_KEY_FILE_ERROR_PARSE,
  G_KEY_FILE_ERROR_NOT_FOUND,
  G_KEY_FILE_ERROR_KEY_NOT_FOUND,
  G_KEY_FILE_ERROR_GROUP_NOT_FOUND,
  G_KEY_FILE_ERROR_INVALID_VALUE
} GKeyFileError;
GQuark g_key_file_error_quark (void);
typedef struct _GKeyFile GKeyFile;
typedef enum
{
  G_KEY_FILE_NONE = 0,
  G_KEY_FILE_KEEP_COMMENTS = 1 << 0,
  G_KEY_FILE_KEEP_TRANSLATIONS = 1 << 1
} GKeyFileFlags;
GKeyFile *g_key_file_new (void);
void g_key_file_free (GKeyFile *key_file);
void g_key_file_set_list_separator (GKeyFile *key_file,
          gchar separator);
gboolean g_key_file_load_from_file (GKeyFile *key_file,
          const gchar *file,
          GKeyFileFlags flags,
          GError **error);
gboolean g_key_file_load_from_data (GKeyFile *key_file,
          const gchar *data,
          gsize length,
          GKeyFileFlags flags,
          GError **error);
gboolean g_key_file_load_from_dirs (GKeyFile *key_file,
          const gchar *file,
          const gchar **search_dirs,
          gchar **full_path,
          GKeyFileFlags flags,
          GError **error);
gboolean g_key_file_load_from_data_dirs (GKeyFile *key_file,
          const gchar *file,
          gchar **full_path,
          GKeyFileFlags flags,
          GError **error);
gchar *g_key_file_to_data (GKeyFile *key_file,
          gsize *length,
          GError **error) __attribute__((__malloc__));
gchar *g_key_file_get_start_group (GKeyFile *key_file) __attribute__((__malloc__));
gchar **g_key_file_get_groups (GKeyFile *key_file,
          gsize *length) __attribute__((__malloc__));
gchar **g_key_file_get_keys (GKeyFile *key_file,
          const gchar *group_name,
          gsize *length,
          GError **error) __attribute__((__malloc__));
gboolean g_key_file_has_group (GKeyFile *key_file,
          const gchar *group_name);
gboolean g_key_file_has_key (GKeyFile *key_file,
          const gchar *group_name,
          const gchar *key,
          GError **error);
gchar *g_key_file_get_value (GKeyFile *key_file,
          const gchar *group_name,
          const gchar *key,
          GError **error) __attribute__((__malloc__));
void g_key_file_set_value (GKeyFile *key_file,
          const gchar *group_name,
          const gchar *key,
          const gchar *value);
gchar *g_key_file_get_string (GKeyFile *key_file,
          const gchar *group_name,
          const gchar *key,
          GError **error) __attribute__((__malloc__));
void g_key_file_set_string (GKeyFile *key_file,
          const gchar *group_name,
          const gchar *key,
          const gchar *string);
gchar *g_key_file_get_locale_string (GKeyFile *key_file,
          const gchar *group_name,
          const gchar *key,
          const gchar *locale,
          GError **error) __attribute__((__malloc__));
void g_key_file_set_locale_string (GKeyFile *key_file,
          const gchar *group_name,
          const gchar *key,
          const gchar *locale,
          const gchar *string);
gboolean g_key_file_get_boolean (GKeyFile *key_file,
          const gchar *group_name,
          const gchar *key,
          GError **error);
void g_key_file_set_boolean (GKeyFile *key_file,
          const gchar *group_name,
          const gchar *key,
          gboolean value);
gint g_key_file_get_integer (GKeyFile *key_file,
          const gchar *group_name,
          const gchar *key,
          GError **error);
void g_key_file_set_integer (GKeyFile *key_file,
          const gchar *group_name,
          const gchar *key,
          gint value);
gdouble g_key_file_get_double (GKeyFile *key_file,
                                             const gchar *group_name,
                                             const gchar *key,
                                             GError **error);
void g_key_file_set_double (GKeyFile *key_file,
                                             const gchar *group_name,
                                             const gchar *key,
                                             gdouble value);
gchar **g_key_file_get_string_list (GKeyFile *key_file,
          const gchar *group_name,
          const gchar *key,
          gsize *length,
          GError **error) __attribute__((__malloc__));
void g_key_file_set_string_list (GKeyFile *key_file,
          const gchar *group_name,
          const gchar *key,
          const gchar * const list[],
          gsize length);
gchar **g_key_file_get_locale_string_list (GKeyFile *key_file,
          const gchar *group_name,
          const gchar *key,
          const gchar *locale,
          gsize *length,
          GError **error) __attribute__((__malloc__));
void g_key_file_set_locale_string_list (GKeyFile *key_file,
          const gchar *group_name,
          const gchar *key,
          const gchar *locale,
          const gchar * const list[],
          gsize length);
gboolean *g_key_file_get_boolean_list (GKeyFile *key_file,
          const gchar *group_name,
          const gchar *key,
          gsize *length,
          GError **error) __attribute__((__malloc__));
void g_key_file_set_boolean_list (GKeyFile *key_file,
          const gchar *group_name,
          const gchar *key,
          gboolean list[],
          gsize length);
gint *g_key_file_get_integer_list (GKeyFile *key_file,
          const gchar *group_name,
          const gchar *key,
          gsize *length,
          GError **error) __attribute__((__malloc__));
void g_key_file_set_double_list (GKeyFile *key_file,
                                             const gchar *group_name,
                                             const gchar *key,
                                             gdouble list[],
                                             gsize length);
gdouble *g_key_file_get_double_list (GKeyFile *key_file,
                                             const gchar *group_name,
                                             const gchar *key,
                                             gsize *length,
                                             GError **error) __attribute__((__malloc__));
void g_key_file_set_integer_list (GKeyFile *key_file,
          const gchar *group_name,
          const gchar *key,
          gint list[],
          gsize length);
void g_key_file_set_comment (GKeyFile *key_file,
                                             const gchar *group_name,
                                             const gchar *key,
                                             const gchar *comment,
                                             GError **error);
gchar *g_key_file_get_comment (GKeyFile *key_file,
                                             const gchar *group_name,
                                             const gchar *key,
                                             GError **error) __attribute__((__malloc__));
void g_key_file_remove_comment (GKeyFile *key_file,
                                             const gchar *group_name,
                                             const gchar *key,
          GError **error);
void g_key_file_remove_key (GKeyFile *key_file,
          const gchar *group_name,
          const gchar *key,
          GError **error);
void g_key_file_remove_group (GKeyFile *key_file,
          const gchar *group_name,
          GError **error);
}
extern "C" {
typedef struct _GMappedFile GMappedFile;
GMappedFile *g_mapped_file_new (const gchar *filename,
             gboolean writable,
             GError **error) __attribute__((__malloc__));
gsize g_mapped_file_get_length (GMappedFile *file);
gchar *g_mapped_file_get_contents (GMappedFile *file);
void g_mapped_file_free (GMappedFile *file);
}
extern "C" {
typedef enum
{
  G_MARKUP_ERROR_BAD_UTF8,
  G_MARKUP_ERROR_EMPTY,
  G_MARKUP_ERROR_PARSE,
  G_MARKUP_ERROR_UNKNOWN_ELEMENT,
  G_MARKUP_ERROR_UNKNOWN_ATTRIBUTE,
  G_MARKUP_ERROR_INVALID_CONTENT
} GMarkupError;
GQuark g_markup_error_quark (void);
typedef enum
{
  G_MARKUP_DO_NOT_USE_THIS_UNSUPPORTED_FLAG = 1 << 0,
  G_MARKUP_TREAT_CDATA_AS_TEXT = 1 << 1
} GMarkupParseFlags;
typedef struct _GMarkupParseContext GMarkupParseContext;
typedef struct _GMarkupParser GMarkupParser;
struct _GMarkupParser
{
  void (*start_element) (GMarkupParseContext *context,
                          const gchar *element_name,
                          const gchar **attribute_names,
                          const gchar **attribute_values,
                          gpointer user_data,
                          GError **error);
  void (*end_element) (GMarkupParseContext *context,
                          const gchar *element_name,
                          gpointer user_data,
                          GError **error);
  void (*text) (GMarkupParseContext *context,
                          const gchar *text,
                          gsize text_len,
                          gpointer user_data,
                          GError **error);
  void (*passthrough) (GMarkupParseContext *context,
                          const gchar *passthrough_text,
                          gsize text_len,
                          gpointer user_data,
                          GError **error);
  void (*error) (GMarkupParseContext *context,
                          GError *error,
                          gpointer user_data);
};
GMarkupParseContext *g_markup_parse_context_new (const GMarkupParser *parser,
                                                   GMarkupParseFlags flags,
                                                   gpointer user_data,
                                                   GDestroyNotify user_data_dnotify);
void g_markup_parse_context_free (GMarkupParseContext *context);
gboolean g_markup_parse_context_parse (GMarkupParseContext *context,
                                                   const gchar *text,
                                                   gssize text_len,
                                                   GError **error);
gboolean g_markup_parse_context_end_parse (GMarkupParseContext *context,
                                                       GError **error);
const gchar *g_markup_parse_context_get_element (GMarkupParseContext *context);
void g_markup_parse_context_get_position (GMarkupParseContext *context,
                                                          gint *line_number,
                                                          gint *char_number);
gchar* g_markup_escape_text (const gchar *text,
                             gssize length);
gchar *g_markup_printf_escaped (const char *format,
    ...) __attribute__((__format__ (__printf__, 1, 2)));
gchar *g_markup_vprintf_escaped (const char *format,
     va_list args);
}
extern "C" {
gsize g_printf_string_upper_bound (const gchar* format,
         va_list args);
typedef enum
{
  G_LOG_FLAG_RECURSION = 1 << 0,
  G_LOG_FLAG_FATAL = 1 << 1,
  G_LOG_LEVEL_ERROR = 1 << 2,
  G_LOG_LEVEL_CRITICAL = 1 << 3,
  G_LOG_LEVEL_WARNING = 1 << 4,
  G_LOG_LEVEL_MESSAGE = 1 << 5,
  G_LOG_LEVEL_INFO = 1 << 6,
  G_LOG_LEVEL_DEBUG = 1 << 7,
  G_LOG_LEVEL_MASK = ~(G_LOG_FLAG_RECURSION | G_LOG_FLAG_FATAL)
} GLogLevelFlags;
typedef void (*GLogFunc) (const gchar *log_domain,
                                                 GLogLevelFlags log_level,
                                                 const gchar *message,
                                                 gpointer user_data);
guint g_log_set_handler (const gchar *log_domain,
                                         GLogLevelFlags log_levels,
                                         GLogFunc log_func,
                                         gpointer user_data);
void g_log_remove_handler (const gchar *log_domain,
                                         guint handler_id);
void g_log_default_handler (const gchar *log_domain,
                                         GLogLevelFlags log_level,
                                         const gchar *message,
                                         gpointer unused_data);
GLogFunc g_log_set_default_handler (GLogFunc log_func,
        gpointer user_data);
void g_log (const gchar *log_domain,
                                         GLogLevelFlags log_level,
                                         const gchar *format,
                                         ...) __attribute__((__format__ (__printf__, 3, 4)));
void g_logv (const gchar *log_domain,
                                         GLogLevelFlags log_level,
                                         const gchar *format,
                                         va_list args);
GLogLevelFlags g_log_set_fatal_mask (const gchar *log_domain,
                                         GLogLevelFlags fatal_mask);
GLogLevelFlags g_log_set_always_fatal (GLogLevelFlags fatal_mask);
__attribute__((visibility("hidden"))) void _g_log_fallback_handler (const gchar *log_domain,
       GLogLevelFlags log_level,
       const gchar *message,
       gpointer unused_data);
void g_return_if_fail_warning (const char *log_domain,
          const char *pretty_function,
          const char *expression);
void g_assert_warning (const char *log_domain,
          const char *file,
          const int line,
                 const char *pretty_function,
                 const char *expression) __attribute__((__noreturn__));
typedef void (*GPrintFunc) (const gchar *string);
void g_print (const gchar *format,
                                         ...) __attribute__((__format__ (__printf__, 1, 2)));
GPrintFunc g_set_print_handler (GPrintFunc func);
void g_printerr (const gchar *format,
                                         ...) __attribute__((__format__ (__printf__, 1, 2)));
GPrintFunc g_set_printerr_handler (GPrintFunc func);
}
extern "C" {
typedef struct _GNode GNode;
typedef enum
{
  G_TRAVERSE_LEAVES = 1 << 0,
  G_TRAVERSE_NON_LEAVES = 1 << 1,
  G_TRAVERSE_ALL = G_TRAVERSE_LEAVES | G_TRAVERSE_NON_LEAVES,
  G_TRAVERSE_MASK = 0x03,
  G_TRAVERSE_LEAFS = G_TRAVERSE_LEAVES,
  G_TRAVERSE_NON_LEAFS = G_TRAVERSE_NON_LEAVES
} GTraverseFlags;
typedef enum
{
  G_IN_ORDER,
  G_PRE_ORDER,
  G_POST_ORDER,
  G_LEVEL_ORDER
} GTraverseType;
typedef gboolean (*GNodeTraverseFunc) (GNode *node,
       gpointer data);
typedef void (*GNodeForeachFunc) (GNode *node,
       gpointer data);
typedef gpointer (*GCopyFunc) (gconstpointer src,
                                                 gpointer data);
struct _GNode
{
  gpointer data;
  GNode *next;
  GNode *prev;
  GNode *parent;
  GNode *children;
};
GNode* g_node_new (gpointer data);
void g_node_destroy (GNode *root);
void g_node_unlink (GNode *node);
GNode* g_node_copy_deep (GNode *node,
     GCopyFunc copy_func,
     gpointer data);
GNode* g_node_copy (GNode *node);
GNode* g_node_insert (GNode *parent,
     gint position,
     GNode *node);
GNode* g_node_insert_before (GNode *parent,
     GNode *sibling,
     GNode *node);
GNode* g_node_insert_after (GNode *parent,
     GNode *sibling,
     GNode *node);
GNode* g_node_prepend (GNode *parent,
     GNode *node);
guint g_node_n_nodes (GNode *root,
     GTraverseFlags flags);
GNode* g_node_get_root (GNode *node);
gboolean g_node_is_ancestor (GNode *node,
     GNode *descendant);
guint g_node_depth (GNode *node);
GNode* g_node_find (GNode *root,
     GTraverseType order,
     GTraverseFlags flags,
     gpointer data);
void g_node_traverse (GNode *root,
     GTraverseType order,
     GTraverseFlags flags,
     gint max_depth,
     GNodeTraverseFunc func,
     gpointer data);
guint g_node_max_height (GNode *root);
void g_node_children_foreach (GNode *node,
      GTraverseFlags flags,
      GNodeForeachFunc func,
      gpointer data);
void g_node_reverse_children (GNode *node);
guint g_node_n_children (GNode *node);
GNode* g_node_nth_child (GNode *node,
      guint n);
GNode* g_node_last_child (GNode *node);
GNode* g_node_find_child (GNode *node,
      GTraverseFlags flags,
      gpointer data);
gint g_node_child_position (GNode *node,
      GNode *child);
gint g_node_child_index (GNode *node,
      gpointer data);
GNode* g_node_first_sibling (GNode *node);
GNode* g_node_last_sibling (GNode *node);
void g_node_push_allocator (gpointer dummy);
void g_node_pop_allocator (void);
}
extern "C" {
typedef struct _GOptionContext GOptionContext;
typedef struct _GOptionGroup GOptionGroup;
typedef struct _GOptionEntry GOptionEntry;
typedef enum
{
  G_OPTION_FLAG_HIDDEN = 1 << 0,
  G_OPTION_FLAG_IN_MAIN = 1 << 1,
  G_OPTION_FLAG_REVERSE = 1 << 2,
  G_OPTION_FLAG_NO_ARG = 1 << 3,
  G_OPTION_FLAG_FILENAME = 1 << 4,
  G_OPTION_FLAG_OPTIONAL_ARG = 1 << 5,
  G_OPTION_FLAG_NOALIAS = 1 << 6
} GOptionFlags;
typedef enum
{
  G_OPTION_ARG_NONE,
  G_OPTION_ARG_STRING,
  G_OPTION_ARG_INT,
  G_OPTION_ARG_CALLBACK,
  G_OPTION_ARG_FILENAME,
  G_OPTION_ARG_STRING_ARRAY,
  G_OPTION_ARG_FILENAME_ARRAY,
  G_OPTION_ARG_DOUBLE,
  G_OPTION_ARG_INT64
} GOptionArg;
typedef gboolean (*GOptionArgFunc) (const gchar *option_name,
        const gchar *value,
        gpointer data,
        GError **error);
typedef gboolean (*GOptionParseFunc) (GOptionContext *context,
          GOptionGroup *group,
          gpointer data,
          GError **error);
typedef void (*GOptionErrorFunc) (GOptionContext *context,
      GOptionGroup *group,
      gpointer data,
      GError **error);
typedef enum
{
  G_OPTION_ERROR_UNKNOWN_OPTION,
  G_OPTION_ERROR_BAD_VALUE,
  G_OPTION_ERROR_FAILED
} GOptionError;
GQuark g_option_error_quark (void);
struct _GOptionEntry
{
  const gchar *long_name;
  gchar short_name;
  gint flags;
  GOptionArg arg;
  gpointer arg_data;
  const gchar *description;
  const gchar *arg_description;
};
GOptionContext *g_option_context_new (const gchar *parameter_string);
void g_option_context_set_summary (GOptionContext *context,
                                                   const gchar *summary);
const gchar *g_option_context_get_summary (GOptionContext *context);
void g_option_context_set_description (GOptionContext *context,
                                                   const gchar *description);
const gchar *g_option_context_get_description (GOptionContext *context);
void g_option_context_free (GOptionContext *context);
void g_option_context_set_help_enabled (GOptionContext *context,
         gboolean help_enabled);
gboolean g_option_context_get_help_enabled (GOptionContext *context);
void g_option_context_set_ignore_unknown_options (GOptionContext *context,
            gboolean ignore_unknown);
gboolean g_option_context_get_ignore_unknown_options (GOptionContext *context);
void g_option_context_add_main_entries (GOptionContext *context,
         const GOptionEntry *entries,
         const gchar *translation_domain);
gboolean g_option_context_parse (GOptionContext *context,
         gint *argc,
         gchar ***argv,
         GError **error);
void g_option_context_set_translate_func (GOptionContext *context,
           GTranslateFunc func,
           gpointer data,
           GDestroyNotify destroy_notify);
void g_option_context_set_translation_domain (GOptionContext *context,
        const gchar *domain);
void g_option_context_add_group (GOptionContext *context,
       GOptionGroup *group);
void g_option_context_set_main_group (GOptionContext *context,
            GOptionGroup *group);
GOptionGroup *g_option_context_get_main_group (GOptionContext *context);
gchar *g_option_context_get_help (GOptionContext *context,
                                               gboolean main_help,
                                               GOptionGroup *group);
GOptionGroup *g_option_group_new (const gchar *name,
           const gchar *description,
           const gchar *help_description,
           gpointer user_data,
           GDestroyNotify destroy);
void g_option_group_set_parse_hooks (GOptionGroup *group,
           GOptionParseFunc pre_parse_func,
           GOptionParseFunc post_parse_func);
void g_option_group_set_error_hook (GOptionGroup *group,
           GOptionErrorFunc error_func);
void g_option_group_free (GOptionGroup *group);
void g_option_group_add_entries (GOptionGroup *group,
           const GOptionEntry *entries);
void g_option_group_set_translate_func (GOptionGroup *group,
           GTranslateFunc func,
           gpointer data,
           GDestroyNotify destroy_notify);
void g_option_group_set_translation_domain (GOptionGroup *group,
           const gchar *domain);
}
extern "C" {
typedef struct _GPatternSpec GPatternSpec;
GPatternSpec* g_pattern_spec_new (const gchar *pattern);
void g_pattern_spec_free (GPatternSpec *pspec);
gboolean g_pattern_spec_equal (GPatternSpec *pspec1,
     GPatternSpec *pspec2);
gboolean g_pattern_match (GPatternSpec *pspec,
     guint string_length,
     const gchar *string,
     const gchar *string_reversed);
gboolean g_pattern_match_string (GPatternSpec *pspec,
     const gchar *string);
gboolean g_pattern_match_simple (const gchar *pattern,
     const gchar *string);
}
extern "C" {
guint g_spaced_primes_closest (guint num) __attribute__((__const__));
}
extern "C" {
void g_qsort_with_data (gconstpointer pbase,
   gint total_elems,
   gsize size,
   GCompareDataFunc compare_func,
   gpointer user_data);
}
extern "C" {
typedef struct _GQueue GQueue;
struct _GQueue
{
  GList *head;
  GList *tail;
  guint length;
};
GQueue* g_queue_new (void);
void g_queue_free (GQueue *queue);
void g_queue_init (GQueue *queue);
void g_queue_clear (GQueue *queue);
gboolean g_queue_is_empty (GQueue *queue);
guint g_queue_get_length (GQueue *queue);
void g_queue_reverse (GQueue *queue);
GQueue * g_queue_copy (GQueue *queue);
void g_queue_foreach (GQueue *queue,
     GFunc func,
     gpointer user_data);
GList * g_queue_find (GQueue *queue,
     gconstpointer data);
GList * g_queue_find_custom (GQueue *queue,
     gconstpointer data,
     GCompareFunc func);
void g_queue_sort (GQueue *queue,
     GCompareDataFunc compare_func,
     gpointer user_data);
void g_queue_push_head (GQueue *queue,
     gpointer data);
void g_queue_push_tail (GQueue *queue,
     gpointer data);
void g_queue_push_nth (GQueue *queue,
     gpointer data,
     gint n);
gpointer g_queue_pop_head (GQueue *queue);
gpointer g_queue_pop_tail (GQueue *queue);
gpointer g_queue_pop_nth (GQueue *queue,
     guint n);
gpointer g_queue_peek_head (GQueue *queue);
gpointer g_queue_peek_tail (GQueue *queue);
gpointer g_queue_peek_nth (GQueue *queue,
     guint n);
gint g_queue_index (GQueue *queue,
     gconstpointer data);
void g_queue_remove (GQueue *queue,
     gconstpointer data);
void g_queue_remove_all (GQueue *queue,
     gconstpointer data);
void g_queue_insert_before (GQueue *queue,
     GList *sibling,
     gpointer data);
void g_queue_insert_after (GQueue *queue,
     GList *sibling,
     gpointer data);
void g_queue_insert_sorted (GQueue *queue,
     gpointer data,
     GCompareDataFunc func,
     gpointer user_data);
void g_queue_push_head_link (GQueue *queue,
     GList *link_);
void g_queue_push_tail_link (GQueue *queue,
     GList *link_);
void g_queue_push_nth_link (GQueue *queue,
     gint n,
     GList *link_);
GList* g_queue_pop_head_link (GQueue *queue);
GList* g_queue_pop_tail_link (GQueue *queue);
GList* g_queue_pop_nth_link (GQueue *queue,
     guint n);
GList* g_queue_peek_head_link (GQueue *queue);
GList* g_queue_peek_tail_link (GQueue *queue);
GList* g_queue_peek_nth_link (GQueue *queue,
     guint n);
gint g_queue_link_index (GQueue *queue,
     GList *link_);
void g_queue_unlink (GQueue *queue,
     GList *link_);
void g_queue_delete_link (GQueue *queue,
     GList *link_);
}
extern "C" {
typedef struct _GRand GRand;
GRand* g_rand_new_with_seed (guint32 seed);
GRand* g_rand_new_with_seed_array (const guint32 *seed,
        guint seed_length);
GRand* g_rand_new (void);
void g_rand_free (GRand *rand_);
GRand* g_rand_copy (GRand *rand_);
void g_rand_set_seed (GRand *rand_,
          guint32 seed);
void g_rand_set_seed_array (GRand *rand_,
          const guint32 *seed,
          guint seed_length);
guint32 g_rand_int (GRand *rand_);
gint32 g_rand_int_range (GRand *rand_,
          gint32 begin,
          gint32 end);
gdouble g_rand_double (GRand *rand_);
gdouble g_rand_double_range (GRand *rand_,
          gdouble begin,
          gdouble end);
void g_random_set_seed (guint32 seed);
guint32 g_random_int (void);
gint32 g_random_int_range (gint32 begin,
          gint32 end);
gdouble g_random_double (void);
gdouble g_random_double_range (gdouble begin,
          gdouble end);
}
extern "C" {
typedef struct _GRelation GRelation;
typedef struct _GTuples GTuples;
struct _GTuples
{
  guint len;
};
GRelation* g_relation_new (gint fields);
void g_relation_destroy (GRelation *relation);
void g_relation_index (GRelation *relation,
                               gint field,
                               GHashFunc hash_func,
                               GEqualFunc key_equal_func);
void g_relation_insert (GRelation *relation,
                               ...);
gint g_relation_delete (GRelation *relation,
                               gconstpointer key,
                               gint field);
GTuples* g_relation_select (GRelation *relation,
                               gconstpointer key,
                               gint field);
gint g_relation_count (GRelation *relation,
                               gconstpointer key,
                               gint field);
gboolean g_relation_exists (GRelation *relation,
                               ...);
void g_relation_print (GRelation *relation);
void g_tuples_destroy (GTuples *tuples);
gpointer g_tuples_index (GTuples *tuples,
                               gint index_,
                               gint field);
}
extern "C" {
typedef enum
{
  G_REGEX_ERROR_COMPILE,
  G_REGEX_ERROR_OPTIMIZE,
  G_REGEX_ERROR_REPLACE,
  G_REGEX_ERROR_MATCH
} GRegexError;
GQuark g_regex_error_quark (void);
typedef enum
{
  G_REGEX_CASELESS = 1 << 0,
  G_REGEX_MULTILINE = 1 << 1,
  G_REGEX_DOTALL = 1 << 2,
  G_REGEX_EXTENDED = 1 << 3,
  G_REGEX_ANCHORED = 1 << 4,
  G_REGEX_DOLLAR_ENDONLY = 1 << 5,
  G_REGEX_UNGREEDY = 1 << 9,
  G_REGEX_RAW = 1 << 11,
  G_REGEX_NO_AUTO_CAPTURE = 1 << 12,
  G_REGEX_OPTIMIZE = 1 << 13,
  G_REGEX_DUPNAMES = 1 << 19,
  G_REGEX_NEWLINE_CR = 1 << 20,
  G_REGEX_NEWLINE_LF = 1 << 21,
  G_REGEX_NEWLINE_CRLF = G_REGEX_NEWLINE_CR | G_REGEX_NEWLINE_LF
} GRegexCompileFlags;
typedef enum
{
  G_REGEX_MATCH_ANCHORED = 1 << 4,
  G_REGEX_MATCH_NOTBOL = 1 << 7,
  G_REGEX_MATCH_NOTEOL = 1 << 8,
  G_REGEX_MATCH_NOTEMPTY = 1 << 10,
  G_REGEX_MATCH_PARTIAL = 1 << 15,
  G_REGEX_MATCH_NEWLINE_CR = 1 << 20,
  G_REGEX_MATCH_NEWLINE_LF = 1 << 21,
  G_REGEX_MATCH_NEWLINE_CRLF = G_REGEX_MATCH_NEWLINE_CR | G_REGEX_MATCH_NEWLINE_LF,
  G_REGEX_MATCH_NEWLINE_ANY = 1 << 22
} GRegexMatchFlags;
typedef struct _GRegex GRegex;
typedef struct _GMatchInfo GMatchInfo;
typedef gboolean (*GRegexEvalCallback) (const GMatchInfo *match_info,
       GString *result,
       gpointer user_data);
GRegex *g_regex_new (const gchar *pattern,
       GRegexCompileFlags compile_options,
       GRegexMatchFlags match_options,
       GError **error);
GRegex *g_regex_ref (GRegex *regex);
void g_regex_unref (GRegex *regex);
const gchar *g_regex_get_pattern (const GRegex *regex);
gint g_regex_get_max_backref (const GRegex *regex);
gint g_regex_get_capture_count (const GRegex *regex);
gint g_regex_get_string_number (const GRegex *regex,
       const gchar *name);
gchar *g_regex_escape_string (const gchar *string,
       gint length);
gboolean g_regex_match_simple (const gchar *pattern,
       const gchar *string,
       GRegexCompileFlags compile_options,
       GRegexMatchFlags match_options);
gboolean g_regex_match (const GRegex *regex,
       const gchar *string,
       GRegexMatchFlags match_options,
       GMatchInfo **match_info);
gboolean g_regex_match_full (const GRegex *regex,
       const gchar *string,
       gssize string_len,
       gint start_position,
       GRegexMatchFlags match_options,
       GMatchInfo **match_info,
       GError **error);
gboolean g_regex_match_all (const GRegex *regex,
       const gchar *string,
       GRegexMatchFlags match_options,
       GMatchInfo **match_info);
gboolean g_regex_match_all_full (const GRegex *regex,
       const gchar *string,
       gssize string_len,
       gint start_position,
       GRegexMatchFlags match_options,
       GMatchInfo **match_info,
       GError **error);
gchar **g_regex_split_simple (const gchar *pattern,
       const gchar *string,
       GRegexCompileFlags compile_options,
       GRegexMatchFlags match_options);
gchar **g_regex_split (const GRegex *regex,
       const gchar *string,
       GRegexMatchFlags match_options);
gchar **g_regex_split_full (const GRegex *regex,
       const gchar *string,
       gssize string_len,
       gint start_position,
       GRegexMatchFlags match_options,
       gint max_tokens,
       GError **error);
gchar *g_regex_replace (const GRegex *regex,
       const gchar *string,
       gssize string_len,
       gint start_position,
       const gchar *replacement,
       GRegexMatchFlags match_options,
       GError **error);
gchar *g_regex_replace_literal (const GRegex *regex,
       const gchar *string,
       gssize string_len,
       gint start_position,
       const gchar *replacement,
       GRegexMatchFlags match_options,
       GError **error);
gchar *g_regex_replace_eval (const GRegex *regex,
       const gchar *string,
       gssize string_len,
       gint start_position,
       GRegexMatchFlags match_options,
       GRegexEvalCallback eval,
       gpointer user_data,
       GError **error);
gboolean g_regex_check_replacement (const gchar *replacement,
       gboolean *has_references,
       GError **error);
GRegex *g_match_info_get_regex (const GMatchInfo *match_info);
const gchar *g_match_info_get_string (const GMatchInfo *match_info);
void g_match_info_free (GMatchInfo *match_info);
gboolean g_match_info_next (GMatchInfo *match_info,
       GError **error);
gboolean g_match_info_matches (const GMatchInfo *match_info);
gint g_match_info_get_match_count (const GMatchInfo *match_info);
gboolean g_match_info_is_partial_match (const GMatchInfo *match_info);
gchar *g_match_info_expand_references(const GMatchInfo *match_info,
       const gchar *string_to_expand,
       GError **error);
gchar *g_match_info_fetch (const GMatchInfo *match_info,
       gint match_num);
gboolean g_match_info_fetch_pos (const GMatchInfo *match_info,
       gint match_num,
       gint *start_pos,
       gint *end_pos);
gchar *g_match_info_fetch_named (const GMatchInfo *match_info,
       const gchar *name);
gboolean g_match_info_fetch_named_pos (const GMatchInfo *match_info,
       const gchar *name,
       gint *start_pos,
       gint *end_pos);
gchar **g_match_info_fetch_all (const GMatchInfo *match_info);
}
extern "C" {
typedef struct _GScanner GScanner;
typedef struct _GScannerConfig GScannerConfig;
typedef union _GTokenValue GTokenValue;
typedef void (*GScannerMsgFunc) (GScanner *scanner,
       gchar *message,
       gboolean error);
typedef enum
{
  G_ERR_UNKNOWN,
  G_ERR_UNEXP_EOF,
  G_ERR_UNEXP_EOF_IN_STRING,
  G_ERR_UNEXP_EOF_IN_COMMENT,
  G_ERR_NON_DIGIT_IN_CONST,
  G_ERR_DIGIT_RADIX,
  G_ERR_FLOAT_RADIX,
  G_ERR_FLOAT_MALFORMED
} GErrorType;
typedef enum
{
  G_TOKEN_EOF = 0,
  G_TOKEN_LEFT_PAREN = '(',
  G_TOKEN_RIGHT_PAREN = ')',
  G_TOKEN_LEFT_CURLY = '{',
  G_TOKEN_RIGHT_CURLY = '}',
  G_TOKEN_LEFT_BRACE = '[',
  G_TOKEN_RIGHT_BRACE = ']',
  G_TOKEN_EQUAL_SIGN = '=',
  G_TOKEN_COMMA = ',',
  G_TOKEN_NONE = 256,
  G_TOKEN_ERROR,
  G_TOKEN_CHAR,
  G_TOKEN_BINARY,
  G_TOKEN_OCTAL,
  G_TOKEN_INT,
  G_TOKEN_HEX,
  G_TOKEN_FLOAT,
  G_TOKEN_STRING,
  G_TOKEN_SYMBOL,
  G_TOKEN_IDENTIFIER,
  G_TOKEN_IDENTIFIER_NULL,
  G_TOKEN_COMMENT_SINGLE,
  G_TOKEN_COMMENT_MULTI,
  G_TOKEN_LAST
} GTokenType;
union _GTokenValue
{
  gpointer v_symbol;
  gchar *v_identifier;
  gulong v_binary;
  gulong v_octal;
  gulong v_int;
  guint64 v_int64;
  gdouble v_float;
  gulong v_hex;
  gchar *v_string;
  gchar *v_comment;
  guchar v_char;
  guint v_error;
};
struct _GScannerConfig
{
  gchar *cset_skip_characters;
  gchar *cset_identifier_first;
  gchar *cset_identifier_nth;
  gchar *cpair_comment_single;
  guint case_sensitive : 1;
  guint skip_comment_multi : 1;
  guint skip_comment_single : 1;
  guint scan_comment_multi : 1;
  guint scan_identifier : 1;
  guint scan_identifier_1char : 1;
  guint scan_identifier_NULL : 1;
  guint scan_symbols : 1;
  guint scan_binary : 1;
  guint scan_octal : 1;
  guint scan_float : 1;
  guint scan_hex : 1;
  guint scan_hex_dollar : 1;
  guint scan_string_sq : 1;
  guint scan_string_dq : 1;
  guint numbers_2_int : 1;
  guint int_2_float : 1;
  guint identifier_2_string : 1;
  guint char_2_token : 1;
  guint symbol_2_token : 1;
  guint scope_0_fallback : 1;
  guint store_int64 : 1;
  guint padding_dummy;
};
struct _GScanner
{
  gpointer user_data;
  guint max_parse_errors;
  guint parse_errors;
  const gchar *input_name;
  GData *qdata;
  GScannerConfig *config;
  GTokenType token;
  GTokenValue value;
  guint line;
  guint position;
  GTokenType next_token;
  GTokenValue next_value;
  guint next_line;
  guint next_position;
  GHashTable *symbol_table;
  gint input_fd;
  const gchar *text;
  const gchar *text_end;
  gchar *buffer;
  guint scope_id;
  GScannerMsgFunc msg_handler;
};
GScanner* g_scanner_new (const GScannerConfig *config_templ);
void g_scanner_destroy (GScanner *scanner);
void g_scanner_input_file (GScanner *scanner,
       gint input_fd);
void g_scanner_sync_file_offset (GScanner *scanner);
void g_scanner_input_text (GScanner *scanner,
       const gchar *text,
       guint text_len);
GTokenType g_scanner_get_next_token (GScanner *scanner);
GTokenType g_scanner_peek_next_token (GScanner *scanner);
GTokenType g_scanner_cur_token (GScanner *scanner);
GTokenValue g_scanner_cur_value (GScanner *scanner);
guint g_scanner_cur_line (GScanner *scanner);
guint g_scanner_cur_position (GScanner *scanner);
gboolean g_scanner_eof (GScanner *scanner);
guint g_scanner_set_scope (GScanner *scanner,
       guint scope_id);
void g_scanner_scope_add_symbol (GScanner *scanner,
       guint scope_id,
       const gchar *symbol,
       gpointer value);
void g_scanner_scope_remove_symbol (GScanner *scanner,
       guint scope_id,
       const gchar *symbol);
gpointer g_scanner_scope_lookup_symbol (GScanner *scanner,
       guint scope_id,
       const gchar *symbol);
void g_scanner_scope_foreach_symbol (GScanner *scanner,
       guint scope_id,
       GHFunc func,
       gpointer user_data);
gpointer g_scanner_lookup_symbol (GScanner *scanner,
       const gchar *symbol);
void g_scanner_unexp_token (GScanner *scanner,
       GTokenType expected_token,
       const gchar *identifier_spec,
       const gchar *symbol_spec,
       const gchar *symbol_name,
       const gchar *message,
       gint is_error);
void g_scanner_error (GScanner *scanner,
       const gchar *format,
       ...) __attribute__((__format__ (__printf__, 2, 3)));
void g_scanner_warn (GScanner *scanner,
       const gchar *format,
       ...) __attribute__((__format__ (__printf__, 2, 3)));
}
typedef struct _GSequence GSequence;
typedef struct _GSequenceNode GSequenceIter;
typedef gint (* GSequenceIterCompareFunc) (GSequenceIter *a,
                                           GSequenceIter *b,
                                           gpointer data);
GSequence * g_sequence_new (GDestroyNotify data_destroy);
void g_sequence_free (GSequence *seq);
gint g_sequence_get_length (GSequence *seq);
void g_sequence_foreach (GSequence *seq,
                                              GFunc func,
                                              gpointer user_data);
void g_sequence_foreach_range (GSequenceIter *begin,
                                              GSequenceIter *end,
                                              GFunc func,
                                              gpointer user_data);
void g_sequence_sort (GSequence *seq,
                                              GCompareDataFunc cmp_func,
                                              gpointer cmp_data);
void g_sequence_sort_iter (GSequence *seq,
                                              GSequenceIterCompareFunc cmp_func,
                                              gpointer cmp_data);
GSequenceIter *g_sequence_get_begin_iter (GSequence *seq);
GSequenceIter *g_sequence_get_end_iter (GSequence *seq);
GSequenceIter *g_sequence_get_iter_at_pos (GSequence *seq,
                                              gint pos);
GSequenceIter *g_sequence_append (GSequence *seq,
                                              gpointer data);
GSequenceIter *g_sequence_prepend (GSequence *seq,
                                              gpointer data);
GSequenceIter *g_sequence_insert_before (GSequenceIter *iter,
                                              gpointer data);
void g_sequence_move (GSequenceIter *src,
                                              GSequenceIter *dest);
void g_sequence_swap (GSequenceIter *a,
                                              GSequenceIter *b);
GSequenceIter *g_sequence_insert_sorted (GSequence *seq,
                                              gpointer data,
                                              GCompareDataFunc cmp_func,
                                              gpointer cmp_data);
GSequenceIter *g_sequence_insert_sorted_iter (GSequence *seq,
                                              gpointer data,
                                              GSequenceIterCompareFunc iter_cmp,
                                              gpointer cmp_data);
void g_sequence_sort_changed (GSequenceIter *iter,
                                              GCompareDataFunc cmp_func,
                                              gpointer cmp_data);
void g_sequence_sort_changed_iter (GSequenceIter *iter,
                                              GSequenceIterCompareFunc iter_cmp,
                                              gpointer cmp_data);
void g_sequence_remove (GSequenceIter *iter);
void g_sequence_remove_range (GSequenceIter *begin,
                                              GSequenceIter *end);
void g_sequence_move_range (GSequenceIter *dest,
                                              GSequenceIter *begin,
                                              GSequenceIter *end);
GSequenceIter *g_sequence_search (GSequence *seq,
                                              gpointer data,
                                              GCompareDataFunc cmp_func,
                                              gpointer cmp_data);
GSequenceIter *g_sequence_search_iter (GSequence *seq,
                                              gpointer data,
                                              GSequenceIterCompareFunc iter_cmp,
                                              gpointer cmp_data);
gpointer g_sequence_get (GSequenceIter *iter);
void g_sequence_set (GSequenceIter *iter,
                                              gpointer data);
gboolean g_sequence_iter_is_begin (GSequenceIter *iter);
gboolean g_sequence_iter_is_end (GSequenceIter *iter);
GSequenceIter *g_sequence_iter_next (GSequenceIter *iter);
GSequenceIter *g_sequence_iter_prev (GSequenceIter *iter);
gint g_sequence_iter_get_position (GSequenceIter *iter);
GSequenceIter *g_sequence_iter_move (GSequenceIter *iter,
                                              gint delta);
GSequence * g_sequence_iter_get_sequence (GSequenceIter *iter);
gint g_sequence_iter_compare (GSequenceIter *a,
                                              GSequenceIter *b);
GSequenceIter *g_sequence_range_get_midpoint (GSequenceIter *begin,
                                              GSequenceIter *end);
extern "C" {
typedef enum
{
  G_SHELL_ERROR_BAD_QUOTING,
  G_SHELL_ERROR_EMPTY_STRING,
  G_SHELL_ERROR_FAILED
} GShellError;
GQuark g_shell_error_quark (void);
gchar* g_shell_quote (const gchar *unquoted_string);
gchar* g_shell_unquote (const gchar *quoted_string,
                             GError **error);
gboolean g_shell_parse_argv (const gchar *command_line,
                             gint *argcp,
                             gchar ***argvp,
                             GError **error);
}
extern "C" {
typedef enum
{
  G_SPAWN_ERROR_FORK,
  G_SPAWN_ERROR_READ,
  G_SPAWN_ERROR_CHDIR,
  G_SPAWN_ERROR_ACCES,
  G_SPAWN_ERROR_PERM,
  G_SPAWN_ERROR_2BIG,
  G_SPAWN_ERROR_NOEXEC,
  G_SPAWN_ERROR_NAMETOOLONG,
  G_SPAWN_ERROR_NOENT,
  G_SPAWN_ERROR_NOMEM,
  G_SPAWN_ERROR_NOTDIR,
  G_SPAWN_ERROR_LOOP,
  G_SPAWN_ERROR_TXTBUSY,
  G_SPAWN_ERROR_IO,
  G_SPAWN_ERROR_NFILE,
  G_SPAWN_ERROR_MFILE,
  G_SPAWN_ERROR_INVAL,
  G_SPAWN_ERROR_ISDIR,
  G_SPAWN_ERROR_LIBBAD,
  G_SPAWN_ERROR_FAILED
} GSpawnError;
typedef void (* GSpawnChildSetupFunc) (gpointer user_data);
typedef enum
{
  G_SPAWN_LEAVE_DESCRIPTORS_OPEN = 1 << 0,
  G_SPAWN_DO_NOT_REAP_CHILD = 1 << 1,
  G_SPAWN_SEARCH_PATH = 1 << 2,
  G_SPAWN_STDOUT_TO_DEV_NULL = 1 << 3,
  G_SPAWN_STDERR_TO_DEV_NULL = 1 << 4,
  G_SPAWN_CHILD_INHERITS_STDIN = 1 << 5,
  G_SPAWN_FILE_AND_ARGV_ZERO = 1 << 6
} GSpawnFlags;
GQuark g_spawn_error_quark (void);
gboolean g_spawn_async (const gchar *working_directory,
                        gchar **argv,
                        gchar **envp,
                        GSpawnFlags flags,
                        GSpawnChildSetupFunc child_setup,
                        gpointer user_data,
                        GPid *child_pid,
                        GError **error);
gboolean g_spawn_async_with_pipes (const gchar *working_directory,
                                   gchar **argv,
                                   gchar **envp,
                                   GSpawnFlags flags,
                                   GSpawnChildSetupFunc child_setup,
                                   gpointer user_data,
                                   GPid *child_pid,
                                   gint *standard_input,
                                   gint *standard_output,
                                   gint *standard_error,
                                   GError **error);
gboolean g_spawn_sync (const gchar *working_directory,
                               gchar **argv,
                               gchar **envp,
                               GSpawnFlags flags,
                               GSpawnChildSetupFunc child_setup,
                               gpointer user_data,
                               gchar **standard_output,
                               gchar **standard_error,
                               gint *exit_status,
                               GError **error);
gboolean g_spawn_command_line_sync (const gchar *command_line,
                                     gchar **standard_output,
                                     gchar **standard_error,
                                     gint *exit_status,
                                     GError **error);
gboolean g_spawn_command_line_async (const gchar *command_line,
                                     GError **error);
void g_spawn_close_pid (GPid pid);
}
extern "C" {
typedef enum {
  G_ASCII_ALNUM = 1 << 0,
  G_ASCII_ALPHA = 1 << 1,
  G_ASCII_CNTRL = 1 << 2,
  G_ASCII_DIGIT = 1 << 3,
  G_ASCII_GRAPH = 1 << 4,
  G_ASCII_LOWER = 1 << 5,
  G_ASCII_PRINT = 1 << 6,
  G_ASCII_PUNCT = 1 << 7,
  G_ASCII_SPACE = 1 << 8,
  G_ASCII_UPPER = 1 << 9,
  G_ASCII_XDIGIT = 1 << 10
} GAsciiType;
extern const guint16 * const g_ascii_table;
gchar g_ascii_tolower (gchar c) __attribute__((__const__));
gchar g_ascii_toupper (gchar c) __attribute__((__const__));
gint g_ascii_digit_value (gchar c) __attribute__((__const__));
gint g_ascii_xdigit_value (gchar c) __attribute__((__const__));
gchar* g_strdelimit (gchar *string,
     const gchar *delimiters,
     gchar new_delimiter);
gchar* g_strcanon (gchar *string,
     const gchar *valid_chars,
     gchar substitutor);
const gchar* g_strerror (gint errnum) __attribute__((__const__));
const gchar* g_strsignal (gint signum) __attribute__((__const__));
gchar* g_strreverse (gchar *string);
gsize g_strlcpy (gchar *dest,
     const gchar *src,
     gsize dest_size);
gsize g_strlcat (gchar *dest,
     const gchar *src,
     gsize dest_size);
gchar * g_strstr_len (const gchar *haystack,
     gssize haystack_len,
     const gchar *needle);
gchar * g_strrstr (const gchar *haystack,
     const gchar *needle);
gchar * g_strrstr_len (const gchar *haystack,
     gssize haystack_len,
     const gchar *needle);
gboolean g_str_has_suffix (const gchar *str,
     const gchar *suffix);
gboolean g_str_has_prefix (const gchar *str,
     const gchar *prefix);
gdouble g_strtod (const gchar *nptr,
     gchar **endptr);
gdouble g_ascii_strtod (const gchar *nptr,
     gchar **endptr);
guint64 g_ascii_strtoull (const gchar *nptr,
     gchar **endptr,
     guint base);
gint64 g_ascii_strtoll (const gchar *nptr,
     gchar **endptr,
     guint base);
gchar * g_ascii_dtostr (gchar *buffer,
     gint buf_len,
     gdouble d);
gchar * g_ascii_formatd (gchar *buffer,
     gint buf_len,
     const gchar *format,
     gdouble d);
gchar* g_strchug (gchar *string);
gchar* g_strchomp (gchar *string);
gint g_ascii_strcasecmp (const gchar *s1,
        const gchar *s2);
gint g_ascii_strncasecmp (const gchar *s1,
        const gchar *s2,
        gsize n);
gchar* g_ascii_strdown (const gchar *str,
        gssize len) __attribute__((__malloc__));
gchar* g_ascii_strup (const gchar *str,
        gssize len) __attribute__((__malloc__));
gint g_strcasecmp (const gchar *s1,
     const gchar *s2);
gint g_strncasecmp (const gchar *s1,
     const gchar *s2,
     guint n);
gchar* g_strdown (gchar *string);
gchar* g_strup (gchar *string);
gchar* g_strdup (const gchar *str) __attribute__((__malloc__));
gchar* g_strdup_printf (const gchar *format,
     ...) __attribute__((__format__ (__printf__, 1, 2))) __attribute__((__malloc__));
gchar* g_strdup_vprintf (const gchar *format,
     va_list args) __attribute__((__malloc__));
gchar* g_strndup (const gchar *str,
     gsize n) __attribute__((__malloc__));
gchar* g_strnfill (gsize length,
     gchar fill_char) __attribute__((__malloc__));
gchar* g_strconcat (const gchar *string1,
     ...) __attribute__((__malloc__)) __attribute__((__sentinel__));
gchar* g_strjoin (const gchar *separator,
     ...) __attribute__((__malloc__)) __attribute__((__sentinel__));
gchar* g_strcompress (const gchar *source) __attribute__((__malloc__));
gchar* g_strescape (const gchar *source,
     const gchar *exceptions) __attribute__((__malloc__));
gpointer g_memdup (gconstpointer mem,
     guint byte_size) __attribute__((__malloc__));
gchar** g_strsplit (const gchar *string,
     const gchar *delimiter,
     gint max_tokens) __attribute__((__malloc__));
gchar ** g_strsplit_set (const gchar *string,
     const gchar *delimiters,
     gint max_tokens) __attribute__((__malloc__));
gchar* g_strjoinv (const gchar *separator,
     gchar **str_array) __attribute__((__malloc__));
void g_strfreev (gchar **str_array);
gchar** g_strdupv (gchar **str_array) __attribute__((__malloc__));
guint g_strv_length (gchar **str_array);
gchar* g_stpcpy (gchar *dest,
                                        const char *src);
const gchar *g_strip_context (const gchar *msgid,
     const gchar *msgval);
}
extern "C" {
typedef struct _GThreadPool GThreadPool;
struct _GThreadPool
{
  GFunc func;
  gpointer user_data;
  gboolean exclusive;
};
GThreadPool* g_thread_pool_new (GFunc func,
                                               gpointer user_data,
                                               gint max_threads,
                                               gboolean exclusive,
                                               GError **error);
void g_thread_pool_push (GThreadPool *pool,
                                               gpointer data,
                                               GError **error);
void g_thread_pool_set_max_threads (GThreadPool *pool,
                                               gint max_threads,
                                               GError **error);
gint g_thread_pool_get_max_threads (GThreadPool *pool);
guint g_thread_pool_get_num_threads (GThreadPool *pool);
guint g_thread_pool_unprocessed (GThreadPool *pool);
void g_thread_pool_free (GThreadPool *pool,
                                               gboolean immediate,
                                               gboolean wait_);
void g_thread_pool_set_max_unused_threads (gint max_threads);
gint g_thread_pool_get_max_unused_threads (void);
guint g_thread_pool_get_num_unused_threads (void);
void g_thread_pool_stop_unused_threads (void);
void g_thread_pool_set_sort_function (GThreadPool *pool,
                                        GCompareDataFunc func,
            gpointer user_data);
void g_thread_pool_set_max_idle_time (guint interval);
guint g_thread_pool_get_max_idle_time (void);
}
extern "C" {
typedef struct _GTimer GTimer;
GTimer* g_timer_new (void);
void g_timer_destroy (GTimer *timer);
void g_timer_start (GTimer *timer);
void g_timer_stop (GTimer *timer);
void g_timer_reset (GTimer *timer);
void g_timer_continue (GTimer *timer);
gdouble g_timer_elapsed (GTimer *timer,
      gulong *microseconds);
void g_usleep (gulong microseconds);
void g_time_val_add (GTimeVal *time_,
                                  glong microseconds);
gboolean g_time_val_from_iso8601 (const gchar *iso_date,
      GTimeVal *time_);
gchar* g_time_val_to_iso8601 (GTimeVal *time_) __attribute__((__malloc__));
}
extern "C" {
typedef struct _GTree GTree;
typedef gboolean (*GTraverseFunc) (gpointer key,
                                   gpointer value,
                                   gpointer data);
GTree* g_tree_new (GCompareFunc key_compare_func);
GTree* g_tree_new_with_data (GCompareDataFunc key_compare_func,
                                 gpointer key_compare_data);
GTree* g_tree_new_full (GCompareDataFunc key_compare_func,
                                 gpointer key_compare_data,
                                 GDestroyNotify key_destroy_func,
                                 GDestroyNotify value_destroy_func);
void g_tree_destroy (GTree *tree);
void g_tree_insert (GTree *tree,
                                 gpointer key,
                                 gpointer value);
void g_tree_replace (GTree *tree,
                                 gpointer key,
                                 gpointer value);
gboolean g_tree_remove (GTree *tree,
                                 gconstpointer key);
gboolean g_tree_steal (GTree *tree,
                                 gconstpointer key);
gpointer g_tree_lookup (GTree *tree,
                                 gconstpointer key);
gboolean g_tree_lookup_extended (GTree *tree,
                                 gconstpointer lookup_key,
                                 gpointer *orig_key,
                                 gpointer *value);
void g_tree_foreach (GTree *tree,
                                 GTraverseFunc func,
                                 gpointer user_data);
void g_tree_traverse (GTree *tree,
                                 GTraverseFunc traverse_func,
                                 GTraverseType traverse_type,
                                 gpointer user_data);
gpointer g_tree_search (GTree *tree,
                                 GCompareFunc search_func,
                                 gconstpointer user_data);
gint g_tree_height (GTree *tree);
gint g_tree_nnodes (GTree *tree);
}
extern "C" {
typedef gulong GType;
typedef struct _GValue GValue;
typedef union _GTypeCValue GTypeCValue;
typedef struct _GTypePlugin GTypePlugin;
typedef struct _GTypeClass GTypeClass;
typedef struct _GTypeInterface GTypeInterface;
typedef struct _GTypeInstance GTypeInstance;
typedef struct _GTypeInfo GTypeInfo;
typedef struct _GTypeFundamentalInfo GTypeFundamentalInfo;
typedef struct _GInterfaceInfo GInterfaceInfo;
typedef struct _GTypeValueTable GTypeValueTable;
typedef struct _GTypeQuery GTypeQuery;
struct _GTypeClass
{
  GType g_type;
};
struct _GTypeInstance
{
  GTypeClass *g_class;
};
struct _GTypeInterface
{
  GType g_type;
  GType g_instance_type;
};
struct _GTypeQuery
{
  GType type;
  const gchar *type_name;
  guint class_size;
  guint instance_size;
};
typedef enum
{
  G_TYPE_DEBUG_NONE = 0,
  G_TYPE_DEBUG_OBJECTS = 1 << 0,
  G_TYPE_DEBUG_SIGNALS = 1 << 1,
  G_TYPE_DEBUG_MASK = 0x03
} GTypeDebugFlags;
void g_type_init (void);
void g_type_init_with_debug_flags (GTypeDebugFlags debug_flags);
const gchar* g_type_name (GType type);
GQuark g_type_qname (GType type);
GType g_type_from_name (const gchar *name);
GType g_type_parent (GType type);
guint g_type_depth (GType type);
GType g_type_next_base (GType leaf_type,
            GType root_type);
gboolean g_type_is_a (GType type,
            GType is_a_type);
gpointer g_type_class_ref (GType type);
gpointer g_type_class_peek (GType type);
gpointer g_type_class_peek_static (GType type);
void g_type_class_unref (gpointer g_class);
gpointer g_type_class_peek_parent (gpointer g_class);
gpointer g_type_interface_peek (gpointer instance_class,
            GType iface_type);
gpointer g_type_interface_peek_parent (gpointer g_iface);
gpointer g_type_default_interface_ref (GType g_type);
gpointer g_type_default_interface_peek (GType g_type);
void g_type_default_interface_unref (gpointer g_iface);
GType* g_type_children (GType type,
            guint *n_children);
GType* g_type_interfaces (GType type,
            guint *n_interfaces);
void g_type_set_qdata (GType type,
            GQuark quark,
            gpointer data);
gpointer g_type_get_qdata (GType type,
            GQuark quark);
void g_type_query (GType type,
            GTypeQuery *query);
typedef void (*GBaseInitFunc) (gpointer g_class);
typedef void (*GBaseFinalizeFunc) (gpointer g_class);
typedef void (*GClassInitFunc) (gpointer g_class,
           gpointer class_data);
typedef void (*GClassFinalizeFunc) (gpointer g_class,
           gpointer class_data);
typedef void (*GInstanceInitFunc) (GTypeInstance *instance,
           gpointer g_class);
typedef void (*GInterfaceInitFunc) (gpointer g_iface,
           gpointer iface_data);
typedef void (*GInterfaceFinalizeFunc) (gpointer g_iface,
           gpointer iface_data);
typedef gboolean (*GTypeClassCacheFunc) (gpointer cache_data,
           GTypeClass *g_class);
typedef void (*GTypeInterfaceCheckFunc) (gpointer check_data,
           gpointer g_iface);
typedef enum
{
  G_TYPE_FLAG_CLASSED = (1 << 0),
  G_TYPE_FLAG_INSTANTIATABLE = (1 << 1),
  G_TYPE_FLAG_DERIVABLE = (1 << 2),
  G_TYPE_FLAG_DEEP_DERIVABLE = (1 << 3)
} GTypeFundamentalFlags;
typedef enum
{
  G_TYPE_FLAG_ABSTRACT = (1 << 4),
  G_TYPE_FLAG_VALUE_ABSTRACT = (1 << 5)
} GTypeFlags;
struct _GTypeInfo
{
  guint16 class_size;
  GBaseInitFunc base_init;
  GBaseFinalizeFunc base_finalize;
  GClassInitFunc class_init;
  GClassFinalizeFunc class_finalize;
  gconstpointer class_data;
  guint16 instance_size;
  guint16 n_preallocs;
  GInstanceInitFunc instance_init;
  const GTypeValueTable *value_table;
};
struct _GTypeFundamentalInfo
{
  GTypeFundamentalFlags type_flags;
};
struct _GInterfaceInfo
{
  GInterfaceInitFunc interface_init;
  GInterfaceFinalizeFunc interface_finalize;
  gpointer interface_data;
};
struct _GTypeValueTable
{
  void (*value_init) (GValue *value);
  void (*value_free) (GValue *value);
  void (*value_copy) (const GValue *src_value,
      GValue *dest_value);
  gpointer (*value_peek_pointer) (const GValue *value);
  gchar *collect_format;
  gchar* (*collect_value) (GValue *value,
      guint n_collect_values,
      GTypeCValue *collect_values,
      guint collect_flags);
  gchar *lcopy_format;
  gchar* (*lcopy_value) (const GValue *value,
      guint n_collect_values,
      GTypeCValue *collect_values,
      guint collect_flags);
};
GType g_type_register_static (GType parent_type,
      const gchar *type_name,
      const GTypeInfo *info,
      GTypeFlags flags);
GType g_type_register_static_simple (GType parent_type,
      const gchar *type_name,
      guint class_size,
      GClassInitFunc class_init,
      guint instance_size,
      GInstanceInitFunc instance_init,
      GTypeFlags flags);
GType g_type_register_dynamic (GType parent_type,
      const gchar *type_name,
      GTypePlugin *plugin,
      GTypeFlags flags);
GType g_type_register_fundamental (GType type_id,
      const gchar *type_name,
      const GTypeInfo *info,
      const GTypeFundamentalInfo *finfo,
      GTypeFlags flags);
void g_type_add_interface_static (GType instance_type,
      GType interface_type,
      const GInterfaceInfo *info);
void g_type_add_interface_dynamic (GType instance_type,
      GType interface_type,
      GTypePlugin *plugin);
void g_type_interface_add_prerequisite (GType interface_type,
      GType prerequisite_type);
GType*g_type_interface_prerequisites (GType interface_type,
      guint *n_prerequisites);
void g_type_class_add_private (gpointer g_class,
                                         gsize private_size);
gpointer g_type_instance_get_private (GTypeInstance *instance,
                                         GType private_type);
GTypePlugin* g_type_get_plugin (GType type);
GTypePlugin* g_type_interface_get_plugin (GType instance_type,
       GType interface_type);
GType g_type_fundamental_next (void);
GType g_type_fundamental (GType type_id);
GTypeInstance* g_type_create_instance (GType type);
void g_type_free_instance (GTypeInstance *instance);
void g_type_add_class_cache_func (gpointer cache_data,
       GTypeClassCacheFunc cache_func);
void g_type_remove_class_cache_func (gpointer cache_data,
       GTypeClassCacheFunc cache_func);
void g_type_class_unref_uncached (gpointer g_class);
void g_type_add_interface_check (gpointer check_data,
       GTypeInterfaceCheckFunc check_func);
void g_type_remove_interface_check (gpointer check_data,
       GTypeInterfaceCheckFunc check_func);
GTypeValueTable* g_type_value_table_peek (GType type);
gboolean g_type_check_instance (GTypeInstance *instance) __attribute__((__pure__));
GTypeInstance* g_type_check_instance_cast (GTypeInstance *instance,
       GType iface_type);
gboolean g_type_check_instance_is_a (GTypeInstance *instance,
       GType iface_type) __attribute__((__pure__));
GTypeClass* g_type_check_class_cast (GTypeClass *g_class,
       GType is_a_type);
gboolean g_type_check_class_is_a (GTypeClass *g_class,
       GType is_a_type) __attribute__((__pure__));
gboolean g_type_check_is_value_type (GType type) __attribute__((__const__));
gboolean g_type_check_value (GValue *value) __attribute__((__pure__));
gboolean g_type_check_value_holds (GValue *value,
       GType type) __attribute__((__pure__));
gboolean g_type_test_flags (GType type,
       guint flags) __attribute__((__const__));
const gchar* g_type_name_from_instance (GTypeInstance *instance);
const gchar* g_type_name_from_class (GTypeClass *g_class);
__attribute__((visibility("hidden"))) void g_value_c_init (void);
__attribute__((visibility("hidden"))) void g_value_types_init (void);
__attribute__((visibility("hidden"))) void g_enum_types_init (void);
__attribute__((visibility("hidden"))) void g_param_type_init (void);
__attribute__((visibility("hidden"))) void g_boxed_type_init (void);
__attribute__((visibility("hidden"))) void g_object_type_init (void);
__attribute__((visibility("hidden"))) void g_param_spec_types_init (void);
__attribute__((visibility("hidden"))) void g_value_transforms_init (void);
__attribute__((visibility("hidden"))) void g_signal_init (void);
extern GTypeDebugFlags _g_type_debug_flags;
}
extern "C" {
typedef gpointer (*GBoxedCopyFunc) (gpointer boxed);
typedef void (*GBoxedFreeFunc) (gpointer boxed);
gpointer g_boxed_copy (GType boxed_type,
       gconstpointer src_boxed);
void g_boxed_free (GType boxed_type,
       gpointer boxed);
void g_value_set_boxed (GValue *value,
       gconstpointer v_boxed);
void g_value_set_static_boxed (GValue *value,
       gconstpointer v_boxed);
gpointer g_value_get_boxed (const GValue *value);
gpointer g_value_dup_boxed (const GValue *value);
GType g_boxed_type_register_static (const gchar *name,
       GBoxedCopyFunc boxed_copy,
       GBoxedFreeFunc boxed_free);
void g_value_take_boxed (GValue *value,
     gconstpointer v_boxed);
void g_value_set_boxed_take_ownership (GValue *value,
       gconstpointer v_boxed);
GType g_closure_get_type (void) __attribute__((__const__));
GType g_value_get_type (void) __attribute__((__const__));
GType g_value_array_get_type (void) __attribute__((__const__));
GType g_date_get_type (void) __attribute__((__const__));
GType g_strv_get_type (void) __attribute__((__const__));
GType g_gstring_get_type (void) __attribute__((__const__));
GType g_hash_table_get_type (void) __attribute__((__const__));
GType g_regex_get_type (void) __attribute__((__const__));
typedef gchar** GStrv;
}
extern "C" {
typedef struct _GEnumClass GEnumClass;
typedef struct _GFlagsClass GFlagsClass;
typedef struct _GEnumValue GEnumValue;
typedef struct _GFlagsValue GFlagsValue;
struct _GEnumClass
{
  GTypeClass g_type_class;
  gint minimum;
  gint maximum;
  guint n_values;
  GEnumValue *values;
};
struct _GFlagsClass
{
  GTypeClass g_type_class;
  guint mask;
  guint n_values;
  GFlagsValue *values;
};
struct _GEnumValue
{
  gint value;
  const gchar *value_name;
  const gchar *value_nick;
};
struct _GFlagsValue
{
  guint value;
  const gchar *value_name;
  const gchar *value_nick;
};
GEnumValue* g_enum_get_value (GEnumClass *enum_class,
       gint value);
GEnumValue* g_enum_get_value_by_name (GEnumClass *enum_class,
       const gchar *name);
GEnumValue* g_enum_get_value_by_nick (GEnumClass *enum_class,
       const gchar *nick);
GFlagsValue* g_flags_get_first_value (GFlagsClass *flags_class,
       guint value);
GFlagsValue* g_flags_get_value_by_name (GFlagsClass *flags_class,
       const gchar *name);
GFlagsValue* g_flags_get_value_by_nick (GFlagsClass *flags_class,
       const gchar *nick);
void g_value_set_enum (GValue *value,
       gint v_enum);
gint g_value_get_enum (const GValue *value);
void g_value_set_flags (GValue *value,
       guint v_flags);
guint g_value_get_flags (const GValue *value);
GType g_enum_register_static (const gchar *name,
        const GEnumValue *const_static_values);
GType g_flags_register_static (const gchar *name,
        const GFlagsValue *const_static_values);
void g_enum_complete_type_info (GType g_enum_type,
        GTypeInfo *info,
        const GEnumValue *const_values);
void g_flags_complete_type_info (GType g_flags_type,
        GTypeInfo *info,
        const GFlagsValue *const_values);
}
extern "C" {
typedef void (*GValueTransform) (const GValue *src_value,
     GValue *dest_value);
struct _GValue
{
  GType g_type;
  union {
    gint v_int;
    guint v_uint;
    glong v_long;
    gulong v_ulong;
    gint64 v_int64;
    guint64 v_uint64;
    gfloat v_float;
    gdouble v_double;
    gpointer v_pointer;
  } data[2];
};
GValue* g_value_init (GValue *value,
      GType g_type);
void g_value_copy (const GValue *src_value,
      GValue *dest_value);
GValue* g_value_reset (GValue *value);
void g_value_unset (GValue *value);
void g_value_set_instance (GValue *value,
      gpointer instance);
gboolean g_value_fits_pointer (const GValue *value);
gpointer g_value_peek_pointer (const GValue *value);
gboolean g_value_type_compatible (GType src_type,
      GType dest_type);
gboolean g_value_type_transformable (GType src_type,
      GType dest_type);
gboolean g_value_transform (const GValue *src_value,
      GValue *dest_value);
void g_value_register_transform_func (GType src_type,
      GType dest_type,
      GValueTransform transform_func);
}
extern "C" {
typedef enum
{
  G_PARAM_READABLE = 1 << 0,
  G_PARAM_WRITABLE = 1 << 1,
  G_PARAM_CONSTRUCT = 1 << 2,
  G_PARAM_CONSTRUCT_ONLY = 1 << 3,
  G_PARAM_LAX_VALIDATION = 1 << 4,
  G_PARAM_STATIC_NAME = 1 << 5,
  G_PARAM_PRIVATE = G_PARAM_STATIC_NAME,
  G_PARAM_STATIC_NICK = 1 << 6,
  G_PARAM_STATIC_BLURB = 1 << 7
} GParamFlags;
typedef struct _GParamSpec GParamSpec;
typedef struct _GParamSpecClass GParamSpecClass;
typedef struct _GParameter GParameter;
typedef struct _GParamSpecPool GParamSpecPool;
struct _GParamSpec
{
  GTypeInstance g_type_instance;
  gchar *name;
  GParamFlags flags;
  GType value_type;
  GType owner_type;
  gchar *_nick;
  gchar *_blurb;
  GData *qdata;
  guint ref_count;
  guint param_id;
};
struct _GParamSpecClass
{
  GTypeClass g_type_class;
  GType value_type;
  void (*finalize) (GParamSpec *pspec);
  void (*value_set_default) (GParamSpec *pspec,
      GValue *value);
  gboolean (*value_validate) (GParamSpec *pspec,
      GValue *value);
  gint (*values_cmp) (GParamSpec *pspec,
      const GValue *value1,
      const GValue *value2);
  gpointer dummy[4];
};
struct _GParameter
{
  const gchar *name;
  GValue value;
};
GParamSpec* g_param_spec_ref (GParamSpec *pspec);
void g_param_spec_unref (GParamSpec *pspec);
void g_param_spec_sink (GParamSpec *pspec);
GParamSpec* g_param_spec_ref_sink (GParamSpec *pspec);
gpointer g_param_spec_get_qdata (GParamSpec *pspec,
       GQuark quark);
void g_param_spec_set_qdata (GParamSpec *pspec,
       GQuark quark,
       gpointer data);
void g_param_spec_set_qdata_full (GParamSpec *pspec,
       GQuark quark,
       gpointer data,
       GDestroyNotify destroy);
gpointer g_param_spec_steal_qdata (GParamSpec *pspec,
       GQuark quark);
GParamSpec* g_param_spec_get_redirect_target (GParamSpec *pspec);
void g_param_value_set_default (GParamSpec *pspec,
       GValue *value);
gboolean g_param_value_defaults (GParamSpec *pspec,
       GValue *value);
gboolean g_param_value_validate (GParamSpec *pspec,
       GValue *value);
gboolean g_param_value_convert (GParamSpec *pspec,
       const GValue *src_value,
       GValue *dest_value,
       gboolean strict_validation);
gint g_param_values_cmp (GParamSpec *pspec,
       const GValue *value1,
       const GValue *value2);
const gchar* g_param_spec_get_name (GParamSpec *pspec);
const gchar* g_param_spec_get_nick (GParamSpec *pspec);
const gchar* g_param_spec_get_blurb (GParamSpec *pspec);
void g_value_set_param (GValue *value,
       GParamSpec *param);
GParamSpec* g_value_get_param (const GValue *value);
GParamSpec* g_value_dup_param (const GValue *value);
void g_value_take_param (GValue *value,
              GParamSpec *param);
void g_value_set_param_take_ownership (GValue *value,
              GParamSpec *param);
typedef struct _GParamSpecTypeInfo GParamSpecTypeInfo;
struct _GParamSpecTypeInfo
{
  guint16 instance_size;
  guint16 n_preallocs;
  void (*instance_init) (GParamSpec *pspec);
  GType value_type;
  void (*finalize) (GParamSpec *pspec);
  void (*value_set_default) (GParamSpec *pspec,
      GValue *value);
  gboolean (*value_validate) (GParamSpec *pspec,
      GValue *value);
  gint (*values_cmp) (GParamSpec *pspec,
      const GValue *value1,
      const GValue *value2);
};
GType g_param_type_register_static (const gchar *name,
      const GParamSpecTypeInfo *pspec_info);
GType _g_param_type_register_static_constant (const gchar *name,
            const GParamSpecTypeInfo *pspec_info,
            GType opt_type);
gpointer g_param_spec_internal (GType param_type,
       const gchar *name,
       const gchar *nick,
       const gchar *blurb,
       GParamFlags flags);
GParamSpecPool* g_param_spec_pool_new (gboolean type_prefixing);
void g_param_spec_pool_insert (GParamSpecPool *pool,
       GParamSpec *pspec,
       GType owner_type);
void g_param_spec_pool_remove (GParamSpecPool *pool,
       GParamSpec *pspec);
GParamSpec* g_param_spec_pool_lookup (GParamSpecPool *pool,
       const gchar *param_name,
       GType owner_type,
       gboolean walk_ancestors);
GList* g_param_spec_pool_list_owned (GParamSpecPool *pool,
       GType owner_type);
GParamSpec** g_param_spec_pool_list (GParamSpecPool *pool,
       GType owner_type,
       guint *n_pspecs_p);
}
extern "C" {
typedef struct _GClosure GClosure;
typedef struct _GClosureNotifyData GClosureNotifyData;
typedef void (*GCallback) (void);
typedef void (*GClosureNotify) (gpointer data,
      GClosure *closure);
typedef void (*GClosureMarshal) (GClosure *closure,
      GValue *return_value,
      guint n_param_values,
      const GValue *param_values,
      gpointer invocation_hint,
      gpointer marshal_data);
typedef struct _GCClosure GCClosure;
struct _GClosureNotifyData
{
  gpointer data;
  GClosureNotify notify;
};
struct _GClosure
{
  volatile guint ref_count : 15;
  volatile guint meta_marshal : 1;
  volatile guint n_guards : 1;
  volatile guint n_fnotifiers : 2;
  volatile guint n_inotifiers : 8;
  volatile guint in_inotify : 1;
  volatile guint floating : 1;
  volatile guint derivative_flag : 1;
  volatile guint in_marshal : 1;
  volatile guint is_invalid : 1;
                  void (*marshal) (GClosure *closure,
         GValue *return_value,
         guint n_param_values,
         const GValue *param_values,
         gpointer invocation_hint,
         gpointer marshal_data);
                    gpointer data;
                  GClosureNotifyData *notifiers;
};
struct _GCClosure
{
  GClosure closure;
  gpointer callback;
};
GClosure* g_cclosure_new (GCallback callback_func,
       gpointer user_data,
       GClosureNotify destroy_data);
GClosure* g_cclosure_new_swap (GCallback callback_func,
       gpointer user_data,
       GClosureNotify destroy_data);
GClosure* g_signal_type_cclosure_new (GType itype,
       guint struct_offset);
GClosure* g_closure_ref (GClosure *closure);
void g_closure_sink (GClosure *closure);
void g_closure_unref (GClosure *closure);
GClosure* g_closure_new_simple (guint sizeof_closure,
       gpointer data);
void g_closure_add_finalize_notifier (GClosure *closure,
       gpointer notify_data,
       GClosureNotify notify_func);
void g_closure_remove_finalize_notifier (GClosure *closure,
       gpointer notify_data,
       GClosureNotify notify_func);
void g_closure_add_invalidate_notifier (GClosure *closure,
       gpointer notify_data,
       GClosureNotify notify_func);
void g_closure_remove_invalidate_notifier (GClosure *closure,
       gpointer notify_data,
       GClosureNotify notify_func);
void g_closure_add_marshal_guards (GClosure *closure,
       gpointer pre_marshal_data,
       GClosureNotify pre_marshal_notify,
       gpointer post_marshal_data,
       GClosureNotify post_marshal_notify);
void g_closure_set_marshal (GClosure *closure,
       GClosureMarshal marshal);
void g_closure_set_meta_marshal (GClosure *closure,
       gpointer marshal_data,
       GClosureMarshal meta_marshal);
void g_closure_invalidate (GClosure *closure);
void g_closure_invoke (GClosure *closure,
       GValue *return_value,
       guint n_param_values,
       const GValue *param_values,
       gpointer invocation_hint);
}
extern "C" {
extern void g_cclosure_marshal_VOID__VOID (GClosure *closure,
                                           GValue *return_value,
                                           guint n_param_values,
                                           const GValue *param_values,
                                           gpointer invocation_hint,
                                           gpointer marshal_data);
extern void g_cclosure_marshal_VOID__BOOLEAN (GClosure *closure,
                                              GValue *return_value,
                                              guint n_param_values,
                                              const GValue *param_values,
                                              gpointer invocation_hint,
                                              gpointer marshal_data);
extern void g_cclosure_marshal_VOID__CHAR (GClosure *closure,
                                           GValue *return_value,
                                           guint n_param_values,
                                           const GValue *param_values,
                                           gpointer invocation_hint,
                                           gpointer marshal_data);
extern void g_cclosure_marshal_VOID__UCHAR (GClosure *closure,
                                            GValue *return_value,
                                            guint n_param_values,
                                            const GValue *param_values,
                                            gpointer invocation_hint,
                                            gpointer marshal_data);
extern void g_cclosure_marshal_VOID__INT (GClosure *closure,
                                          GValue *return_value,
                                          guint n_param_values,
                                          const GValue *param_values,
                                          gpointer invocation_hint,
                                          gpointer marshal_data);
extern void g_cclosure_marshal_VOID__UINT (GClosure *closure,
                                           GValue *return_value,
                                           guint n_param_values,
                                           const GValue *param_values,
                                           gpointer invocation_hint,
                                           gpointer marshal_data);
extern void g_cclosure_marshal_VOID__LONG (GClosure *closure,
                                           GValue *return_value,
                                           guint n_param_values,
                                           const GValue *param_values,
                                           gpointer invocation_hint,
                                           gpointer marshal_data);
extern void g_cclosure_marshal_VOID__ULONG (GClosure *closure,
                                            GValue *return_value,
                                            guint n_param_values,
                                            const GValue *param_values,
                                            gpointer invocation_hint,
                                            gpointer marshal_data);
extern void g_cclosure_marshal_VOID__ENUM (GClosure *closure,
                                           GValue *return_value,
                                           guint n_param_values,
                                           const GValue *param_values,
                                           gpointer invocation_hint,
                                           gpointer marshal_data);
extern void g_cclosure_marshal_VOID__FLAGS (GClosure *closure,
                                            GValue *return_value,
                                            guint n_param_values,
                                            const GValue *param_values,
                                            gpointer invocation_hint,
                                            gpointer marshal_data);
extern void g_cclosure_marshal_VOID__FLOAT (GClosure *closure,
                                            GValue *return_value,
                                            guint n_param_values,
                                            const GValue *param_values,
                                            gpointer invocation_hint,
                                            gpointer marshal_data);
extern void g_cclosure_marshal_VOID__DOUBLE (GClosure *closure,
                                             GValue *return_value,
                                             guint n_param_values,
                                             const GValue *param_values,
                                             gpointer invocation_hint,
                                             gpointer marshal_data);
extern void g_cclosure_marshal_VOID__STRING (GClosure *closure,
                                             GValue *return_value,
                                             guint n_param_values,
                                             const GValue *param_values,
                                             gpointer invocation_hint,
                                             gpointer marshal_data);
extern void g_cclosure_marshal_VOID__PARAM (GClosure *closure,
                                            GValue *return_value,
                                            guint n_param_values,
                                            const GValue *param_values,
                                            gpointer invocation_hint,
                                            gpointer marshal_data);
extern void g_cclosure_marshal_VOID__BOXED (GClosure *closure,
                                            GValue *return_value,
                                            guint n_param_values,
                                            const GValue *param_values,
                                            gpointer invocation_hint,
                                            gpointer marshal_data);
extern void g_cclosure_marshal_VOID__POINTER (GClosure *closure,
                                              GValue *return_value,
                                              guint n_param_values,
                                              const GValue *param_values,
                                              gpointer invocation_hint,
                                              gpointer marshal_data);
extern void g_cclosure_marshal_VOID__OBJECT (GClosure *closure,
                                             GValue *return_value,
                                             guint n_param_values,
                                             const GValue *param_values,
                                             gpointer invocation_hint,
                                             gpointer marshal_data);
extern void g_cclosure_marshal_VOID__UINT_POINTER (GClosure *closure,
                                                   GValue *return_value,
                                                   guint n_param_values,
                                                   const GValue *param_values,
                                                   gpointer invocation_hint,
                                                   gpointer marshal_data);
extern void g_cclosure_marshal_BOOLEAN__FLAGS (GClosure *closure,
                                               GValue *return_value,
                                               guint n_param_values,
                                               const GValue *param_values,
                                               gpointer invocation_hint,
                                               gpointer marshal_data);
extern void g_cclosure_marshal_STRING__OBJECT_POINTER (GClosure *closure,
                                                       GValue *return_value,
                                                       guint n_param_values,
                                                       const GValue *param_values,
                                                       gpointer invocation_hint,
                                                       gpointer marshal_data);
}
extern "C" {
typedef struct _GSignalQuery GSignalQuery;
typedef struct _GSignalInvocationHint GSignalInvocationHint;
typedef GClosureMarshal GSignalCMarshaller;
typedef gboolean (*GSignalEmissionHook) (GSignalInvocationHint *ihint,
      guint n_param_values,
      const GValue *param_values,
      gpointer data);
typedef gboolean (*GSignalAccumulator) (GSignalInvocationHint *ihint,
      GValue *return_accu,
      const GValue *handler_return,
      gpointer data);
typedef enum
{
  G_SIGNAL_RUN_FIRST = 1 << 0,
  G_SIGNAL_RUN_LAST = 1 << 1,
  G_SIGNAL_RUN_CLEANUP = 1 << 2,
  G_SIGNAL_NO_RECURSE = 1 << 3,
  G_SIGNAL_DETAILED = 1 << 4,
  G_SIGNAL_ACTION = 1 << 5,
  G_SIGNAL_NO_HOOKS = 1 << 6
} GSignalFlags;
typedef enum
{
  G_CONNECT_AFTER = 1 << 0,
  G_CONNECT_SWAPPED = 1 << 1
} GConnectFlags;
typedef enum
{
  G_SIGNAL_MATCH_ID = 1 << 0,
  G_SIGNAL_MATCH_DETAIL = 1 << 1,
  G_SIGNAL_MATCH_CLOSURE = 1 << 2,
  G_SIGNAL_MATCH_FUNC = 1 << 3,
  G_SIGNAL_MATCH_DATA = 1 << 4,
  G_SIGNAL_MATCH_UNBLOCKED = 1 << 5
} GSignalMatchType;
struct _GSignalInvocationHint
{
  guint signal_id;
  GQuark detail;
  GSignalFlags run_type;
};
struct _GSignalQuery
{
  guint signal_id;
  const gchar *signal_name;
  GType itype;
  GSignalFlags signal_flags;
  GType return_type;
  guint n_params;
  const GType *param_types;
};
guint g_signal_newv (const gchar *signal_name,
          GType itype,
          GSignalFlags signal_flags,
          GClosure *class_closure,
          GSignalAccumulator accumulator,
          gpointer accu_data,
          GSignalCMarshaller c_marshaller,
          GType return_type,
          guint n_params,
          GType *param_types);
guint g_signal_new_valist (const gchar *signal_name,
          GType itype,
          GSignalFlags signal_flags,
          GClosure *class_closure,
          GSignalAccumulator accumulator,
          gpointer accu_data,
          GSignalCMarshaller c_marshaller,
          GType return_type,
          guint n_params,
          va_list args);
guint g_signal_new (const gchar *signal_name,
          GType itype,
          GSignalFlags signal_flags,
          guint class_offset,
          GSignalAccumulator accumulator,
          gpointer accu_data,
          GSignalCMarshaller c_marshaller,
          GType return_type,
          guint n_params,
          ...);
void g_signal_emitv (const GValue *instance_and_params,
          guint signal_id,
          GQuark detail,
          GValue *return_value);
void g_signal_emit_valist (gpointer instance,
          guint signal_id,
          GQuark detail,
          va_list var_args);
void g_signal_emit (gpointer instance,
          guint signal_id,
          GQuark detail,
          ...);
void g_signal_emit_by_name (gpointer instance,
          const gchar *detailed_signal,
          ...);
guint g_signal_lookup (const gchar *name,
          GType itype);
const gchar* g_signal_name (guint signal_id);
void g_signal_query (guint signal_id,
          GSignalQuery *query);
guint* g_signal_list_ids (GType itype,
          guint *n_ids);
gboolean g_signal_parse_name (const gchar *detailed_signal,
          GType itype,
          guint *signal_id_p,
          GQuark *detail_p,
          gboolean force_detail_quark);
GSignalInvocationHint* g_signal_get_invocation_hint (gpointer instance);
void g_signal_stop_emission (gpointer instance,
          guint signal_id,
          GQuark detail);
void g_signal_stop_emission_by_name (gpointer instance,
          const gchar *detailed_signal);
gulong g_signal_add_emission_hook (guint signal_id,
          GQuark detail,
          GSignalEmissionHook hook_func,
          gpointer hook_data,
          GDestroyNotify data_destroy);
void g_signal_remove_emission_hook (guint signal_id,
          gulong hook_id);
gboolean g_signal_has_handler_pending (gpointer instance,
            guint signal_id,
            GQuark detail,
            gboolean may_be_blocked);
gulong g_signal_connect_closure_by_id (gpointer instance,
            guint signal_id,
            GQuark detail,
            GClosure *closure,
            gboolean after);
gulong g_signal_connect_closure (gpointer instance,
            const gchar *detailed_signal,
            GClosure *closure,
            gboolean after);
gulong g_signal_connect_data (gpointer instance,
            const gchar *detailed_signal,
            GCallback c_handler,
            gpointer data,
            GClosureNotify destroy_data,
            GConnectFlags connect_flags);
void g_signal_handler_block (gpointer instance,
            gulong handler_id);
void g_signal_handler_unblock (gpointer instance,
            gulong handler_id);
void g_signal_handler_disconnect (gpointer instance,
            gulong handler_id);
gboolean g_signal_handler_is_connected (gpointer instance,
            gulong handler_id);
gulong g_signal_handler_find (gpointer instance,
            GSignalMatchType mask,
            guint signal_id,
            GQuark detail,
            GClosure *closure,
            gpointer func,
            gpointer data);
guint g_signal_handlers_block_matched (gpointer instance,
            GSignalMatchType mask,
            guint signal_id,
            GQuark detail,
            GClosure *closure,
            gpointer func,
            gpointer data);
guint g_signal_handlers_unblock_matched (gpointer instance,
            GSignalMatchType mask,
            guint signal_id,
            GQuark detail,
            GClosure *closure,
            gpointer func,
            gpointer data);
guint g_signal_handlers_disconnect_matched (gpointer instance,
            GSignalMatchType mask,
            guint signal_id,
            GQuark detail,
            GClosure *closure,
            gpointer func,
            gpointer data);
void g_signal_override_class_closure (guint signal_id,
            GType instance_type,
            GClosure *class_closure);
void g_signal_chain_from_overridden (const GValue *instance_and_params,
            GValue *return_value);
gboolean g_signal_accumulator_true_handled (GSignalInvocationHint *ihint,
         GValue *return_accu,
         const GValue *handler_return,
         gpointer dummy);
void g_signal_handlers_destroy (gpointer instance);
void _g_signals_destroy (GType itype);
}
extern "C" {
typedef struct _GObject GObject;
typedef struct _GObjectClass GObjectClass;
typedef struct _GObject GInitiallyUnowned;
typedef struct _GObjectClass GInitiallyUnownedClass;
typedef struct _GObjectConstructParam GObjectConstructParam;
typedef void (*GObjectGetPropertyFunc) (GObject *object,
                                         guint property_id,
                                         GValue *value,
                                         GParamSpec *pspec);
typedef void (*GObjectSetPropertyFunc) (GObject *object,
                                         guint property_id,
                                         const GValue *value,
                                         GParamSpec *pspec);
typedef void (*GObjectFinalizeFunc) (GObject *object);
typedef void (*GWeakNotify) (gpointer data,
      GObject *where_the_object_was);
struct _GObject
{
  GTypeInstance g_type_instance;
  volatile guint ref_count;
  GData *qdata;
};
struct _GObjectClass
{
  GTypeClass g_type_class;
  GSList *construct_properties;
  GObject* (*constructor) (GType type,
                                 guint n_construct_properties,
                                 GObjectConstructParam *construct_properties);
  void (*set_property) (GObject *object,
                                         guint property_id,
                                         const GValue *value,
                                         GParamSpec *pspec);
  void (*get_property) (GObject *object,
                                         guint property_id,
                                         GValue *value,
                                         GParamSpec *pspec);
  void (*dispose) (GObject *object);
  void (*finalize) (GObject *object);
  void (*dispatch_properties_changed) (GObject *object,
          guint n_pspecs,
          GParamSpec **pspecs);
  void (*notify) (GObject *object,
      GParamSpec *pspec);
  void (*constructed) (GObject *object);
  gpointer pdummy[7];
};
struct _GObjectConstructParam
{
  GParamSpec *pspec;
  GValue *value;
};
GType g_initially_unowned_get_type (void);
void g_object_class_install_property (GObjectClass *oclass,
            guint property_id,
            GParamSpec *pspec);
GParamSpec* g_object_class_find_property (GObjectClass *oclass,
            const gchar *property_name);
GParamSpec**g_object_class_list_properties (GObjectClass *oclass,
            guint *n_properties);
void g_object_class_override_property (GObjectClass *oclass,
            guint property_id,
            const gchar *name);
void g_object_interface_install_property (gpointer g_iface,
       GParamSpec *pspec);
GParamSpec* g_object_interface_find_property (gpointer g_iface,
       const gchar *property_name);
GParamSpec**g_object_interface_list_properties (gpointer g_iface,
       guint *n_properties_p);
gpointer g_object_new (GType object_type,
            const gchar *first_property_name,
            ...);
gpointer g_object_newv (GType object_type,
            guint n_parameters,
            GParameter *parameters);
GObject* g_object_new_valist (GType object_type,
            const gchar *first_property_name,
            va_list var_args);
void g_object_set (gpointer object,
            const gchar *first_property_name,
            ...) __attribute__((__sentinel__));
void g_object_get (gpointer object,
            const gchar *first_property_name,
            ...) __attribute__((__sentinel__));
gpointer g_object_connect (gpointer object,
            const gchar *signal_spec,
            ...) __attribute__((__sentinel__));
void g_object_disconnect (gpointer object,
            const gchar *signal_spec,
            ...) __attribute__((__sentinel__));
void g_object_set_valist (GObject *object,
            const gchar *first_property_name,
            va_list var_args);
void g_object_get_valist (GObject *object,
            const gchar *first_property_name,
            va_list var_args);
void g_object_set_property (GObject *object,
            const gchar *property_name,
            const GValue *value);
void g_object_get_property (GObject *object,
            const gchar *property_name,
            GValue *value);
void g_object_freeze_notify (GObject *object);
void g_object_notify (GObject *object,
            const gchar *property_name);
void g_object_thaw_notify (GObject *object);
gboolean g_object_is_floating (gpointer object);
gpointer g_object_ref_sink (gpointer object);
gpointer g_object_ref (gpointer object);
void g_object_unref (gpointer object);
void g_object_weak_ref (GObject *object,
            GWeakNotify notify,
            gpointer data);
void g_object_weak_unref (GObject *object,
            GWeakNotify notify,
            gpointer data);
void g_object_add_weak_pointer (GObject *object,
                                               gpointer *weak_pointer_location);
void g_object_remove_weak_pointer (GObject *object,
                                               gpointer *weak_pointer_location);
typedef void (*GToggleNotify) (gpointer data,
          GObject *object,
          gboolean is_last_ref);
void g_object_add_toggle_ref (GObject *object,
     GToggleNotify notify,
     gpointer data);
void g_object_remove_toggle_ref (GObject *object,
     GToggleNotify notify,
     gpointer data);
gpointer g_object_get_qdata (GObject *object,
            GQuark quark);
void g_object_set_qdata (GObject *object,
            GQuark quark,
            gpointer data);
void g_object_set_qdata_full (GObject *object,
            GQuark quark,
            gpointer data,
            GDestroyNotify destroy);
gpointer g_object_steal_qdata (GObject *object,
            GQuark quark);
gpointer g_object_get_data (GObject *object,
            const gchar *key);
void g_object_set_data (GObject *object,
            const gchar *key,
            gpointer data);
void g_object_set_data_full (GObject *object,
            const gchar *key,
            gpointer data,
            GDestroyNotify destroy);
gpointer g_object_steal_data (GObject *object,
            const gchar *key);
void g_object_watch_closure (GObject *object,
            GClosure *closure);
GClosure* g_cclosure_new_object (GCallback callback_func,
            GObject *object);
GClosure* g_cclosure_new_object_swap (GCallback callback_func,
            GObject *object);
GClosure* g_closure_new_object (guint sizeof_closure,
            GObject *object);
void g_value_set_object (GValue *value,
            gpointer v_object);
gpointer g_value_get_object (const GValue *value);
gpointer g_value_dup_object (const GValue *value);
gulong g_signal_connect_object (gpointer instance,
            const gchar *detailed_signal,
            GCallback c_handler,
            gpointer gobject,
            GConnectFlags connect_flags);
void g_object_force_floating (GObject *object);
void g_object_run_dispose (GObject *object);
void g_value_take_object (GValue *value,
            gpointer v_object);
void g_value_set_object_take_ownership (GValue *value,
            gpointer v_object);
gsize g_object_compat_control (gsize what,
            gpointer data);
}
extern "C" {
typedef struct _GParamSpecChar GParamSpecChar;
typedef struct _GParamSpecUChar GParamSpecUChar;
typedef struct _GParamSpecBoolean GParamSpecBoolean;
typedef struct _GParamSpecInt GParamSpecInt;
typedef struct _GParamSpecUInt GParamSpecUInt;
typedef struct _GParamSpecLong GParamSpecLong;
typedef struct _GParamSpecULong GParamSpecULong;
typedef struct _GParamSpecInt64 GParamSpecInt64;
typedef struct _GParamSpecUInt64 GParamSpecUInt64;
typedef struct _GParamSpecUnichar GParamSpecUnichar;
typedef struct _GParamSpecEnum GParamSpecEnum;
typedef struct _GParamSpecFlags GParamSpecFlags;
typedef struct _GParamSpecFloat GParamSpecFloat;
typedef struct _GParamSpecDouble GParamSpecDouble;
typedef struct _GParamSpecString GParamSpecString;
typedef struct _GParamSpecParam GParamSpecParam;
typedef struct _GParamSpecBoxed GParamSpecBoxed;
typedef struct _GParamSpecPointer GParamSpecPointer;
typedef struct _GParamSpecValueArray GParamSpecValueArray;
typedef struct _GParamSpecObject GParamSpecObject;
typedef struct _GParamSpecOverride GParamSpecOverride;
typedef struct _GParamSpecGType GParamSpecGType;
struct _GParamSpecChar
{
  GParamSpec parent_instance;
  gint8 minimum;
  gint8 maximum;
  gint8 default_value;
};
struct _GParamSpecUChar
{
  GParamSpec parent_instance;
  guint8 minimum;
  guint8 maximum;
  guint8 default_value;
};
struct _GParamSpecBoolean
{
  GParamSpec parent_instance;
  gboolean default_value;
};
struct _GParamSpecInt
{
  GParamSpec parent_instance;
  gint minimum;
  gint maximum;
  gint default_value;
};
struct _GParamSpecUInt
{
  GParamSpec parent_instance;
  guint minimum;
  guint maximum;
  guint default_value;
};
struct _GParamSpecLong
{
  GParamSpec parent_instance;
  glong minimum;
  glong maximum;
  glong default_value;
};
struct _GParamSpecULong
{
  GParamSpec parent_instance;
  gulong minimum;
  gulong maximum;
  gulong default_value;
};
struct _GParamSpecInt64
{
  GParamSpec parent_instance;
  gint64 minimum;
  gint64 maximum;
  gint64 default_value;
};
struct _GParamSpecUInt64
{
  GParamSpec parent_instance;
  guint64 minimum;
  guint64 maximum;
  guint64 default_value;
};
struct _GParamSpecUnichar
{
  GParamSpec parent_instance;
  gunichar default_value;
};
struct _GParamSpecEnum
{
  GParamSpec parent_instance;
  GEnumClass *enum_class;
  gint default_value;
};
struct _GParamSpecFlags
{
  GParamSpec parent_instance;
  GFlagsClass *flags_class;
  guint default_value;
};
struct _GParamSpecFloat
{
  GParamSpec parent_instance;
  gfloat minimum;
  gfloat maximum;
  gfloat default_value;
  gfloat epsilon;
};
struct _GParamSpecDouble
{
  GParamSpec parent_instance;
  gdouble minimum;
  gdouble maximum;
  gdouble default_value;
  gdouble epsilon;
};
struct _GParamSpecString
{
  GParamSpec parent_instance;
  gchar *default_value;
  gchar *cset_first;
  gchar *cset_nth;
  gchar substitutor;
  guint null_fold_if_empty : 1;
  guint ensure_non_null : 1;
};
struct _GParamSpecParam
{
  GParamSpec parent_instance;
};
struct _GParamSpecBoxed
{
  GParamSpec parent_instance;
};
struct _GParamSpecPointer
{
  GParamSpec parent_instance;
};
struct _GParamSpecValueArray
{
  GParamSpec parent_instance;
  GParamSpec *element_spec;
  guint fixed_n_elements;
};
struct _GParamSpecObject
{
  GParamSpec parent_instance;
};
struct _GParamSpecOverride
{
  GParamSpec parent_instance;
  GParamSpec *overridden;
};
struct _GParamSpecGType
{
  GParamSpec parent_instance;
  GType is_a_type;
};
GParamSpec* g_param_spec_char (const gchar *name,
       const gchar *nick,
       const gchar *blurb,
       gint8 minimum,
       gint8 maximum,
       gint8 default_value,
       GParamFlags flags);
GParamSpec* g_param_spec_uchar (const gchar *name,
       const gchar *nick,
       const gchar *blurb,
       guint8 minimum,
       guint8 maximum,
       guint8 default_value,
       GParamFlags flags);
GParamSpec* g_param_spec_boolean (const gchar *name,
       const gchar *nick,
       const gchar *blurb,
       gboolean default_value,
       GParamFlags flags);
GParamSpec* g_param_spec_int (const gchar *name,
       const gchar *nick,
       const gchar *blurb,
       gint minimum,
       gint maximum,
       gint default_value,
       GParamFlags flags);
GParamSpec* g_param_spec_uint (const gchar *name,
       const gchar *nick,
       const gchar *blurb,
       guint minimum,
       guint maximum,
       guint default_value,
       GParamFlags flags);
GParamSpec* g_param_spec_long (const gchar *name,
       const gchar *nick,
       const gchar *blurb,
       glong minimum,
       glong maximum,
       glong default_value,
       GParamFlags flags);
GParamSpec* g_param_spec_ulong (const gchar *name,
       const gchar *nick,
       const gchar *blurb,
       gulong minimum,
       gulong maximum,
       gulong default_value,
       GParamFlags flags);
GParamSpec* g_param_spec_int64 (const gchar *name,
       const gchar *nick,
       const gchar *blurb,
       gint64 minimum,
       gint64 maximum,
       gint64 default_value,
       GParamFlags flags);
GParamSpec* g_param_spec_uint64 (const gchar *name,
       const gchar *nick,
       const gchar *blurb,
       guint64 minimum,
       guint64 maximum,
       guint64 default_value,
       GParamFlags flags);
GParamSpec* g_param_spec_unichar (const gchar *name,
              const gchar *nick,
              const gchar *blurb,
              gunichar default_value,
              GParamFlags flags);
GParamSpec* g_param_spec_enum (const gchar *name,
       const gchar *nick,
       const gchar *blurb,
       GType enum_type,
       gint default_value,
       GParamFlags flags);
GParamSpec* g_param_spec_flags (const gchar *name,
       const gchar *nick,
       const gchar *blurb,
       GType flags_type,
       guint default_value,
       GParamFlags flags);
GParamSpec* g_param_spec_float (const gchar *name,
       const gchar *nick,
       const gchar *blurb,
       gfloat minimum,
       gfloat maximum,
       gfloat default_value,
       GParamFlags flags);
GParamSpec* g_param_spec_double (const gchar *name,
       const gchar *nick,
       const gchar *blurb,
       gdouble minimum,
       gdouble maximum,
       gdouble default_value,
       GParamFlags flags);
GParamSpec* g_param_spec_string (const gchar *name,
       const gchar *nick,
       const gchar *blurb,
       const gchar *default_value,
       GParamFlags flags);
GParamSpec* g_param_spec_param (const gchar *name,
       const gchar *nick,
       const gchar *blurb,
       GType param_type,
       GParamFlags flags);
GParamSpec* g_param_spec_boxed (const gchar *name,
       const gchar *nick,
       const gchar *blurb,
       GType boxed_type,
       GParamFlags flags);
GParamSpec* g_param_spec_pointer (const gchar *name,
       const gchar *nick,
       const gchar *blurb,
       GParamFlags flags);
GParamSpec* g_param_spec_value_array (const gchar *name,
       const gchar *nick,
       const gchar *blurb,
       GParamSpec *element_spec,
       GParamFlags flags);
GParamSpec* g_param_spec_object (const gchar *name,
       const gchar *nick,
       const gchar *blurb,
       GType object_type,
       GParamFlags flags);
GParamSpec* g_param_spec_override (const gchar *name,
       GParamSpec *overridden);
GParamSpec* g_param_spec_gtype (const gchar *name,
       const gchar *nick,
       const gchar *blurb,
       GType is_a_type,
       GParamFlags flags);
extern GType *g_param_spec_types;
}
extern "C" {
void g_source_set_closure (GSource *source,
      GClosure *closure);
GType g_io_channel_get_type (void);
GType g_io_condition_get_type (void);
}
extern "C" {
typedef struct _GTypeModule GTypeModule;
typedef struct _GTypeModuleClass GTypeModuleClass;
struct _GTypeModule
{
  GObject parent_instance;
  guint use_count;
  GSList *type_infos;
  GSList *interface_infos;
  gchar *name;
};
struct _GTypeModuleClass
{
  GObjectClass parent_class;
  gboolean (* load) (GTypeModule *module);
  void (* unload) (GTypeModule *module);
  void (*reserved1) (void);
  void (*reserved2) (void);
  void (*reserved3) (void);
  void (*reserved4) (void);
};
GType g_type_module_get_type (void) __attribute__((__const__));
gboolean g_type_module_use (GTypeModule *module);
void g_type_module_unuse (GTypeModule *module);
void g_type_module_set_name (GTypeModule *module,
                                       const gchar *name);
GType g_type_module_register_type (GTypeModule *module,
                                       GType parent_type,
                                       const gchar *type_name,
                                       const GTypeInfo *type_info,
                                       GTypeFlags flags);
void g_type_module_add_interface (GTypeModule *module,
                                       GType instance_type,
                                       GType interface_type,
                                       const GInterfaceInfo *interface_info);
GType g_type_module_register_enum (GTypeModule *module,
                                       const gchar *name,
                                       const GEnumValue *const_static_values);
GType g_type_module_register_flags (GTypeModule *module,
                                       const gchar *name,
                                       const GFlagsValue *const_static_values);
}
extern "C" {
typedef struct _GTypePluginClass GTypePluginClass;
typedef void (*GTypePluginUse) (GTypePlugin *plugin);
typedef void (*GTypePluginUnuse) (GTypePlugin *plugin);
typedef void (*GTypePluginCompleteTypeInfo) (GTypePlugin *plugin,
         GType g_type,
         GTypeInfo *info,
         GTypeValueTable *value_table);
typedef void (*GTypePluginCompleteInterfaceInfo) (GTypePlugin *plugin,
         GType instance_type,
         GType interface_type,
         GInterfaceInfo *info);
struct _GTypePluginClass
{
  GTypeInterface base_iface;
  GTypePluginUse use_plugin;
  GTypePluginUnuse unuse_plugin;
  GTypePluginCompleteTypeInfo complete_type_info;
  GTypePluginCompleteInterfaceInfo complete_interface_info;
};
GType g_type_plugin_get_type (void) __attribute__((__const__));
void g_type_plugin_use (GTypePlugin *plugin);
void g_type_plugin_unuse (GTypePlugin *plugin);
void g_type_plugin_complete_type_info (GTypePlugin *plugin,
       GType g_type,
       GTypeInfo *info,
       GTypeValueTable *value_table);
void g_type_plugin_complete_interface_info (GTypePlugin *plugin,
       GType instance_type,
       GType interface_type,
       GInterfaceInfo *info);
}
extern "C" {
typedef struct _GValueArray GValueArray;
struct _GValueArray
{
  guint n_values;
  GValue *values;
  guint n_prealloced;
};
GValue* g_value_array_get_nth (GValueArray *value_array,
           guint index_);
GValueArray* g_value_array_new (guint n_prealloced);
void g_value_array_free (GValueArray *value_array);
GValueArray* g_value_array_copy (const GValueArray *value_array);
GValueArray* g_value_array_prepend (GValueArray *value_array,
           const GValue *value);
GValueArray* g_value_array_append (GValueArray *value_array,
           const GValue *value);
GValueArray* g_value_array_insert (GValueArray *value_array,
           guint index_,
           const GValue *value);
GValueArray* g_value_array_remove (GValueArray *value_array,
           guint index_);
GValueArray* g_value_array_sort (GValueArray *value_array,
           GCompareFunc compare_func);
GValueArray* g_value_array_sort_with_data (GValueArray *value_array,
           GCompareDataFunc compare_func,
           gpointer user_data);
}
extern "C" {
void g_value_set_char (GValue *value,
       gchar v_char);
gchar g_value_get_char (const GValue *value);
void g_value_set_uchar (GValue *value,
       guchar v_uchar);
guchar g_value_get_uchar (const GValue *value);
void g_value_set_boolean (GValue *value,
       gboolean v_boolean);
gboolean g_value_get_boolean (const GValue *value);
void g_value_set_int (GValue *value,
       gint v_int);
gint g_value_get_int (const GValue *value);
void g_value_set_uint (GValue *value,
       guint v_uint);
guint g_value_get_uint (const GValue *value);
void g_value_set_long (GValue *value,
       glong v_long);
glong g_value_get_long (const GValue *value);
void g_value_set_ulong (GValue *value,
       gulong v_ulong);
gulong g_value_get_ulong (const GValue *value);
void g_value_set_int64 (GValue *value,
       gint64 v_int64);
gint64 g_value_get_int64 (const GValue *value);
void g_value_set_uint64 (GValue *value,
       guint64 v_uint64);
guint64 g_value_get_uint64 (const GValue *value);
void g_value_set_float (GValue *value,
       gfloat v_float);
gfloat g_value_get_float (const GValue *value);
void g_value_set_double (GValue *value,
       gdouble v_double);
gdouble g_value_get_double (const GValue *value);
void g_value_set_string (GValue *value,
       const gchar *v_string);
void g_value_set_static_string (GValue *value,
       const gchar *v_string);
const gchar* g_value_get_string (const GValue *value);
gchar* g_value_dup_string (const GValue *value);
void g_value_set_pointer (GValue *value,
       gpointer v_pointer);
gpointer g_value_get_pointer (const GValue *value);
GType g_gtype_get_type (void);
void g_value_set_gtype (GValue *value,
       GType v_gtype);
GType g_value_get_gtype (const GValue *value);
GType g_pointer_type_register_static (const gchar *name);
gchar* g_strdup_value_contents (const GValue *value);
void g_value_take_string (GValue *value,
       gchar *v_string);
void g_value_set_string_take_ownership (GValue *value,
       gchar *v_string);
typedef gchar* gchararray;
}
namespace Glib
{
template <class T_CppObject>
class RefPtr
{
public:
  inline RefPtr();
  inline ~RefPtr();
  explicit inline RefPtr(T_CppObject* pCppObject);
  inline RefPtr(const RefPtr<T_CppObject>& src);
  template <class T_CastFrom>
  inline RefPtr(const RefPtr<T_CastFrom>& src);
  inline void swap(RefPtr<T_CppObject>& other);
  inline RefPtr<T_CppObject>& operator=(const RefPtr<T_CppObject>& src);
  template <class T_CastFrom>
  inline RefPtr<T_CppObject>& operator=(const RefPtr<T_CastFrom>& src);
  inline bool operator==(const RefPtr<T_CppObject>& src) const;
  inline bool operator!=(const RefPtr<T_CppObject>& src) const;
  inline T_CppObject* operator->() const;
  inline operator bool() const;
  inline void clear();
  template <class T_CastFrom>
  static inline RefPtr<T_CppObject> cast_dynamic(const RefPtr<T_CastFrom>& src);
  template <class T_CastFrom>
  static inline RefPtr<T_CppObject> cast_static(const RefPtr<T_CastFrom>& src);
  template <class T_CastFrom>
  static inline RefPtr<T_CppObject> cast_const(const RefPtr<T_CastFrom>& src);
private:
  T_CppObject* pCppObject_;
};
template <class T_CppObject> inline
T_CppObject* RefPtr<T_CppObject>::operator->() const
{
  return pCppObject_;
}
template <class T_CppObject> inline
RefPtr<T_CppObject>::RefPtr()
:
  pCppObject_ (0)
{}
template <class T_CppObject> inline
RefPtr<T_CppObject>::~RefPtr()
{
  if(pCppObject_)
    pCppObject_->unreference();
}
template <class T_CppObject> inline
RefPtr<T_CppObject>::RefPtr(T_CppObject* pCppObject)
:
  pCppObject_ (pCppObject)
{}
template <class T_CppObject> inline
RefPtr<T_CppObject>::RefPtr(const RefPtr<T_CppObject>& src)
:
  pCppObject_ (src.pCppObject_)
{
  if(pCppObject_)
    pCppObject_->reference();
}
template <class T_CppObject>
  template <class T_CastFrom>
inline
RefPtr<T_CppObject>::RefPtr(const RefPtr<T_CastFrom>& src)
:
  pCppObject_ (src.operator->())
{
  if(pCppObject_)
    pCppObject_->reference();
}
template <class T_CppObject> inline
void RefPtr<T_CppObject>::swap(RefPtr<T_CppObject>& other)
{
  T_CppObject *const temp = pCppObject_;
  pCppObject_ = other.pCppObject_;
  other.pCppObject_ = temp;
}
template <class T_CppObject> inline
RefPtr<T_CppObject>& RefPtr<T_CppObject>::operator=(const RefPtr<T_CppObject>& src)
{
  RefPtr<T_CppObject> temp (src);
  this->swap(temp);
  return *this;
}
template <class T_CppObject>
  template <class T_CastFrom>
inline
RefPtr<T_CppObject>& RefPtr<T_CppObject>::operator=(const RefPtr<T_CastFrom>& src)
{
  RefPtr<T_CppObject> temp (src);
  this->swap(temp);
  return *this;
}
template <class T_CppObject> inline
bool RefPtr<T_CppObject>::operator==(const RefPtr<T_CppObject>& src) const
{
  return (pCppObject_ == src.pCppObject_);
}
template <class T_CppObject> inline
bool RefPtr<T_CppObject>::operator!=(const RefPtr<T_CppObject>& src) const
{
  return (pCppObject_ != src.pCppObject_);
}
template <class T_CppObject> inline
RefPtr<T_CppObject>::operator bool() const
{
  return (pCppObject_ != 0);
}
template <class T_CppObject> inline
void RefPtr<T_CppObject>::clear()
{
  RefPtr<T_CppObject> temp;
  this->swap(temp);
}
template <class T_CppObject>
  template <class T_CastFrom>
inline
RefPtr<T_CppObject> RefPtr<T_CppObject>::cast_dynamic(const RefPtr<T_CastFrom>& src)
{
  T_CppObject *const pCppObject = dynamic_cast<T_CppObject*>(src.operator->());
  if(pCppObject)
    pCppObject->reference();
  return RefPtr<T_CppObject>(pCppObject);
}
template <class T_CppObject>
  template <class T_CastFrom>
inline
RefPtr<T_CppObject> RefPtr<T_CppObject>::cast_static(const RefPtr<T_CastFrom>& src)
{
  T_CppObject *const pCppObject = static_cast<T_CppObject*>(src.operator->());
  if(pCppObject)
    pCppObject->reference();
  return RefPtr<T_CppObject>(pCppObject);
}
template <class T_CppObject>
  template <class T_CastFrom>
inline
RefPtr<T_CppObject> RefPtr<T_CppObject>::cast_const(const RefPtr<T_CastFrom>& src)
{
  T_CppObject *const pCppObject = const_cast<T_CppObject*>(src.operator->());
  if(pCppObject)
    pCppObject->reference();
  return RefPtr<T_CppObject>(pCppObject);
}
template <class T_CppObject> inline
void swap(RefPtr<T_CppObject>& lhs, RefPtr<T_CppObject>& rhs)
{
  lhs.swap(rhs);
}
}
namespace Glib
{
enum UnicodeType
{
  UNICODE_CONTROL,
  UNICODE_FORMAT,
  UNICODE_UNASSIGNED,
  UNICODE_PRIVATE_USE,
  UNICODE_SURROGATE,
  UNICODE_LOWERCASE_LETTER,
  UNICODE_MODIFIER_LETTER,
  UNICODE_OTHER_LETTER,
  UNICODE_TITLECASE_LETTER,
  UNICODE_UPPERCASE_LETTER,
  UNICODE_COMBINING_MARK,
  UNICODE_ENCLOSING_MARK,
  UNICODE_NON_SPACING_MARK,
  UNICODE_DECIMAL_NUMBER,
  UNICODE_LETTER_NUMBER,
  UNICODE_OTHER_NUMBER,
  UNICODE_CONNECT_PUNCTUATION,
  UNICODE_DASH_PUNCTUATION,
  UNICODE_CLOSE_PUNCTUATION,
  UNICODE_FINAL_PUNCTUATION,
  UNICODE_INITIAL_PUNCTUATION,
  UNICODE_OTHER_PUNCTUATION,
  UNICODE_OPEN_PUNCTUATION,
  UNICODE_CURRENCY_SYMBOL,
  UNICODE_MODIFIER_SYMBOL,
  UNICODE_MATH_SYMBOL,
  UNICODE_OTHER_SYMBOL,
  UNICODE_LINE_SEPARATOR,
  UNICODE_PARAGRAPH_SEPARATOR,
  UNICODE_SPACE_SEPARATOR
};
enum UnicodeBreakType
{
  UNICODE_BREAK_MANDATORY,
  UNICODE_BREAK_CARRIAGE_RETURN,
  UNICODE_BREAK_LINE_FEED,
  UNICODE_BREAK_COMBINING_MARK,
  UNICODE_BREAK_SURROGATE,
  UNICODE_BREAK_ZERO_WIDTH_SPACE,
  UNICODE_BREAK_INSEPARABLE,
  UNICODE_BREAK_NON_BREAKING_GLUE,
  UNICODE_BREAK_CONTINGENT,
  UNICODE_BREAK_SPACE,
  UNICODE_BREAK_AFTER,
  UNICODE_BREAK_BEFORE,
  UNICODE_BREAK_BEFORE_AND_AFTER,
  UNICODE_BREAK_HYPHEN,
  UNICODE_BREAK_NON_STARTER,
  UNICODE_BREAK_OPEN_PUNCTUATION,
  UNICODE_BREAK_CLOSE_PUNCTUATION,
  UNICODE_BREAK_QUOTATION,
  UNICODE_BREAK_EXCLAMATION,
  UNICODE_BREAK_IDEOGRAPHIC,
  UNICODE_BREAK_NUMERIC,
  UNICODE_BREAK_INFIX_SEPARATOR,
  UNICODE_BREAK_SYMBOL,
  UNICODE_BREAK_ALPHABETIC,
  UNICODE_BREAK_PREFIX,
  UNICODE_BREAK_POSTFIX,
  UNICODE_BREAK_COMPLEX_CONTEXT,
  UNICODE_BREAK_AMBIGUOUS,
  UNICODE_BREAK_UNKNOWN,
  UNICODE_BREAK_NEXT_LINE,
  UNICODE_BREAK_WORD_JOINER,
  UNICODE_BREAK_HANGUL_L_JAMO,
  UNICODE_BREAK_HANGUL_V_JAMO,
  UNICODE_BREAK_HANGUL_T_JAMO,
  UNICODE_BREAK_HANGUL_LV_SYLLABLE,
  UNICODE_BREAK_HANGUL_LVT_SYLLABLE
};
enum AsciiType
{
  ASCII_ALNUM = 1 << 0,
  ASCII_ALPHA = 1 << 1,
  ASCII_CNTRL = 1 << 2,
  ASCII_DIGIT = 1 << 3,
  ASCII_GRAPH = 1 << 4,
  ASCII_LOWER = 1 << 5,
  ASCII_PRINT = 1 << 6,
  ASCII_PUNCT = 1 << 7,
  ASCII_SPACE = 1 << 8,
  ASCII_UPPER = 1 << 9,
  ASCII_XDIGIT = 1 << 10
};
inline AsciiType operator|(AsciiType lhs, AsciiType rhs)
  { return static_cast<AsciiType>(static_cast<unsigned>(lhs) | static_cast<unsigned>(rhs)); }
inline AsciiType operator&(AsciiType lhs, AsciiType rhs)
  { return static_cast<AsciiType>(static_cast<unsigned>(lhs) & static_cast<unsigned>(rhs)); }
inline AsciiType operator^(AsciiType lhs, AsciiType rhs)
  { return static_cast<AsciiType>(static_cast<unsigned>(lhs) ^ static_cast<unsigned>(rhs)); }
inline AsciiType operator~(AsciiType flags)
  { return static_cast<AsciiType>(~static_cast<unsigned>(flags)); }
inline AsciiType& operator|=(AsciiType& lhs, AsciiType rhs)
  { return (lhs = static_cast<AsciiType>(static_cast<unsigned>(lhs) | static_cast<unsigned>(rhs))); }
inline AsciiType& operator&=(AsciiType& lhs, AsciiType rhs)
  { return (lhs = static_cast<AsciiType>(static_cast<unsigned>(lhs) & static_cast<unsigned>(rhs))); }
inline AsciiType& operator^=(AsciiType& lhs, AsciiType rhs)
  { return (lhs = static_cast<AsciiType>(static_cast<unsigned>(lhs) ^ static_cast<unsigned>(rhs))); }
enum NormalizeMode
{
  NORMALIZE_DEFAULT,
  NORMALIZE_NFD,
  NORMALIZE_DEFAULT_COMPOSE,
  NORMALIZE_NFC = NORMALIZE_DEFAULT_COMPOSE,
  NORMALIZE_ALL,
  NORMALIZE_NFKD = NORMALIZE_ALL,
  NORMALIZE_ALL_COMPOSE,
  NORMALIZE_NFKC = NORMALIZE_ALL_COMPOSE
};
namespace Unicode
{
inline bool validate(gunichar uc)
  { return (g_unichar_validate(uc) != 0); }
inline bool isalnum(gunichar uc)
  { return (g_unichar_isalnum(uc) != 0); }
inline bool isalpha(gunichar uc)
  { return (g_unichar_isalpha(uc) != 0); }
inline bool iscntrl(gunichar uc)
  { return (g_unichar_iscntrl(uc) != 0); }
inline bool isdigit(gunichar uc)
  { return (g_unichar_isdigit(uc) != 0); }
inline bool isgraph(gunichar uc)
  { return (g_unichar_isgraph(uc) != 0); }
inline bool islower(gunichar uc)
  { return (g_unichar_islower(uc) != 0); }
inline bool isprint(gunichar uc)
  { return (g_unichar_isprint(uc) != 0); }
inline bool ispunct(gunichar uc)
  { return (g_unichar_ispunct(uc) != 0); }
inline bool isspace(gunichar uc)
  { return (g_unichar_isspace(uc) != 0); }
inline bool isupper(gunichar uc)
  { return (g_unichar_isupper(uc) != 0); }
inline bool isxdigit(gunichar uc)
  { return (g_unichar_isxdigit(uc) != 0); }
inline bool istitle(gunichar uc)
  { return (g_unichar_istitle(uc) != 0); }
inline bool isdefined(gunichar uc)
  { return (g_unichar_isdefined(uc) != 0); }
inline bool iswide(gunichar uc)
  { return (g_unichar_iswide(uc) != 0); }
inline gunichar toupper(gunichar uc)
  { return g_unichar_toupper(uc); }
inline gunichar tolower(gunichar uc)
  { return g_unichar_tolower(uc); }
inline gunichar totitle(gunichar uc)
  { return g_unichar_totitle(uc); }
inline int digit_value(gunichar uc)
  { return g_unichar_digit_value(uc); }
inline int xdigit_value(gunichar uc)
  { return g_unichar_xdigit_value(uc); }
inline Glib::UnicodeType type(gunichar uc)
  { return static_cast<Glib::UnicodeType>(static_cast<int>(g_unichar_type(uc))); }
inline Glib::UnicodeBreakType break_type(gunichar uc)
  { return static_cast<Glib::UnicodeBreakType>(static_cast<int>(g_unichar_break_type(uc))); }
}
namespace Ascii
{
inline bool isalnum(char c)
  { return ((g_ascii_table[(guchar) (c)] & G_ASCII_ALNUM) != 0); }
inline bool isalpha(char c)
  { return ((g_ascii_table[(guchar) (c)] & G_ASCII_ALPHA) != 0); }
inline bool iscntrl(char c)
  { return ((g_ascii_table[(guchar) (c)] & G_ASCII_CNTRL) != 0); }
inline bool isdigit(char c)
  { return ((g_ascii_table[(guchar) (c)] & G_ASCII_DIGIT) != 0); }
inline bool isgraph(char c)
  { return ((g_ascii_table[(guchar) (c)] & G_ASCII_GRAPH) != 0); }
inline bool islower(char c)
  { return ((g_ascii_table[(guchar) (c)] & G_ASCII_LOWER) != 0); }
inline bool isprint(char c)
  { return ((g_ascii_table[(guchar) (c)] & G_ASCII_PRINT) != 0); }
inline bool ispunct(char c)
  { return ((g_ascii_table[(guchar) (c)] & G_ASCII_PUNCT) != 0); }
inline bool isspace(char c)
  { return ((g_ascii_table[(guchar) (c)] & G_ASCII_SPACE) != 0); }
inline bool isupper(char c)
  { return ((g_ascii_table[(guchar) (c)] & G_ASCII_UPPER) != 0); }
inline bool isxdigit(char c)
  { return ((g_ascii_table[(guchar) (c)] & G_ASCII_XDIGIT) != 0); }
inline char tolower(char c)
  { return g_ascii_tolower(c); }
inline char toupper(char c)
  { return g_ascii_toupper(c); }
inline int digit_value(char c)
  { return g_ascii_digit_value(c); }
inline int xdigit_value(char c)
  { return g_ascii_xdigit_value(c); }
}
}
namespace Glib
{
template <class T>
class ustring_Iterator
{
public:
  typedef std::bidirectional_iterator_tag iterator_category;
  typedef gunichar value_type;
  typedef std::string::difference_type difference_type;
  typedef value_type reference;
  typedef void pointer;
  inline ustring_Iterator();
  inline ustring_Iterator(const ustring_Iterator<std::string::iterator>& other);
  inline value_type operator*() const;
  inline ustring_Iterator<T> & operator++();
  inline const ustring_Iterator<T> operator++(int);
  inline ustring_Iterator<T> & operator--();
  inline const ustring_Iterator<T> operator--(int);
  explicit inline ustring_Iterator(T pos);
  inline T base() const;
private:
  T pos_;
};
gunichar get_unichar_from_std_iterator(std::string::const_iterator pos) __attribute__((__pure__));
class ustring
{
public:
  typedef std::string::size_type size_type;
  typedef std::string::difference_type difference_type;
  typedef gunichar value_type;
  typedef gunichar & reference;
  typedef const gunichar & const_reference;
  typedef ustring_Iterator<std::string::iterator> iterator;
  typedef ustring_Iterator<std::string::const_iterator> const_iterator;
  typedef std::reverse_iterator<iterator> reverse_iterator;
  typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
  static const size_type npos = std::string::npos;
  ustring();
  ~ustring();
  ustring(const ustring& other);
  ustring& operator=(const ustring& other);
  void swap(ustring& other);
  ustring(const std::string& src);
  ustring(const ustring& src, size_type i, size_type n=npos);
  ustring(const char* src, size_type n);
  ustring(const char* src);
  ustring(size_type n, gunichar uc);
  ustring(size_type n, char c);
  template <class In> ustring(In pbegin, In pend);
  ustring& operator=(const std::string& src);
  ustring& operator=(const char* src);
  ustring& operator=(gunichar uc);
  ustring& operator=(char c);
  ustring& assign(const ustring& src);
  ustring& assign(const ustring& src, size_type i, size_type n);
  ustring& assign(const char* src, size_type n);
  ustring& assign(const char* src);
  ustring& assign(size_type n, gunichar uc);
  ustring& assign(size_type n, char c);
  template <class In> ustring& assign(In pbegin, In pend);
  ustring& operator+=(const ustring& src);
  ustring& operator+=(const char* src);
  ustring& operator+=(gunichar uc);
  ustring& operator+=(char c);
  void push_back(gunichar uc);
  void push_back(char c);
  ustring& append(const ustring& src);
  ustring& append(const ustring& src, size_type i, size_type n);
  ustring& append(const char* src, size_type n);
  ustring& append(const char* src);
  ustring& append(size_type n, gunichar uc);
  ustring& append(size_type n, char c);
  template <class In> ustring& append(In pbegin, In pend);
  ustring& insert(size_type i, const ustring& src);
  ustring& insert(size_type i, const ustring& src, size_type i2, size_type n);
  ustring& insert(size_type i, const char* src, size_type n);
  ustring& insert(size_type i, const char* src);
  ustring& insert(size_type i, size_type n, gunichar uc);
  ustring& insert(size_type i, size_type n, char c);
  iterator insert(iterator p, gunichar uc);
  iterator insert(iterator p, char c);
  void insert(iterator p, size_type n, gunichar uc);
  void insert(iterator p, size_type n, char c);
  template <class In> void insert(iterator p, In pbegin, In pend);
  ustring& replace(size_type i, size_type n, const ustring& src);
  ustring& replace(size_type i, size_type n, const ustring& src, size_type i2, size_type n2);
  ustring& replace(size_type i, size_type n, const char* src, size_type n2);
  ustring& replace(size_type i, size_type n, const char* src);
  ustring& replace(size_type i, size_type n, size_type n2, gunichar uc);
  ustring& replace(size_type i, size_type n, size_type n2, char c);
  ustring& replace(iterator pbegin, iterator pend, const ustring& src);
  ustring& replace(iterator pbegin, iterator pend, const char* src, size_type n);
  ustring& replace(iterator pbegin, iterator pend, const char* src);
  ustring& replace(iterator pbegin, iterator pend, size_type n, gunichar uc);
  ustring& replace(iterator pbegin, iterator pend, size_type n, char c);
  template <class In> ustring& replace(iterator pbegin, iterator pend, In pbegin2, In pend2);
  void clear();
  ustring& erase(size_type i, size_type n=npos);
  ustring& erase();
  iterator erase(iterator p);
  iterator erase(iterator pbegin, iterator pend);
  int compare(const ustring& rhs) const;
  int compare(const char* rhs) const;
  int compare(size_type i, size_type n, const ustring& rhs) const;
  int compare(size_type i, size_type n, const ustring& rhs, size_type i2, size_type n2) const;
  int compare(size_type i, size_type n, const char* rhs, size_type n2) const;
  int compare(size_type i, size_type n, const char* rhs) const;
  std::string collate_key() const;
  std::string casefold_collate_key() const;
  value_type operator[](size_type i) const;
  value_type at(size_type i) const;
  inline ustring substr(size_type i=0, size_type n=npos) const;
  iterator begin();
  iterator end();
  const_iterator begin() const;
  const_iterator end() const;
  reverse_iterator rbegin();
  reverse_iterator rend();
  const_reverse_iterator rbegin() const;
  const_reverse_iterator rend() const;
  size_type find(const ustring& str, size_type i=0) const;
  size_type find(const char* str, size_type i, size_type n) const;
  size_type find(const char* str, size_type i=0) const;
  size_type find(gunichar uc, size_type i=0) const;
  size_type find(char c, size_type i=0) const;
  size_type rfind(const ustring& str, size_type i=npos) const;
  size_type rfind(const char* str, size_type i, size_type n) const;
  size_type rfind(const char* str, size_type i=npos) const;
  size_type rfind(gunichar uc, size_type i=npos) const;
  size_type rfind(char c, size_type i=npos) const;
  size_type find_first_of(const ustring& match, size_type i=0) const;
  size_type find_first_of(const char* match, size_type i, size_type n) const;
  size_type find_first_of(const char* match, size_type i=0) const;
  size_type find_first_of(gunichar uc, size_type i=0) const;
  size_type find_first_of(char c, size_type i=0) const;
  size_type find_last_of(const ustring& match, size_type i=npos) const;
  size_type find_last_of(const char* match, size_type i, size_type n) const;
  size_type find_last_of(const char* match, size_type i=npos) const;
  size_type find_last_of(gunichar uc, size_type i=npos) const;
  size_type find_last_of(char c, size_type i=npos) const;
  size_type find_first_not_of(const ustring& match, size_type i=0) const;
  size_type find_first_not_of(const char* match, size_type i, size_type n) const;
  size_type find_first_not_of(const char* match, size_type i=0) const;
  size_type find_first_not_of(gunichar uc, size_type i=0) const;
  size_type find_first_not_of(char c, size_type i=0) const;
  size_type find_last_not_of(const ustring& match, size_type i=npos) const;
  size_type find_last_not_of(const char* match, size_type i, size_type n) const;
  size_type find_last_not_of(const char* match, size_type i=npos) const;
  size_type find_last_not_of(gunichar uc, size_type i=npos) const;
  size_type find_last_not_of(char c, size_type i=npos) const;
  bool empty() const;
  size_type size() const;
  size_type length() const;
  size_type bytes() const;
  void resize(size_type n, gunichar uc);
  void resize(size_type n, char c='\0');
  size_type capacity() const;
  size_type max_size() const;
  void reserve(size_type n=0);
  inline operator std::string() const;
  inline const std::string& raw() const;
  const char* data() const;
  const char* c_str() const;
  size_type copy(char* dest, size_type n, size_type i=0) const;
  bool validate() const;
  bool validate(iterator& first_invalid);
  bool validate(const_iterator& first_invalid) const;
  bool is_ascii() const;
  ustring normalize(NormalizeMode mode = NORMALIZE_DEFAULT_COMPOSE) const;
  ustring uppercase() const;
  ustring lowercase() const;
  ustring casefold() const;
private:
  template <class In, class ValueType = typename std::iterator_traits<In>::value_type>
  struct SequenceToString;
  template <class In>
  struct SequenceToString<In, char>;
  template <class In>
  struct SequenceToString<In, gunichar>;
  std::string string_;
};
template <class In, class ValueType>
struct ustring::SequenceToString
{};
template <class In>
struct ustring::SequenceToString<In, char> : public std::string
{
  SequenceToString(In pbegin, In pend);
};
template <class In>
struct ustring::SequenceToString<In, gunichar> : public std::string
{
  SequenceToString(In pbegin, In pend);
};
template <>
struct ustring::SequenceToString<Glib::ustring::iterator, gunichar> : public std::string
{
  SequenceToString(Glib::ustring::iterator pbegin, Glib::ustring::iterator pend);
};
template <>
struct ustring::SequenceToString<Glib::ustring::const_iterator, gunichar> : public std::string
{
  SequenceToString(Glib::ustring::const_iterator pbegin, Glib::ustring::const_iterator pend);
};
std::istream& operator>>(std::istream& is, Glib::ustring& utf8_string);
std::ostream& operator<<(std::ostream& os, const Glib::ustring& utf8_string);
template <class T> inline
ustring_Iterator<T>::ustring_Iterator(T pos)
:
  pos_ (pos)
{}
template <class T> inline
T ustring_Iterator<T>::base() const
{
  return pos_;
}
template <class T> inline
ustring_Iterator<T>::ustring_Iterator()
:
  pos_ ()
{}
template <class T> inline
ustring_Iterator<T>::ustring_Iterator(const ustring_Iterator<std::string::iterator>& other)
:
  pos_ (other.base())
{}
template <class T> inline
typename ustring_Iterator<T>::value_type ustring_Iterator<T>::operator*() const
{
  return Glib::get_unichar_from_std_iterator(pos_);
}
template <class T> inline
ustring_Iterator<T>& ustring_Iterator<T>::operator++()
{
  pos_ += g_utf8_skip[static_cast<unsigned char>(*pos_)];
  return *this;
}
template <class T> inline
const ustring_Iterator<T> ustring_Iterator<T>::operator++(int)
{
  const ustring_Iterator<T> temp (*this);
  this->operator++();
  return temp;
}
template <class T> inline
ustring_Iterator<T>& ustring_Iterator<T>::operator--()
{
  do --pos_; while((static_cast<unsigned char>(*pos_) & 0xC0u) == 0x80);
  return *this;
}
template <class T> inline
const ustring_Iterator<T> ustring_Iterator<T>::operator--(int)
{
  const ustring_Iterator<T> temp (*this);
  this->operator--();
  return temp;
}
template <class T> inline
bool operator==(const ustring_Iterator<T>& lhs, const ustring_Iterator<T>& rhs)
{
  return (lhs.base() == rhs.base());
}
template <class T> inline
bool operator!=(const ustring_Iterator<T>& lhs, const ustring_Iterator<T>& rhs)
{
  return (lhs.base() != rhs.base());
}
template <class T> inline
bool operator<(const ustring_Iterator<T>& lhs, const ustring_Iterator<T>& rhs)
{
  return (lhs.base() < rhs.base());
}
template <class T> inline
bool operator>(const ustring_Iterator<T>& lhs, const ustring_Iterator<T>& rhs)
{
  return (lhs.base() > rhs.base());
}
template <class T> inline
bool operator<=(const ustring_Iterator<T>& lhs, const ustring_Iterator<T>& rhs)
{
  return (lhs.base() <= rhs.base());
}
template <class T> inline
bool operator>=(const ustring_Iterator<T>& lhs, const ustring_Iterator<T>& rhs)
{
  return (lhs.base() >= rhs.base());
}
template <class In>
ustring::SequenceToString<In,char>::SequenceToString(In pbegin, In pend)
:
  std::string(pbegin, pend)
{}
template <class In>
ustring::SequenceToString<In,gunichar>::SequenceToString(In pbegin, In pend)
{
  char utf8_buf[6];
  for(; pbegin != pend; ++pbegin)
  {
    const std::string::size_type utf8_len = g_unichar_to_utf8(*pbegin, utf8_buf);
    this->append(utf8_buf, utf8_len);
  }
}
template <class In>
ustring::ustring(In pbegin, In pend)
:
  string_ (Glib::ustring::SequenceToString<In>(pbegin, pend))
{}
template <class In>
ustring& ustring::assign(In pbegin, In pend)
{
  Glib::ustring::SequenceToString<In> temp_string (pbegin, pend);
  string_.swap(temp_string);
  return *this;
}
template <class In>
ustring& ustring::append(In pbegin, In pend)
{
  string_.append(Glib::ustring::SequenceToString<In>(pbegin, pend));
  return *this;
}
template <class In>
void ustring::insert(ustring::iterator p, In pbegin, In pend)
{
  string_.insert(p.base(), Glib::ustring::SequenceToString<In>(pbegin, pend));
}
template <class In>
ustring& ustring::replace(ustring::iterator pbegin, ustring::iterator pend, In pbegin2, In pend2)
{
  string_.replace(
      pbegin.base(), pend.base(),
      Glib::ustring::SequenceToString<In>(pbegin2, pend2));
  return *this;
}
inline
ustring ustring::substr(ustring::size_type i, ustring::size_type n) const
{
  return ustring(*this, i, n);
}
inline
ustring::operator std::string() const
{
  return string_;
}
inline
const std::string& ustring::raw() const
{
  return string_;
}
inline
void swap(ustring& lhs, ustring& rhs)
{
  lhs.swap(rhs);
}
inline bool operator==(const ustring& lhs, const ustring& rhs)
  { return (lhs.compare(rhs) == 0); }
inline bool operator==(const ustring& lhs, const char* rhs)
  { return (lhs.compare(rhs) == 0); }
inline bool operator==(const char* lhs, const ustring& rhs)
  { return (rhs.compare(lhs) == 0); }
inline bool operator!=(const ustring& lhs, const ustring& rhs)
  { return (lhs.compare(rhs) != 0); }
inline bool operator!=(const ustring& lhs, const char* rhs)
  { return (lhs.compare(rhs) != 0); }
inline bool operator!=(const char* lhs, const ustring& rhs)
  { return (rhs.compare(lhs) != 0); }
inline bool operator<(const ustring& lhs, const ustring& rhs)
  { return (lhs.compare(rhs) < 0); }
inline bool operator<(const ustring& lhs, const char* rhs)
  { return (lhs.compare(rhs) < 0); }
inline bool operator<(const char* lhs, const ustring& rhs)
  { return (rhs.compare(lhs) > 0); }
inline bool operator>(const ustring& lhs, const ustring& rhs)
  { return (lhs.compare(rhs) > 0); }
inline bool operator>(const ustring& lhs, const char* rhs)
  { return (lhs.compare(rhs) > 0); }
inline bool operator>(const char* lhs, const ustring& rhs)
  { return (rhs.compare(lhs) < 0); }
inline bool operator<=(const ustring& lhs, const ustring& rhs)
  { return (lhs.compare(rhs) <= 0); }
inline bool operator<=(const ustring& lhs, const char* rhs)
  { return (lhs.compare(rhs) <= 0); }
inline bool operator<=(const char* lhs, const ustring& rhs)
  { return (rhs.compare(lhs) >= 0); }
inline bool operator>=(const ustring& lhs, const ustring& rhs)
  { return (lhs.compare(rhs) >= 0); }
inline bool operator>=(const ustring& lhs, const char* rhs)
  { return (lhs.compare(rhs) >= 0); }
inline bool operator>=(const char* lhs, const ustring& rhs)
  { return (rhs.compare(lhs) <= 0); }
inline ustring operator+(const ustring& lhs, const ustring& rhs)
  { ustring temp (lhs); temp += rhs; return temp; }
inline ustring operator+(const ustring& lhs, const char* rhs)
  { ustring temp (lhs); temp += rhs; return temp; }
inline ustring operator+(const char* lhs, const ustring& rhs)
  { ustring temp (lhs); temp += rhs; return temp; }
inline ustring operator+(const ustring& lhs, gunichar rhs)
  { ustring temp (lhs); temp += rhs; return temp; }
inline ustring operator+(gunichar lhs, const ustring& rhs)
  { ustring temp (1, lhs); temp += rhs; return temp; }
inline ustring operator+(const ustring& lhs, char rhs)
  { ustring temp (lhs); temp += rhs; return temp; }
inline ustring operator+(char lhs, const ustring& rhs)
  { ustring temp (1, lhs); temp += rhs; return temp; }
}
extern "C"
{
  typedef void (*GCallback) (void);
  typedef struct _GObject GObject;
}
namespace sigc {
template <class T_type>
struct type_trait
{
  typedef T_type type;
  typedef T_type& pass;
  typedef const T_type& take;
  typedef T_type* pointer;
};
template <class T_type, int N>
struct type_trait<T_type[N]>
{
  typedef T_type* type;
  typedef T_type*& pass;
  typedef const T_type*& take;
  typedef T_type** pointer;
};
template <class T_type>
struct type_trait<T_type&>
{
  typedef T_type type;
  typedef T_type& pass;
  typedef T_type& take;
  typedef T_type* pointer;
};
template <class T_type>
struct type_trait<const T_type&>
{
  typedef const T_type type;
  typedef const T_type& pass;
  typedef const T_type& take;
  typedef const T_type* pointer;
};
template<>
struct type_trait<void>
{
  typedef void type;
  typedef void pass;
  typedef void take;
  typedef void* pointer;
};
template <class T_base, class T_derived>
struct is_base_and_derived
{
private:
  struct big {
    char memory[64];
  };
  static big is_base_class_(...);
  static char is_base_class_(typename type_trait<T_base>::pointer);
public:
  static const bool value =
    sizeof(is_base_class_(reinterpret_cast<typename type_trait<T_derived>::pointer>(0))) ==
    sizeof(char);
  void avoid_gcc3_warning_();
};
template <class T_base>
struct is_base_and_derived<T_base, T_base>
{
  static const bool value = true;
};
}
namespace sigc {
namespace internal {
typedef void* (*func_destroy_notify) (void* data);
struct trackable_callback
{
  void* data_;
  func_destroy_notify func_;
  trackable_callback(void* data, func_destroy_notify func)
    : data_(data), func_(func) {}
};
struct trackable_callback_list
{
  void add_callback(void* data, func_destroy_notify func);
  void remove_callback(void* data);
  void clear();
  trackable_callback_list()
    : clearing_(false) {}
  ~trackable_callback_list();
private:
  typedef std::list<trackable_callback> callback_list;
  callback_list callbacks_;
  bool clearing_;
};
}
struct trackable
{
  trackable();
  trackable(const trackable& src);
  trackable& operator=(const trackable& src);
  ~trackable();
  typedef internal::func_destroy_notify func_destroy_notify;
  void add_destroy_notify_callback(void* data, func_destroy_notify func) const;
  void remove_destroy_notify_callback(void* data) const;
  void notify_callbacks();
private:
  internal::trackable_callback_list* callback_list() const;
  mutable internal::trackable_callback_list* callback_list_;
};
}
namespace sigc {
namespace internal {
template <bool I_derived, class T_type, class T_limit>
struct with_type;
template <class T_type, class T_limit> struct
with_type<false, T_type, T_limit>
{
  static void execute_(const T_type&, const T_limit&) {}
};
template <class T_type, class T_limit>
struct with_type<true, T_type, T_limit>
{
  static void execute_(const T_type& _A_type, const T_limit& _A_action)
  { _A_action.action_(_A_type); }
};
template <class T_target, class T_action>
struct limit_derived_target
{
  typedef limit_derived_target<T_target, T_action> T_self;
  template <class T_type>
  void operator()(const T_type& _A_type) const
  {
    with_type<is_base_and_derived<T_target, T_type>::value, T_type, T_self>::execute_(_A_type, *this);
  }
  limit_derived_target(const T_action& _A_action)
  : action_(_A_action)
  {}
  T_action action_;
};
template <bool I_derived, class T_type, class T_limit>
struct with_type_pointer;
template <class T_type, class T_limit>
struct with_type_pointer<false, T_type, T_limit>
{
 static void execute_(const T_type&, const T_limit&) {}
};
template <class T_type, class T_limit>
struct with_type_pointer<true, T_type, T_limit>
{
  static void execute_(const T_type& _A_type, const T_limit& _A_action)
  { _A_action.action_(&_A_type); }
};
template <class T_target, class T_action>
struct limit_derived_target<T_target*, T_action>
{
  typedef limit_derived_target<T_target*, T_action> T_self;
  template <class T_type>
  void operator()(const T_type& _A_type) const
  {
    with_type_pointer<is_base_and_derived<T_target, T_type>::value, T_type, T_self>::execute_(_A_type, *this);
  }
  limit_derived_target(const T_action& _A_action)
  : action_(_A_action)
  {}
  T_action action_;
};
}
template <class T_action, class T_functor>
void visit_each(const T_action& _A_action, const T_functor& _A_functor)
{ _A_action(_A_functor); }
template <class T_type, class T_action, class T_functor>
void visit_each_type(const T_action& _A_action, const T_functor& _A_functor)
{
  typedef internal::limit_derived_target<T_type, T_action> type_limited_action;
  type_limited_action limited_action(_A_action);
  visit_each(limited_action, _A_functor);
}
}
namespace sigc {
struct nil;
struct functor_base {};
template <class T_functor, bool I_derives_functor_base=is_base_and_derived<functor_base,T_functor>::value>
struct functor_trait
{
  typedef void result_type;
  typedef T_functor functor_type;
};
template <class T_functor>
struct functor_trait<T_functor,true>
{
  typedef typename T_functor::result_type result_type;
  typedef T_functor functor_type;
};
template <class T_return> class pointer_functor0;
template <class T_return>
struct functor_trait<T_return (*)(), false>
{
  typedef T_return result_type;
  typedef pointer_functor0<T_return> functor_type;
};
template <class T_arg1, class T_return> class pointer_functor1;
template <class T_arg1, class T_return>
struct functor_trait<T_return (*)(T_arg1), false>
{
  typedef T_return result_type;
  typedef pointer_functor1<T_arg1, T_return> functor_type;
};
template <class T_arg1,class T_arg2, class T_return> class pointer_functor2;
template <class T_arg1,class T_arg2, class T_return>
struct functor_trait<T_return (*)(T_arg1,T_arg2), false>
{
  typedef T_return result_type;
  typedef pointer_functor2<T_arg1,T_arg2, T_return> functor_type;
};
template <class T_arg1,class T_arg2,class T_arg3, class T_return> class pointer_functor3;
template <class T_arg1,class T_arg2,class T_arg3, class T_return>
struct functor_trait<T_return (*)(T_arg1,T_arg2,T_arg3), false>
{
  typedef T_return result_type;
  typedef pointer_functor3<T_arg1,T_arg2,T_arg3, T_return> functor_type;
};
template <class T_arg1,class T_arg2,class T_arg3,class T_arg4, class T_return> class pointer_functor4;
template <class T_arg1,class T_arg2,class T_arg3,class T_arg4, class T_return>
struct functor_trait<T_return (*)(T_arg1,T_arg2,T_arg3,T_arg4), false>
{
  typedef T_return result_type;
  typedef pointer_functor4<T_arg1,T_arg2,T_arg3,T_arg4, T_return> functor_type;
};
template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5, class T_return> class pointer_functor5;
template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5, class T_return>
struct functor_trait<T_return (*)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5), false>
{
  typedef T_return result_type;
  typedef pointer_functor5<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5, T_return> functor_type;
};
template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6, class T_return> class pointer_functor6;
template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6, class T_return>
struct functor_trait<T_return (*)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6), false>
{
  typedef T_return result_type;
  typedef pointer_functor6<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6, T_return> functor_type;
};
template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7, class T_return> class pointer_functor7;
template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7, class T_return>
struct functor_trait<T_return (*)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7), false>
{
  typedef T_return result_type;
  typedef pointer_functor7<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7, T_return> functor_type;
};
template <class T_return, class T_obj> class mem_functor0;
template <class T_return, class T_obj> class const_mem_functor0;
template <class T_return, class T_obj>
struct functor_trait<T_return (T_obj::*)(), false>
{
  typedef T_return result_type;
  typedef mem_functor0<T_return, T_obj> functor_type;
};
template <class T_return, class T_obj>
struct functor_trait<T_return (T_obj::*)() const, false>
{
  typedef T_return result_type;
  typedef const_mem_functor0<T_return, T_obj> functor_type;
};
template <class T_arg1, class T_return, class T_obj> class mem_functor1;
template <class T_arg1, class T_return, class T_obj> class const_mem_functor1;
template <class T_arg1, class T_return, class T_obj>
struct functor_trait<T_return (T_obj::*)(T_arg1), false>
{
  typedef T_return result_type;
  typedef mem_functor1<T_arg1, T_return, T_obj> functor_type;
};
template <class T_arg1, class T_return, class T_obj>
struct functor_trait<T_return (T_obj::*)(T_arg1) const, false>
{
  typedef T_return result_type;
  typedef const_mem_functor1<T_arg1, T_return, T_obj> functor_type;
};
template <class T_arg1,class T_arg2, class T_return, class T_obj> class mem_functor2;
template <class T_arg1,class T_arg2, class T_return, class T_obj> class const_mem_functor2;
template <class T_arg1,class T_arg2, class T_return, class T_obj>
struct functor_trait<T_return (T_obj::*)(T_arg1,T_arg2), false>
{
  typedef T_return result_type;
  typedef mem_functor2<T_arg1,T_arg2, T_return, T_obj> functor_type;
};
template <class T_arg1,class T_arg2, class T_return, class T_obj>
struct functor_trait<T_return (T_obj::*)(T_arg1,T_arg2) const, false>
{
  typedef T_return result_type;
  typedef const_mem_functor2<T_arg1,T_arg2, T_return, T_obj> functor_type;
};
template <class T_arg1,class T_arg2,class T_arg3, class T_return, class T_obj> class mem_functor3;
template <class T_arg1,class T_arg2,class T_arg3, class T_return, class T_obj> class const_mem_functor3;
template <class T_arg1,class T_arg2,class T_arg3, class T_return, class T_obj>
struct functor_trait<T_return (T_obj::*)(T_arg1,T_arg2,T_arg3), false>
{
  typedef T_return result_type;
  typedef mem_functor3<T_arg1,T_arg2,T_arg3, T_return, T_obj> functor_type;
};
template <class T_arg1,class T_arg2,class T_arg3, class T_return, class T_obj>
struct functor_trait<T_return (T_obj::*)(T_arg1,T_arg2,T_arg3) const, false>
{
  typedef T_return result_type;
  typedef const_mem_functor3<T_arg1,T_arg2,T_arg3, T_return, T_obj> functor_type;
};
template <class T_arg1,class T_arg2,class T_arg3,class T_arg4, class T_return, class T_obj> class mem_functor4;
template <class T_arg1,class T_arg2,class T_arg3,class T_arg4, class T_return, class T_obj> class const_mem_functor4;
template <class T_arg1,class T_arg2,class T_arg3,class T_arg4, class T_return, class T_obj>
struct functor_trait<T_return (T_obj::*)(T_arg1,T_arg2,T_arg3,T_arg4), false>
{
  typedef T_return result_type;
  typedef mem_functor4<T_arg1,T_arg2,T_arg3,T_arg4, T_return, T_obj> functor_type;
};
template <class T_arg1,class T_arg2,class T_arg3,class T_arg4, class T_return, class T_obj>
struct functor_trait<T_return (T_obj::*)(T_arg1,T_arg2,T_arg3,T_arg4) const, false>
{
  typedef T_return result_type;
  typedef const_mem_functor4<T_arg1,T_arg2,T_arg3,T_arg4, T_return, T_obj> functor_type;
};
template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5, class T_return, class T_obj> class mem_functor5;
template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5, class T_return, class T_obj> class const_mem_functor5;
template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5, class T_return, class T_obj>
struct functor_trait<T_return (T_obj::*)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5), false>
{
  typedef T_return result_type;
  typedef mem_functor5<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5, T_return, T_obj> functor_type;
};
template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5, class T_return, class T_obj>
struct functor_trait<T_return (T_obj::*)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5) const, false>
{
  typedef T_return result_type;
  typedef const_mem_functor5<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5, T_return, T_obj> functor_type;
};
template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6, class T_return, class T_obj> class mem_functor6;
template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6, class T_return, class T_obj> class const_mem_functor6;
template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6, class T_return, class T_obj>
struct functor_trait<T_return (T_obj::*)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6), false>
{
  typedef T_return result_type;
  typedef mem_functor6<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6, T_return, T_obj> functor_type;
};
template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6, class T_return, class T_obj>
struct functor_trait<T_return (T_obj::*)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6) const, false>
{
  typedef T_return result_type;
  typedef const_mem_functor6<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6, T_return, T_obj> functor_type;
};
template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7, class T_return, class T_obj> class mem_functor7;
template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7, class T_return, class T_obj> class const_mem_functor7;
template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7, class T_return, class T_obj>
struct functor_trait<T_return (T_obj::*)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7), false>
{
  typedef T_return result_type;
  typedef mem_functor7<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7, T_return, T_obj> functor_type;
};
template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7, class T_return, class T_obj>
struct functor_trait<T_return (T_obj::*)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7) const, false>
{
  typedef T_return result_type;
  typedef const_mem_functor7<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7, T_return, T_obj> functor_type;
};
}
namespace sigc {
template <class T_return>
class pointer_functor0 : public functor_base
{
  typedef T_return (*function_type)();
protected:
  function_type func_ptr_;
public:
  typedef T_return result_type;
  pointer_functor0() {}
  explicit pointer_functor0(function_type _A_func): func_ptr_(_A_func) {}
  T_return operator()() const
    { return func_ptr_(); }
};
template <class T_arg1, class T_return>
class pointer_functor1 : public functor_base
{
  typedef T_return (*function_type)(T_arg1);
protected:
  function_type func_ptr_;
public:
  typedef T_return result_type;
  pointer_functor1() {}
  explicit pointer_functor1(function_type _A_func): func_ptr_(_A_func) {}
  T_return operator()(typename type_trait<T_arg1>::take _A_a1) const
    { return func_ptr_(_A_a1); }
};
template <class T_arg1,class T_arg2, class T_return>
class pointer_functor2 : public functor_base
{
  typedef T_return (*function_type)(T_arg1,T_arg2);
protected:
  function_type func_ptr_;
public:
  typedef T_return result_type;
  pointer_functor2() {}
  explicit pointer_functor2(function_type _A_func): func_ptr_(_A_func) {}
  T_return operator()(typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2) const
    { return func_ptr_(_A_a1,_A_a2); }
};
template <class T_arg1,class T_arg2,class T_arg3, class T_return>
class pointer_functor3 : public functor_base
{
  typedef T_return (*function_type)(T_arg1,T_arg2,T_arg3);
protected:
  function_type func_ptr_;
public:
  typedef T_return result_type;
  pointer_functor3() {}
  explicit pointer_functor3(function_type _A_func): func_ptr_(_A_func) {}
  T_return operator()(typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3) const
    { return func_ptr_(_A_a1,_A_a2,_A_a3); }
};
template <class T_arg1,class T_arg2,class T_arg3,class T_arg4, class T_return>
class pointer_functor4 : public functor_base
{
  typedef T_return (*function_type)(T_arg1,T_arg2,T_arg3,T_arg4);
protected:
  function_type func_ptr_;
public:
  typedef T_return result_type;
  pointer_functor4() {}
  explicit pointer_functor4(function_type _A_func): func_ptr_(_A_func) {}
  T_return operator()(typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3,typename type_trait<T_arg4>::take _A_a4) const
    { return func_ptr_(_A_a1,_A_a2,_A_a3,_A_a4); }
};
template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5, class T_return>
class pointer_functor5 : public functor_base
{
  typedef T_return (*function_type)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5);
protected:
  function_type func_ptr_;
public:
  typedef T_return result_type;
  pointer_functor5() {}
  explicit pointer_functor5(function_type _A_func): func_ptr_(_A_func) {}
  T_return operator()(typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3,typename type_trait<T_arg4>::take _A_a4,typename type_trait<T_arg5>::take _A_a5) const
    { return func_ptr_(_A_a1,_A_a2,_A_a3,_A_a4,_A_a5); }
};
template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6, class T_return>
class pointer_functor6 : public functor_base
{
  typedef T_return (*function_type)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6);
protected:
  function_type func_ptr_;
public:
  typedef T_return result_type;
  pointer_functor6() {}
  explicit pointer_functor6(function_type _A_func): func_ptr_(_A_func) {}
  T_return operator()(typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3,typename type_trait<T_arg4>::take _A_a4,typename type_trait<T_arg5>::take _A_a5,typename type_trait<T_arg6>::take _A_a6) const
    { return func_ptr_(_A_a1,_A_a2,_A_a3,_A_a4,_A_a5,_A_a6); }
};
template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7, class T_return>
class pointer_functor7 : public functor_base
{
  typedef T_return (*function_type)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7);
protected:
  function_type func_ptr_;
public:
  typedef T_return result_type;
  pointer_functor7() {}
  explicit pointer_functor7(function_type _A_func): func_ptr_(_A_func) {}
  T_return operator()(typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3,typename type_trait<T_arg4>::take _A_a4,typename type_trait<T_arg5>::take _A_a5,typename type_trait<T_arg6>::take _A_a6,typename type_trait<T_arg7>::take _A_a7) const
    { return func_ptr_(_A_a1,_A_a2,_A_a3,_A_a4,_A_a5,_A_a6,_A_a7); }
};
template <class T_return>
inline pointer_functor0<T_return>
ptr_fun0(T_return (*_A_func)())
{ return pointer_functor0<T_return>(_A_func); }
template <class T_arg1, class T_return>
inline pointer_functor1<T_arg1, T_return>
ptr_fun1(T_return (*_A_func)(T_arg1))
{ return pointer_functor1<T_arg1, T_return>(_A_func); }
template <class T_arg1,class T_arg2, class T_return>
inline pointer_functor2<T_arg1,T_arg2, T_return>
ptr_fun2(T_return (*_A_func)(T_arg1,T_arg2))
{ return pointer_functor2<T_arg1,T_arg2, T_return>(_A_func); }
template <class T_arg1,class T_arg2,class T_arg3, class T_return>
inline pointer_functor3<T_arg1,T_arg2,T_arg3, T_return>
ptr_fun3(T_return (*_A_func)(T_arg1,T_arg2,T_arg3))
{ return pointer_functor3<T_arg1,T_arg2,T_arg3, T_return>(_A_func); }
template <class T_arg1,class T_arg2,class T_arg3,class T_arg4, class T_return>
inline pointer_functor4<T_arg1,T_arg2,T_arg3,T_arg4, T_return>
ptr_fun4(T_return (*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4))
{ return pointer_functor4<T_arg1,T_arg2,T_arg3,T_arg4, T_return>(_A_func); }
template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5, class T_return>
inline pointer_functor5<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5, T_return>
ptr_fun5(T_return (*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5))
{ return pointer_functor5<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5, T_return>(_A_func); }
template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6, class T_return>
inline pointer_functor6<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6, T_return>
ptr_fun6(T_return (*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6))
{ return pointer_functor6<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6, T_return>(_A_func); }
template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7, class T_return>
inline pointer_functor7<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7, T_return>
ptr_fun7(T_return (*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7))
{ return pointer_functor7<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7, T_return>(_A_func); }
template <class T_return>
inline pointer_functor0<T_return>
ptr_fun(T_return (*_A_func)())
{ return pointer_functor0<T_return>(_A_func); }
template <class T_arg1, class T_return>
inline pointer_functor1<T_arg1, T_return>
ptr_fun(T_return (*_A_func)(T_arg1))
{ return pointer_functor1<T_arg1, T_return>(_A_func); }
template <class T_arg1,class T_arg2, class T_return>
inline pointer_functor2<T_arg1,T_arg2, T_return>
ptr_fun(T_return (*_A_func)(T_arg1,T_arg2))
{ return pointer_functor2<T_arg1,T_arg2, T_return>(_A_func); }
template <class T_arg1,class T_arg2,class T_arg3, class T_return>
inline pointer_functor3<T_arg1,T_arg2,T_arg3, T_return>
ptr_fun(T_return (*_A_func)(T_arg1,T_arg2,T_arg3))
{ return pointer_functor3<T_arg1,T_arg2,T_arg3, T_return>(_A_func); }
template <class T_arg1,class T_arg2,class T_arg3,class T_arg4, class T_return>
inline pointer_functor4<T_arg1,T_arg2,T_arg3,T_arg4, T_return>
ptr_fun(T_return (*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4))
{ return pointer_functor4<T_arg1,T_arg2,T_arg3,T_arg4, T_return>(_A_func); }
template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5, class T_return>
inline pointer_functor5<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5, T_return>
ptr_fun(T_return (*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5))
{ return pointer_functor5<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5, T_return>(_A_func); }
template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6, class T_return>
inline pointer_functor6<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6, T_return>
ptr_fun(T_return (*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6))
{ return pointer_functor6<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6, T_return>(_A_func); }
template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7, class T_return>
inline pointer_functor7<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7, T_return>
ptr_fun(T_return (*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7))
{ return pointer_functor7<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7, T_return>(_A_func); }
}
namespace sigc {
template <class T_type,
          bool I_derives_trackable =
            is_base_and_derived<trackable, T_type>::value>
class limit_reference
{
public:
  limit_reference(T_type& _A_target)
    : visited(_A_target)
    {}
  inline const T_type& visit() const
    { return visited; }
  inline T_type& invoke() const
    { return visited; }
private:
  T_type& visited;
};
template <class T_type>
class limit_reference<T_type, true>
{
public:
  limit_reference(T_type& _A_target)
    : visited(_A_target),
      invoked(_A_target)
    {}
  inline const trackable& visit() const
    { return visited; }
  inline T_type& invoke() const
    { return invoked; }
private:
  trackable& visited;
  T_type& invoked;
};
template <class T_action, class T_type, bool I_derives_trackable>
void
visit_each(const T_action& _A_action,
           const limit_reference<T_type, I_derives_trackable>& _A_target)
{
  visit_each(_A_action, _A_target.visit());
}
template <class T_type,
          bool I_derives_trackable =
            is_base_and_derived<trackable, T_type>::value>
class const_limit_reference
{
public:
  const_limit_reference(const T_type& _A_target)
    : visited(_A_target)
    {}
  inline const T_type& visit() const
    { return visited; }
  inline const T_type& invoke() const
    { return visited; }
private:
  const T_type& visited;
};
template <class T_type>
class const_limit_reference<T_type, true>
{
public:
  const_limit_reference(const T_type& _A_target)
    : visited(_A_target),
      invoked(_A_target)
    {}
  inline const trackable& visit() const
    { return visited; }
  inline const T_type& invoke() const
    { return invoked; }
private:
  const trackable& visited;
  const T_type& invoked;
};
template <class T_action, class T_type, bool I_derives_trackable>
void
visit_each(const T_action& _A_action,
           const const_limit_reference<T_type, I_derives_trackable>& _A_target)
{
  visit_each(_A_action, _A_target.visit());
}
template <class T_type,
          bool I_derives_trackable =
            is_base_and_derived<trackable, T_type>::value>
class volatile_limit_reference
{
public:
  volatile_limit_reference(T_type& _A_target)
    : visited(_A_target)
    {}
  inline const T_type& visit() const
    { return visited; }
  inline volatile T_type& invoke() const
    { return visited; }
private:
  T_type& visited;
};
template <class T_type>
class volatile_limit_reference<T_type, true>
{
public:
  volatile_limit_reference(T_type& _A_target)
    : visited(_A_target),
      invoked(_A_target)
    {}
  inline const trackable& visit() const
    { return visited; }
  inline volatile T_type& invoke() const
    { return invoked; }
private:
  trackable& visited;
  T_type& invoked;
};
template <class T_action, class T_type, bool I_derives_trackable>
void
visit_each(const T_action& _A_action,
           const volatile_limit_reference<T_type, I_derives_trackable>& _A_target)
{
  visit_each(_A_action, _A_target.visit());
}
template <class T_type,
          bool I_derives_trackable =
            is_base_and_derived<trackable, T_type>::value>
class const_volatile_limit_reference
{
public:
  const_volatile_limit_reference(const T_type& _A_target)
    : visited(_A_target)
    {}
  inline const T_type& visit() const
    { return visited; }
  inline const volatile T_type& invoke() const
    { return visited; }
private:
  const T_type& visited;
};
template <class T_type>
class const_volatile_limit_reference<T_type, true>
{
public:
  const_volatile_limit_reference(const T_type& _A_target)
    : visited(_A_target),
      invoked(_A_target)
    {}
  inline const trackable& visit() const
    { return visited; }
  inline const volatile T_type& invoke() const
    { return invoked; }
private:
  const trackable& visited;
  const T_type& invoked;
};
template <class T_action, class T_type, bool I_derives_trackable>
void
visit_each(const T_action& _A_action,
           const const_volatile_limit_reference<T_type, I_derives_trackable>& _A_target)
{
  visit_each(_A_action, _A_target.visit());
}
}
namespace sigc {
template <class T_return, class T_obj>
class mem_functor0 : public functor_base
{
public:
  typedef T_return (T_obj::*function_type)() ;
  typedef T_return result_type;
  mem_functor0() : func_ptr_(0) {}
  explicit mem_functor0(function_type _A_func) : func_ptr_(_A_func) {}
  T_return operator()(T_obj* _A_obj) const
    { return (_A_obj->*(this->func_ptr_))(); }
  T_return operator()(T_obj& _A_obj) const
    { return (_A_obj.*func_ptr_)(); }
protected:
  function_type func_ptr_;
};
template <class T_return, class T_obj, class T_arg1>
class mem_functor1 : public functor_base
{
public:
  typedef T_return (T_obj::*function_type)(T_arg1) ;
  typedef T_return result_type;
  mem_functor1() : func_ptr_(0) {}
  explicit mem_functor1(function_type _A_func) : func_ptr_(_A_func) {}
  T_return operator()(T_obj* _A_obj, typename type_trait<T_arg1>::take _A_a1) const
    { return (_A_obj->*(this->func_ptr_))(_A_a1); }
  T_return operator()(T_obj& _A_obj, typename type_trait<T_arg1>::take _A_a1) const
    { return (_A_obj.*func_ptr_)(_A_a1); }
protected:
  function_type func_ptr_;
};
template <class T_return, class T_obj, class T_arg1,class T_arg2>
class mem_functor2 : public functor_base
{
public:
  typedef T_return (T_obj::*function_type)(T_arg1,T_arg2) ;
  typedef T_return result_type;
  mem_functor2() : func_ptr_(0) {}
  explicit mem_functor2(function_type _A_func) : func_ptr_(_A_func) {}
  T_return operator()(T_obj* _A_obj, typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2) const
    { return (_A_obj->*(this->func_ptr_))(_A_a1,_A_a2); }
  T_return operator()(T_obj& _A_obj, typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2) const
    { return (_A_obj.*func_ptr_)(_A_a1,_A_a2); }
protected:
  function_type func_ptr_;
};
template <class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3>
class mem_functor3 : public functor_base
{
public:
  typedef T_return (T_obj::*function_type)(T_arg1,T_arg2,T_arg3) ;
  typedef T_return result_type;
  mem_functor3() : func_ptr_(0) {}
  explicit mem_functor3(function_type _A_func) : func_ptr_(_A_func) {}
  T_return operator()(T_obj* _A_obj, typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3) const
    { return (_A_obj->*(this->func_ptr_))(_A_a1,_A_a2,_A_a3); }
  T_return operator()(T_obj& _A_obj, typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3) const
    { return (_A_obj.*func_ptr_)(_A_a1,_A_a2,_A_a3); }
protected:
  function_type func_ptr_;
};
template <class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3,class T_arg4>
class mem_functor4 : public functor_base
{
public:
  typedef T_return (T_obj::*function_type)(T_arg1,T_arg2,T_arg3,T_arg4) ;
  typedef T_return result_type;
  mem_functor4() : func_ptr_(0) {}
  explicit mem_functor4(function_type _A_func) : func_ptr_(_A_func) {}
  T_return operator()(T_obj* _A_obj, typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3,typename type_trait<T_arg4>::take _A_a4) const
    { return (_A_obj->*(this->func_ptr_))(_A_a1,_A_a2,_A_a3,_A_a4); }
  T_return operator()(T_obj& _A_obj, typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3,typename type_trait<T_arg4>::take _A_a4) const
    { return (_A_obj.*func_ptr_)(_A_a1,_A_a2,_A_a3,_A_a4); }
protected:
  function_type func_ptr_;
};
template <class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
class mem_functor5 : public functor_base
{
public:
  typedef T_return (T_obj::*function_type)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5) ;
  typedef T_return result_type;
  mem_functor5() : func_ptr_(0) {}
  explicit mem_functor5(function_type _A_func) : func_ptr_(_A_func) {}
  T_return operator()(T_obj* _A_obj, typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3,typename type_trait<T_arg4>::take _A_a4,typename type_trait<T_arg5>::take _A_a5) const
    { return (_A_obj->*(this->func_ptr_))(_A_a1,_A_a2,_A_a3,_A_a4,_A_a5); }
  T_return operator()(T_obj& _A_obj, typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3,typename type_trait<T_arg4>::take _A_a4,typename type_trait<T_arg5>::take _A_a5) const
    { return (_A_obj.*func_ptr_)(_A_a1,_A_a2,_A_a3,_A_a4,_A_a5); }
protected:
  function_type func_ptr_;
};
template <class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
class mem_functor6 : public functor_base
{
public:
  typedef T_return (T_obj::*function_type)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6) ;
  typedef T_return result_type;
  mem_functor6() : func_ptr_(0) {}
  explicit mem_functor6(function_type _A_func) : func_ptr_(_A_func) {}
  T_return operator()(T_obj* _A_obj, typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3,typename type_trait<T_arg4>::take _A_a4,typename type_trait<T_arg5>::take _A_a5,typename type_trait<T_arg6>::take _A_a6) const
    { return (_A_obj->*(this->func_ptr_))(_A_a1,_A_a2,_A_a3,_A_a4,_A_a5,_A_a6); }
  T_return operator()(T_obj& _A_obj, typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3,typename type_trait<T_arg4>::take _A_a4,typename type_trait<T_arg5>::take _A_a5,typename type_trait<T_arg6>::take _A_a6) const
    { return (_A_obj.*func_ptr_)(_A_a1,_A_a2,_A_a3,_A_a4,_A_a5,_A_a6); }
protected:
  function_type func_ptr_;
};
template <class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
class mem_functor7 : public functor_base
{
public:
  typedef T_return (T_obj::*function_type)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7) ;
  typedef T_return result_type;
  mem_functor7() : func_ptr_(0) {}
  explicit mem_functor7(function_type _A_func) : func_ptr_(_A_func) {}
  T_return operator()(T_obj* _A_obj, typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3,typename type_trait<T_arg4>::take _A_a4,typename type_trait<T_arg5>::take _A_a5,typename type_trait<T_arg6>::take _A_a6,typename type_trait<T_arg7>::take _A_a7) const
    { return (_A_obj->*(this->func_ptr_))(_A_a1,_A_a2,_A_a3,_A_a4,_A_a5,_A_a6,_A_a7); }
  T_return operator()(T_obj& _A_obj, typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3,typename type_trait<T_arg4>::take _A_a4,typename type_trait<T_arg5>::take _A_a5,typename type_trait<T_arg6>::take _A_a6,typename type_trait<T_arg7>::take _A_a7) const
    { return (_A_obj.*func_ptr_)(_A_a1,_A_a2,_A_a3,_A_a4,_A_a5,_A_a6,_A_a7); }
protected:
  function_type func_ptr_;
};
template <class T_return, class T_obj>
class const_mem_functor0 : public functor_base
{
public:
  typedef T_return (T_obj::*function_type)() const;
  typedef T_return result_type;
  const_mem_functor0() : func_ptr_(0) {}
  explicit const_mem_functor0(function_type _A_func) : func_ptr_(_A_func) {}
  T_return operator()(const T_obj* _A_obj) const
    { return (_A_obj->*(this->func_ptr_))(); }
  T_return operator()(const T_obj& _A_obj) const
    { return (_A_obj.*func_ptr_)(); }
protected:
  function_type func_ptr_;
};
template <class T_return, class T_obj, class T_arg1>
class const_mem_functor1 : public functor_base
{
public:
  typedef T_return (T_obj::*function_type)(T_arg1) const;
  typedef T_return result_type;
  const_mem_functor1() : func_ptr_(0) {}
  explicit const_mem_functor1(function_type _A_func) : func_ptr_(_A_func) {}
  T_return operator()(const T_obj* _A_obj, typename type_trait<T_arg1>::take _A_a1) const
    { return (_A_obj->*(this->func_ptr_))(_A_a1); }
  T_return operator()(const T_obj& _A_obj, typename type_trait<T_arg1>::take _A_a1) const
    { return (_A_obj.*func_ptr_)(_A_a1); }
protected:
  function_type func_ptr_;
};
template <class T_return, class T_obj, class T_arg1,class T_arg2>
class const_mem_functor2 : public functor_base
{
public:
  typedef T_return (T_obj::*function_type)(T_arg1,T_arg2) const;
  typedef T_return result_type;
  const_mem_functor2() : func_ptr_(0) {}
  explicit const_mem_functor2(function_type _A_func) : func_ptr_(_A_func) {}
  T_return operator()(const T_obj* _A_obj, typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2) const
    { return (_A_obj->*(this->func_ptr_))(_A_a1,_A_a2); }
  T_return operator()(const T_obj& _A_obj, typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2) const
    { return (_A_obj.*func_ptr_)(_A_a1,_A_a2); }
protected:
  function_type func_ptr_;
};
template <class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3>
class const_mem_functor3 : public functor_base
{
public:
  typedef T_return (T_obj::*function_type)(T_arg1,T_arg2,T_arg3) const;
  typedef T_return result_type;
  const_mem_functor3() : func_ptr_(0) {}
  explicit const_mem_functor3(function_type _A_func) : func_ptr_(_A_func) {}
  T_return operator()(const T_obj* _A_obj, typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3) const
    { return (_A_obj->*(this->func_ptr_))(_A_a1,_A_a2,_A_a3); }
  T_return operator()(const T_obj& _A_obj, typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3) const
    { return (_A_obj.*func_ptr_)(_A_a1,_A_a2,_A_a3); }
protected:
  function_type func_ptr_;
};
template <class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3,class T_arg4>
class const_mem_functor4 : public functor_base
{
public:
  typedef T_return (T_obj::*function_type)(T_arg1,T_arg2,T_arg3,T_arg4) const;
  typedef T_return result_type;
  const_mem_functor4() : func_ptr_(0) {}
  explicit const_mem_functor4(function_type _A_func) : func_ptr_(_A_func) {}
  T_return operator()(const T_obj* _A_obj, typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3,typename type_trait<T_arg4>::take _A_a4) const
    { return (_A_obj->*(this->func_ptr_))(_A_a1,_A_a2,_A_a3,_A_a4); }
  T_return operator()(const T_obj& _A_obj, typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3,typename type_trait<T_arg4>::take _A_a4) const
    { return (_A_obj.*func_ptr_)(_A_a1,_A_a2,_A_a3,_A_a4); }
protected:
  function_type func_ptr_;
};
template <class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
class const_mem_functor5 : public functor_base
{
public:
  typedef T_return (T_obj::*function_type)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5) const;
  typedef T_return result_type;
  const_mem_functor5() : func_ptr_(0) {}
  explicit const_mem_functor5(function_type _A_func) : func_ptr_(_A_func) {}
  T_return operator()(const T_obj* _A_obj, typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3,typename type_trait<T_arg4>::take _A_a4,typename type_trait<T_arg5>::take _A_a5) const
    { return (_A_obj->*(this->func_ptr_))(_A_a1,_A_a2,_A_a3,_A_a4,_A_a5); }
  T_return operator()(const T_obj& _A_obj, typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3,typename type_trait<T_arg4>::take _A_a4,typename type_trait<T_arg5>::take _A_a5) const
    { return (_A_obj.*func_ptr_)(_A_a1,_A_a2,_A_a3,_A_a4,_A_a5); }
protected:
  function_type func_ptr_;
};
template <class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
class const_mem_functor6 : public functor_base
{
public:
  typedef T_return (T_obj::*function_type)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6) const;
  typedef T_return result_type;
  const_mem_functor6() : func_ptr_(0) {}
  explicit const_mem_functor6(function_type _A_func) : func_ptr_(_A_func) {}
  T_return operator()(const T_obj* _A_obj, typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3,typename type_trait<T_arg4>::take _A_a4,typename type_trait<T_arg5>::take _A_a5,typename type_trait<T_arg6>::take _A_a6) const
    { return (_A_obj->*(this->func_ptr_))(_A_a1,_A_a2,_A_a3,_A_a4,_A_a5,_A_a6); }
  T_return operator()(const T_obj& _A_obj, typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3,typename type_trait<T_arg4>::take _A_a4,typename type_trait<T_arg5>::take _A_a5,typename type_trait<T_arg6>::take _A_a6) const
    { return (_A_obj.*func_ptr_)(_A_a1,_A_a2,_A_a3,_A_a4,_A_a5,_A_a6); }
protected:
  function_type func_ptr_;
};
template <class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
class const_mem_functor7 : public functor_base
{
public:
  typedef T_return (T_obj::*function_type)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7) const;
  typedef T_return result_type;
  const_mem_functor7() : func_ptr_(0) {}
  explicit const_mem_functor7(function_type _A_func) : func_ptr_(_A_func) {}
  T_return operator()(const T_obj* _A_obj, typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3,typename type_trait<T_arg4>::take _A_a4,typename type_trait<T_arg5>::take _A_a5,typename type_trait<T_arg6>::take _A_a6,typename type_trait<T_arg7>::take _A_a7) const
    { return (_A_obj->*(this->func_ptr_))(_A_a1,_A_a2,_A_a3,_A_a4,_A_a5,_A_a6,_A_a7); }
  T_return operator()(const T_obj& _A_obj, typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3,typename type_trait<T_arg4>::take _A_a4,typename type_trait<T_arg5>::take _A_a5,typename type_trait<T_arg6>::take _A_a6,typename type_trait<T_arg7>::take _A_a7) const
    { return (_A_obj.*func_ptr_)(_A_a1,_A_a2,_A_a3,_A_a4,_A_a5,_A_a6,_A_a7); }
protected:
  function_type func_ptr_;
};
template <class T_return, class T_obj>
class volatile_mem_functor0 : public functor_base
{
public:
  typedef T_return (T_obj::*function_type)() volatile;
  typedef T_return result_type;
  volatile_mem_functor0() : func_ptr_(0) {}
  explicit volatile_mem_functor0(function_type _A_func) : func_ptr_(_A_func) {}
  T_return operator()(T_obj* _A_obj) const
    { return (_A_obj->*(this->func_ptr_))(); }
  T_return operator()(T_obj& _A_obj) const
    { return (_A_obj.*func_ptr_)(); }
protected:
  function_type func_ptr_;
};
template <class T_return, class T_obj, class T_arg1>
class volatile_mem_functor1 : public functor_base
{
public:
  typedef T_return (T_obj::*function_type)(T_arg1) volatile;
  typedef T_return result_type;
  volatile_mem_functor1() : func_ptr_(0) {}
  explicit volatile_mem_functor1(function_type _A_func) : func_ptr_(_A_func) {}
  T_return operator()(T_obj* _A_obj, typename type_trait<T_arg1>::take _A_a1) const
    { return (_A_obj->*(this->func_ptr_))(_A_a1); }
  T_return operator()(T_obj& _A_obj, typename type_trait<T_arg1>::take _A_a1) const
    { return (_A_obj.*func_ptr_)(_A_a1); }
protected:
  function_type func_ptr_;
};
template <class T_return, class T_obj, class T_arg1,class T_arg2>
class volatile_mem_functor2 : public functor_base
{
public:
  typedef T_return (T_obj::*function_type)(T_arg1,T_arg2) volatile;
  typedef T_return result_type;
  volatile_mem_functor2() : func_ptr_(0) {}
  explicit volatile_mem_functor2(function_type _A_func) : func_ptr_(_A_func) {}
  T_return operator()(T_obj* _A_obj, typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2) const
    { return (_A_obj->*(this->func_ptr_))(_A_a1,_A_a2); }
  T_return operator()(T_obj& _A_obj, typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2) const
    { return (_A_obj.*func_ptr_)(_A_a1,_A_a2); }
protected:
  function_type func_ptr_;
};
template <class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3>
class volatile_mem_functor3 : public functor_base
{
public:
  typedef T_return (T_obj::*function_type)(T_arg1,T_arg2,T_arg3) volatile;
  typedef T_return result_type;
  volatile_mem_functor3() : func_ptr_(0) {}
  explicit volatile_mem_functor3(function_type _A_func) : func_ptr_(_A_func) {}
  T_return operator()(T_obj* _A_obj, typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3) const
    { return (_A_obj->*(this->func_ptr_))(_A_a1,_A_a2,_A_a3); }
  T_return operator()(T_obj& _A_obj, typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3) const
    { return (_A_obj.*func_ptr_)(_A_a1,_A_a2,_A_a3); }
protected:
  function_type func_ptr_;
};
template <class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3,class T_arg4>
class volatile_mem_functor4 : public functor_base
{
public:
  typedef T_return (T_obj::*function_type)(T_arg1,T_arg2,T_arg3,T_arg4) volatile;
  typedef T_return result_type;
  volatile_mem_functor4() : func_ptr_(0) {}
  explicit volatile_mem_functor4(function_type _A_func) : func_ptr_(_A_func) {}
  T_return operator()(T_obj* _A_obj, typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3,typename type_trait<T_arg4>::take _A_a4) const
    { return (_A_obj->*(this->func_ptr_))(_A_a1,_A_a2,_A_a3,_A_a4); }
  T_return operator()(T_obj& _A_obj, typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3,typename type_trait<T_arg4>::take _A_a4) const
    { return (_A_obj.*func_ptr_)(_A_a1,_A_a2,_A_a3,_A_a4); }
protected:
  function_type func_ptr_;
};
template <class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
class volatile_mem_functor5 : public functor_base
{
public:
  typedef T_return (T_obj::*function_type)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5) volatile;
  typedef T_return result_type;
  volatile_mem_functor5() : func_ptr_(0) {}
  explicit volatile_mem_functor5(function_type _A_func) : func_ptr_(_A_func) {}
  T_return operator()(T_obj* _A_obj, typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3,typename type_trait<T_arg4>::take _A_a4,typename type_trait<T_arg5>::take _A_a5) const
    { return (_A_obj->*(this->func_ptr_))(_A_a1,_A_a2,_A_a3,_A_a4,_A_a5); }
  T_return operator()(T_obj& _A_obj, typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3,typename type_trait<T_arg4>::take _A_a4,typename type_trait<T_arg5>::take _A_a5) const
    { return (_A_obj.*func_ptr_)(_A_a1,_A_a2,_A_a3,_A_a4,_A_a5); }
protected:
  function_type func_ptr_;
};
template <class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
class volatile_mem_functor6 : public functor_base
{
public:
  typedef T_return (T_obj::*function_type)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6) volatile;
  typedef T_return result_type;
  volatile_mem_functor6() : func_ptr_(0) {}
  explicit volatile_mem_functor6(function_type _A_func) : func_ptr_(_A_func) {}
  T_return operator()(T_obj* _A_obj, typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3,typename type_trait<T_arg4>::take _A_a4,typename type_trait<T_arg5>::take _A_a5,typename type_trait<T_arg6>::take _A_a6) const
    { return (_A_obj->*(this->func_ptr_))(_A_a1,_A_a2,_A_a3,_A_a4,_A_a5,_A_a6); }
  T_return operator()(T_obj& _A_obj, typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3,typename type_trait<T_arg4>::take _A_a4,typename type_trait<T_arg5>::take _A_a5,typename type_trait<T_arg6>::take _A_a6) const
    { return (_A_obj.*func_ptr_)(_A_a1,_A_a2,_A_a3,_A_a4,_A_a5,_A_a6); }
protected:
  function_type func_ptr_;
};
template <class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
class volatile_mem_functor7 : public functor_base
{
public:
  typedef T_return (T_obj::*function_type)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7) volatile;
  typedef T_return result_type;
  volatile_mem_functor7() : func_ptr_(0) {}
  explicit volatile_mem_functor7(function_type _A_func) : func_ptr_(_A_func) {}
  T_return operator()(T_obj* _A_obj, typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3,typename type_trait<T_arg4>::take _A_a4,typename type_trait<T_arg5>::take _A_a5,typename type_trait<T_arg6>::take _A_a6,typename type_trait<T_arg7>::take _A_a7) const
    { return (_A_obj->*(this->func_ptr_))(_A_a1,_A_a2,_A_a3,_A_a4,_A_a5,_A_a6,_A_a7); }
  T_return operator()(T_obj& _A_obj, typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3,typename type_trait<T_arg4>::take _A_a4,typename type_trait<T_arg5>::take _A_a5,typename type_trait<T_arg6>::take _A_a6,typename type_trait<T_arg7>::take _A_a7) const
    { return (_A_obj.*func_ptr_)(_A_a1,_A_a2,_A_a3,_A_a4,_A_a5,_A_a6,_A_a7); }
protected:
  function_type func_ptr_;
};
template <class T_return, class T_obj>
class const_volatile_mem_functor0 : public functor_base
{
public:
  typedef T_return (T_obj::*function_type)() const volatile;
  typedef T_return result_type;
  const_volatile_mem_functor0() : func_ptr_(0) {}
  explicit const_volatile_mem_functor0(function_type _A_func) : func_ptr_(_A_func) {}
  T_return operator()(const T_obj* _A_obj) const
    { return (_A_obj->*(this->func_ptr_))(); }
  T_return operator()(const T_obj& _A_obj) const
    { return (_A_obj.*func_ptr_)(); }
protected:
  function_type func_ptr_;
};
template <class T_return, class T_obj, class T_arg1>
class const_volatile_mem_functor1 : public functor_base
{
public:
  typedef T_return (T_obj::*function_type)(T_arg1) const volatile;
  typedef T_return result_type;
  const_volatile_mem_functor1() : func_ptr_(0) {}
  explicit const_volatile_mem_functor1(function_type _A_func) : func_ptr_(_A_func) {}
  T_return operator()(const T_obj* _A_obj, typename type_trait<T_arg1>::take _A_a1) const
    { return (_A_obj->*(this->func_ptr_))(_A_a1); }
  T_return operator()(const T_obj& _A_obj, typename type_trait<T_arg1>::take _A_a1) const
    { return (_A_obj.*func_ptr_)(_A_a1); }
protected:
  function_type func_ptr_;
};
template <class T_return, class T_obj, class T_arg1,class T_arg2>
class const_volatile_mem_functor2 : public functor_base
{
public:
  typedef T_return (T_obj::*function_type)(T_arg1,T_arg2) const volatile;
  typedef T_return result_type;
  const_volatile_mem_functor2() : func_ptr_(0) {}
  explicit const_volatile_mem_functor2(function_type _A_func) : func_ptr_(_A_func) {}
  T_return operator()(const T_obj* _A_obj, typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2) const
    { return (_A_obj->*(this->func_ptr_))(_A_a1,_A_a2); }
  T_return operator()(const T_obj& _A_obj, typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2) const
    { return (_A_obj.*func_ptr_)(_A_a1,_A_a2); }
protected:
  function_type func_ptr_;
};
template <class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3>
class const_volatile_mem_functor3 : public functor_base
{
public:
  typedef T_return (T_obj::*function_type)(T_arg1,T_arg2,T_arg3) const volatile;
  typedef T_return result_type;
  const_volatile_mem_functor3() : func_ptr_(0) {}
  explicit const_volatile_mem_functor3(function_type _A_func) : func_ptr_(_A_func) {}
  T_return operator()(const T_obj* _A_obj, typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3) const
    { return (_A_obj->*(this->func_ptr_))(_A_a1,_A_a2,_A_a3); }
  T_return operator()(const T_obj& _A_obj, typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3) const
    { return (_A_obj.*func_ptr_)(_A_a1,_A_a2,_A_a3); }
protected:
  function_type func_ptr_;
};
template <class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3,class T_arg4>
class const_volatile_mem_functor4 : public functor_base
{
public:
  typedef T_return (T_obj::*function_type)(T_arg1,T_arg2,T_arg3,T_arg4) const volatile;
  typedef T_return result_type;
  const_volatile_mem_functor4() : func_ptr_(0) {}
  explicit const_volatile_mem_functor4(function_type _A_func) : func_ptr_(_A_func) {}
  T_return operator()(const T_obj* _A_obj, typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3,typename type_trait<T_arg4>::take _A_a4) const
    { return (_A_obj->*(this->func_ptr_))(_A_a1,_A_a2,_A_a3,_A_a4); }
  T_return operator()(const T_obj& _A_obj, typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3,typename type_trait<T_arg4>::take _A_a4) const
    { return (_A_obj.*func_ptr_)(_A_a1,_A_a2,_A_a3,_A_a4); }
protected:
  function_type func_ptr_;
};
template <class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
class const_volatile_mem_functor5 : public functor_base
{
public:
  typedef T_return (T_obj::*function_type)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5) const volatile;
  typedef T_return result_type;
  const_volatile_mem_functor5() : func_ptr_(0) {}
  explicit const_volatile_mem_functor5(function_type _A_func) : func_ptr_(_A_func) {}
  T_return operator()(const T_obj* _A_obj, typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3,typename type_trait<T_arg4>::take _A_a4,typename type_trait<T_arg5>::take _A_a5) const
    { return (_A_obj->*(this->func_ptr_))(_A_a1,_A_a2,_A_a3,_A_a4,_A_a5); }
  T_return operator()(const T_obj& _A_obj, typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3,typename type_trait<T_arg4>::take _A_a4,typename type_trait<T_arg5>::take _A_a5) const
    { return (_A_obj.*func_ptr_)(_A_a1,_A_a2,_A_a3,_A_a4,_A_a5); }
protected:
  function_type func_ptr_;
};
template <class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
class const_volatile_mem_functor6 : public functor_base
{
public:
  typedef T_return (T_obj::*function_type)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6) const volatile;
  typedef T_return result_type;
  const_volatile_mem_functor6() : func_ptr_(0) {}
  explicit const_volatile_mem_functor6(function_type _A_func) : func_ptr_(_A_func) {}
  T_return operator()(const T_obj* _A_obj, typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3,typename type_trait<T_arg4>::take _A_a4,typename type_trait<T_arg5>::take _A_a5,typename type_trait<T_arg6>::take _A_a6) const
    { return (_A_obj->*(this->func_ptr_))(_A_a1,_A_a2,_A_a3,_A_a4,_A_a5,_A_a6); }
  T_return operator()(const T_obj& _A_obj, typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3,typename type_trait<T_arg4>::take _A_a4,typename type_trait<T_arg5>::take _A_a5,typename type_trait<T_arg6>::take _A_a6) const
    { return (_A_obj.*func_ptr_)(_A_a1,_A_a2,_A_a3,_A_a4,_A_a5,_A_a6); }
protected:
  function_type func_ptr_;
};
template <class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
class const_volatile_mem_functor7 : public functor_base
{
public:
  typedef T_return (T_obj::*function_type)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7) const volatile;
  typedef T_return result_type;
  const_volatile_mem_functor7() : func_ptr_(0) {}
  explicit const_volatile_mem_functor7(function_type _A_func) : func_ptr_(_A_func) {}
  T_return operator()(const T_obj* _A_obj, typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3,typename type_trait<T_arg4>::take _A_a4,typename type_trait<T_arg5>::take _A_a5,typename type_trait<T_arg6>::take _A_a6,typename type_trait<T_arg7>::take _A_a7) const
    { return (_A_obj->*(this->func_ptr_))(_A_a1,_A_a2,_A_a3,_A_a4,_A_a5,_A_a6,_A_a7); }
  T_return operator()(const T_obj& _A_obj, typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3,typename type_trait<T_arg4>::take _A_a4,typename type_trait<T_arg5>::take _A_a5,typename type_trait<T_arg6>::take _A_a6,typename type_trait<T_arg7>::take _A_a7) const
    { return (_A_obj.*func_ptr_)(_A_a1,_A_a2,_A_a3,_A_a4,_A_a5,_A_a6,_A_a7); }
protected:
  function_type func_ptr_;
};
template <class T_return, class T_obj>
class bound_mem_functor0
  : public mem_functor0<T_return, T_obj>
{
  typedef mem_functor0<T_return, T_obj> base_type_;
public:
  typedef typename base_type_::function_type function_type;
  bound_mem_functor0( T_obj* _A_obj, function_type _A_func)
    : base_type_(_A_func),
      obj_(*_A_obj)
    {}
  bound_mem_functor0( T_obj& _A_obj, function_type _A_func)
    : base_type_(_A_func),
      obj_(_A_obj)
    {}
  T_return operator()() const
    { return (obj_.invoke().*(this->func_ptr_))(); }
  limit_reference<T_obj> obj_;
};
template <class T_action, class T_return, class T_obj>
void visit_each(const T_action& _A_action,
                const bound_mem_functor0<T_return, T_obj>& _A_target)
{
  sigc::visit_each(_A_action, _A_target.obj_);
}
template <class T_return, class T_obj, class T_arg1>
class bound_mem_functor1
  : public mem_functor1<T_return, T_obj, T_arg1>
{
  typedef mem_functor1<T_return, T_obj, T_arg1> base_type_;
public:
  typedef typename base_type_::function_type function_type;
  bound_mem_functor1( T_obj* _A_obj, function_type _A_func)
    : base_type_(_A_func),
      obj_(*_A_obj)
    {}
  bound_mem_functor1( T_obj& _A_obj, function_type _A_func)
    : base_type_(_A_func),
      obj_(_A_obj)
    {}
  T_return operator()(typename type_trait<T_arg1>::take _A_a1) const
    { return (obj_.invoke().*(this->func_ptr_))(_A_a1); }
  limit_reference<T_obj> obj_;
};
template <class T_action, class T_return, class T_obj, class T_arg1>
void visit_each(const T_action& _A_action,
                const bound_mem_functor1<T_return, T_obj, T_arg1>& _A_target)
{
  sigc::visit_each(_A_action, _A_target.obj_);
}
template <class T_return, class T_obj, class T_arg1,class T_arg2>
class bound_mem_functor2
  : public mem_functor2<T_return, T_obj, T_arg1,T_arg2>
{
  typedef mem_functor2<T_return, T_obj, T_arg1,T_arg2> base_type_;
public:
  typedef typename base_type_::function_type function_type;
  bound_mem_functor2( T_obj* _A_obj, function_type _A_func)
    : base_type_(_A_func),
      obj_(*_A_obj)
    {}
  bound_mem_functor2( T_obj& _A_obj, function_type _A_func)
    : base_type_(_A_func),
      obj_(_A_obj)
    {}
  T_return operator()(typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2) const
    { return (obj_.invoke().*(this->func_ptr_))(_A_a1,_A_a2); }
  limit_reference<T_obj> obj_;
};
template <class T_action, class T_return, class T_obj, class T_arg1,class T_arg2>
void visit_each(const T_action& _A_action,
                const bound_mem_functor2<T_return, T_obj, T_arg1,T_arg2>& _A_target)
{
  sigc::visit_each(_A_action, _A_target.obj_);
}
template <class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3>
class bound_mem_functor3
  : public mem_functor3<T_return, T_obj, T_arg1,T_arg2,T_arg3>
{
  typedef mem_functor3<T_return, T_obj, T_arg1,T_arg2,T_arg3> base_type_;
public:
  typedef typename base_type_::function_type function_type;
  bound_mem_functor3( T_obj* _A_obj, function_type _A_func)
    : base_type_(_A_func),
      obj_(*_A_obj)
    {}
  bound_mem_functor3( T_obj& _A_obj, function_type _A_func)
    : base_type_(_A_func),
      obj_(_A_obj)
    {}
  T_return operator()(typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3) const
    { return (obj_.invoke().*(this->func_ptr_))(_A_a1,_A_a2,_A_a3); }
  limit_reference<T_obj> obj_;
};
template <class T_action, class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3>
void visit_each(const T_action& _A_action,
                const bound_mem_functor3<T_return, T_obj, T_arg1,T_arg2,T_arg3>& _A_target)
{
  sigc::visit_each(_A_action, _A_target.obj_);
}
template <class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3,class T_arg4>
class bound_mem_functor4
  : public mem_functor4<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4>
{
  typedef mem_functor4<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4> base_type_;
public:
  typedef typename base_type_::function_type function_type;
  bound_mem_functor4( T_obj* _A_obj, function_type _A_func)
    : base_type_(_A_func),
      obj_(*_A_obj)
    {}
  bound_mem_functor4( T_obj& _A_obj, function_type _A_func)
    : base_type_(_A_func),
      obj_(_A_obj)
    {}
  T_return operator()(typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3,typename type_trait<T_arg4>::take _A_a4) const
    { return (obj_.invoke().*(this->func_ptr_))(_A_a1,_A_a2,_A_a3,_A_a4); }
  limit_reference<T_obj> obj_;
};
template <class T_action, class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3,class T_arg4>
void visit_each(const T_action& _A_action,
                const bound_mem_functor4<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4>& _A_target)
{
  sigc::visit_each(_A_action, _A_target.obj_);
}
template <class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
class bound_mem_functor5
  : public mem_functor5<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>
{
  typedef mem_functor5<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5> base_type_;
public:
  typedef typename base_type_::function_type function_type;
  bound_mem_functor5( T_obj* _A_obj, function_type _A_func)
    : base_type_(_A_func),
      obj_(*_A_obj)
    {}
  bound_mem_functor5( T_obj& _A_obj, function_type _A_func)
    : base_type_(_A_func),
      obj_(_A_obj)
    {}
  T_return operator()(typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3,typename type_trait<T_arg4>::take _A_a4,typename type_trait<T_arg5>::take _A_a5) const
    { return (obj_.invoke().*(this->func_ptr_))(_A_a1,_A_a2,_A_a3,_A_a4,_A_a5); }
  limit_reference<T_obj> obj_;
};
template <class T_action, class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
void visit_each(const T_action& _A_action,
                const bound_mem_functor5<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>& _A_target)
{
  sigc::visit_each(_A_action, _A_target.obj_);
}
template <class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
class bound_mem_functor6
  : public mem_functor6<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>
{
  typedef mem_functor6<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6> base_type_;
public:
  typedef typename base_type_::function_type function_type;
  bound_mem_functor6( T_obj* _A_obj, function_type _A_func)
    : base_type_(_A_func),
      obj_(*_A_obj)
    {}
  bound_mem_functor6( T_obj& _A_obj, function_type _A_func)
    : base_type_(_A_func),
      obj_(_A_obj)
    {}
  T_return operator()(typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3,typename type_trait<T_arg4>::take _A_a4,typename type_trait<T_arg5>::take _A_a5,typename type_trait<T_arg6>::take _A_a6) const
    { return (obj_.invoke().*(this->func_ptr_))(_A_a1,_A_a2,_A_a3,_A_a4,_A_a5,_A_a6); }
  limit_reference<T_obj> obj_;
};
template <class T_action, class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
void visit_each(const T_action& _A_action,
                const bound_mem_functor6<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>& _A_target)
{
  sigc::visit_each(_A_action, _A_target.obj_);
}
template <class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
class bound_mem_functor7
  : public mem_functor7<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>
{
  typedef mem_functor7<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7> base_type_;
public:
  typedef typename base_type_::function_type function_type;
  bound_mem_functor7( T_obj* _A_obj, function_type _A_func)
    : base_type_(_A_func),
      obj_(*_A_obj)
    {}
  bound_mem_functor7( T_obj& _A_obj, function_type _A_func)
    : base_type_(_A_func),
      obj_(_A_obj)
    {}
  T_return operator()(typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3,typename type_trait<T_arg4>::take _A_a4,typename type_trait<T_arg5>::take _A_a5,typename type_trait<T_arg6>::take _A_a6,typename type_trait<T_arg7>::take _A_a7) const
    { return (obj_.invoke().*(this->func_ptr_))(_A_a1,_A_a2,_A_a3,_A_a4,_A_a5,_A_a6,_A_a7); }
  limit_reference<T_obj> obj_;
};
template <class T_action, class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
void visit_each(const T_action& _A_action,
                const bound_mem_functor7<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>& _A_target)
{
  sigc::visit_each(_A_action, _A_target.obj_);
}
template <class T_return, class T_obj>
class bound_const_mem_functor0
  : public const_mem_functor0<T_return, T_obj>
{
  typedef const_mem_functor0<T_return, T_obj> base_type_;
public:
  typedef typename base_type_::function_type function_type;
  bound_const_mem_functor0(const T_obj* _A_obj, function_type _A_func)
    : base_type_(_A_func),
      obj_(*_A_obj)
    {}
  bound_const_mem_functor0(const T_obj& _A_obj, function_type _A_func)
    : base_type_(_A_func),
      obj_(_A_obj)
    {}
  T_return operator()() const
    { return (obj_.invoke().*(this->func_ptr_))(); }
  const_limit_reference<T_obj> obj_;
};
template <class T_action, class T_return, class T_obj>
void visit_each(const T_action& _A_action,
                const bound_const_mem_functor0<T_return, T_obj>& _A_target)
{
  sigc::visit_each(_A_action, _A_target.obj_);
}
template <class T_return, class T_obj, class T_arg1>
class bound_const_mem_functor1
  : public const_mem_functor1<T_return, T_obj, T_arg1>
{
  typedef const_mem_functor1<T_return, T_obj, T_arg1> base_type_;
public:
  typedef typename base_type_::function_type function_type;
  bound_const_mem_functor1(const T_obj* _A_obj, function_type _A_func)
    : base_type_(_A_func),
      obj_(*_A_obj)
    {}
  bound_const_mem_functor1(const T_obj& _A_obj, function_type _A_func)
    : base_type_(_A_func),
      obj_(_A_obj)
    {}
  T_return operator()(typename type_trait<T_arg1>::take _A_a1) const
    { return (obj_.invoke().*(this->func_ptr_))(_A_a1); }
  const_limit_reference<T_obj> obj_;
};
template <class T_action, class T_return, class T_obj, class T_arg1>
void visit_each(const T_action& _A_action,
                const bound_const_mem_functor1<T_return, T_obj, T_arg1>& _A_target)
{
  sigc::visit_each(_A_action, _A_target.obj_);
}
template <class T_return, class T_obj, class T_arg1,class T_arg2>
class bound_const_mem_functor2
  : public const_mem_functor2<T_return, T_obj, T_arg1,T_arg2>
{
  typedef const_mem_functor2<T_return, T_obj, T_arg1,T_arg2> base_type_;
public:
  typedef typename base_type_::function_type function_type;
  bound_const_mem_functor2(const T_obj* _A_obj, function_type _A_func)
    : base_type_(_A_func),
      obj_(*_A_obj)
    {}
  bound_const_mem_functor2(const T_obj& _A_obj, function_type _A_func)
    : base_type_(_A_func),
      obj_(_A_obj)
    {}
  T_return operator()(typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2) const
    { return (obj_.invoke().*(this->func_ptr_))(_A_a1,_A_a2); }
  const_limit_reference<T_obj> obj_;
};
template <class T_action, class T_return, class T_obj, class T_arg1,class T_arg2>
void visit_each(const T_action& _A_action,
                const bound_const_mem_functor2<T_return, T_obj, T_arg1,T_arg2>& _A_target)
{
  sigc::visit_each(_A_action, _A_target.obj_);
}
template <class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3>
class bound_const_mem_functor3
  : public const_mem_functor3<T_return, T_obj, T_arg1,T_arg2,T_arg3>
{
  typedef const_mem_functor3<T_return, T_obj, T_arg1,T_arg2,T_arg3> base_type_;
public:
  typedef typename base_type_::function_type function_type;
  bound_const_mem_functor3(const T_obj* _A_obj, function_type _A_func)
    : base_type_(_A_func),
      obj_(*_A_obj)
    {}
  bound_const_mem_functor3(const T_obj& _A_obj, function_type _A_func)
    : base_type_(_A_func),
      obj_(_A_obj)
    {}
  T_return operator()(typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3) const
    { return (obj_.invoke().*(this->func_ptr_))(_A_a1,_A_a2,_A_a3); }
  const_limit_reference<T_obj> obj_;
};
template <class T_action, class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3>
void visit_each(const T_action& _A_action,
                const bound_const_mem_functor3<T_return, T_obj, T_arg1,T_arg2,T_arg3>& _A_target)
{
  sigc::visit_each(_A_action, _A_target.obj_);
}
template <class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3,class T_arg4>
class bound_const_mem_functor4
  : public const_mem_functor4<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4>
{
  typedef const_mem_functor4<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4> base_type_;
public:
  typedef typename base_type_::function_type function_type;
  bound_const_mem_functor4(const T_obj* _A_obj, function_type _A_func)
    : base_type_(_A_func),
      obj_(*_A_obj)
    {}
  bound_const_mem_functor4(const T_obj& _A_obj, function_type _A_func)
    : base_type_(_A_func),
      obj_(_A_obj)
    {}
  T_return operator()(typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3,typename type_trait<T_arg4>::take _A_a4) const
    { return (obj_.invoke().*(this->func_ptr_))(_A_a1,_A_a2,_A_a3,_A_a4); }
  const_limit_reference<T_obj> obj_;
};
template <class T_action, class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3,class T_arg4>
void visit_each(const T_action& _A_action,
                const bound_const_mem_functor4<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4>& _A_target)
{
  sigc::visit_each(_A_action, _A_target.obj_);
}
template <class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
class bound_const_mem_functor5
  : public const_mem_functor5<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>
{
  typedef const_mem_functor5<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5> base_type_;
public:
  typedef typename base_type_::function_type function_type;
  bound_const_mem_functor5(const T_obj* _A_obj, function_type _A_func)
    : base_type_(_A_func),
      obj_(*_A_obj)
    {}
  bound_const_mem_functor5(const T_obj& _A_obj, function_type _A_func)
    : base_type_(_A_func),
      obj_(_A_obj)
    {}
  T_return operator()(typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3,typename type_trait<T_arg4>::take _A_a4,typename type_trait<T_arg5>::take _A_a5) const
    { return (obj_.invoke().*(this->func_ptr_))(_A_a1,_A_a2,_A_a3,_A_a4,_A_a5); }
  const_limit_reference<T_obj> obj_;
};
template <class T_action, class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
void visit_each(const T_action& _A_action,
                const bound_const_mem_functor5<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>& _A_target)
{
  sigc::visit_each(_A_action, _A_target.obj_);
}
template <class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
class bound_const_mem_functor6
  : public const_mem_functor6<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>
{
  typedef const_mem_functor6<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6> base_type_;
public:
  typedef typename base_type_::function_type function_type;
  bound_const_mem_functor6(const T_obj* _A_obj, function_type _A_func)
    : base_type_(_A_func),
      obj_(*_A_obj)
    {}
  bound_const_mem_functor6(const T_obj& _A_obj, function_type _A_func)
    : base_type_(_A_func),
      obj_(_A_obj)
    {}
  T_return operator()(typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3,typename type_trait<T_arg4>::take _A_a4,typename type_trait<T_arg5>::take _A_a5,typename type_trait<T_arg6>::take _A_a6) const
    { return (obj_.invoke().*(this->func_ptr_))(_A_a1,_A_a2,_A_a3,_A_a4,_A_a5,_A_a6); }
  const_limit_reference<T_obj> obj_;
};
template <class T_action, class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
void visit_each(const T_action& _A_action,
                const bound_const_mem_functor6<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>& _A_target)
{
  sigc::visit_each(_A_action, _A_target.obj_);
}
template <class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
class bound_const_mem_functor7
  : public const_mem_functor7<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>
{
  typedef const_mem_functor7<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7> base_type_;
public:
  typedef typename base_type_::function_type function_type;
  bound_const_mem_functor7(const T_obj* _A_obj, function_type _A_func)
    : base_type_(_A_func),
      obj_(*_A_obj)
    {}
  bound_const_mem_functor7(const T_obj& _A_obj, function_type _A_func)
    : base_type_(_A_func),
      obj_(_A_obj)
    {}
  T_return operator()(typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3,typename type_trait<T_arg4>::take _A_a4,typename type_trait<T_arg5>::take _A_a5,typename type_trait<T_arg6>::take _A_a6,typename type_trait<T_arg7>::take _A_a7) const
    { return (obj_.invoke().*(this->func_ptr_))(_A_a1,_A_a2,_A_a3,_A_a4,_A_a5,_A_a6,_A_a7); }
  const_limit_reference<T_obj> obj_;
};
template <class T_action, class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
void visit_each(const T_action& _A_action,
                const bound_const_mem_functor7<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>& _A_target)
{
  sigc::visit_each(_A_action, _A_target.obj_);
}
template <class T_return, class T_obj>
class bound_volatile_mem_functor0
  : public volatile_mem_functor0<T_return, T_obj>
{
  typedef volatile_mem_functor0<T_return, T_obj> base_type_;
public:
  typedef typename base_type_::function_type function_type;
  bound_volatile_mem_functor0( T_obj* _A_obj, function_type _A_func)
    : base_type_(_A_func),
      obj_(*_A_obj)
    {}
  bound_volatile_mem_functor0( T_obj& _A_obj, function_type _A_func)
    : base_type_(_A_func),
      obj_(_A_obj)
    {}
  T_return operator()() const
    { return (obj_.invoke().*(this->func_ptr_))(); }
  volatile_limit_reference<T_obj> obj_;
};
template <class T_action, class T_return, class T_obj>
void visit_each(const T_action& _A_action,
                const bound_volatile_mem_functor0<T_return, T_obj>& _A_target)
{
  sigc::visit_each(_A_action, _A_target.obj_);
}
template <class T_return, class T_obj, class T_arg1>
class bound_volatile_mem_functor1
  : public volatile_mem_functor1<T_return, T_obj, T_arg1>
{
  typedef volatile_mem_functor1<T_return, T_obj, T_arg1> base_type_;
public:
  typedef typename base_type_::function_type function_type;
  bound_volatile_mem_functor1( T_obj* _A_obj, function_type _A_func)
    : base_type_(_A_func),
      obj_(*_A_obj)
    {}
  bound_volatile_mem_functor1( T_obj& _A_obj, function_type _A_func)
    : base_type_(_A_func),
      obj_(_A_obj)
    {}
  T_return operator()(typename type_trait<T_arg1>::take _A_a1) const
    { return (obj_.invoke().*(this->func_ptr_))(_A_a1); }
  volatile_limit_reference<T_obj> obj_;
};
template <class T_action, class T_return, class T_obj, class T_arg1>
void visit_each(const T_action& _A_action,
                const bound_volatile_mem_functor1<T_return, T_obj, T_arg1>& _A_target)
{
  sigc::visit_each(_A_action, _A_target.obj_);
}
template <class T_return, class T_obj, class T_arg1,class T_arg2>
class bound_volatile_mem_functor2
  : public volatile_mem_functor2<T_return, T_obj, T_arg1,T_arg2>
{
  typedef volatile_mem_functor2<T_return, T_obj, T_arg1,T_arg2> base_type_;
public:
  typedef typename base_type_::function_type function_type;
  bound_volatile_mem_functor2( T_obj* _A_obj, function_type _A_func)
    : base_type_(_A_func),
      obj_(*_A_obj)
    {}
  bound_volatile_mem_functor2( T_obj& _A_obj, function_type _A_func)
    : base_type_(_A_func),
      obj_(_A_obj)
    {}
  T_return operator()(typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2) const
    { return (obj_.invoke().*(this->func_ptr_))(_A_a1,_A_a2); }
  volatile_limit_reference<T_obj> obj_;
};
template <class T_action, class T_return, class T_obj, class T_arg1,class T_arg2>
void visit_each(const T_action& _A_action,
                const bound_volatile_mem_functor2<T_return, T_obj, T_arg1,T_arg2>& _A_target)
{
  sigc::visit_each(_A_action, _A_target.obj_);
}
template <class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3>
class bound_volatile_mem_functor3
  : public volatile_mem_functor3<T_return, T_obj, T_arg1,T_arg2,T_arg3>
{
  typedef volatile_mem_functor3<T_return, T_obj, T_arg1,T_arg2,T_arg3> base_type_;
public:
  typedef typename base_type_::function_type function_type;
  bound_volatile_mem_functor3( T_obj* _A_obj, function_type _A_func)
    : base_type_(_A_func),
      obj_(*_A_obj)
    {}
  bound_volatile_mem_functor3( T_obj& _A_obj, function_type _A_func)
    : base_type_(_A_func),
      obj_(_A_obj)
    {}
  T_return operator()(typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3) const
    { return (obj_.invoke().*(this->func_ptr_))(_A_a1,_A_a2,_A_a3); }
  volatile_limit_reference<T_obj> obj_;
};
template <class T_action, class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3>
void visit_each(const T_action& _A_action,
                const bound_volatile_mem_functor3<T_return, T_obj, T_arg1,T_arg2,T_arg3>& _A_target)
{
  sigc::visit_each(_A_action, _A_target.obj_);
}
template <class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3,class T_arg4>
class bound_volatile_mem_functor4
  : public volatile_mem_functor4<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4>
{
  typedef volatile_mem_functor4<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4> base_type_;
public:
  typedef typename base_type_::function_type function_type;
  bound_volatile_mem_functor4( T_obj* _A_obj, function_type _A_func)
    : base_type_(_A_func),
      obj_(*_A_obj)
    {}
  bound_volatile_mem_functor4( T_obj& _A_obj, function_type _A_func)
    : base_type_(_A_func),
      obj_(_A_obj)
    {}
  T_return operator()(typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3,typename type_trait<T_arg4>::take _A_a4) const
    { return (obj_.invoke().*(this->func_ptr_))(_A_a1,_A_a2,_A_a3,_A_a4); }
  volatile_limit_reference<T_obj> obj_;
};
template <class T_action, class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3,class T_arg4>
void visit_each(const T_action& _A_action,
                const bound_volatile_mem_functor4<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4>& _A_target)
{
  sigc::visit_each(_A_action, _A_target.obj_);
}
template <class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
class bound_volatile_mem_functor5
  : public volatile_mem_functor5<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>
{
  typedef volatile_mem_functor5<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5> base_type_;
public:
  typedef typename base_type_::function_type function_type;
  bound_volatile_mem_functor5( T_obj* _A_obj, function_type _A_func)
    : base_type_(_A_func),
      obj_(*_A_obj)
    {}
  bound_volatile_mem_functor5( T_obj& _A_obj, function_type _A_func)
    : base_type_(_A_func),
      obj_(_A_obj)
    {}
  T_return operator()(typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3,typename type_trait<T_arg4>::take _A_a4,typename type_trait<T_arg5>::take _A_a5) const
    { return (obj_.invoke().*(this->func_ptr_))(_A_a1,_A_a2,_A_a3,_A_a4,_A_a5); }
  volatile_limit_reference<T_obj> obj_;
};
template <class T_action, class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
void visit_each(const T_action& _A_action,
                const bound_volatile_mem_functor5<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>& _A_target)
{
  sigc::visit_each(_A_action, _A_target.obj_);
}
template <class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
class bound_volatile_mem_functor6
  : public volatile_mem_functor6<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>
{
  typedef volatile_mem_functor6<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6> base_type_;
public:
  typedef typename base_type_::function_type function_type;
  bound_volatile_mem_functor6( T_obj* _A_obj, function_type _A_func)
    : base_type_(_A_func),
      obj_(*_A_obj)
    {}
  bound_volatile_mem_functor6( T_obj& _A_obj, function_type _A_func)
    : base_type_(_A_func),
      obj_(_A_obj)
    {}
  T_return operator()(typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3,typename type_trait<T_arg4>::take _A_a4,typename type_trait<T_arg5>::take _A_a5,typename type_trait<T_arg6>::take _A_a6) const
    { return (obj_.invoke().*(this->func_ptr_))(_A_a1,_A_a2,_A_a3,_A_a4,_A_a5,_A_a6); }
  volatile_limit_reference<T_obj> obj_;
};
template <class T_action, class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
void visit_each(const T_action& _A_action,
                const bound_volatile_mem_functor6<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>& _A_target)
{
  sigc::visit_each(_A_action, _A_target.obj_);
}
template <class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
class bound_volatile_mem_functor7
  : public volatile_mem_functor7<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>
{
  typedef volatile_mem_functor7<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7> base_type_;
public:
  typedef typename base_type_::function_type function_type;
  bound_volatile_mem_functor7( T_obj* _A_obj, function_type _A_func)
    : base_type_(_A_func),
      obj_(*_A_obj)
    {}
  bound_volatile_mem_functor7( T_obj& _A_obj, function_type _A_func)
    : base_type_(_A_func),
      obj_(_A_obj)
    {}
  T_return operator()(typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3,typename type_trait<T_arg4>::take _A_a4,typename type_trait<T_arg5>::take _A_a5,typename type_trait<T_arg6>::take _A_a6,typename type_trait<T_arg7>::take _A_a7) const
    { return (obj_.invoke().*(this->func_ptr_))(_A_a1,_A_a2,_A_a3,_A_a4,_A_a5,_A_a6,_A_a7); }
  volatile_limit_reference<T_obj> obj_;
};
template <class T_action, class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
void visit_each(const T_action& _A_action,
                const bound_volatile_mem_functor7<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>& _A_target)
{
  sigc::visit_each(_A_action, _A_target.obj_);
}
template <class T_return, class T_obj>
class bound_const_volatile_mem_functor0
  : public const_volatile_mem_functor0<T_return, T_obj>
{
  typedef const_volatile_mem_functor0<T_return, T_obj> base_type_;
public:
  typedef typename base_type_::function_type function_type;
  bound_const_volatile_mem_functor0(const T_obj* _A_obj, function_type _A_func)
    : base_type_(_A_func),
      obj_(*_A_obj)
    {}
  bound_const_volatile_mem_functor0(const T_obj& _A_obj, function_type _A_func)
    : base_type_(_A_func),
      obj_(_A_obj)
    {}
  T_return operator()() const
    { return (obj_.invoke().*(this->func_ptr_))(); }
  const_volatile_limit_reference<T_obj> obj_;
};
template <class T_action, class T_return, class T_obj>
void visit_each(const T_action& _A_action,
                const bound_const_volatile_mem_functor0<T_return, T_obj>& _A_target)
{
  sigc::visit_each(_A_action, _A_target.obj_);
}
template <class T_return, class T_obj, class T_arg1>
class bound_const_volatile_mem_functor1
  : public const_volatile_mem_functor1<T_return, T_obj, T_arg1>
{
  typedef const_volatile_mem_functor1<T_return, T_obj, T_arg1> base_type_;
public:
  typedef typename base_type_::function_type function_type;
  bound_const_volatile_mem_functor1(const T_obj* _A_obj, function_type _A_func)
    : base_type_(_A_func),
      obj_(*_A_obj)
    {}
  bound_const_volatile_mem_functor1(const T_obj& _A_obj, function_type _A_func)
    : base_type_(_A_func),
      obj_(_A_obj)
    {}
  T_return operator()(typename type_trait<T_arg1>::take _A_a1) const
    { return (obj_.invoke().*(this->func_ptr_))(_A_a1); }
  const_volatile_limit_reference<T_obj> obj_;
};
template <class T_action, class T_return, class T_obj, class T_arg1>
void visit_each(const T_action& _A_action,
                const bound_const_volatile_mem_functor1<T_return, T_obj, T_arg1>& _A_target)
{
  sigc::visit_each(_A_action, _A_target.obj_);
}
template <class T_return, class T_obj, class T_arg1,class T_arg2>
class bound_const_volatile_mem_functor2
  : public const_volatile_mem_functor2<T_return, T_obj, T_arg1,T_arg2>
{
  typedef const_volatile_mem_functor2<T_return, T_obj, T_arg1,T_arg2> base_type_;
public:
  typedef typename base_type_::function_type function_type;
  bound_const_volatile_mem_functor2(const T_obj* _A_obj, function_type _A_func)
    : base_type_(_A_func),
      obj_(*_A_obj)
    {}
  bound_const_volatile_mem_functor2(const T_obj& _A_obj, function_type _A_func)
    : base_type_(_A_func),
      obj_(_A_obj)
    {}
  T_return operator()(typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2) const
    { return (obj_.invoke().*(this->func_ptr_))(_A_a1,_A_a2); }
  const_volatile_limit_reference<T_obj> obj_;
};
template <class T_action, class T_return, class T_obj, class T_arg1,class T_arg2>
void visit_each(const T_action& _A_action,
                const bound_const_volatile_mem_functor2<T_return, T_obj, T_arg1,T_arg2>& _A_target)
{
  sigc::visit_each(_A_action, _A_target.obj_);
}
template <class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3>
class bound_const_volatile_mem_functor3
  : public const_volatile_mem_functor3<T_return, T_obj, T_arg1,T_arg2,T_arg3>
{
  typedef const_volatile_mem_functor3<T_return, T_obj, T_arg1,T_arg2,T_arg3> base_type_;
public:
  typedef typename base_type_::function_type function_type;
  bound_const_volatile_mem_functor3(const T_obj* _A_obj, function_type _A_func)
    : base_type_(_A_func),
      obj_(*_A_obj)
    {}
  bound_const_volatile_mem_functor3(const T_obj& _A_obj, function_type _A_func)
    : base_type_(_A_func),
      obj_(_A_obj)
    {}
  T_return operator()(typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3) const
    { return (obj_.invoke().*(this->func_ptr_))(_A_a1,_A_a2,_A_a3); }
  const_volatile_limit_reference<T_obj> obj_;
};
template <class T_action, class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3>
void visit_each(const T_action& _A_action,
                const bound_const_volatile_mem_functor3<T_return, T_obj, T_arg1,T_arg2,T_arg3>& _A_target)
{
  sigc::visit_each(_A_action, _A_target.obj_);
}
template <class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3,class T_arg4>
class bound_const_volatile_mem_functor4
  : public const_volatile_mem_functor4<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4>
{
  typedef const_volatile_mem_functor4<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4> base_type_;
public:
  typedef typename base_type_::function_type function_type;
  bound_const_volatile_mem_functor4(const T_obj* _A_obj, function_type _A_func)
    : base_type_(_A_func),
      obj_(*_A_obj)
    {}
  bound_const_volatile_mem_functor4(const T_obj& _A_obj, function_type _A_func)
    : base_type_(_A_func),
      obj_(_A_obj)
    {}
  T_return operator()(typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3,typename type_trait<T_arg4>::take _A_a4) const
    { return (obj_.invoke().*(this->func_ptr_))(_A_a1,_A_a2,_A_a3,_A_a4); }
  const_volatile_limit_reference<T_obj> obj_;
};
template <class T_action, class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3,class T_arg4>
void visit_each(const T_action& _A_action,
                const bound_const_volatile_mem_functor4<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4>& _A_target)
{
  sigc::visit_each(_A_action, _A_target.obj_);
}
template <class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
class bound_const_volatile_mem_functor5
  : public const_volatile_mem_functor5<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>
{
  typedef const_volatile_mem_functor5<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5> base_type_;
public:
  typedef typename base_type_::function_type function_type;
  bound_const_volatile_mem_functor5(const T_obj* _A_obj, function_type _A_func)
    : base_type_(_A_func),
      obj_(*_A_obj)
    {}
  bound_const_volatile_mem_functor5(const T_obj& _A_obj, function_type _A_func)
    : base_type_(_A_func),
      obj_(_A_obj)
    {}
  T_return operator()(typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3,typename type_trait<T_arg4>::take _A_a4,typename type_trait<T_arg5>::take _A_a5) const
    { return (obj_.invoke().*(this->func_ptr_))(_A_a1,_A_a2,_A_a3,_A_a4,_A_a5); }
  const_volatile_limit_reference<T_obj> obj_;
};
template <class T_action, class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
void visit_each(const T_action& _A_action,
                const bound_const_volatile_mem_functor5<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>& _A_target)
{
  sigc::visit_each(_A_action, _A_target.obj_);
}
template <class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
class bound_const_volatile_mem_functor6
  : public const_volatile_mem_functor6<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>
{
  typedef const_volatile_mem_functor6<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6> base_type_;
public:
  typedef typename base_type_::function_type function_type;
  bound_const_volatile_mem_functor6(const T_obj* _A_obj, function_type _A_func)
    : base_type_(_A_func),
      obj_(*_A_obj)
    {}
  bound_const_volatile_mem_functor6(const T_obj& _A_obj, function_type _A_func)
    : base_type_(_A_func),
      obj_(_A_obj)
    {}
  T_return operator()(typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3,typename type_trait<T_arg4>::take _A_a4,typename type_trait<T_arg5>::take _A_a5,typename type_trait<T_arg6>::take _A_a6) const
    { return (obj_.invoke().*(this->func_ptr_))(_A_a1,_A_a2,_A_a3,_A_a4,_A_a5,_A_a6); }
  const_volatile_limit_reference<T_obj> obj_;
};
template <class T_action, class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
void visit_each(const T_action& _A_action,
                const bound_const_volatile_mem_functor6<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>& _A_target)
{
  sigc::visit_each(_A_action, _A_target.obj_);
}
template <class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
class bound_const_volatile_mem_functor7
  : public const_volatile_mem_functor7<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>
{
  typedef const_volatile_mem_functor7<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7> base_type_;
public:
  typedef typename base_type_::function_type function_type;
  bound_const_volatile_mem_functor7(const T_obj* _A_obj, function_type _A_func)
    : base_type_(_A_func),
      obj_(*_A_obj)
    {}
  bound_const_volatile_mem_functor7(const T_obj& _A_obj, function_type _A_func)
    : base_type_(_A_func),
      obj_(_A_obj)
    {}
  T_return operator()(typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3,typename type_trait<T_arg4>::take _A_a4,typename type_trait<T_arg5>::take _A_a5,typename type_trait<T_arg6>::take _A_a6,typename type_trait<T_arg7>::take _A_a7) const
    { return (obj_.invoke().*(this->func_ptr_))(_A_a1,_A_a2,_A_a3,_A_a4,_A_a5,_A_a6,_A_a7); }
  const_volatile_limit_reference<T_obj> obj_;
};
template <class T_action, class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
void visit_each(const T_action& _A_action,
                const bound_const_volatile_mem_functor7<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>& _A_target)
{
  sigc::visit_each(_A_action, _A_target.obj_);
}
template <class T_return, class T_obj>
inline mem_functor0<T_return, T_obj>
mem_fun0(T_return (T_obj::*_A_func)() )
{ return mem_functor0<T_return, T_obj>(_A_func); }
template <class T_arg1, class T_return, class T_obj>
inline mem_functor1<T_return, T_obj, T_arg1>
mem_fun1(T_return (T_obj::*_A_func)(T_arg1) )
{ return mem_functor1<T_return, T_obj, T_arg1>(_A_func); }
template <class T_arg1,class T_arg2, class T_return, class T_obj>
inline mem_functor2<T_return, T_obj, T_arg1,T_arg2>
mem_fun2(T_return (T_obj::*_A_func)(T_arg1,T_arg2) )
{ return mem_functor2<T_return, T_obj, T_arg1,T_arg2>(_A_func); }
template <class T_arg1,class T_arg2,class T_arg3, class T_return, class T_obj>
inline mem_functor3<T_return, T_obj, T_arg1,T_arg2,T_arg3>
mem_fun3(T_return (T_obj::*_A_func)(T_arg1,T_arg2,T_arg3) )
{ return mem_functor3<T_return, T_obj, T_arg1,T_arg2,T_arg3>(_A_func); }
template <class T_arg1,class T_arg2,class T_arg3,class T_arg4, class T_return, class T_obj>
inline mem_functor4<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4>
mem_fun4(T_return (T_obj::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4) )
{ return mem_functor4<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4>(_A_func); }
template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5, class T_return, class T_obj>
inline mem_functor5<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>
mem_fun5(T_return (T_obj::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5) )
{ return mem_functor5<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>(_A_func); }
template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6, class T_return, class T_obj>
inline mem_functor6<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>
mem_fun6(T_return (T_obj::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6) )
{ return mem_functor6<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>(_A_func); }
template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7, class T_return, class T_obj>
inline mem_functor7<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>
mem_fun7(T_return (T_obj::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7) )
{ return mem_functor7<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>(_A_func); }
template <class T_return, class T_obj>
inline const_mem_functor0<T_return, T_obj>
mem_fun0(T_return (T_obj::*_A_func)() const)
{ return const_mem_functor0<T_return, T_obj>(_A_func); }
template <class T_arg1, class T_return, class T_obj>
inline const_mem_functor1<T_return, T_obj, T_arg1>
mem_fun1(T_return (T_obj::*_A_func)(T_arg1) const)
{ return const_mem_functor1<T_return, T_obj, T_arg1>(_A_func); }
template <class T_arg1,class T_arg2, class T_return, class T_obj>
inline const_mem_functor2<T_return, T_obj, T_arg1,T_arg2>
mem_fun2(T_return (T_obj::*_A_func)(T_arg1,T_arg2) const)
{ return const_mem_functor2<T_return, T_obj, T_arg1,T_arg2>(_A_func); }
template <class T_arg1,class T_arg2,class T_arg3, class T_return, class T_obj>
inline const_mem_functor3<T_return, T_obj, T_arg1,T_arg2,T_arg3>
mem_fun3(T_return (T_obj::*_A_func)(T_arg1,T_arg2,T_arg3) const)
{ return const_mem_functor3<T_return, T_obj, T_arg1,T_arg2,T_arg3>(_A_func); }
template <class T_arg1,class T_arg2,class T_arg3,class T_arg4, class T_return, class T_obj>
inline const_mem_functor4<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4>
mem_fun4(T_return (T_obj::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4) const)
{ return const_mem_functor4<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4>(_A_func); }
template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5, class T_return, class T_obj>
inline const_mem_functor5<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>
mem_fun5(T_return (T_obj::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5) const)
{ return const_mem_functor5<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>(_A_func); }
template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6, class T_return, class T_obj>
inline const_mem_functor6<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>
mem_fun6(T_return (T_obj::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6) const)
{ return const_mem_functor6<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>(_A_func); }
template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7, class T_return, class T_obj>
inline const_mem_functor7<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>
mem_fun7(T_return (T_obj::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7) const)
{ return const_mem_functor7<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>(_A_func); }
template <class T_return, class T_obj>
inline volatile_mem_functor0<T_return, T_obj>
mem_fun0(T_return (T_obj::*_A_func)() volatile)
{ return volatile_mem_functor0<T_return, T_obj>(_A_func); }
template <class T_arg1, class T_return, class T_obj>
inline volatile_mem_functor1<T_return, T_obj, T_arg1>
mem_fun1(T_return (T_obj::*_A_func)(T_arg1) volatile)
{ return volatile_mem_functor1<T_return, T_obj, T_arg1>(_A_func); }
template <class T_arg1,class T_arg2, class T_return, class T_obj>
inline volatile_mem_functor2<T_return, T_obj, T_arg1,T_arg2>
mem_fun2(T_return (T_obj::*_A_func)(T_arg1,T_arg2) volatile)
{ return volatile_mem_functor2<T_return, T_obj, T_arg1,T_arg2>(_A_func); }
template <class T_arg1,class T_arg2,class T_arg3, class T_return, class T_obj>
inline volatile_mem_functor3<T_return, T_obj, T_arg1,T_arg2,T_arg3>
mem_fun3(T_return (T_obj::*_A_func)(T_arg1,T_arg2,T_arg3) volatile)
{ return volatile_mem_functor3<T_return, T_obj, T_arg1,T_arg2,T_arg3>(_A_func); }
template <class T_arg1,class T_arg2,class T_arg3,class T_arg4, class T_return, class T_obj>
inline volatile_mem_functor4<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4>
mem_fun4(T_return (T_obj::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4) volatile)
{ return volatile_mem_functor4<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4>(_A_func); }
template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5, class T_return, class T_obj>
inline volatile_mem_functor5<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>
mem_fun5(T_return (T_obj::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5) volatile)
{ return volatile_mem_functor5<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>(_A_func); }
template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6, class T_return, class T_obj>
inline volatile_mem_functor6<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>
mem_fun6(T_return (T_obj::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6) volatile)
{ return volatile_mem_functor6<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>(_A_func); }
template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7, class T_return, class T_obj>
inline volatile_mem_functor7<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>
mem_fun7(T_return (T_obj::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7) volatile)
{ return volatile_mem_functor7<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>(_A_func); }
template <class T_return, class T_obj>
inline const_volatile_mem_functor0<T_return, T_obj>
mem_fun0(T_return (T_obj::*_A_func)() const volatile)
{ return const_volatile_mem_functor0<T_return, T_obj>(_A_func); }
template <class T_arg1, class T_return, class T_obj>
inline const_volatile_mem_functor1<T_return, T_obj, T_arg1>
mem_fun1(T_return (T_obj::*_A_func)(T_arg1) const volatile)
{ return const_volatile_mem_functor1<T_return, T_obj, T_arg1>(_A_func); }
template <class T_arg1,class T_arg2, class T_return, class T_obj>
inline const_volatile_mem_functor2<T_return, T_obj, T_arg1,T_arg2>
mem_fun2(T_return (T_obj::*_A_func)(T_arg1,T_arg2) const volatile)
{ return const_volatile_mem_functor2<T_return, T_obj, T_arg1,T_arg2>(_A_func); }
template <class T_arg1,class T_arg2,class T_arg3, class T_return, class T_obj>
inline const_volatile_mem_functor3<T_return, T_obj, T_arg1,T_arg2,T_arg3>
mem_fun3(T_return (T_obj::*_A_func)(T_arg1,T_arg2,T_arg3) const volatile)
{ return const_volatile_mem_functor3<T_return, T_obj, T_arg1,T_arg2,T_arg3>(_A_func); }
template <class T_arg1,class T_arg2,class T_arg3,class T_arg4, class T_return, class T_obj>
inline const_volatile_mem_functor4<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4>
mem_fun4(T_return (T_obj::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4) const volatile)
{ return const_volatile_mem_functor4<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4>(_A_func); }
template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5, class T_return, class T_obj>
inline const_volatile_mem_functor5<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>
mem_fun5(T_return (T_obj::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5) const volatile)
{ return const_volatile_mem_functor5<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>(_A_func); }
template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6, class T_return, class T_obj>
inline const_volatile_mem_functor6<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>
mem_fun6(T_return (T_obj::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6) const volatile)
{ return const_volatile_mem_functor6<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>(_A_func); }
template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7, class T_return, class T_obj>
inline const_volatile_mem_functor7<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>
mem_fun7(T_return (T_obj::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7) const volatile)
{ return const_volatile_mem_functor7<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>(_A_func); }
template <class T_return, class T_obj, class T_obj2>
inline bound_mem_functor0<T_return, T_obj>
mem_fun0( T_obj* _A_obj, T_return (T_obj2::*_A_func)() )
{ return bound_mem_functor0<T_return, T_obj>(_A_obj, _A_func); }
template <class T_return, class T_obj, class T_obj2>
inline bound_mem_functor0<T_return, T_obj>
mem_fun0( T_obj& _A_obj, T_return (T_obj2::*_A_func)() )
{ return bound_mem_functor0<T_return, T_obj>(_A_obj, _A_func); }
template <class T_arg1, class T_return, class T_obj, class T_obj2>
inline bound_mem_functor1<T_return, T_obj, T_arg1>
mem_fun1( T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1) )
{ return bound_mem_functor1<T_return, T_obj, T_arg1>(_A_obj, _A_func); }
template <class T_arg1, class T_return, class T_obj, class T_obj2>
inline bound_mem_functor1<T_return, T_obj, T_arg1>
mem_fun1( T_obj& _A_obj, T_return (T_obj2::*_A_func)(T_arg1) )
{ return bound_mem_functor1<T_return, T_obj, T_arg1>(_A_obj, _A_func); }
template <class T_arg1,class T_arg2, class T_return, class T_obj, class T_obj2>
inline bound_mem_functor2<T_return, T_obj, T_arg1,T_arg2>
mem_fun2( T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2) )
{ return bound_mem_functor2<T_return, T_obj, T_arg1,T_arg2>(_A_obj, _A_func); }
template <class T_arg1,class T_arg2, class T_return, class T_obj, class T_obj2>
inline bound_mem_functor2<T_return, T_obj, T_arg1,T_arg2>
mem_fun2( T_obj& _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2) )
{ return bound_mem_functor2<T_return, T_obj, T_arg1,T_arg2>(_A_obj, _A_func); }
template <class T_arg1,class T_arg2,class T_arg3, class T_return, class T_obj, class T_obj2>
inline bound_mem_functor3<T_return, T_obj, T_arg1,T_arg2,T_arg3>
mem_fun3( T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3) )
{ return bound_mem_functor3<T_return, T_obj, T_arg1,T_arg2,T_arg3>(_A_obj, _A_func); }
template <class T_arg1,class T_arg2,class T_arg3, class T_return, class T_obj, class T_obj2>
inline bound_mem_functor3<T_return, T_obj, T_arg1,T_arg2,T_arg3>
mem_fun3( T_obj& _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3) )
{ return bound_mem_functor3<T_return, T_obj, T_arg1,T_arg2,T_arg3>(_A_obj, _A_func); }
template <class T_arg1,class T_arg2,class T_arg3,class T_arg4, class T_return, class T_obj, class T_obj2>
inline bound_mem_functor4<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4>
mem_fun4( T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4) )
{ return bound_mem_functor4<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4>(_A_obj, _A_func); }
template <class T_arg1,class T_arg2,class T_arg3,class T_arg4, class T_return, class T_obj, class T_obj2>
inline bound_mem_functor4<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4>
mem_fun4( T_obj& _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4) )
{ return bound_mem_functor4<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4>(_A_obj, _A_func); }
template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5, class T_return, class T_obj, class T_obj2>
inline bound_mem_functor5<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>
mem_fun5( T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5) )
{ return bound_mem_functor5<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>(_A_obj, _A_func); }
template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5, class T_return, class T_obj, class T_obj2>
inline bound_mem_functor5<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>
mem_fun5( T_obj& _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5) )
{ return bound_mem_functor5<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>(_A_obj, _A_func); }
template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6, class T_return, class T_obj, class T_obj2>
inline bound_mem_functor6<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>
mem_fun6( T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6) )
{ return bound_mem_functor6<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>(_A_obj, _A_func); }
template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6, class T_return, class T_obj, class T_obj2>
inline bound_mem_functor6<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>
mem_fun6( T_obj& _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6) )
{ return bound_mem_functor6<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>(_A_obj, _A_func); }
template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7, class T_return, class T_obj, class T_obj2>
inline bound_mem_functor7<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>
mem_fun7( T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7) )
{ return bound_mem_functor7<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>(_A_obj, _A_func); }
template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7, class T_return, class T_obj, class T_obj2>
inline bound_mem_functor7<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>
mem_fun7( T_obj& _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7) )
{ return bound_mem_functor7<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>(_A_obj, _A_func); }
template <class T_return, class T_obj, class T_obj2>
inline bound_const_mem_functor0<T_return, T_obj>
mem_fun0( T_obj* _A_obj, T_return (T_obj2::*_A_func)() const)
{ return bound_const_mem_functor0<T_return, T_obj>(_A_obj, _A_func); }
template <class T_return, class T_obj, class T_obj2>
inline bound_const_mem_functor0<T_return, T_obj>
mem_fun0( T_obj& _A_obj, T_return (T_obj2::*_A_func)() const)
{ return bound_const_mem_functor0<T_return, T_obj>(_A_obj, _A_func); }
template <class T_arg1, class T_return, class T_obj, class T_obj2>
inline bound_const_mem_functor1<T_return, T_obj, T_arg1>
mem_fun1( T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1) const)
{ return bound_const_mem_functor1<T_return, T_obj, T_arg1>(_A_obj, _A_func); }
template <class T_arg1, class T_return, class T_obj, class T_obj2>
inline bound_const_mem_functor1<T_return, T_obj, T_arg1>
mem_fun1( T_obj& _A_obj, T_return (T_obj2::*_A_func)(T_arg1) const)
{ return bound_const_mem_functor1<T_return, T_obj, T_arg1>(_A_obj, _A_func); }
template <class T_arg1,class T_arg2, class T_return, class T_obj, class T_obj2>
inline bound_const_mem_functor2<T_return, T_obj, T_arg1,T_arg2>
mem_fun2( T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2) const)
{ return bound_const_mem_functor2<T_return, T_obj, T_arg1,T_arg2>(_A_obj, _A_func); }
template <class T_arg1,class T_arg2, class T_return, class T_obj, class T_obj2>
inline bound_const_mem_functor2<T_return, T_obj, T_arg1,T_arg2>
mem_fun2( T_obj& _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2) const)
{ return bound_const_mem_functor2<T_return, T_obj, T_arg1,T_arg2>(_A_obj, _A_func); }
template <class T_arg1,class T_arg2,class T_arg3, class T_return, class T_obj, class T_obj2>
inline bound_const_mem_functor3<T_return, T_obj, T_arg1,T_arg2,T_arg3>
mem_fun3( T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3) const)
{ return bound_const_mem_functor3<T_return, T_obj, T_arg1,T_arg2,T_arg3>(_A_obj, _A_func); }
template <class T_arg1,class T_arg2,class T_arg3, class T_return, class T_obj, class T_obj2>
inline bound_const_mem_functor3<T_return, T_obj, T_arg1,T_arg2,T_arg3>
mem_fun3( T_obj& _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3) const)
{ return bound_const_mem_functor3<T_return, T_obj, T_arg1,T_arg2,T_arg3>(_A_obj, _A_func); }
template <class T_arg1,class T_arg2,class T_arg3,class T_arg4, class T_return, class T_obj, class T_obj2>
inline bound_const_mem_functor4<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4>
mem_fun4( T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4) const)
{ return bound_const_mem_functor4<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4>(_A_obj, _A_func); }
template <class T_arg1,class T_arg2,class T_arg3,class T_arg4, class T_return, class T_obj, class T_obj2>
inline bound_const_mem_functor4<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4>
mem_fun4( T_obj& _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4) const)
{ return bound_const_mem_functor4<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4>(_A_obj, _A_func); }
template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5, class T_return, class T_obj, class T_obj2>
inline bound_const_mem_functor5<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>
mem_fun5( T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5) const)
{ return bound_const_mem_functor5<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>(_A_obj, _A_func); }
template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5, class T_return, class T_obj, class T_obj2>
inline bound_const_mem_functor5<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>
mem_fun5( T_obj& _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5) const)
{ return bound_const_mem_functor5<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>(_A_obj, _A_func); }
template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6, class T_return, class T_obj, class T_obj2>
inline bound_const_mem_functor6<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>
mem_fun6( T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6) const)
{ return bound_const_mem_functor6<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>(_A_obj, _A_func); }
template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6, class T_return, class T_obj, class T_obj2>
inline bound_const_mem_functor6<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>
mem_fun6( T_obj& _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6) const)
{ return bound_const_mem_functor6<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>(_A_obj, _A_func); }
template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7, class T_return, class T_obj, class T_obj2>
inline bound_const_mem_functor7<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>
mem_fun7( T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7) const)
{ return bound_const_mem_functor7<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>(_A_obj, _A_func); }
template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7, class T_return, class T_obj, class T_obj2>
inline bound_const_mem_functor7<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>
mem_fun7( T_obj& _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7) const)
{ return bound_const_mem_functor7<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>(_A_obj, _A_func); }
template <class T_return, class T_obj, class T_obj2>
inline bound_volatile_mem_functor0<T_return, T_obj>
mem_fun0( T_obj* _A_obj, T_return (T_obj2::*_A_func)() volatile)
{ return bound_volatile_mem_functor0<T_return, T_obj>(_A_obj, _A_func); }
template <class T_return, class T_obj, class T_obj2>
inline bound_volatile_mem_functor0<T_return, T_obj>
mem_fun0( T_obj& _A_obj, T_return (T_obj2::*_A_func)() volatile)
{ return bound_volatile_mem_functor0<T_return, T_obj>(_A_obj, _A_func); }
template <class T_arg1, class T_return, class T_obj, class T_obj2>
inline bound_volatile_mem_functor1<T_return, T_obj, T_arg1>
mem_fun1( T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1) volatile)
{ return bound_volatile_mem_functor1<T_return, T_obj, T_arg1>(_A_obj, _A_func); }
template <class T_arg1, class T_return, class T_obj, class T_obj2>
inline bound_volatile_mem_functor1<T_return, T_obj, T_arg1>
mem_fun1( T_obj& _A_obj, T_return (T_obj2::*_A_func)(T_arg1) volatile)
{ return bound_volatile_mem_functor1<T_return, T_obj, T_arg1>(_A_obj, _A_func); }
template <class T_arg1,class T_arg2, class T_return, class T_obj, class T_obj2>
inline bound_volatile_mem_functor2<T_return, T_obj, T_arg1,T_arg2>
mem_fun2( T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2) volatile)
{ return bound_volatile_mem_functor2<T_return, T_obj, T_arg1,T_arg2>(_A_obj, _A_func); }
template <class T_arg1,class T_arg2, class T_return, class T_obj, class T_obj2>
inline bound_volatile_mem_functor2<T_return, T_obj, T_arg1,T_arg2>
mem_fun2( T_obj& _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2) volatile)
{ return bound_volatile_mem_functor2<T_return, T_obj, T_arg1,T_arg2>(_A_obj, _A_func); }
template <class T_arg1,class T_arg2,class T_arg3, class T_return, class T_obj, class T_obj2>
inline bound_volatile_mem_functor3<T_return, T_obj, T_arg1,T_arg2,T_arg3>
mem_fun3( T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3) volatile)
{ return bound_volatile_mem_functor3<T_return, T_obj, T_arg1,T_arg2,T_arg3>(_A_obj, _A_func); }
template <class T_arg1,class T_arg2,class T_arg3, class T_return, class T_obj, class T_obj2>
inline bound_volatile_mem_functor3<T_return, T_obj, T_arg1,T_arg2,T_arg3>
mem_fun3( T_obj& _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3) volatile)
{ return bound_volatile_mem_functor3<T_return, T_obj, T_arg1,T_arg2,T_arg3>(_A_obj, _A_func); }
template <class T_arg1,class T_arg2,class T_arg3,class T_arg4, class T_return, class T_obj, class T_obj2>
inline bound_volatile_mem_functor4<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4>
mem_fun4( T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4) volatile)
{ return bound_volatile_mem_functor4<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4>(_A_obj, _A_func); }
template <class T_arg1,class T_arg2,class T_arg3,class T_arg4, class T_return, class T_obj, class T_obj2>
inline bound_volatile_mem_functor4<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4>
mem_fun4( T_obj& _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4) volatile)
{ return bound_volatile_mem_functor4<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4>(_A_obj, _A_func); }
template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5, class T_return, class T_obj, class T_obj2>
inline bound_volatile_mem_functor5<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>
mem_fun5( T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5) volatile)
{ return bound_volatile_mem_functor5<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>(_A_obj, _A_func); }
template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5, class T_return, class T_obj, class T_obj2>
inline bound_volatile_mem_functor5<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>
mem_fun5( T_obj& _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5) volatile)
{ return bound_volatile_mem_functor5<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>(_A_obj, _A_func); }
template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6, class T_return, class T_obj, class T_obj2>
inline bound_volatile_mem_functor6<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>
mem_fun6( T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6) volatile)
{ return bound_volatile_mem_functor6<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>(_A_obj, _A_func); }
template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6, class T_return, class T_obj, class T_obj2>
inline bound_volatile_mem_functor6<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>
mem_fun6( T_obj& _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6) volatile)
{ return bound_volatile_mem_functor6<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>(_A_obj, _A_func); }
template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7, class T_return, class T_obj, class T_obj2>
inline bound_volatile_mem_functor7<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>
mem_fun7( T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7) volatile)
{ return bound_volatile_mem_functor7<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>(_A_obj, _A_func); }
template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7, class T_return, class T_obj, class T_obj2>
inline bound_volatile_mem_functor7<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>
mem_fun7( T_obj& _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7) volatile)
{ return bound_volatile_mem_functor7<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>(_A_obj, _A_func); }
template <class T_return, class T_obj, class T_obj2>
inline bound_const_volatile_mem_functor0<T_return, T_obj>
mem_fun0( T_obj* _A_obj, T_return (T_obj2::*_A_func)() const volatile)
{ return bound_const_volatile_mem_functor0<T_return, T_obj>(_A_obj, _A_func); }
template <class T_return, class T_obj, class T_obj2>
inline bound_const_volatile_mem_functor0<T_return, T_obj>
mem_fun0( T_obj& _A_obj, T_return (T_obj2::*_A_func)() const volatile)
{ return bound_const_volatile_mem_functor0<T_return, T_obj>(_A_obj, _A_func); }
template <class T_arg1, class T_return, class T_obj, class T_obj2>
inline bound_const_volatile_mem_functor1<T_return, T_obj, T_arg1>
mem_fun1( T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1) const volatile)
{ return bound_const_volatile_mem_functor1<T_return, T_obj, T_arg1>(_A_obj, _A_func); }
template <class T_arg1, class T_return, class T_obj, class T_obj2>
inline bound_const_volatile_mem_functor1<T_return, T_obj, T_arg1>
mem_fun1( T_obj& _A_obj, T_return (T_obj2::*_A_func)(T_arg1) const volatile)
{ return bound_const_volatile_mem_functor1<T_return, T_obj, T_arg1>(_A_obj, _A_func); }
template <class T_arg1,class T_arg2, class T_return, class T_obj, class T_obj2>
inline bound_const_volatile_mem_functor2<T_return, T_obj, T_arg1,T_arg2>
mem_fun2( T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2) const volatile)
{ return bound_const_volatile_mem_functor2<T_return, T_obj, T_arg1,T_arg2>(_A_obj, _A_func); }
template <class T_arg1,class T_arg2, class T_return, class T_obj, class T_obj2>
inline bound_const_volatile_mem_functor2<T_return, T_obj, T_arg1,T_arg2>
mem_fun2( T_obj& _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2) const volatile)
{ return bound_const_volatile_mem_functor2<T_return, T_obj, T_arg1,T_arg2>(_A_obj, _A_func); }
template <class T_arg1,class T_arg2,class T_arg3, class T_return, class T_obj, class T_obj2>
inline bound_const_volatile_mem_functor3<T_return, T_obj, T_arg1,T_arg2,T_arg3>
mem_fun3( T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3) const volatile)
{ return bound_const_volatile_mem_functor3<T_return, T_obj, T_arg1,T_arg2,T_arg3>(_A_obj, _A_func); }
template <class T_arg1,class T_arg2,class T_arg3, class T_return, class T_obj, class T_obj2>
inline bound_const_volatile_mem_functor3<T_return, T_obj, T_arg1,T_arg2,T_arg3>
mem_fun3( T_obj& _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3) const volatile)
{ return bound_const_volatile_mem_functor3<T_return, T_obj, T_arg1,T_arg2,T_arg3>(_A_obj, _A_func); }
template <class T_arg1,class T_arg2,class T_arg3,class T_arg4, class T_return, class T_obj, class T_obj2>
inline bound_const_volatile_mem_functor4<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4>
mem_fun4( T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4) const volatile)
{ return bound_const_volatile_mem_functor4<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4>(_A_obj, _A_func); }
template <class T_arg1,class T_arg2,class T_arg3,class T_arg4, class T_return, class T_obj, class T_obj2>
inline bound_const_volatile_mem_functor4<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4>
mem_fun4( T_obj& _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4) const volatile)
{ return bound_const_volatile_mem_functor4<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4>(_A_obj, _A_func); }
template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5, class T_return, class T_obj, class T_obj2>
inline bound_const_volatile_mem_functor5<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>
mem_fun5( T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5) const volatile)
{ return bound_const_volatile_mem_functor5<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>(_A_obj, _A_func); }
template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5, class T_return, class T_obj, class T_obj2>
inline bound_const_volatile_mem_functor5<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>
mem_fun5( T_obj& _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5) const volatile)
{ return bound_const_volatile_mem_functor5<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>(_A_obj, _A_func); }
template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6, class T_return, class T_obj, class T_obj2>
inline bound_const_volatile_mem_functor6<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>
mem_fun6( T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6) const volatile)
{ return bound_const_volatile_mem_functor6<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>(_A_obj, _A_func); }
template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6, class T_return, class T_obj, class T_obj2>
inline bound_const_volatile_mem_functor6<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>
mem_fun6( T_obj& _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6) const volatile)
{ return bound_const_volatile_mem_functor6<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>(_A_obj, _A_func); }
template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7, class T_return, class T_obj, class T_obj2>
inline bound_const_volatile_mem_functor7<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>
mem_fun7( T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7) const volatile)
{ return bound_const_volatile_mem_functor7<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>(_A_obj, _A_func); }
template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7, class T_return, class T_obj, class T_obj2>
inline bound_const_volatile_mem_functor7<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>
mem_fun7( T_obj& _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7) const volatile)
{ return bound_const_volatile_mem_functor7<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>(_A_obj, _A_func); }
template <class T_return, class T_obj>
inline mem_functor0<T_return, T_obj>
mem_fun(T_return (T_obj::*_A_func)() )
{ return mem_functor0<T_return, T_obj>(_A_func); }
template <class T_arg1, class T_return, class T_obj>
inline mem_functor1<T_return, T_obj, T_arg1>
mem_fun(T_return (T_obj::*_A_func)(T_arg1) )
{ return mem_functor1<T_return, T_obj, T_arg1>(_A_func); }
template <class T_arg1,class T_arg2, class T_return, class T_obj>
inline mem_functor2<T_return, T_obj, T_arg1,T_arg2>
mem_fun(T_return (T_obj::*_A_func)(T_arg1,T_arg2) )
{ return mem_functor2<T_return, T_obj, T_arg1,T_arg2>(_A_func); }
template <class T_arg1,class T_arg2,class T_arg3, class T_return, class T_obj>
inline mem_functor3<T_return, T_obj, T_arg1,T_arg2,T_arg3>
mem_fun(T_return (T_obj::*_A_func)(T_arg1,T_arg2,T_arg3) )
{ return mem_functor3<T_return, T_obj, T_arg1,T_arg2,T_arg3>(_A_func); }
template <class T_arg1,class T_arg2,class T_arg3,class T_arg4, class T_return, class T_obj>
inline mem_functor4<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4>
mem_fun(T_return (T_obj::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4) )
{ return mem_functor4<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4>(_A_func); }
template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5, class T_return, class T_obj>
inline mem_functor5<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>
mem_fun(T_return (T_obj::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5) )
{ return mem_functor5<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>(_A_func); }
template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6, class T_return, class T_obj>
inline mem_functor6<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>
mem_fun(T_return (T_obj::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6) )
{ return mem_functor6<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>(_A_func); }
template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7, class T_return, class T_obj>
inline mem_functor7<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>
mem_fun(T_return (T_obj::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7) )
{ return mem_functor7<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>(_A_func); }
template <class T_return, class T_obj>
inline const_mem_functor0<T_return, T_obj>
mem_fun(T_return (T_obj::*_A_func)() const)
{ return const_mem_functor0<T_return, T_obj>(_A_func); }
template <class T_arg1, class T_return, class T_obj>
inline const_mem_functor1<T_return, T_obj, T_arg1>
mem_fun(T_return (T_obj::*_A_func)(T_arg1) const)
{ return const_mem_functor1<T_return, T_obj, T_arg1>(_A_func); }
template <class T_arg1,class T_arg2, class T_return, class T_obj>
inline const_mem_functor2<T_return, T_obj, T_arg1,T_arg2>
mem_fun(T_return (T_obj::*_A_func)(T_arg1,T_arg2) const)
{ return const_mem_functor2<T_return, T_obj, T_arg1,T_arg2>(_A_func); }
template <class T_arg1,class T_arg2,class T_arg3, class T_return, class T_obj>
inline const_mem_functor3<T_return, T_obj, T_arg1,T_arg2,T_arg3>
mem_fun(T_return (T_obj::*_A_func)(T_arg1,T_arg2,T_arg3) const)
{ return const_mem_functor3<T_return, T_obj, T_arg1,T_arg2,T_arg3>(_A_func); }
template <class T_arg1,class T_arg2,class T_arg3,class T_arg4, class T_return, class T_obj>
inline const_mem_functor4<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4>
mem_fun(T_return (T_obj::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4) const)
{ return const_mem_functor4<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4>(_A_func); }
template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5, class T_return, class T_obj>
inline const_mem_functor5<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>
mem_fun(T_return (T_obj::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5) const)
{ return const_mem_functor5<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>(_A_func); }
template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6, class T_return, class T_obj>
inline const_mem_functor6<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>
mem_fun(T_return (T_obj::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6) const)
{ return const_mem_functor6<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>(_A_func); }
template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7, class T_return, class T_obj>
inline const_mem_functor7<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>
mem_fun(T_return (T_obj::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7) const)
{ return const_mem_functor7<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>(_A_func); }
template <class T_return, class T_obj>
inline volatile_mem_functor0<T_return, T_obj>
mem_fun(T_return (T_obj::*_A_func)() volatile)
{ return volatile_mem_functor0<T_return, T_obj>(_A_func); }
template <class T_arg1, class T_return, class T_obj>
inline volatile_mem_functor1<T_return, T_obj, T_arg1>
mem_fun(T_return (T_obj::*_A_func)(T_arg1) volatile)
{ return volatile_mem_functor1<T_return, T_obj, T_arg1>(_A_func); }
template <class T_arg1,class T_arg2, class T_return, class T_obj>
inline volatile_mem_functor2<T_return, T_obj, T_arg1,T_arg2>
mem_fun(T_return (T_obj::*_A_func)(T_arg1,T_arg2) volatile)
{ return volatile_mem_functor2<T_return, T_obj, T_arg1,T_arg2>(_A_func); }
template <class T_arg1,class T_arg2,class T_arg3, class T_return, class T_obj>
inline volatile_mem_functor3<T_return, T_obj, T_arg1,T_arg2,T_arg3>
mem_fun(T_return (T_obj::*_A_func)(T_arg1,T_arg2,T_arg3) volatile)
{ return volatile_mem_functor3<T_return, T_obj, T_arg1,T_arg2,T_arg3>(_A_func); }
template <class T_arg1,class T_arg2,class T_arg3,class T_arg4, class T_return, class T_obj>
inline volatile_mem_functor4<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4>
mem_fun(T_return (T_obj::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4) volatile)
{ return volatile_mem_functor4<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4>(_A_func); }
template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5, class T_return, class T_obj>
inline volatile_mem_functor5<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>
mem_fun(T_return (T_obj::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5) volatile)
{ return volatile_mem_functor5<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>(_A_func); }
template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6, class T_return, class T_obj>
inline volatile_mem_functor6<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>
mem_fun(T_return (T_obj::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6) volatile)
{ return volatile_mem_functor6<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>(_A_func); }
template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7, class T_return, class T_obj>
inline volatile_mem_functor7<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>
mem_fun(T_return (T_obj::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7) volatile)
{ return volatile_mem_functor7<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>(_A_func); }
template <class T_return, class T_obj>
inline const_volatile_mem_functor0<T_return, T_obj>
mem_fun(T_return (T_obj::*_A_func)() const volatile)
{ return const_volatile_mem_functor0<T_return, T_obj>(_A_func); }
template <class T_arg1, class T_return, class T_obj>
inline const_volatile_mem_functor1<T_return, T_obj, T_arg1>
mem_fun(T_return (T_obj::*_A_func)(T_arg1) const volatile)
{ return const_volatile_mem_functor1<T_return, T_obj, T_arg1>(_A_func); }
template <class T_arg1,class T_arg2, class T_return, class T_obj>
inline const_volatile_mem_functor2<T_return, T_obj, T_arg1,T_arg2>
mem_fun(T_return (T_obj::*_A_func)(T_arg1,T_arg2) const volatile)
{ return const_volatile_mem_functor2<T_return, T_obj, T_arg1,T_arg2>(_A_func); }
template <class T_arg1,class T_arg2,class T_arg3, class T_return, class T_obj>
inline const_volatile_mem_functor3<T_return, T_obj, T_arg1,T_arg2,T_arg3>
mem_fun(T_return (T_obj::*_A_func)(T_arg1,T_arg2,T_arg3) const volatile)
{ return const_volatile_mem_functor3<T_return, T_obj, T_arg1,T_arg2,T_arg3>(_A_func); }
template <class T_arg1,class T_arg2,class T_arg3,class T_arg4, class T_return, class T_obj>
inline const_volatile_mem_functor4<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4>
mem_fun(T_return (T_obj::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4) const volatile)
{ return const_volatile_mem_functor4<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4>(_A_func); }
template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5, class T_return, class T_obj>
inline const_volatile_mem_functor5<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>
mem_fun(T_return (T_obj::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5) const volatile)
{ return const_volatile_mem_functor5<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>(_A_func); }
template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6, class T_return, class T_obj>
inline const_volatile_mem_functor6<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>
mem_fun(T_return (T_obj::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6) const volatile)
{ return const_volatile_mem_functor6<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>(_A_func); }
template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7, class T_return, class T_obj>
inline const_volatile_mem_functor7<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>
mem_fun(T_return (T_obj::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7) const volatile)
{ return const_volatile_mem_functor7<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>(_A_func); }
template <class T_return, class T_obj, class T_obj2>
inline bound_mem_functor0<T_return, T_obj>
mem_fun( T_obj* _A_obj, T_return (T_obj2::*_A_func)() )
{ return bound_mem_functor0<T_return, T_obj>(_A_obj, _A_func); }
template <class T_return, class T_obj, class T_obj2>
inline bound_mem_functor0<T_return, T_obj>
mem_fun( T_obj& _A_obj, T_return (T_obj2::*_A_func)() )
{ return bound_mem_functor0<T_return, T_obj>(_A_obj, _A_func); }
template <class T_arg1, class T_return, class T_obj, class T_obj2>
inline bound_mem_functor1<T_return, T_obj, T_arg1>
mem_fun( T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1) )
{ return bound_mem_functor1<T_return, T_obj, T_arg1>(_A_obj, _A_func); }
template <class T_arg1, class T_return, class T_obj, class T_obj2>
inline bound_mem_functor1<T_return, T_obj, T_arg1>
mem_fun( T_obj& _A_obj, T_return (T_obj2::*_A_func)(T_arg1) )
{ return bound_mem_functor1<T_return, T_obj, T_arg1>(_A_obj, _A_func); }
template <class T_arg1,class T_arg2, class T_return, class T_obj, class T_obj2>
inline bound_mem_functor2<T_return, T_obj, T_arg1,T_arg2>
mem_fun( T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2) )
{ return bound_mem_functor2<T_return, T_obj, T_arg1,T_arg2>(_A_obj, _A_func); }
template <class T_arg1,class T_arg2, class T_return, class T_obj, class T_obj2>
inline bound_mem_functor2<T_return, T_obj, T_arg1,T_arg2>
mem_fun( T_obj& _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2) )
{ return bound_mem_functor2<T_return, T_obj, T_arg1,T_arg2>(_A_obj, _A_func); }
template <class T_arg1,class T_arg2,class T_arg3, class T_return, class T_obj, class T_obj2>
inline bound_mem_functor3<T_return, T_obj, T_arg1,T_arg2,T_arg3>
mem_fun( T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3) )
{ return bound_mem_functor3<T_return, T_obj, T_arg1,T_arg2,T_arg3>(_A_obj, _A_func); }
template <class T_arg1,class T_arg2,class T_arg3, class T_return, class T_obj, class T_obj2>
inline bound_mem_functor3<T_return, T_obj, T_arg1,T_arg2,T_arg3>
mem_fun( T_obj& _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3) )
{ return bound_mem_functor3<T_return, T_obj, T_arg1,T_arg2,T_arg3>(_A_obj, _A_func); }
template <class T_arg1,class T_arg2,class T_arg3,class T_arg4, class T_return, class T_obj, class T_obj2>
inline bound_mem_functor4<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4>
mem_fun( T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4) )
{ return bound_mem_functor4<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4>(_A_obj, _A_func); }
template <class T_arg1,class T_arg2,class T_arg3,class T_arg4, class T_return, class T_obj, class T_obj2>
inline bound_mem_functor4<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4>
mem_fun( T_obj& _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4) )
{ return bound_mem_functor4<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4>(_A_obj, _A_func); }
template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5, class T_return, class T_obj, class T_obj2>
inline bound_mem_functor5<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>
mem_fun( T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5) )
{ return bound_mem_functor5<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>(_A_obj, _A_func); }
template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5, class T_return, class T_obj, class T_obj2>
inline bound_mem_functor5<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>
mem_fun( T_obj& _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5) )
{ return bound_mem_functor5<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>(_A_obj, _A_func); }
template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6, class T_return, class T_obj, class T_obj2>
inline bound_mem_functor6<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>
mem_fun( T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6) )
{ return bound_mem_functor6<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>(_A_obj, _A_func); }
template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6, class T_return, class T_obj, class T_obj2>
inline bound_mem_functor6<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>
mem_fun( T_obj& _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6) )
{ return bound_mem_functor6<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>(_A_obj, _A_func); }
template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7, class T_return, class T_obj, class T_obj2>
inline bound_mem_functor7<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>
mem_fun( T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7) )
{ return bound_mem_functor7<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>(_A_obj, _A_func); }
template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7, class T_return, class T_obj, class T_obj2>
inline bound_mem_functor7<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>
mem_fun( T_obj& _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7) )
{ return bound_mem_functor7<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>(_A_obj, _A_func); }
template <class T_return, class T_obj, class T_obj2>
inline bound_const_mem_functor0<T_return, T_obj>
mem_fun( T_obj* _A_obj, T_return (T_obj2::*_A_func)() const)
{ return bound_const_mem_functor0<T_return, T_obj>(_A_obj, _A_func); }
template <class T_return, class T_obj, class T_obj2>
inline bound_const_mem_functor0<T_return, T_obj>
mem_fun( T_obj& _A_obj, T_return (T_obj2::*_A_func)() const)
{ return bound_const_mem_functor0<T_return, T_obj>(_A_obj, _A_func); }
template <class T_arg1, class T_return, class T_obj, class T_obj2>
inline bound_const_mem_functor1<T_return, T_obj, T_arg1>
mem_fun( T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1) const)
{ return bound_const_mem_functor1<T_return, T_obj, T_arg1>(_A_obj, _A_func); }
template <class T_arg1, class T_return, class T_obj, class T_obj2>
inline bound_const_mem_functor1<T_return, T_obj, T_arg1>
mem_fun( T_obj& _A_obj, T_return (T_obj2::*_A_func)(T_arg1) const)
{ return bound_const_mem_functor1<T_return, T_obj, T_arg1>(_A_obj, _A_func); }
template <class T_arg1,class T_arg2, class T_return, class T_obj, class T_obj2>
inline bound_const_mem_functor2<T_return, T_obj, T_arg1,T_arg2>
mem_fun( T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2) const)
{ return bound_const_mem_functor2<T_return, T_obj, T_arg1,T_arg2>(_A_obj, _A_func); }
template <class T_arg1,class T_arg2, class T_return, class T_obj, class T_obj2>
inline bound_const_mem_functor2<T_return, T_obj, T_arg1,T_arg2>
mem_fun( T_obj& _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2) const)
{ return bound_const_mem_functor2<T_return, T_obj, T_arg1,T_arg2>(_A_obj, _A_func); }
template <class T_arg1,class T_arg2,class T_arg3, class T_return, class T_obj, class T_obj2>
inline bound_const_mem_functor3<T_return, T_obj, T_arg1,T_arg2,T_arg3>
mem_fun( T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3) const)
{ return bound_const_mem_functor3<T_return, T_obj, T_arg1,T_arg2,T_arg3>(_A_obj, _A_func); }
template <class T_arg1,class T_arg2,class T_arg3, class T_return, class T_obj, class T_obj2>
inline bound_const_mem_functor3<T_return, T_obj, T_arg1,T_arg2,T_arg3>
mem_fun( T_obj& _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3) const)
{ return bound_const_mem_functor3<T_return, T_obj, T_arg1,T_arg2,T_arg3>(_A_obj, _A_func); }
template <class T_arg1,class T_arg2,class T_arg3,class T_arg4, class T_return, class T_obj, class T_obj2>
inline bound_const_mem_functor4<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4>
mem_fun( T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4) const)
{ return bound_const_mem_functor4<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4>(_A_obj, _A_func); }
template <class T_arg1,class T_arg2,class T_arg3,class T_arg4, class T_return, class T_obj, class T_obj2>
inline bound_const_mem_functor4<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4>
mem_fun( T_obj& _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4) const)
{ return bound_const_mem_functor4<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4>(_A_obj, _A_func); }
template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5, class T_return, class T_obj, class T_obj2>
inline bound_const_mem_functor5<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>
mem_fun( T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5) const)
{ return bound_const_mem_functor5<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>(_A_obj, _A_func); }
template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5, class T_return, class T_obj, class T_obj2>
inline bound_const_mem_functor5<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>
mem_fun( T_obj& _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5) const)
{ return bound_const_mem_functor5<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>(_A_obj, _A_func); }
template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6, class T_return, class T_obj, class T_obj2>
inline bound_const_mem_functor6<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>
mem_fun( T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6) const)
{ return bound_const_mem_functor6<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>(_A_obj, _A_func); }
template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6, class T_return, class T_obj, class T_obj2>
inline bound_const_mem_functor6<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>
mem_fun( T_obj& _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6) const)
{ return bound_const_mem_functor6<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>(_A_obj, _A_func); }
template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7, class T_return, class T_obj, class T_obj2>
inline bound_const_mem_functor7<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>
mem_fun( T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7) const)
{ return bound_const_mem_functor7<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>(_A_obj, _A_func); }
template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7, class T_return, class T_obj, class T_obj2>
inline bound_const_mem_functor7<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>
mem_fun( T_obj& _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7) const)
{ return bound_const_mem_functor7<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>(_A_obj, _A_func); }
template <class T_return, class T_obj, class T_obj2>
inline bound_volatile_mem_functor0<T_return, T_obj>
mem_fun( T_obj* _A_obj, T_return (T_obj2::*_A_func)() volatile)
{ return bound_volatile_mem_functor0<T_return, T_obj>(_A_obj, _A_func); }
template <class T_return, class T_obj, class T_obj2>
inline bound_volatile_mem_functor0<T_return, T_obj>
mem_fun( T_obj& _A_obj, T_return (T_obj2::*_A_func)() volatile)
{ return bound_volatile_mem_functor0<T_return, T_obj>(_A_obj, _A_func); }
template <class T_arg1, class T_return, class T_obj, class T_obj2>
inline bound_volatile_mem_functor1<T_return, T_obj, T_arg1>
mem_fun( T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1) volatile)
{ return bound_volatile_mem_functor1<T_return, T_obj, T_arg1>(_A_obj, _A_func); }
template <class T_arg1, class T_return, class T_obj, class T_obj2>
inline bound_volatile_mem_functor1<T_return, T_obj, T_arg1>
mem_fun( T_obj& _A_obj, T_return (T_obj2::*_A_func)(T_arg1) volatile)
{ return bound_volatile_mem_functor1<T_return, T_obj, T_arg1>(_A_obj, _A_func); }
template <class T_arg1,class T_arg2, class T_return, class T_obj, class T_obj2>
inline bound_volatile_mem_functor2<T_return, T_obj, T_arg1,T_arg2>
mem_fun( T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2) volatile)
{ return bound_volatile_mem_functor2<T_return, T_obj, T_arg1,T_arg2>(_A_obj, _A_func); }
template <class T_arg1,class T_arg2, class T_return, class T_obj, class T_obj2>
inline bound_volatile_mem_functor2<T_return, T_obj, T_arg1,T_arg2>
mem_fun( T_obj& _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2) volatile)
{ return bound_volatile_mem_functor2<T_return, T_obj, T_arg1,T_arg2>(_A_obj, _A_func); }
template <class T_arg1,class T_arg2,class T_arg3, class T_return, class T_obj, class T_obj2>
inline bound_volatile_mem_functor3<T_return, T_obj, T_arg1,T_arg2,T_arg3>
mem_fun( T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3) volatile)
{ return bound_volatile_mem_functor3<T_return, T_obj, T_arg1,T_arg2,T_arg3>(_A_obj, _A_func); }
template <class T_arg1,class T_arg2,class T_arg3, class T_return, class T_obj, class T_obj2>
inline bound_volatile_mem_functor3<T_return, T_obj, T_arg1,T_arg2,T_arg3>
mem_fun( T_obj& _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3) volatile)
{ return bound_volatile_mem_functor3<T_return, T_obj, T_arg1,T_arg2,T_arg3>(_A_obj, _A_func); }
template <class T_arg1,class T_arg2,class T_arg3,class T_arg4, class T_return, class T_obj, class T_obj2>
inline bound_volatile_mem_functor4<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4>
mem_fun( T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4) volatile)
{ return bound_volatile_mem_functor4<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4>(_A_obj, _A_func); }
template <class T_arg1,class T_arg2,class T_arg3,class T_arg4, class T_return, class T_obj, class T_obj2>
inline bound_volatile_mem_functor4<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4>
mem_fun( T_obj& _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4) volatile)
{ return bound_volatile_mem_functor4<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4>(_A_obj, _A_func); }
template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5, class T_return, class T_obj, class T_obj2>
inline bound_volatile_mem_functor5<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>
mem_fun( T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5) volatile)
{ return bound_volatile_mem_functor5<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>(_A_obj, _A_func); }
template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5, class T_return, class T_obj, class T_obj2>
inline bound_volatile_mem_functor5<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>
mem_fun( T_obj& _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5) volatile)
{ return bound_volatile_mem_functor5<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>(_A_obj, _A_func); }
template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6, class T_return, class T_obj, class T_obj2>
inline bound_volatile_mem_functor6<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>
mem_fun( T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6) volatile)
{ return bound_volatile_mem_functor6<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>(_A_obj, _A_func); }
template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6, class T_return, class T_obj, class T_obj2>
inline bound_volatile_mem_functor6<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>
mem_fun( T_obj& _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6) volatile)
{ return bound_volatile_mem_functor6<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>(_A_obj, _A_func); }
template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7, class T_return, class T_obj, class T_obj2>
inline bound_volatile_mem_functor7<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>
mem_fun( T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7) volatile)
{ return bound_volatile_mem_functor7<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>(_A_obj, _A_func); }
template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7, class T_return, class T_obj, class T_obj2>
inline bound_volatile_mem_functor7<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>
mem_fun( T_obj& _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7) volatile)
{ return bound_volatile_mem_functor7<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>(_A_obj, _A_func); }
template <class T_return, class T_obj, class T_obj2>
inline bound_const_volatile_mem_functor0<T_return, T_obj>
mem_fun( T_obj* _A_obj, T_return (T_obj2::*_A_func)() const volatile)
{ return bound_const_volatile_mem_functor0<T_return, T_obj>(_A_obj, _A_func); }
template <class T_return, class T_obj, class T_obj2>
inline bound_const_volatile_mem_functor0<T_return, T_obj>
mem_fun( T_obj& _A_obj, T_return (T_obj2::*_A_func)() const volatile)
{ return bound_const_volatile_mem_functor0<T_return, T_obj>(_A_obj, _A_func); }
template <class T_arg1, class T_return, class T_obj, class T_obj2>
inline bound_const_volatile_mem_functor1<T_return, T_obj, T_arg1>
mem_fun( T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1) const volatile)
{ return bound_const_volatile_mem_functor1<T_return, T_obj, T_arg1>(_A_obj, _A_func); }
template <class T_arg1, class T_return, class T_obj, class T_obj2>
inline bound_const_volatile_mem_functor1<T_return, T_obj, T_arg1>
mem_fun( T_obj& _A_obj, T_return (T_obj2::*_A_func)(T_arg1) const volatile)
{ return bound_const_volatile_mem_functor1<T_return, T_obj, T_arg1>(_A_obj, _A_func); }
template <class T_arg1,class T_arg2, class T_return, class T_obj, class T_obj2>
inline bound_const_volatile_mem_functor2<T_return, T_obj, T_arg1,T_arg2>
mem_fun( T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2) const volatile)
{ return bound_const_volatile_mem_functor2<T_return, T_obj, T_arg1,T_arg2>(_A_obj, _A_func); }
template <class T_arg1,class T_arg2, class T_return, class T_obj, class T_obj2>
inline bound_const_volatile_mem_functor2<T_return, T_obj, T_arg1,T_arg2>
mem_fun( T_obj& _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2) const volatile)
{ return bound_const_volatile_mem_functor2<T_return, T_obj, T_arg1,T_arg2>(_A_obj, _A_func); }
template <class T_arg1,class T_arg2,class T_arg3, class T_return, class T_obj, class T_obj2>
inline bound_const_volatile_mem_functor3<T_return, T_obj, T_arg1,T_arg2,T_arg3>
mem_fun( T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3) const volatile)
{ return bound_const_volatile_mem_functor3<T_return, T_obj, T_arg1,T_arg2,T_arg3>(_A_obj, _A_func); }
template <class T_arg1,class T_arg2,class T_arg3, class T_return, class T_obj, class T_obj2>
inline bound_const_volatile_mem_functor3<T_return, T_obj, T_arg1,T_arg2,T_arg3>
mem_fun( T_obj& _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3) const volatile)
{ return bound_const_volatile_mem_functor3<T_return, T_obj, T_arg1,T_arg2,T_arg3>(_A_obj, _A_func); }
template <class T_arg1,class T_arg2,class T_arg3,class T_arg4, class T_return, class T_obj, class T_obj2>
inline bound_const_volatile_mem_functor4<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4>
mem_fun( T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4) const volatile)
{ return bound_const_volatile_mem_functor4<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4>(_A_obj, _A_func); }
template <class T_arg1,class T_arg2,class T_arg3,class T_arg4, class T_return, class T_obj, class T_obj2>
inline bound_const_volatile_mem_functor4<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4>
mem_fun( T_obj& _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4) const volatile)
{ return bound_const_volatile_mem_functor4<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4>(_A_obj, _A_func); }
template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5, class T_return, class T_obj, class T_obj2>
inline bound_const_volatile_mem_functor5<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>
mem_fun( T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5) const volatile)
{ return bound_const_volatile_mem_functor5<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>(_A_obj, _A_func); }
template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5, class T_return, class T_obj, class T_obj2>
inline bound_const_volatile_mem_functor5<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>
mem_fun( T_obj& _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5) const volatile)
{ return bound_const_volatile_mem_functor5<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>(_A_obj, _A_func); }
template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6, class T_return, class T_obj, class T_obj2>
inline bound_const_volatile_mem_functor6<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>
mem_fun( T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6) const volatile)
{ return bound_const_volatile_mem_functor6<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>(_A_obj, _A_func); }
template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6, class T_return, class T_obj, class T_obj2>
inline bound_const_volatile_mem_functor6<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>
mem_fun( T_obj& _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6) const volatile)
{ return bound_const_volatile_mem_functor6<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>(_A_obj, _A_func); }
template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7, class T_return, class T_obj, class T_obj2>
inline bound_const_volatile_mem_functor7<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>
mem_fun( T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7) const volatile)
{ return bound_const_volatile_mem_functor7<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>(_A_obj, _A_func); }
template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7, class T_return, class T_obj, class T_obj2>
inline bound_const_volatile_mem_functor7<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>
mem_fun( T_obj& _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7) const volatile)
{ return bound_const_volatile_mem_functor7<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>(_A_obj, _A_func); }
}
namespace sigc {
struct adaptor_base : public functor_base {};
template <class T_functor,
          class T_arg1=void,class T_arg2=void,class T_arg3=void,class T_arg4=void,class T_arg5=void,class T_arg6=void,class T_arg7=void,
          bool I_derives_adaptor_base=is_base_and_derived<adaptor_base,T_functor>::value>
struct deduce_result_type
  { typedef typename functor_trait<T_functor>::result_type type; };
template <class T_functor>
struct deduce_result_type<T_functor, void,void,void,void,void,void,void, true>
  { typedef typename T_functor::template deduce_result_type<>::type type; };
template <class T_functor, class T_arg1>
struct deduce_result_type<T_functor, T_arg1, void,void,void,void,void,void, true>
  { typedef typename T_functor::template deduce_result_type<T_arg1>::type type; };
template <class T_functor, class T_arg1,class T_arg2>
struct deduce_result_type<T_functor, T_arg1,T_arg2, void,void,void,void,void, true>
  { typedef typename T_functor::template deduce_result_type<T_arg1,T_arg2>::type type; };
template <class T_functor, class T_arg1,class T_arg2,class T_arg3>
struct deduce_result_type<T_functor, T_arg1,T_arg2,T_arg3, void,void,void,void, true>
  { typedef typename T_functor::template deduce_result_type<T_arg1,T_arg2,T_arg3>::type type; };
template <class T_functor, class T_arg1,class T_arg2,class T_arg3,class T_arg4>
struct deduce_result_type<T_functor, T_arg1,T_arg2,T_arg3,T_arg4, void,void,void, true>
  { typedef typename T_functor::template deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4>::type type; };
template <class T_functor, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
struct deduce_result_type<T_functor, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5, void,void, true>
  { typedef typename T_functor::template deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>::type type; };
template <class T_functor, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
struct deduce_result_type<T_functor, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6, void, true>
  { typedef typename T_functor::template deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>::type type; };
template <class T_functor, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
struct deduce_result_type<T_functor, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7, true>
  { typedef typename T_functor::template deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>::type type; };
}
namespace sigc {
template <class T_functor> struct adapts;
template <class T_functor>
struct adaptor_functor : public adaptor_base
{
  template <class T_arg1=void,class T_arg2=void,class T_arg3=void,class T_arg4=void,class T_arg5=void,class T_arg6=void,class T_arg7=void>
  struct deduce_result_type
    { typedef typename sigc::deduce_result_type<T_functor, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>::type type; };
  typedef typename functor_trait<T_functor>::result_type result_type;
  result_type
  operator()() const;
  template <class T_arg1>
  typename deduce_result_type<T_arg1>::type
  operator()(T_arg1 _A_arg1) const
    { return functor_(_A_arg1); }
  template <class T_arg1,class T_arg2>
  typename deduce_result_type<T_arg1,T_arg2>::type
  operator()(T_arg1 _A_arg1,T_arg2 _A_arg2) const
    { return functor_(_A_arg1,_A_arg2); }
  template <class T_arg1,class T_arg2,class T_arg3>
  typename deduce_result_type<T_arg1,T_arg2,T_arg3>::type
  operator()(T_arg1 _A_arg1,T_arg2 _A_arg2,T_arg3 _A_arg3) const
    { return functor_(_A_arg1,_A_arg2,_A_arg3); }
  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4>
  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4>::type
  operator()(T_arg1 _A_arg1,T_arg2 _A_arg2,T_arg3 _A_arg3,T_arg4 _A_arg4) const
    { return functor_(_A_arg1,_A_arg2,_A_arg3,_A_arg4); }
  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>::type
  operator()(T_arg1 _A_arg1,T_arg2 _A_arg2,T_arg3 _A_arg3,T_arg4 _A_arg4,T_arg5 _A_arg5) const
    { return functor_(_A_arg1,_A_arg2,_A_arg3,_A_arg4,_A_arg5); }
  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>::type
  operator()(T_arg1 _A_arg1,T_arg2 _A_arg2,T_arg3 _A_arg3,T_arg4 _A_arg4,T_arg5 _A_arg5,T_arg6 _A_arg6) const
    { return functor_(_A_arg1,_A_arg2,_A_arg3,_A_arg4,_A_arg5,_A_arg6); }
  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>::type
  operator()(T_arg1 _A_arg1,T_arg2 _A_arg2,T_arg3 _A_arg3,T_arg4 _A_arg4,T_arg5 _A_arg5,T_arg6 _A_arg6,T_arg7 _A_arg7) const
    { return functor_(_A_arg1,_A_arg2,_A_arg3,_A_arg4,_A_arg5,_A_arg6,_A_arg7); }
  adaptor_functor()
    {}
  explicit adaptor_functor(const T_functor& _A_functor)
    : functor_(_A_functor)
    {}
  template <class T_type>
  explicit adaptor_functor(const T_type& _A_type)
    : functor_(_A_type)
    {}
  mutable T_functor functor_;
};
template <class T_functor>
typename adaptor_functor<T_functor>::result_type
adaptor_functor<T_functor>::operator()() const
  { return functor_(); }
template <class T_action, class T_functor>
void visit_each(const T_action& _A_action,
                const adaptor_functor<T_functor>& _A_target)
{
  sigc::visit_each(_A_action, _A_target.functor_);
}
template <class T_functor, bool I_isadaptor = is_base_and_derived<adaptor_base, T_functor>::value> struct adaptor_trait;
template <class T_functor>
struct adaptor_trait<T_functor, true>
{
  typedef typename T_functor::result_type result_type;
  typedef T_functor functor_type;
  typedef T_functor adaptor_type;
};
template <class T_functor>
struct adaptor_trait<T_functor, false>
{
  typedef typename functor_trait<T_functor>::result_type result_type;
  typedef typename functor_trait<T_functor>::functor_type functor_type;
  typedef adaptor_functor<functor_type> adaptor_type;
};
template <class T_functor>
struct adapts : public adaptor_base
{
  typedef typename adaptor_trait<T_functor>::result_type result_type;
  typedef typename adaptor_trait<T_functor>::adaptor_type adaptor_type;
  explicit adapts(const T_functor& _A_functor)
    : functor_(_A_functor)
    {}
  mutable adaptor_type functor_;
};
}
namespace sigc
{
namespace internal {
typedef void* (*hook)(void*);
struct slot_rep : public trackable
{
  hook call_;
  hook destroy_;
  hook dup_;
  hook cleanup_;
  void* parent_;
  inline slot_rep(hook call__, hook destroy__, hook dup__)
    : call_(call__), destroy_(destroy__), dup_(dup__), cleanup_(0), parent_(0) {}
  inline ~slot_rep()
    { destroy(); }
  inline void destroy()
    { if (destroy_) (*destroy_)(this); }
  inline slot_rep* dup() const
    { return reinterpret_cast<slot_rep*>((*dup_)(const_cast<slot_rep*>(this))); }
  inline void set_parent(void* parent, hook cleanup)
    {
      parent_ = parent;
      cleanup_ = cleanup;
    }
  void disconnect();
  static void* notify(void* data);
};
struct slot_do_bind
{
  slot_rep* rep_;
  inline slot_do_bind(slot_rep* rep) : rep_(rep) {}
  inline void operator()(const trackable* t) const
    { t->add_destroy_notify_callback(rep_, &slot_rep::notify); }
};
struct slot_do_unbind
{
  slot_rep* rep_;
  inline slot_do_unbind(slot_rep* rep) : rep_(rep) {}
  inline void operator()(const trackable* t) const
    { t->remove_destroy_notify_callback(rep_); }
};
}
class slot_base : public functor_base
{
  typedef internal::slot_rep rep_type;
public:
  slot_base();
  explicit slot_base(rep_type* rep);
  slot_base(const slot_base& src);
  ~slot_base();
  operator bool() const;
  void set_parent(void* parent, void* (*cleanup)(void*)) const;
  typedef trackable::func_destroy_notify func_destroy_notify;
  void add_destroy_notify_callback(void* data, func_destroy_notify func) const;
  void remove_destroy_notify_callback(void* data) const;
  inline bool empty() const
    { return (!rep_ || !rep_->call_); }
  inline bool blocked() const
    { return blocked_; }
  bool block(bool should_block = true);
  bool unblock();
  void disconnect();
  slot_base& operator=(const slot_base& src);
public:
  mutable rep_type *rep_;
  bool blocked_;
};
}
namespace sigc {
namespace internal {
template <class T_functor>
struct typed_slot_rep : public slot_rep
{
  typedef typed_slot_rep<T_functor> self;
  typedef typename adaptor_trait<T_functor>::adaptor_type adaptor_type;
  adaptor_type functor_;
  inline typed_slot_rep(const T_functor& functor)
    : slot_rep(0, &destroy, &dup), functor_(functor)
    { visit_each_type<trackable*>(slot_do_bind(this), functor_); }
  inline typed_slot_rep(const typed_slot_rep& cl)
    : slot_rep(cl.call_, &destroy, &dup), functor_(cl.functor_)
    { visit_each_type<trackable*>(slot_do_bind(this), functor_); }
  inline ~typed_slot_rep()
    {
      call_ = 0;
      destroy_ = 0;
      visit_each_type<trackable*>(slot_do_unbind(this), functor_);
    }
  static void* destroy(void* data)
    {
      self* self_ = static_cast<self*>(reinterpret_cast<slot_rep*>(data));
      self_->call_ = 0;
      self_->destroy_ = 0;
      visit_each_type<trackable*>(slot_do_unbind(self_), self_->functor_);
      self_->functor_.~adaptor_type();
      return 0;
    }
  static void* dup(void* data)
    {
      slot_rep* a_rep = reinterpret_cast<slot_rep*>(data);
      return static_cast<slot_rep*>(new self(*static_cast<self*>(a_rep)));
    }
};
template<class T_functor, class T_return>
struct slot_call0
{
  static T_return call_it(slot_rep* rep)
    {
      typedef typed_slot_rep<T_functor> typed_slot;
      typed_slot *typed_rep = static_cast<typed_slot*>(rep);
      return (typed_rep->functor_)();
    }
  static hook address()
    { return reinterpret_cast<hook>(&call_it); }
};
template<class T_functor, class T_return, class T_arg1>
struct slot_call1
{
  static T_return call_it(slot_rep* rep, typename type_trait<T_arg1>::take a_1)
    {
      typedef typed_slot_rep<T_functor> typed_slot;
      typed_slot *typed_rep = static_cast<typed_slot*>(rep);
      return (typed_rep->functor_).template operator()<typename type_trait<T_arg1>::take>
               (a_1);
    }
  static hook address()
    { return reinterpret_cast<hook>(&call_it); }
};
template<class T_functor, class T_return, class T_arg1,class T_arg2>
struct slot_call2
{
  static T_return call_it(slot_rep* rep, typename type_trait<T_arg1>::take a_1,typename type_trait<T_arg2>::take a_2)
    {
      typedef typed_slot_rep<T_functor> typed_slot;
      typed_slot *typed_rep = static_cast<typed_slot*>(rep);
      return (typed_rep->functor_).template operator()<typename type_trait<T_arg1>::take,typename type_trait<T_arg2>::take>
               (a_1,a_2);
    }
  static hook address()
    { return reinterpret_cast<hook>(&call_it); }
};
template<class T_functor, class T_return, class T_arg1,class T_arg2,class T_arg3>
struct slot_call3
{
  static T_return call_it(slot_rep* rep, typename type_trait<T_arg1>::take a_1,typename type_trait<T_arg2>::take a_2,typename type_trait<T_arg3>::take a_3)
    {
      typedef typed_slot_rep<T_functor> typed_slot;
      typed_slot *typed_rep = static_cast<typed_slot*>(rep);
      return (typed_rep->functor_).template operator()<typename type_trait<T_arg1>::take,typename type_trait<T_arg2>::take,typename type_trait<T_arg3>::take>
               (a_1,a_2,a_3);
    }
  static hook address()
    { return reinterpret_cast<hook>(&call_it); }
};
template<class T_functor, class T_return, class T_arg1,class T_arg2,class T_arg3,class T_arg4>
struct slot_call4
{
  static T_return call_it(slot_rep* rep, typename type_trait<T_arg1>::take a_1,typename type_trait<T_arg2>::take a_2,typename type_trait<T_arg3>::take a_3,typename type_trait<T_arg4>::take a_4)
    {
      typedef typed_slot_rep<T_functor> typed_slot;
      typed_slot *typed_rep = static_cast<typed_slot*>(rep);
      return (typed_rep->functor_).template operator()<typename type_trait<T_arg1>::take,typename type_trait<T_arg2>::take,typename type_trait<T_arg3>::take,typename type_trait<T_arg4>::take>
               (a_1,a_2,a_3,a_4);
    }
  static hook address()
    { return reinterpret_cast<hook>(&call_it); }
};
template<class T_functor, class T_return, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
struct slot_call5
{
  static T_return call_it(slot_rep* rep, typename type_trait<T_arg1>::take a_1,typename type_trait<T_arg2>::take a_2,typename type_trait<T_arg3>::take a_3,typename type_trait<T_arg4>::take a_4,typename type_trait<T_arg5>::take a_5)
    {
      typedef typed_slot_rep<T_functor> typed_slot;
      typed_slot *typed_rep = static_cast<typed_slot*>(rep);
      return (typed_rep->functor_).template operator()<typename type_trait<T_arg1>::take,typename type_trait<T_arg2>::take,typename type_trait<T_arg3>::take,typename type_trait<T_arg4>::take,typename type_trait<T_arg5>::take>
               (a_1,a_2,a_3,a_4,a_5);
    }
  static hook address()
    { return reinterpret_cast<hook>(&call_it); }
};
template<class T_functor, class T_return, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
struct slot_call6
{
  static T_return call_it(slot_rep* rep, typename type_trait<T_arg1>::take a_1,typename type_trait<T_arg2>::take a_2,typename type_trait<T_arg3>::take a_3,typename type_trait<T_arg4>::take a_4,typename type_trait<T_arg5>::take a_5,typename type_trait<T_arg6>::take a_6)
    {
      typedef typed_slot_rep<T_functor> typed_slot;
      typed_slot *typed_rep = static_cast<typed_slot*>(rep);
      return (typed_rep->functor_).template operator()<typename type_trait<T_arg1>::take,typename type_trait<T_arg2>::take,typename type_trait<T_arg3>::take,typename type_trait<T_arg4>::take,typename type_trait<T_arg5>::take,typename type_trait<T_arg6>::take>
               (a_1,a_2,a_3,a_4,a_5,a_6);
    }
  static hook address()
    { return reinterpret_cast<hook>(&call_it); }
};
template<class T_functor, class T_return, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
struct slot_call7
{
  static T_return call_it(slot_rep* rep, typename type_trait<T_arg1>::take a_1,typename type_trait<T_arg2>::take a_2,typename type_trait<T_arg3>::take a_3,typename type_trait<T_arg4>::take a_4,typename type_trait<T_arg5>::take a_5,typename type_trait<T_arg6>::take a_6,typename type_trait<T_arg7>::take a_7)
    {
      typedef typed_slot_rep<T_functor> typed_slot;
      typed_slot *typed_rep = static_cast<typed_slot*>(rep);
      return (typed_rep->functor_).template operator()<typename type_trait<T_arg1>::take,typename type_trait<T_arg2>::take,typename type_trait<T_arg3>::take,typename type_trait<T_arg4>::take,typename type_trait<T_arg5>::take,typename type_trait<T_arg6>::take,typename type_trait<T_arg7>::take>
               (a_1,a_2,a_3,a_4,a_5,a_6,a_7);
    }
  static hook address()
    { return reinterpret_cast<hook>(&call_it); }
};
}
template <class T_return>
class slot0
  : public slot_base
{
public:
  typedef T_return result_type;
private:
  typedef internal::slot_rep rep_type;
public:
  typedef T_return (*call_type)(rep_type*);
  inline T_return operator()() const
    {
      if (!empty() && !blocked())
        return (reinterpret_cast<call_type>(slot_base::rep_->call_))(slot_base::rep_);
      return T_return();
    }
  inline slot0() {}
  template <class T_functor>
  slot0(const T_functor& _A_func)
    : slot_base(new internal::typed_slot_rep<T_functor>(_A_func))
    {
      slot_base::rep_->call_ = internal::slot_call0<T_functor, T_return>::address();
    }
  slot0(const slot0& src)
    : slot_base(src) {}
  slot0& operator=(const slot0& src)
    { slot_base::operator=(src); return *this; }
};
template <class T_return, class T_arg1>
class slot1
  : public slot_base
{
public:
  typedef T_return result_type;
  typedef typename type_trait<T_arg1>::take arg1_type_;
private:
  typedef internal::slot_rep rep_type;
public:
  typedef T_return (*call_type)(rep_type*, arg1_type_);
  inline T_return operator()(arg1_type_ _A_a1) const
    {
      if (!empty() && !blocked())
        return (reinterpret_cast<call_type>(slot_base::rep_->call_))(slot_base::rep_, _A_a1);
      return T_return();
    }
  inline slot1() {}
  template <class T_functor>
  slot1(const T_functor& _A_func)
    : slot_base(new internal::typed_slot_rep<T_functor>(_A_func))
    {
      slot_base::rep_->call_ = internal::slot_call1<T_functor, T_return, T_arg1>::address();
    }
  slot1(const slot1& src)
    : slot_base(src) {}
  slot1& operator=(const slot1& src)
    { slot_base::operator=(src); return *this; }
};
template <class T_return, class T_arg1,class T_arg2>
class slot2
  : public slot_base
{
public:
  typedef T_return result_type;
  typedef typename type_trait<T_arg1>::take arg1_type_;
  typedef typename type_trait<T_arg2>::take arg2_type_;
private:
  typedef internal::slot_rep rep_type;
public:
  typedef T_return (*call_type)(rep_type*, arg1_type_,arg2_type_);
  inline T_return operator()(arg1_type_ _A_a1,arg2_type_ _A_a2) const
    {
      if (!empty() && !blocked())
        return (reinterpret_cast<call_type>(slot_base::rep_->call_))(slot_base::rep_, _A_a1,_A_a2);
      return T_return();
    }
  inline slot2() {}
  template <class T_functor>
  slot2(const T_functor& _A_func)
    : slot_base(new internal::typed_slot_rep<T_functor>(_A_func))
    {
      slot_base::rep_->call_ = internal::slot_call2<T_functor, T_return, T_arg1,T_arg2>::address();
    }
  slot2(const slot2& src)
    : slot_base(src) {}
  slot2& operator=(const slot2& src)
    { slot_base::operator=(src); return *this; }
};
template <class T_return, class T_arg1,class T_arg2,class T_arg3>
class slot3
  : public slot_base
{
public:
  typedef T_return result_type;
  typedef typename type_trait<T_arg1>::take arg1_type_;
  typedef typename type_trait<T_arg2>::take arg2_type_;
  typedef typename type_trait<T_arg3>::take arg3_type_;
private:
  typedef internal::slot_rep rep_type;
public:
  typedef T_return (*call_type)(rep_type*, arg1_type_,arg2_type_,arg3_type_);
  inline T_return operator()(arg1_type_ _A_a1,arg2_type_ _A_a2,arg3_type_ _A_a3) const
    {
      if (!empty() && !blocked())
        return (reinterpret_cast<call_type>(slot_base::rep_->call_))(slot_base::rep_, _A_a1,_A_a2,_A_a3);
      return T_return();
    }
  inline slot3() {}
  template <class T_functor>
  slot3(const T_functor& _A_func)
    : slot_base(new internal::typed_slot_rep<T_functor>(_A_func))
    {
      slot_base::rep_->call_ = internal::slot_call3<T_functor, T_return, T_arg1,T_arg2,T_arg3>::address();
    }
  slot3(const slot3& src)
    : slot_base(src) {}
  slot3& operator=(const slot3& src)
    { slot_base::operator=(src); return *this; }
};
template <class T_return, class T_arg1,class T_arg2,class T_arg3,class T_arg4>
class slot4
  : public slot_base
{
public:
  typedef T_return result_type;
  typedef typename type_trait<T_arg1>::take arg1_type_;
  typedef typename type_trait<T_arg2>::take arg2_type_;
  typedef typename type_trait<T_arg3>::take arg3_type_;
  typedef typename type_trait<T_arg4>::take arg4_type_;
private:
  typedef internal::slot_rep rep_type;
public:
  typedef T_return (*call_type)(rep_type*, arg1_type_,arg2_type_,arg3_type_,arg4_type_);
  inline T_return operator()(arg1_type_ _A_a1,arg2_type_ _A_a2,arg3_type_ _A_a3,arg4_type_ _A_a4) const
    {
      if (!empty() && !blocked())
        return (reinterpret_cast<call_type>(slot_base::rep_->call_))(slot_base::rep_, _A_a1,_A_a2,_A_a3,_A_a4);
      return T_return();
    }
  inline slot4() {}
  template <class T_functor>
  slot4(const T_functor& _A_func)
    : slot_base(new internal::typed_slot_rep<T_functor>(_A_func))
    {
      slot_base::rep_->call_ = internal::slot_call4<T_functor, T_return, T_arg1,T_arg2,T_arg3,T_arg4>::address();
    }
  slot4(const slot4& src)
    : slot_base(src) {}
  slot4& operator=(const slot4& src)
    { slot_base::operator=(src); return *this; }
};
template <class T_return, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
class slot5
  : public slot_base
{
public:
  typedef T_return result_type;
  typedef typename type_trait<T_arg1>::take arg1_type_;
  typedef typename type_trait<T_arg2>::take arg2_type_;
  typedef typename type_trait<T_arg3>::take arg3_type_;
  typedef typename type_trait<T_arg4>::take arg4_type_;
  typedef typename type_trait<T_arg5>::take arg5_type_;
private:
  typedef internal::slot_rep rep_type;
public:
  typedef T_return (*call_type)(rep_type*, arg1_type_,arg2_type_,arg3_type_,arg4_type_,arg5_type_);
  inline T_return operator()(arg1_type_ _A_a1,arg2_type_ _A_a2,arg3_type_ _A_a3,arg4_type_ _A_a4,arg5_type_ _A_a5) const
    {
      if (!empty() && !blocked())
        return (reinterpret_cast<call_type>(slot_base::rep_->call_))(slot_base::rep_, _A_a1,_A_a2,_A_a3,_A_a4,_A_a5);
      return T_return();
    }
  inline slot5() {}
  template <class T_functor>
  slot5(const T_functor& _A_func)
    : slot_base(new internal::typed_slot_rep<T_functor>(_A_func))
    {
      slot_base::rep_->call_ = internal::slot_call5<T_functor, T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>::address();
    }
  slot5(const slot5& src)
    : slot_base(src) {}
  slot5& operator=(const slot5& src)
    { slot_base::operator=(src); return *this; }
};
template <class T_return, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
class slot6
  : public slot_base
{
public:
  typedef T_return result_type;
  typedef typename type_trait<T_arg1>::take arg1_type_;
  typedef typename type_trait<T_arg2>::take arg2_type_;
  typedef typename type_trait<T_arg3>::take arg3_type_;
  typedef typename type_trait<T_arg4>::take arg4_type_;
  typedef typename type_trait<T_arg5>::take arg5_type_;
  typedef typename type_trait<T_arg6>::take arg6_type_;
private:
  typedef internal::slot_rep rep_type;
public:
  typedef T_return (*call_type)(rep_type*, arg1_type_,arg2_type_,arg3_type_,arg4_type_,arg5_type_,arg6_type_);
  inline T_return operator()(arg1_type_ _A_a1,arg2_type_ _A_a2,arg3_type_ _A_a3,arg4_type_ _A_a4,arg5_type_ _A_a5,arg6_type_ _A_a6) const
    {
      if (!empty() && !blocked())
        return (reinterpret_cast<call_type>(slot_base::rep_->call_))(slot_base::rep_, _A_a1,_A_a2,_A_a3,_A_a4,_A_a5,_A_a6);
      return T_return();
    }
  inline slot6() {}
  template <class T_functor>
  slot6(const T_functor& _A_func)
    : slot_base(new internal::typed_slot_rep<T_functor>(_A_func))
    {
      slot_base::rep_->call_ = internal::slot_call6<T_functor, T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>::address();
    }
  slot6(const slot6& src)
    : slot_base(src) {}
  slot6& operator=(const slot6& src)
    { slot_base::operator=(src); return *this; }
};
template <class T_return, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
class slot7
  : public slot_base
{
public:
  typedef T_return result_type;
  typedef typename type_trait<T_arg1>::take arg1_type_;
  typedef typename type_trait<T_arg2>::take arg2_type_;
  typedef typename type_trait<T_arg3>::take arg3_type_;
  typedef typename type_trait<T_arg4>::take arg4_type_;
  typedef typename type_trait<T_arg5>::take arg5_type_;
  typedef typename type_trait<T_arg6>::take arg6_type_;
  typedef typename type_trait<T_arg7>::take arg7_type_;
private:
  typedef internal::slot_rep rep_type;
public:
  typedef T_return (*call_type)(rep_type*, arg1_type_,arg2_type_,arg3_type_,arg4_type_,arg5_type_,arg6_type_,arg7_type_);
  inline T_return operator()(arg1_type_ _A_a1,arg2_type_ _A_a2,arg3_type_ _A_a3,arg4_type_ _A_a4,arg5_type_ _A_a5,arg6_type_ _A_a6,arg7_type_ _A_a7) const
    {
      if (!empty() && !blocked())
        return (reinterpret_cast<call_type>(slot_base::rep_->call_))(slot_base::rep_, _A_a1,_A_a2,_A_a3,_A_a4,_A_a5,_A_a6,_A_a7);
      return T_return();
    }
  inline slot7() {}
  template <class T_functor>
  slot7(const T_functor& _A_func)
    : slot_base(new internal::typed_slot_rep<T_functor>(_A_func))
    {
      slot_base::rep_->call_ = internal::slot_call7<T_functor, T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>::address();
    }
  slot7(const slot7& src)
    : slot_base(src) {}
  slot7& operator=(const slot7& src)
    { slot_base::operator=(src); return *this; }
};
template <class T_return, class T_arg1 = nil,class T_arg2 = nil,class T_arg3 = nil,class T_arg4 = nil,class T_arg5 = nil,class T_arg6 = nil,class T_arg7 = nil>
class slot
  : public slot7<T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>
{
public:
  typedef slot7<T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7> parent_type;
  inline slot() {}
  template <class T_functor>
  slot(const T_functor& _A_func)
    : parent_type(_A_func) {}
  slot(const slot& src)
    : parent_type(reinterpret_cast<const parent_type&>(src)) {}
};
template <class T_return>
class slot <T_return, nil, nil, nil, nil, nil, nil, nil>
  : public slot0<T_return>
{
public:
  typedef slot0<T_return> parent_type;
  inline slot() {}
  template <class T_functor>
  slot(const T_functor& _A_func)
    : parent_type(_A_func) {}
  slot(const slot& src)
    : parent_type(reinterpret_cast<const parent_type&>(src)) {}
};
template <class T_return, class T_arg1>
class slot <T_return, T_arg1, nil, nil, nil, nil, nil, nil>
  : public slot1<T_return, T_arg1>
{
public:
  typedef slot1<T_return, T_arg1> parent_type;
  inline slot() {}
  template <class T_functor>
  slot(const T_functor& _A_func)
    : parent_type(_A_func) {}
  slot(const slot& src)
    : parent_type(reinterpret_cast<const parent_type&>(src)) {}
};
template <class T_return, class T_arg1,class T_arg2>
class slot <T_return, T_arg1, T_arg2, nil, nil, nil, nil, nil>
  : public slot2<T_return, T_arg1,T_arg2>
{
public:
  typedef slot2<T_return, T_arg1,T_arg2> parent_type;
  inline slot() {}
  template <class T_functor>
  slot(const T_functor& _A_func)
    : parent_type(_A_func) {}
  slot(const slot& src)
    : parent_type(reinterpret_cast<const parent_type&>(src)) {}
};
template <class T_return, class T_arg1,class T_arg2,class T_arg3>
class slot <T_return, T_arg1, T_arg2, T_arg3, nil, nil, nil, nil>
  : public slot3<T_return, T_arg1,T_arg2,T_arg3>
{
public:
  typedef slot3<T_return, T_arg1,T_arg2,T_arg3> parent_type;
  inline slot() {}
  template <class T_functor>
  slot(const T_functor& _A_func)
    : parent_type(_A_func) {}
  slot(const slot& src)
    : parent_type(reinterpret_cast<const parent_type&>(src)) {}
};
template <class T_return, class T_arg1,class T_arg2,class T_arg3,class T_arg4>
class slot <T_return, T_arg1, T_arg2, T_arg3, T_arg4, nil, nil, nil>
  : public slot4<T_return, T_arg1,T_arg2,T_arg3,T_arg4>
{
public:
  typedef slot4<T_return, T_arg1,T_arg2,T_arg3,T_arg4> parent_type;
  inline slot() {}
  template <class T_functor>
  slot(const T_functor& _A_func)
    : parent_type(_A_func) {}
  slot(const slot& src)
    : parent_type(reinterpret_cast<const parent_type&>(src)) {}
};
template <class T_return, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
class slot <T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, nil, nil>
  : public slot5<T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>
{
public:
  typedef slot5<T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5> parent_type;
  inline slot() {}
  template <class T_functor>
  slot(const T_functor& _A_func)
    : parent_type(_A_func) {}
  slot(const slot& src)
    : parent_type(reinterpret_cast<const parent_type&>(src)) {}
};
template <class T_return, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
class slot <T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, nil>
  : public slot6<T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>
{
public:
  typedef slot6<T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6> parent_type;
  inline slot() {}
  template <class T_functor>
  slot(const T_functor& _A_func)
    : parent_type(_A_func) {}
  slot(const slot& src)
    : parent_type(reinterpret_cast<const parent_type&>(src)) {}
};
}
namespace sigc
{
namespace internal
{
struct signal_impl
{
  typedef size_t size_type;
  typedef std::list<slot_base> slot_list;
  typedef slot_list::iterator iterator_type;
  typedef slot_list::const_iterator const_iterator_type;
  signal_impl();
  inline void reference()
    { ++ref_count_; }
  inline void reference_exec()
    { ++ref_count_; ++exec_count_; }
  inline void unreference()
    { if (!(--ref_count_)) delete this; }
  inline void unreference_exec()
    {
      if (!(--ref_count_)) delete this;
      else if (!(--exec_count_) && deferred_) sweep();
    }
  inline bool empty() const
    { return slots_.empty(); }
  void clear();
  size_type size() const;
  iterator_type connect(const slot_base& slot_);
  iterator_type insert(iterator_type i, const slot_base& slot_);
  iterator_type erase(iterator_type i);
  void sweep();
  static void* notify(void* d);
  short ref_count_;
  short exec_count_;
  bool deferred_;
  std::list<slot_base> slots_;
};
struct signal_exec
{
  signal_impl* sig_;
  inline signal_exec(const signal_impl* sig)
    : sig_(const_cast<signal_impl*>(sig) )
    { sig_->reference_exec(); }
  inline ~signal_exec()
    { sig_->unreference_exec(); }
};
struct temp_slot_list
{
  typedef signal_impl::slot_list slot_list;
  typedef signal_impl::iterator_type iterator;
  typedef signal_impl::const_iterator_type const_iterator;
  temp_slot_list(slot_list &slots) : slots_(slots)
  {
    placeholder = slots_.insert(slots_.end(), slot_base());
  }
  ~temp_slot_list()
  {
    slots_.erase(placeholder);
  }
  iterator begin() { return slots_.begin(); }
  iterator end() { return placeholder; }
  const_iterator begin() const { return slots_.begin(); }
  const_iterator end() const { return placeholder; }
private:
  slot_list &slots_;
  slot_list::iterator placeholder;
};
}
struct signal_base : public trackable
{
  typedef size_t size_type;
  signal_base();
  signal_base(const signal_base& src);
  ~signal_base();
  signal_base& operator = (const signal_base& src);
  inline bool empty() const
    { return (!impl_ || impl_->empty()); }
  void clear();
  size_type size() const;
protected:
  typedef internal::signal_impl::iterator_type iterator_type;
  iterator_type connect(const slot_base& slot_);
  iterator_type insert(iterator_type i, const slot_base& slot_);
  iterator_type erase(iterator_type i);
  internal::signal_impl* impl() const;
  mutable internal::signal_impl* impl_;
};
}
namespace sigc {
template <typename T_slot>
struct slot_iterator
{
  typedef size_t size_type;
  typedef ptrdiff_t difference_type;
  typedef std::bidirectional_iterator_tag iterator_category;
  typedef T_slot slot_type;
  typedef T_slot value_type;
  typedef T_slot* pointer;
  typedef T_slot& reference;
  typedef typename internal::signal_impl::iterator_type iterator_type;
  slot_iterator()
    {}
  explicit slot_iterator(const iterator_type& i)
    : i_(i) {}
  reference operator*() const
    { return static_cast<reference>(*i_); }
  pointer operator->() const
    { return &(operator*()); }
  slot_iterator& operator++()
    {
      ++i_;
      return *this;
    }
  slot_iterator operator++(int)
    {
      slot_iterator __tmp(*this);
      ++i_;
      return __tmp;
    }
  slot_iterator& operator--()
    {
      --i_;
      return *this;
    }
  slot_iterator operator--(int)
    {
      slot_iterator __tmp(*this);
      --i_;
      return __tmp;
    }
  bool operator == (const slot_iterator& other) const
    { return i_ == other.i_; }
  bool operator != (const slot_iterator& other) const
    { return i_ != other.i_; }
  iterator_type i_;
};
template <typename T_slot>
struct slot_const_iterator
{
  typedef size_t size_type;
  typedef ptrdiff_t difference_type;
  typedef std::bidirectional_iterator_tag iterator_category;
  typedef T_slot slot_type;
  typedef T_slot value_type;
  typedef const T_slot* pointer;
  typedef const T_slot& reference;
  typedef typename internal::signal_impl::const_iterator_type iterator_type;
  slot_const_iterator()
    {}
  explicit slot_const_iterator(const iterator_type& i)
    : i_(i) {}
  reference operator*() const
    { return static_cast<reference>(*i_); }
  pointer operator->() const
    { return &(operator*()); }
  slot_const_iterator& operator++()
    {
      ++i_;
      return *this;
    }
  slot_const_iterator operator++(int)
    {
      slot_const_iterator __tmp(*this);
      ++i_;
      return __tmp;
    }
  slot_const_iterator& operator--()
    {
      --i_;
      return *this;
    }
  slot_const_iterator operator--(int)
    {
      slot_const_iterator __tmp(*this);
      --i_;
      return __tmp;
    }
  bool operator == (const slot_const_iterator& other) const
    { return i_ == other.i_; }
  bool operator != (const slot_const_iterator& other) const
    { return i_ != other.i_; }
  iterator_type i_;
};
template <class T_slot>
struct slot_list
{
  typedef T_slot slot_type;
  typedef slot_type& reference;
  typedef const slot_type& const_reference;
  typedef slot_iterator<slot_type> iterator;
  typedef slot_const_iterator<slot_type> const_iterator;
  typedef std::reverse_iterator<iterator> reverse_iterator;
  typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
  slot_list()
    : list_(0) {}
  explicit slot_list(internal::signal_impl* __list)
    : list_(__list) {}
  iterator begin()
    { return iterator(list_->slots_.begin()); }
  const_iterator begin() const
    { return const_iterator(list_->slots_.begin()); }
  iterator end()
    { return iterator(list_->slots_.end()); }
  const_iterator end() const
    { return const_iterator(list_->slots_.end()); }
  reverse_iterator rbegin()
    { return reverse_iterator(end()); }
  const_reverse_iterator rbegin() const
    { return const_reverse_iterator(end()); }
  reverse_iterator rend()
    { return reverse_iterator(begin()); }
  const_reverse_iterator rend() const
    { return const_reverse_iterator(begin()); }
  reference front()
    { return *begin(); }
  const_reference front() const
    { return *begin(); }
  reference back()
    { return *(--end()); }
  const_reference back() const
    { return *(--end()); }
  iterator insert(iterator i, const slot_type& slot_)
    { return iterator(list_->insert(i.i_, static_cast<const slot_base&>(slot_))); }
  void push_front(const slot_type& c)
    { insert(begin(), c); }
  void push_back(const slot_type& c)
    { insert(end(), c); }
  iterator erase(iterator i)
    { return iterator(list_->erase(i.i_)); }
  iterator erase(iterator first_, iterator last_)
    {
      while (first_ != last_)
        first_ = erase(first_);
      return last_;
    }
  void pop_front()
    { erase(begin()); }
  void pop_back()
    {
      iterator tmp_ = end();
      erase(--tmp_);
    }
protected:
  internal::signal_impl* list_;
};
namespace internal {
template <class T_emitter, class T_result = typename T_emitter::result_type>
struct slot_iterator_buf
{
  typedef size_t size_type;
  typedef ptrdiff_t difference_type;
  typedef std::bidirectional_iterator_tag iterator_category;
  typedef T_emitter emitter_type;
  typedef T_result result_type;
  typedef typename T_emitter::slot_type slot_type;
  typedef signal_impl::const_iterator_type iterator_type;
  slot_iterator_buf()
    : c_(0), invoked_(false) {}
  slot_iterator_buf(const iterator_type& i, const emitter_type* c)
    : i_(i), c_(c), invoked_(false) {}
  result_type operator*() const
    {
      if (!i_->empty() && !i_->blocked() && !invoked_)
        {
          r_ = (*c_)(static_cast<const slot_type&>(*i_));
          invoked_ = true;
        }
      return r_;
    }
  slot_iterator_buf& operator++()
    {
      ++i_;
      invoked_ = false;
      return *this;
    }
  slot_iterator_buf operator++(int)
    {
      slot_iterator_buf __tmp(*this);
      ++i_;
      invoked_ = false;
      return __tmp;
    }
  slot_iterator_buf& operator--()
    {
      --i_;
      invoked_ = false;
      return *this;
    }
  slot_iterator_buf operator--(int)
    {
      slot_iterator_buf __tmp(*this);
      --i_;
      invoked_ = false;
      return __tmp;
    }
  bool operator == (const slot_iterator_buf& other) const
    { return (!c_ || (i_ == other.i_)); }
  bool operator != (const slot_iterator_buf& other) const
    { return (c_ && (i_ != other.i_)); }
private:
  iterator_type i_;
  const emitter_type* c_;
  mutable result_type r_;
  mutable bool invoked_;
};
template <class T_emitter>
struct slot_iterator_buf<T_emitter, void>
{
  typedef size_t size_type;
  typedef ptrdiff_t difference_type;
  typedef std::bidirectional_iterator_tag iterator_category;
  typedef T_emitter emitter_type;
  typedef void result_type;
  typedef typename T_emitter::slot_type slot_type;
  typedef signal_impl::const_iterator_type iterator_type;
  slot_iterator_buf()
    : c_(0), invoked_(false) {}
  slot_iterator_buf(const iterator_type& i, const emitter_type* c)
    : i_(i), c_(c), invoked_(false) {}
  void operator*() const
    {
      if (!i_->empty() && !i_->blocked() && !invoked_)
        {
          (*c_)(static_cast<const slot_type&>(*i_));
          invoked_ = true;
        }
    }
  slot_iterator_buf& operator++()
    {
      ++i_;
      invoked_ = false;
      return *this;
    }
  slot_iterator_buf operator++(int)
    {
      slot_iterator_buf __tmp(*this);
      ++i_;
      invoked_ = false;
      return __tmp;
    }
  slot_iterator_buf& operator--()
    {
      --i_;
      invoked_ = false;
      return *this;
    }
  slot_iterator_buf operator--(int)
    {
      slot_iterator_buf __tmp(*this);
      --i_;
      invoked_ = false;
      return __tmp;
    }
  bool operator == (const slot_iterator_buf& other) const
    { return i_ == other.i_; }
  bool operator != (const slot_iterator_buf& other) const
    { return i_ != other.i_; }
private:
  iterator_type i_;
  const emitter_type* c_;
  mutable bool invoked_;
};
template <class T_return, class T_accumulator>
struct signal_emit0
{
  typedef signal_emit0<T_return, T_accumulator> self_type;
  typedef typename T_accumulator::result_type result_type;
  typedef slot<T_return> slot_type;
  typedef internal::slot_iterator_buf<self_type> slot_iterator_buf_type;
  typedef signal_impl::const_iterator_type iterator_type;
  signal_emit0() {}
  T_return operator()(const slot_type& _A_slot) const
    { return (reinterpret_cast<typename slot_type::call_type>(_A_slot.rep_->call_))(_A_slot.rep_); }
  static result_type emit(signal_impl* impl)
    {
      T_accumulator accumulator;
      if (!impl)
        return accumulator(slot_iterator_buf_type(), slot_iterator_buf_type());
      signal_exec exec(impl);
      temp_slot_list slots(impl->slots_);
      self_type self ;
      return accumulator(slot_iterator_buf_type(slots.begin(), &self),
                         slot_iterator_buf_type(slots.end(), &self));
    }
};
template <class T_return>
struct signal_emit0<T_return, nil>
{
  typedef signal_emit0<T_return, nil > self_type;
  typedef T_return result_type;
  typedef slot<T_return> slot_type;
  typedef signal_impl::const_iterator_type iterator_type;
  typedef typename slot_type::call_type call_type;
  static result_type emit(signal_impl* impl)
    {
      if (!impl || impl->slots_.empty())
        return T_return();
      signal_exec exec(impl);
      T_return r_ = T_return();
      {
        temp_slot_list slots(impl->slots_);
        iterator_type it = slots.begin();
        for (; it != slots.end(); ++it)
          if (!it->empty() && !it->blocked()) break;
        if (it == slots.end())
          return T_return();
        r_ = (reinterpret_cast<call_type>(it->rep_->call_))(it->rep_);
        for (++it; it != slots.end(); ++it)
          {
            if (it->empty() || it->blocked())
              continue;
            r_ = (reinterpret_cast<call_type>(it->rep_->call_))(it->rep_);
          }
      }
      return r_;
    }
};
template <>
struct signal_emit0<void, nil>
{
  typedef signal_emit0<void, nil> self_type;
  typedef void result_type;
  typedef slot<void> slot_type;
  typedef signal_impl::const_iterator_type iterator_type;
  typedef void (*call_type)(slot_rep*);
  static result_type emit(signal_impl* impl)
    {
      if (!impl || impl->slots_.empty()) return;
      signal_exec exec(impl);
      temp_slot_list slots(impl->slots_);
      for (iterator_type it = slots.begin(); it != slots.end(); ++it)
        {
          if (it->empty() || it->blocked())
            continue;
          (reinterpret_cast<call_type>(it->rep_->call_))(it->rep_);
        }
    }
};
template <class T_return, class T_arg1, class T_accumulator>
struct signal_emit1
{
  typedef signal_emit1<T_return, T_arg1, T_accumulator> self_type;
  typedef typename T_accumulator::result_type result_type;
  typedef slot<T_return, T_arg1> slot_type;
  typedef internal::slot_iterator_buf<self_type> slot_iterator_buf_type;
  typedef signal_impl::const_iterator_type iterator_type;
  signal_emit1(typename type_trait<T_arg1>::take _A_a1)
    : _A_a1_(_A_a1) {}
  T_return operator()(const slot_type& _A_slot) const
    { return (reinterpret_cast<typename slot_type::call_type>(_A_slot.rep_->call_))(_A_slot.rep_, _A_a1_); }
  static result_type emit(signal_impl* impl, typename type_trait<T_arg1>::take _A_a1)
    {
      T_accumulator accumulator;
      if (!impl)
        return accumulator(slot_iterator_buf_type(), slot_iterator_buf_type());
      signal_exec exec(impl);
      temp_slot_list slots(impl->slots_);
      self_type self (_A_a1);
      return accumulator(slot_iterator_buf_type(slots.begin(), &self),
                         slot_iterator_buf_type(slots.end(), &self));
    }
  typename type_trait<T_arg1>::take _A_a1_;
};
template <class T_return, class T_arg1>
struct signal_emit1<T_return, T_arg1, nil>
{
  typedef signal_emit1<T_return, T_arg1, nil > self_type;
  typedef T_return result_type;
  typedef slot<T_return, T_arg1> slot_type;
  typedef signal_impl::const_iterator_type iterator_type;
  typedef typename slot_type::call_type call_type;
  static result_type emit(signal_impl* impl, typename type_trait<T_arg1>::take _A_a1)
    {
      if (!impl || impl->slots_.empty())
        return T_return();
      signal_exec exec(impl);
      T_return r_ = T_return();
      {
        temp_slot_list slots(impl->slots_);
        iterator_type it = slots.begin();
        for (; it != slots.end(); ++it)
          if (!it->empty() && !it->blocked()) break;
        if (it == slots.end())
          return T_return();
        r_ = (reinterpret_cast<call_type>(it->rep_->call_))(it->rep_, _A_a1);
        for (++it; it != slots.end(); ++it)
          {
            if (it->empty() || it->blocked())
              continue;
            r_ = (reinterpret_cast<call_type>(it->rep_->call_))(it->rep_, _A_a1);
          }
      }
      return r_;
    }
};
template <class T_arg1>
struct signal_emit1<void, T_arg1, nil>
{
  typedef signal_emit1<void, T_arg1, nil> self_type;
  typedef void result_type;
  typedef slot<void, T_arg1> slot_type;
  typedef signal_impl::const_iterator_type iterator_type;
  typedef typename slot_type::call_type call_type;
  static result_type emit(signal_impl* impl, typename type_trait<T_arg1>::take _A_a1)
    {
      if (!impl || impl->slots_.empty()) return;
      signal_exec exec(impl);
      temp_slot_list slots(impl->slots_);
      for (iterator_type it = slots.begin(); it != slots.end(); ++it)
        {
          if (it->empty() || it->blocked())
            continue;
          (reinterpret_cast<call_type>(it->rep_->call_))(it->rep_, _A_a1);
        }
    }
};
template <class T_return, class T_arg1,class T_arg2, class T_accumulator>
struct signal_emit2
{
  typedef signal_emit2<T_return, T_arg1,T_arg2, T_accumulator> self_type;
  typedef typename T_accumulator::result_type result_type;
  typedef slot<T_return, T_arg1,T_arg2> slot_type;
  typedef internal::slot_iterator_buf<self_type> slot_iterator_buf_type;
  typedef signal_impl::const_iterator_type iterator_type;
  signal_emit2(typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2)
    : _A_a1_(_A_a1),_A_a2_(_A_a2) {}
  T_return operator()(const slot_type& _A_slot) const
    { return (reinterpret_cast<typename slot_type::call_type>(_A_slot.rep_->call_))(_A_slot.rep_, _A_a1_,_A_a2_); }
  static result_type emit(signal_impl* impl, typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2)
    {
      T_accumulator accumulator;
      if (!impl)
        return accumulator(slot_iterator_buf_type(), slot_iterator_buf_type());
      signal_exec exec(impl);
      temp_slot_list slots(impl->slots_);
      self_type self (_A_a1,_A_a2);
      return accumulator(slot_iterator_buf_type(slots.begin(), &self),
                         slot_iterator_buf_type(slots.end(), &self));
    }
  typename type_trait<T_arg1>::take _A_a1_;
  typename type_trait<T_arg2>::take _A_a2_;
};
template <class T_return, class T_arg1,class T_arg2>
struct signal_emit2<T_return, T_arg1,T_arg2, nil>
{
  typedef signal_emit2<T_return, T_arg1,T_arg2, nil > self_type;
  typedef T_return result_type;
  typedef slot<T_return, T_arg1,T_arg2> slot_type;
  typedef signal_impl::const_iterator_type iterator_type;
  typedef typename slot_type::call_type call_type;
  static result_type emit(signal_impl* impl, typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2)
    {
      if (!impl || impl->slots_.empty())
        return T_return();
      signal_exec exec(impl);
      T_return r_ = T_return();
      {
        temp_slot_list slots(impl->slots_);
        iterator_type it = slots.begin();
        for (; it != slots.end(); ++it)
          if (!it->empty() && !it->blocked()) break;
        if (it == slots.end())
          return T_return();
        r_ = (reinterpret_cast<call_type>(it->rep_->call_))(it->rep_, _A_a1,_A_a2);
        for (++it; it != slots.end(); ++it)
          {
            if (it->empty() || it->blocked())
              continue;
            r_ = (reinterpret_cast<call_type>(it->rep_->call_))(it->rep_, _A_a1,_A_a2);
          }
      }
      return r_;
    }
};
template <class T_arg1,class T_arg2>
struct signal_emit2<void, T_arg1,T_arg2, nil>
{
  typedef signal_emit2<void, T_arg1,T_arg2, nil> self_type;
  typedef void result_type;
  typedef slot<void, T_arg1,T_arg2> slot_type;
  typedef signal_impl::const_iterator_type iterator_type;
  typedef typename slot_type::call_type call_type;
  static result_type emit(signal_impl* impl, typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2)
    {
      if (!impl || impl->slots_.empty()) return;
      signal_exec exec(impl);
      temp_slot_list slots(impl->slots_);
      for (iterator_type it = slots.begin(); it != slots.end(); ++it)
        {
          if (it->empty() || it->blocked())
            continue;
          (reinterpret_cast<call_type>(it->rep_->call_))(it->rep_, _A_a1,_A_a2);
        }
    }
};
template <class T_return, class T_arg1,class T_arg2,class T_arg3, class T_accumulator>
struct signal_emit3
{
  typedef signal_emit3<T_return, T_arg1,T_arg2,T_arg3, T_accumulator> self_type;
  typedef typename T_accumulator::result_type result_type;
  typedef slot<T_return, T_arg1,T_arg2,T_arg3> slot_type;
  typedef internal::slot_iterator_buf<self_type> slot_iterator_buf_type;
  typedef signal_impl::const_iterator_type iterator_type;
  signal_emit3(typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3)
    : _A_a1_(_A_a1),_A_a2_(_A_a2),_A_a3_(_A_a3) {}
  T_return operator()(const slot_type& _A_slot) const
    { return (reinterpret_cast<typename slot_type::call_type>(_A_slot.rep_->call_))(_A_slot.rep_, _A_a1_,_A_a2_,_A_a3_); }
  static result_type emit(signal_impl* impl, typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3)
    {
      T_accumulator accumulator;
      if (!impl)
        return accumulator(slot_iterator_buf_type(), slot_iterator_buf_type());
      signal_exec exec(impl);
      temp_slot_list slots(impl->slots_);
      self_type self (_A_a1,_A_a2,_A_a3);
      return accumulator(slot_iterator_buf_type(slots.begin(), &self),
                         slot_iterator_buf_type(slots.end(), &self));
    }
  typename type_trait<T_arg1>::take _A_a1_;
  typename type_trait<T_arg2>::take _A_a2_;
  typename type_trait<T_arg3>::take _A_a3_;
};
template <class T_return, class T_arg1,class T_arg2,class T_arg3>
struct signal_emit3<T_return, T_arg1,T_arg2,T_arg3, nil>
{
  typedef signal_emit3<T_return, T_arg1,T_arg2,T_arg3, nil > self_type;
  typedef T_return result_type;
  typedef slot<T_return, T_arg1,T_arg2,T_arg3> slot_type;
  typedef signal_impl::const_iterator_type iterator_type;
  typedef typename slot_type::call_type call_type;
  static result_type emit(signal_impl* impl, typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3)
    {
      if (!impl || impl->slots_.empty())
        return T_return();
      signal_exec exec(impl);
      T_return r_ = T_return();
      {
        temp_slot_list slots(impl->slots_);
        iterator_type it = slots.begin();
        for (; it != slots.end(); ++it)
          if (!it->empty() && !it->blocked()) break;
        if (it == slots.end())
          return T_return();
        r_ = (reinterpret_cast<call_type>(it->rep_->call_))(it->rep_, _A_a1,_A_a2,_A_a3);
        for (++it; it != slots.end(); ++it)
          {
            if (it->empty() || it->blocked())
              continue;
            r_ = (reinterpret_cast<call_type>(it->rep_->call_))(it->rep_, _A_a1,_A_a2,_A_a3);
          }
      }
      return r_;
    }
};
template <class T_arg1,class T_arg2,class T_arg3>
struct signal_emit3<void, T_arg1,T_arg2,T_arg3, nil>
{
  typedef signal_emit3<void, T_arg1,T_arg2,T_arg3, nil> self_type;
  typedef void result_type;
  typedef slot<void, T_arg1,T_arg2,T_arg3> slot_type;
  typedef signal_impl::const_iterator_type iterator_type;
  typedef typename slot_type::call_type call_type;
  static result_type emit(signal_impl* impl, typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3)
    {
      if (!impl || impl->slots_.empty()) return;
      signal_exec exec(impl);
      temp_slot_list slots(impl->slots_);
      for (iterator_type it = slots.begin(); it != slots.end(); ++it)
        {
          if (it->empty() || it->blocked())
            continue;
          (reinterpret_cast<call_type>(it->rep_->call_))(it->rep_, _A_a1,_A_a2,_A_a3);
        }
    }
};
template <class T_return, class T_arg1,class T_arg2,class T_arg3,class T_arg4, class T_accumulator>
struct signal_emit4
{
  typedef signal_emit4<T_return, T_arg1,T_arg2,T_arg3,T_arg4, T_accumulator> self_type;
  typedef typename T_accumulator::result_type result_type;
  typedef slot<T_return, T_arg1,T_arg2,T_arg3,T_arg4> slot_type;
  typedef internal::slot_iterator_buf<self_type> slot_iterator_buf_type;
  typedef signal_impl::const_iterator_type iterator_type;
  signal_emit4(typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3,typename type_trait<T_arg4>::take _A_a4)
    : _A_a1_(_A_a1),_A_a2_(_A_a2),_A_a3_(_A_a3),_A_a4_(_A_a4) {}
  T_return operator()(const slot_type& _A_slot) const
    { return (reinterpret_cast<typename slot_type::call_type>(_A_slot.rep_->call_))(_A_slot.rep_, _A_a1_,_A_a2_,_A_a3_,_A_a4_); }
  static result_type emit(signal_impl* impl, typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3,typename type_trait<T_arg4>::take _A_a4)
    {
      T_accumulator accumulator;
      if (!impl)
        return accumulator(slot_iterator_buf_type(), slot_iterator_buf_type());
      signal_exec exec(impl);
      temp_slot_list slots(impl->slots_);
      self_type self (_A_a1,_A_a2,_A_a3,_A_a4);
      return accumulator(slot_iterator_buf_type(slots.begin(), &self),
                         slot_iterator_buf_type(slots.end(), &self));
    }
  typename type_trait<T_arg1>::take _A_a1_;
  typename type_trait<T_arg2>::take _A_a2_;
  typename type_trait<T_arg3>::take _A_a3_;
  typename type_trait<T_arg4>::take _A_a4_;
};
template <class T_return, class T_arg1,class T_arg2,class T_arg3,class T_arg4>
struct signal_emit4<T_return, T_arg1,T_arg2,T_arg3,T_arg4, nil>
{
  typedef signal_emit4<T_return, T_arg1,T_arg2,T_arg3,T_arg4, nil > self_type;
  typedef T_return result_type;
  typedef slot<T_return, T_arg1,T_arg2,T_arg3,T_arg4> slot_type;
  typedef signal_impl::const_iterator_type iterator_type;
  typedef typename slot_type::call_type call_type;
  static result_type emit(signal_impl* impl, typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3,typename type_trait<T_arg4>::take _A_a4)
    {
      if (!impl || impl->slots_.empty())
        return T_return();
      signal_exec exec(impl);
      T_return r_ = T_return();
      {
        temp_slot_list slots(impl->slots_);
        iterator_type it = slots.begin();
        for (; it != slots.end(); ++it)
          if (!it->empty() && !it->blocked()) break;
        if (it == slots.end())
          return T_return();
        r_ = (reinterpret_cast<call_type>(it->rep_->call_))(it->rep_, _A_a1,_A_a2,_A_a3,_A_a4);
        for (++it; it != slots.end(); ++it)
          {
            if (it->empty() || it->blocked())
              continue;
            r_ = (reinterpret_cast<call_type>(it->rep_->call_))(it->rep_, _A_a1,_A_a2,_A_a3,_A_a4);
          }
      }
      return r_;
    }
};
template <class T_arg1,class T_arg2,class T_arg3,class T_arg4>
struct signal_emit4<void, T_arg1,T_arg2,T_arg3,T_arg4, nil>
{
  typedef signal_emit4<void, T_arg1,T_arg2,T_arg3,T_arg4, nil> self_type;
  typedef void result_type;
  typedef slot<void, T_arg1,T_arg2,T_arg3,T_arg4> slot_type;
  typedef signal_impl::const_iterator_type iterator_type;
  typedef typename slot_type::call_type call_type;
  static result_type emit(signal_impl* impl, typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3,typename type_trait<T_arg4>::take _A_a4)
    {
      if (!impl || impl->slots_.empty()) return;
      signal_exec exec(impl);
      temp_slot_list slots(impl->slots_);
      for (iterator_type it = slots.begin(); it != slots.end(); ++it)
        {
          if (it->empty() || it->blocked())
            continue;
          (reinterpret_cast<call_type>(it->rep_->call_))(it->rep_, _A_a1,_A_a2,_A_a3,_A_a4);
        }
    }
};
template <class T_return, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5, class T_accumulator>
struct signal_emit5
{
  typedef signal_emit5<T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5, T_accumulator> self_type;
  typedef typename T_accumulator::result_type result_type;
  typedef slot<T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5> slot_type;
  typedef internal::slot_iterator_buf<self_type> slot_iterator_buf_type;
  typedef signal_impl::const_iterator_type iterator_type;
  signal_emit5(typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3,typename type_trait<T_arg4>::take _A_a4,typename type_trait<T_arg5>::take _A_a5)
    : _A_a1_(_A_a1),_A_a2_(_A_a2),_A_a3_(_A_a3),_A_a4_(_A_a4),_A_a5_(_A_a5) {}
  T_return operator()(const slot_type& _A_slot) const
    { return (reinterpret_cast<typename slot_type::call_type>(_A_slot.rep_->call_))(_A_slot.rep_, _A_a1_,_A_a2_,_A_a3_,_A_a4_,_A_a5_); }
  static result_type emit(signal_impl* impl, typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3,typename type_trait<T_arg4>::take _A_a4,typename type_trait<T_arg5>::take _A_a5)
    {
      T_accumulator accumulator;
      if (!impl)
        return accumulator(slot_iterator_buf_type(), slot_iterator_buf_type());
      signal_exec exec(impl);
      temp_slot_list slots(impl->slots_);
      self_type self (_A_a1,_A_a2,_A_a3,_A_a4,_A_a5);
      return accumulator(slot_iterator_buf_type(slots.begin(), &self),
                         slot_iterator_buf_type(slots.end(), &self));
    }
  typename type_trait<T_arg1>::take _A_a1_;
  typename type_trait<T_arg2>::take _A_a2_;
  typename type_trait<T_arg3>::take _A_a3_;
  typename type_trait<T_arg4>::take _A_a4_;
  typename type_trait<T_arg5>::take _A_a5_;
};
template <class T_return, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
struct signal_emit5<T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5, nil>
{
  typedef signal_emit5<T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5, nil > self_type;
  typedef T_return result_type;
  typedef slot<T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5> slot_type;
  typedef signal_impl::const_iterator_type iterator_type;
  typedef typename slot_type::call_type call_type;
  static result_type emit(signal_impl* impl, typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3,typename type_trait<T_arg4>::take _A_a4,typename type_trait<T_arg5>::take _A_a5)
    {
      if (!impl || impl->slots_.empty())
        return T_return();
      signal_exec exec(impl);
      T_return r_ = T_return();
      {
        temp_slot_list slots(impl->slots_);
        iterator_type it = slots.begin();
        for (; it != slots.end(); ++it)
          if (!it->empty() && !it->blocked()) break;
        if (it == slots.end())
          return T_return();
        r_ = (reinterpret_cast<call_type>(it->rep_->call_))(it->rep_, _A_a1,_A_a2,_A_a3,_A_a4,_A_a5);
        for (++it; it != slots.end(); ++it)
          {
            if (it->empty() || it->blocked())
              continue;
            r_ = (reinterpret_cast<call_type>(it->rep_->call_))(it->rep_, _A_a1,_A_a2,_A_a3,_A_a4,_A_a5);
          }
      }
      return r_;
    }
};
template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
struct signal_emit5<void, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5, nil>
{
  typedef signal_emit5<void, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5, nil> self_type;
  typedef void result_type;
  typedef slot<void, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5> slot_type;
  typedef signal_impl::const_iterator_type iterator_type;
  typedef typename slot_type::call_type call_type;
  static result_type emit(signal_impl* impl, typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3,typename type_trait<T_arg4>::take _A_a4,typename type_trait<T_arg5>::take _A_a5)
    {
      if (!impl || impl->slots_.empty()) return;
      signal_exec exec(impl);
      temp_slot_list slots(impl->slots_);
      for (iterator_type it = slots.begin(); it != slots.end(); ++it)
        {
          if (it->empty() || it->blocked())
            continue;
          (reinterpret_cast<call_type>(it->rep_->call_))(it->rep_, _A_a1,_A_a2,_A_a3,_A_a4,_A_a5);
        }
    }
};
template <class T_return, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6, class T_accumulator>
struct signal_emit6
{
  typedef signal_emit6<T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6, T_accumulator> self_type;
  typedef typename T_accumulator::result_type result_type;
  typedef slot<T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6> slot_type;
  typedef internal::slot_iterator_buf<self_type> slot_iterator_buf_type;
  typedef signal_impl::const_iterator_type iterator_type;
  signal_emit6(typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3,typename type_trait<T_arg4>::take _A_a4,typename type_trait<T_arg5>::take _A_a5,typename type_trait<T_arg6>::take _A_a6)
    : _A_a1_(_A_a1),_A_a2_(_A_a2),_A_a3_(_A_a3),_A_a4_(_A_a4),_A_a5_(_A_a5),_A_a6_(_A_a6) {}
  T_return operator()(const slot_type& _A_slot) const
    { return (reinterpret_cast<typename slot_type::call_type>(_A_slot.rep_->call_))(_A_slot.rep_, _A_a1_,_A_a2_,_A_a3_,_A_a4_,_A_a5_,_A_a6_); }
  static result_type emit(signal_impl* impl, typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3,typename type_trait<T_arg4>::take _A_a4,typename type_trait<T_arg5>::take _A_a5,typename type_trait<T_arg6>::take _A_a6)
    {
      T_accumulator accumulator;
      if (!impl)
        return accumulator(slot_iterator_buf_type(), slot_iterator_buf_type());
      signal_exec exec(impl);
      temp_slot_list slots(impl->slots_);
      self_type self (_A_a1,_A_a2,_A_a3,_A_a4,_A_a5,_A_a6);
      return accumulator(slot_iterator_buf_type(slots.begin(), &self),
                         slot_iterator_buf_type(slots.end(), &self));
    }
  typename type_trait<T_arg1>::take _A_a1_;
  typename type_trait<T_arg2>::take _A_a2_;
  typename type_trait<T_arg3>::take _A_a3_;
  typename type_trait<T_arg4>::take _A_a4_;
  typename type_trait<T_arg5>::take _A_a5_;
  typename type_trait<T_arg6>::take _A_a6_;
};
template <class T_return, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
struct signal_emit6<T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6, nil>
{
  typedef signal_emit6<T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6, nil > self_type;
  typedef T_return result_type;
  typedef slot<T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6> slot_type;
  typedef signal_impl::const_iterator_type iterator_type;
  typedef typename slot_type::call_type call_type;
  static result_type emit(signal_impl* impl, typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3,typename type_trait<T_arg4>::take _A_a4,typename type_trait<T_arg5>::take _A_a5,typename type_trait<T_arg6>::take _A_a6)
    {
      if (!impl || impl->slots_.empty())
        return T_return();
      signal_exec exec(impl);
      T_return r_ = T_return();
      {
        temp_slot_list slots(impl->slots_);
        iterator_type it = slots.begin();
        for (; it != slots.end(); ++it)
          if (!it->empty() && !it->blocked()) break;
        if (it == slots.end())
          return T_return();
        r_ = (reinterpret_cast<call_type>(it->rep_->call_))(it->rep_, _A_a1,_A_a2,_A_a3,_A_a4,_A_a5,_A_a6);
        for (++it; it != slots.end(); ++it)
          {
            if (it->empty() || it->blocked())
              continue;
            r_ = (reinterpret_cast<call_type>(it->rep_->call_))(it->rep_, _A_a1,_A_a2,_A_a3,_A_a4,_A_a5,_A_a6);
          }
      }
      return r_;
    }
};
template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
struct signal_emit6<void, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6, nil>
{
  typedef signal_emit6<void, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6, nil> self_type;
  typedef void result_type;
  typedef slot<void, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6> slot_type;
  typedef signal_impl::const_iterator_type iterator_type;
  typedef typename slot_type::call_type call_type;
  static result_type emit(signal_impl* impl, typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3,typename type_trait<T_arg4>::take _A_a4,typename type_trait<T_arg5>::take _A_a5,typename type_trait<T_arg6>::take _A_a6)
    {
      if (!impl || impl->slots_.empty()) return;
      signal_exec exec(impl);
      temp_slot_list slots(impl->slots_);
      for (iterator_type it = slots.begin(); it != slots.end(); ++it)
        {
          if (it->empty() || it->blocked())
            continue;
          (reinterpret_cast<call_type>(it->rep_->call_))(it->rep_, _A_a1,_A_a2,_A_a3,_A_a4,_A_a5,_A_a6);
        }
    }
};
template <class T_return, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7, class T_accumulator>
struct signal_emit7
{
  typedef signal_emit7<T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7, T_accumulator> self_type;
  typedef typename T_accumulator::result_type result_type;
  typedef slot<T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7> slot_type;
  typedef internal::slot_iterator_buf<self_type> slot_iterator_buf_type;
  typedef signal_impl::const_iterator_type iterator_type;
  signal_emit7(typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3,typename type_trait<T_arg4>::take _A_a4,typename type_trait<T_arg5>::take _A_a5,typename type_trait<T_arg6>::take _A_a6,typename type_trait<T_arg7>::take _A_a7)
    : _A_a1_(_A_a1),_A_a2_(_A_a2),_A_a3_(_A_a3),_A_a4_(_A_a4),_A_a5_(_A_a5),_A_a6_(_A_a6),_A_a7_(_A_a7) {}
  T_return operator()(const slot_type& _A_slot) const
    { return (reinterpret_cast<typename slot_type::call_type>(_A_slot.rep_->call_))(_A_slot.rep_, _A_a1_,_A_a2_,_A_a3_,_A_a4_,_A_a5_,_A_a6_,_A_a7_); }
  static result_type emit(signal_impl* impl, typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3,typename type_trait<T_arg4>::take _A_a4,typename type_trait<T_arg5>::take _A_a5,typename type_trait<T_arg6>::take _A_a6,typename type_trait<T_arg7>::take _A_a7)
    {
      T_accumulator accumulator;
      if (!impl)
        return accumulator(slot_iterator_buf_type(), slot_iterator_buf_type());
      signal_exec exec(impl);
      temp_slot_list slots(impl->slots_);
      self_type self (_A_a1,_A_a2,_A_a3,_A_a4,_A_a5,_A_a6,_A_a7);
      return accumulator(slot_iterator_buf_type(slots.begin(), &self),
                         slot_iterator_buf_type(slots.end(), &self));
    }
  typename type_trait<T_arg1>::take _A_a1_;
  typename type_trait<T_arg2>::take _A_a2_;
  typename type_trait<T_arg3>::take _A_a3_;
  typename type_trait<T_arg4>::take _A_a4_;
  typename type_trait<T_arg5>::take _A_a5_;
  typename type_trait<T_arg6>::take _A_a6_;
  typename type_trait<T_arg7>::take _A_a7_;
};
template <class T_return, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
struct signal_emit7<T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7, nil>
{
  typedef signal_emit7<T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7, nil > self_type;
  typedef T_return result_type;
  typedef slot<T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7> slot_type;
  typedef signal_impl::const_iterator_type iterator_type;
  typedef typename slot_type::call_type call_type;
  static result_type emit(signal_impl* impl, typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3,typename type_trait<T_arg4>::take _A_a4,typename type_trait<T_arg5>::take _A_a5,typename type_trait<T_arg6>::take _A_a6,typename type_trait<T_arg7>::take _A_a7)
    {
      if (!impl || impl->slots_.empty())
        return T_return();
      signal_exec exec(impl);
      T_return r_ = T_return();
      {
        temp_slot_list slots(impl->slots_);
        iterator_type it = slots.begin();
        for (; it != slots.end(); ++it)
          if (!it->empty() && !it->blocked()) break;
        if (it == slots.end())
          return T_return();
        r_ = (reinterpret_cast<call_type>(it->rep_->call_))(it->rep_, _A_a1,_A_a2,_A_a3,_A_a4,_A_a5,_A_a6,_A_a7);
        for (++it; it != slots.end(); ++it)
          {
            if (it->empty() || it->blocked())
              continue;
            r_ = (reinterpret_cast<call_type>(it->rep_->call_))(it->rep_, _A_a1,_A_a2,_A_a3,_A_a4,_A_a5,_A_a6,_A_a7);
          }
      }
      return r_;
    }
};
template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
struct signal_emit7<void, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7, nil>
{
  typedef signal_emit7<void, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7, nil> self_type;
  typedef void result_type;
  typedef slot<void, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7> slot_type;
  typedef signal_impl::const_iterator_type iterator_type;
  typedef typename slot_type::call_type call_type;
  static result_type emit(signal_impl* impl, typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3,typename type_trait<T_arg4>::take _A_a4,typename type_trait<T_arg5>::take _A_a5,typename type_trait<T_arg6>::take _A_a6,typename type_trait<T_arg7>::take _A_a7)
    {
      if (!impl || impl->slots_.empty()) return;
      signal_exec exec(impl);
      temp_slot_list slots(impl->slots_);
      for (iterator_type it = slots.begin(); it != slots.end(); ++it)
        {
          if (it->empty() || it->blocked())
            continue;
          (reinterpret_cast<call_type>(it->rep_->call_))(it->rep_, _A_a1,_A_a2,_A_a3,_A_a4,_A_a5,_A_a6,_A_a7);
        }
    }
};
}
template <class T_return, class T_accumulator=nil>
class signal0
  : public signal_base
{
public:
  typedef internal::signal_emit0<T_return, T_accumulator> emitter_type;
  typedef typename emitter_type::result_type result_type;
  typedef slot<T_return> slot_type;
  typedef slot_list<slot_type> slot_list_type;
  typedef typename slot_list_type::iterator iterator;
  typedef typename slot_list_type::const_iterator const_iterator;
  typedef typename slot_list_type::reverse_iterator reverse_iterator;
  typedef typename slot_list_type::const_reverse_iterator const_reverse_iterator;
  typedef slot_list_type slot_list;
  iterator connect(const slot_type& slot_)
    { return iterator(signal_base::connect(static_cast<const slot_base&>(slot_))); }
  result_type emit() const
    { return emitter_type::emit(impl_); }
  result_type operator()() const
    { return emit(); }
  bound_const_mem_functor0<result_type, signal0> make_slot() const
    { return bound_const_mem_functor0<result_type, signal0>(this, &signal0::emit); }
  slot_list_type slots()
    { return slot_list_type(impl()); }
  const slot_list_type slots() const
    { return slot_list_type(const_cast<signal0*>(this)->impl()); }
  signal0() {}
  signal0(const signal0& src)
    : signal_base(src) {}
};
template <class T_return, class T_arg1, class T_accumulator=nil>
class signal1
  : public signal_base
{
public:
  typedef internal::signal_emit1<T_return, T_arg1, T_accumulator> emitter_type;
  typedef typename emitter_type::result_type result_type;
  typedef slot<T_return, T_arg1> slot_type;
  typedef slot_list<slot_type> slot_list_type;
  typedef typename slot_list_type::iterator iterator;
  typedef typename slot_list_type::const_iterator const_iterator;
  typedef typename slot_list_type::reverse_iterator reverse_iterator;
  typedef typename slot_list_type::const_reverse_iterator const_reverse_iterator;
  typedef slot_list_type slot_list;
  iterator connect(const slot_type& slot_)
    { return iterator(signal_base::connect(static_cast<const slot_base&>(slot_))); }
  result_type emit(typename type_trait<T_arg1>::take _A_a1) const
    { return emitter_type::emit(impl_, _A_a1); }
  result_type operator()(typename type_trait<T_arg1>::take _A_a1) const
    { return emit(_A_a1); }
  bound_const_mem_functor1<result_type, signal1, typename type_trait<T_arg1>::take> make_slot() const
    { return bound_const_mem_functor1<result_type, signal1, typename type_trait<T_arg1>::take>(this, &signal1::emit); }
  slot_list_type slots()
    { return slot_list_type(impl()); }
  const slot_list_type slots() const
    { return slot_list_type(const_cast<signal1*>(this)->impl()); }
  signal1() {}
  signal1(const signal1& src)
    : signal_base(src) {}
};
template <class T_return, class T_arg1,class T_arg2, class T_accumulator=nil>
class signal2
  : public signal_base
{
public:
  typedef internal::signal_emit2<T_return, T_arg1,T_arg2, T_accumulator> emitter_type;
  typedef typename emitter_type::result_type result_type;
  typedef slot<T_return, T_arg1,T_arg2> slot_type;
  typedef slot_list<slot_type> slot_list_type;
  typedef typename slot_list_type::iterator iterator;
  typedef typename slot_list_type::const_iterator const_iterator;
  typedef typename slot_list_type::reverse_iterator reverse_iterator;
  typedef typename slot_list_type::const_reverse_iterator const_reverse_iterator;
  typedef slot_list_type slot_list;
  iterator connect(const slot_type& slot_)
    { return iterator(signal_base::connect(static_cast<const slot_base&>(slot_))); }
  result_type emit(typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2) const
    { return emitter_type::emit(impl_, _A_a1,_A_a2); }
  result_type operator()(typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2) const
    { return emit(_A_a1,_A_a2); }
  bound_const_mem_functor2<result_type, signal2, typename type_trait<T_arg1>::take,typename type_trait<T_arg2>::take> make_slot() const
    { return bound_const_mem_functor2<result_type, signal2, typename type_trait<T_arg1>::take,typename type_trait<T_arg2>::take>(this, &signal2::emit); }
  slot_list_type slots()
    { return slot_list_type(impl()); }
  const slot_list_type slots() const
    { return slot_list_type(const_cast<signal2*>(this)->impl()); }
  signal2() {}
  signal2(const signal2& src)
    : signal_base(src) {}
};
template <class T_return, class T_arg1,class T_arg2,class T_arg3, class T_accumulator=nil>
class signal3
  : public signal_base
{
public:
  typedef internal::signal_emit3<T_return, T_arg1,T_arg2,T_arg3, T_accumulator> emitter_type;
  typedef typename emitter_type::result_type result_type;
  typedef slot<T_return, T_arg1,T_arg2,T_arg3> slot_type;
  typedef slot_list<slot_type> slot_list_type;
  typedef typename slot_list_type::iterator iterator;
  typedef typename slot_list_type::const_iterator const_iterator;
  typedef typename slot_list_type::reverse_iterator reverse_iterator;
  typedef typename slot_list_type::const_reverse_iterator const_reverse_iterator;
  typedef slot_list_type slot_list;
  iterator connect(const slot_type& slot_)
    { return iterator(signal_base::connect(static_cast<const slot_base&>(slot_))); }
  result_type emit(typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3) const
    { return emitter_type::emit(impl_, _A_a1,_A_a2,_A_a3); }
  result_type operator()(typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3) const
    { return emit(_A_a1,_A_a2,_A_a3); }
  bound_const_mem_functor3<result_type, signal3, typename type_trait<T_arg1>::take,typename type_trait<T_arg2>::take,typename type_trait<T_arg3>::take> make_slot() const
    { return bound_const_mem_functor3<result_type, signal3, typename type_trait<T_arg1>::take,typename type_trait<T_arg2>::take,typename type_trait<T_arg3>::take>(this, &signal3::emit); }
  slot_list_type slots()
    { return slot_list_type(impl()); }
  const slot_list_type slots() const
    { return slot_list_type(const_cast<signal3*>(this)->impl()); }
  signal3() {}
  signal3(const signal3& src)
    : signal_base(src) {}
};
template <class T_return, class T_arg1,class T_arg2,class T_arg3,class T_arg4, class T_accumulator=nil>
class signal4
  : public signal_base
{
public:
  typedef internal::signal_emit4<T_return, T_arg1,T_arg2,T_arg3,T_arg4, T_accumulator> emitter_type;
  typedef typename emitter_type::result_type result_type;
  typedef slot<T_return, T_arg1,T_arg2,T_arg3,T_arg4> slot_type;
  typedef slot_list<slot_type> slot_list_type;
  typedef typename slot_list_type::iterator iterator;
  typedef typename slot_list_type::const_iterator const_iterator;
  typedef typename slot_list_type::reverse_iterator reverse_iterator;
  typedef typename slot_list_type::const_reverse_iterator const_reverse_iterator;
  typedef slot_list_type slot_list;
  iterator connect(const slot_type& slot_)
    { return iterator(signal_base::connect(static_cast<const slot_base&>(slot_))); }
  result_type emit(typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3,typename type_trait<T_arg4>::take _A_a4) const
    { return emitter_type::emit(impl_, _A_a1,_A_a2,_A_a3,_A_a4); }
  result_type operator()(typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3,typename type_trait<T_arg4>::take _A_a4) const
    { return emit(_A_a1,_A_a2,_A_a3,_A_a4); }
  bound_const_mem_functor4<result_type, signal4, typename type_trait<T_arg1>::take,typename type_trait<T_arg2>::take,typename type_trait<T_arg3>::take,typename type_trait<T_arg4>::take> make_slot() const
    { return bound_const_mem_functor4<result_type, signal4, typename type_trait<T_arg1>::take,typename type_trait<T_arg2>::take,typename type_trait<T_arg3>::take,typename type_trait<T_arg4>::take>(this, &signal4::emit); }
  slot_list_type slots()
    { return slot_list_type(impl()); }
  const slot_list_type slots() const
    { return slot_list_type(const_cast<signal4*>(this)->impl()); }
  signal4() {}
  signal4(const signal4& src)
    : signal_base(src) {}
};
template <class T_return, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5, class T_accumulator=nil>
class signal5
  : public signal_base
{
public:
  typedef internal::signal_emit5<T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5, T_accumulator> emitter_type;
  typedef typename emitter_type::result_type result_type;
  typedef slot<T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5> slot_type;
  typedef slot_list<slot_type> slot_list_type;
  typedef typename slot_list_type::iterator iterator;
  typedef typename slot_list_type::const_iterator const_iterator;
  typedef typename slot_list_type::reverse_iterator reverse_iterator;
  typedef typename slot_list_type::const_reverse_iterator const_reverse_iterator;
  typedef slot_list_type slot_list;
  iterator connect(const slot_type& slot_)
    { return iterator(signal_base::connect(static_cast<const slot_base&>(slot_))); }
  result_type emit(typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3,typename type_trait<T_arg4>::take _A_a4,typename type_trait<T_arg5>::take _A_a5) const
    { return emitter_type::emit(impl_, _A_a1,_A_a2,_A_a3,_A_a4,_A_a5); }
  result_type operator()(typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3,typename type_trait<T_arg4>::take _A_a4,typename type_trait<T_arg5>::take _A_a5) const
    { return emit(_A_a1,_A_a2,_A_a3,_A_a4,_A_a5); }
  bound_const_mem_functor5<result_type, signal5, typename type_trait<T_arg1>::take,typename type_trait<T_arg2>::take,typename type_trait<T_arg3>::take,typename type_trait<T_arg4>::take,typename type_trait<T_arg5>::take> make_slot() const
    { return bound_const_mem_functor5<result_type, signal5, typename type_trait<T_arg1>::take,typename type_trait<T_arg2>::take,typename type_trait<T_arg3>::take,typename type_trait<T_arg4>::take,typename type_trait<T_arg5>::take>(this, &signal5::emit); }
  slot_list_type slots()
    { return slot_list_type(impl()); }
  const slot_list_type slots() const
    { return slot_list_type(const_cast<signal5*>(this)->impl()); }
  signal5() {}
  signal5(const signal5& src)
    : signal_base(src) {}
};
template <class T_return, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6, class T_accumulator=nil>
class signal6
  : public signal_base
{
public:
  typedef internal::signal_emit6<T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6, T_accumulator> emitter_type;
  typedef typename emitter_type::result_type result_type;
  typedef slot<T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6> slot_type;
  typedef slot_list<slot_type> slot_list_type;
  typedef typename slot_list_type::iterator iterator;
  typedef typename slot_list_type::const_iterator const_iterator;
  typedef typename slot_list_type::reverse_iterator reverse_iterator;
  typedef typename slot_list_type::const_reverse_iterator const_reverse_iterator;
  typedef slot_list_type slot_list;
  iterator connect(const slot_type& slot_)
    { return iterator(signal_base::connect(static_cast<const slot_base&>(slot_))); }
  result_type emit(typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3,typename type_trait<T_arg4>::take _A_a4,typename type_trait<T_arg5>::take _A_a5,typename type_trait<T_arg6>::take _A_a6) const
    { return emitter_type::emit(impl_, _A_a1,_A_a2,_A_a3,_A_a4,_A_a5,_A_a6); }
  result_type operator()(typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3,typename type_trait<T_arg4>::take _A_a4,typename type_trait<T_arg5>::take _A_a5,typename type_trait<T_arg6>::take _A_a6) const
    { return emit(_A_a1,_A_a2,_A_a3,_A_a4,_A_a5,_A_a6); }
  bound_const_mem_functor6<result_type, signal6, typename type_trait<T_arg1>::take,typename type_trait<T_arg2>::take,typename type_trait<T_arg3>::take,typename type_trait<T_arg4>::take,typename type_trait<T_arg5>::take,typename type_trait<T_arg6>::take> make_slot() const
    { return bound_const_mem_functor6<result_type, signal6, typename type_trait<T_arg1>::take,typename type_trait<T_arg2>::take,typename type_trait<T_arg3>::take,typename type_trait<T_arg4>::take,typename type_trait<T_arg5>::take,typename type_trait<T_arg6>::take>(this, &signal6::emit); }
  slot_list_type slots()
    { return slot_list_type(impl()); }
  const slot_list_type slots() const
    { return slot_list_type(const_cast<signal6*>(this)->impl()); }
  signal6() {}
  signal6(const signal6& src)
    : signal_base(src) {}
};
template <class T_return, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7, class T_accumulator=nil>
class signal7
  : public signal_base
{
public:
  typedef internal::signal_emit7<T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7, T_accumulator> emitter_type;
  typedef typename emitter_type::result_type result_type;
  typedef slot<T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7> slot_type;
  typedef slot_list<slot_type> slot_list_type;
  typedef typename slot_list_type::iterator iterator;
  typedef typename slot_list_type::const_iterator const_iterator;
  typedef typename slot_list_type::reverse_iterator reverse_iterator;
  typedef typename slot_list_type::const_reverse_iterator const_reverse_iterator;
  typedef slot_list_type slot_list;
  iterator connect(const slot_type& slot_)
    { return iterator(signal_base::connect(static_cast<const slot_base&>(slot_))); }
  result_type emit(typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3,typename type_trait<T_arg4>::take _A_a4,typename type_trait<T_arg5>::take _A_a5,typename type_trait<T_arg6>::take _A_a6,typename type_trait<T_arg7>::take _A_a7) const
    { return emitter_type::emit(impl_, _A_a1,_A_a2,_A_a3,_A_a4,_A_a5,_A_a6,_A_a7); }
  result_type operator()(typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3,typename type_trait<T_arg4>::take _A_a4,typename type_trait<T_arg5>::take _A_a5,typename type_trait<T_arg6>::take _A_a6,typename type_trait<T_arg7>::take _A_a7) const
    { return emit(_A_a1,_A_a2,_A_a3,_A_a4,_A_a5,_A_a6,_A_a7); }
  bound_const_mem_functor7<result_type, signal7, typename type_trait<T_arg1>::take,typename type_trait<T_arg2>::take,typename type_trait<T_arg3>::take,typename type_trait<T_arg4>::take,typename type_trait<T_arg5>::take,typename type_trait<T_arg6>::take,typename type_trait<T_arg7>::take> make_slot() const
    { return bound_const_mem_functor7<result_type, signal7, typename type_trait<T_arg1>::take,typename type_trait<T_arg2>::take,typename type_trait<T_arg3>::take,typename type_trait<T_arg4>::take,typename type_trait<T_arg5>::take,typename type_trait<T_arg6>::take,typename type_trait<T_arg7>::take>(this, &signal7::emit); }
  slot_list_type slots()
    { return slot_list_type(impl()); }
  const slot_list_type slots() const
    { return slot_list_type(const_cast<signal7*>(this)->impl()); }
  signal7() {}
  signal7(const signal7& src)
    : signal_base(src) {}
};
template <class T_return, class T_arg1 = nil,class T_arg2 = nil,class T_arg3 = nil,class T_arg4 = nil,class T_arg5 = nil,class T_arg6 = nil,class T_arg7 = nil>
class signal
  : public signal7<T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7, nil>
{
public:
  template <class T_accumulator>
  class accumulated
    : public signal7<T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7, T_accumulator>
  {
  public:
    accumulated() {}
    accumulated(const accumulated& src)
      : signal7<T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7, T_accumulator>(src) {}
  };
  signal() {}
  signal(const signal& src)
    : signal7<T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7, nil>(src) {}
};
template <class T_return>
class signal <T_return, nil,nil,nil,nil,nil,nil,nil>
  : public signal0<T_return, nil>
{
public:
  template <class T_accumulator>
  class accumulated
    : public signal0<T_return, T_accumulator>
  {
  public:
    accumulated() {}
    accumulated(const accumulated& src)
      : signal0<T_return, T_accumulator>(src) {}
  };
  signal() {}
  signal(const signal& src)
    : signal0<T_return, nil>(src) {}
};
template <class T_return, class T_arg1>
class signal <T_return, T_arg1, nil,nil,nil,nil,nil,nil>
  : public signal1<T_return, T_arg1, nil>
{
public:
  template <class T_accumulator>
  class accumulated
    : public signal1<T_return, T_arg1, T_accumulator>
  {
  public:
    accumulated() {}
    accumulated(const accumulated& src)
      : signal1<T_return, T_arg1, T_accumulator>(src) {}
  };
  signal() {}
  signal(const signal& src)
    : signal1<T_return, T_arg1, nil>(src) {}
};
template <class T_return, class T_arg1,class T_arg2>
class signal <T_return, T_arg1,T_arg2, nil,nil,nil,nil,nil>
  : public signal2<T_return, T_arg1,T_arg2, nil>
{
public:
  template <class T_accumulator>
  class accumulated
    : public signal2<T_return, T_arg1,T_arg2, T_accumulator>
  {
  public:
    accumulated() {}
    accumulated(const accumulated& src)
      : signal2<T_return, T_arg1,T_arg2, T_accumulator>(src) {}
  };
  signal() {}
  signal(const signal& src)
    : signal2<T_return, T_arg1,T_arg2, nil>(src) {}
};
template <class T_return, class T_arg1,class T_arg2,class T_arg3>
class signal <T_return, T_arg1,T_arg2,T_arg3, nil,nil,nil,nil>
  : public signal3<T_return, T_arg1,T_arg2,T_arg3, nil>
{
public:
  template <class T_accumulator>
  class accumulated
    : public signal3<T_return, T_arg1,T_arg2,T_arg3, T_accumulator>
  {
  public:
    accumulated() {}
    accumulated(const accumulated& src)
      : signal3<T_return, T_arg1,T_arg2,T_arg3, T_accumulator>(src) {}
  };
  signal() {}
  signal(const signal& src)
    : signal3<T_return, T_arg1,T_arg2,T_arg3, nil>(src) {}
};
template <class T_return, class T_arg1,class T_arg2,class T_arg3,class T_arg4>
class signal <T_return, T_arg1,T_arg2,T_arg3,T_arg4, nil,nil,nil>
  : public signal4<T_return, T_arg1,T_arg2,T_arg3,T_arg4, nil>
{
public:
  template <class T_accumulator>
  class accumulated
    : public signal4<T_return, T_arg1,T_arg2,T_arg3,T_arg4, T_accumulator>
  {
  public:
    accumulated() {}
    accumulated(const accumulated& src)
      : signal4<T_return, T_arg1,T_arg2,T_arg3,T_arg4, T_accumulator>(src) {}
  };
  signal() {}
  signal(const signal& src)
    : signal4<T_return, T_arg1,T_arg2,T_arg3,T_arg4, nil>(src) {}
};
template <class T_return, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
class signal <T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5, nil,nil>
  : public signal5<T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5, nil>
{
public:
  template <class T_accumulator>
  class accumulated
    : public signal5<T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5, T_accumulator>
  {
  public:
    accumulated() {}
    accumulated(const accumulated& src)
      : signal5<T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5, T_accumulator>(src) {}
  };
  signal() {}
  signal(const signal& src)
    : signal5<T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5, nil>(src) {}
};
template <class T_return, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
class signal <T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6, nil>
  : public signal6<T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6, nil>
{
public:
  template <class T_accumulator>
  class accumulated
    : public signal6<T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6, T_accumulator>
  {
  public:
    accumulated() {}
    accumulated(const accumulated& src)
      : signal6<T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6, T_accumulator>(src) {}
  };
  signal() {}
  signal(const signal& src)
    : signal6<T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6, nil>(src) {}
};
}
namespace SigC {
template <class T_return, class T_accumulator=::sigc::nil>
class Signal0
  : public ::sigc::signal0<T_return, T_accumulator>
{
public:
  typedef ::sigc::signal0<T_return, T_accumulator> parent_type;
  typedef typename parent_type::result_type result_type;
  typedef typename parent_type::slot_type slot_type;
  Signal0() {}
  Signal0(const Signal0& src)
    : ::sigc::signal0<T_return, T_accumulator>(src) {}
  slot_type slot() const
    { return ::sigc::bound_const_mem_functor0<result_type, parent_type>(this, &parent_type::emit); }
};
template <class T_return, class T_arg1, class T_accumulator=::sigc::nil>
class Signal1
  : public ::sigc::signal1<T_return, T_arg1, T_accumulator>
{
public:
  typedef ::sigc::signal1<T_return, T_arg1, T_accumulator> parent_type;
  typedef typename parent_type::result_type result_type;
  typedef typename parent_type::slot_type slot_type;
  Signal1() {}
  Signal1(const Signal1& src)
    : ::sigc::signal1<T_return, T_arg1, T_accumulator>(src) {}
  slot_type slot() const
    { return ::sigc::bound_const_mem_functor1<result_type, parent_type, typename ::sigc::type_trait<T_arg1>::take>(this, &parent_type::emit); }
};
template <class T_return, class T_arg1,class T_arg2, class T_accumulator=::sigc::nil>
class Signal2
  : public ::sigc::signal2<T_return, T_arg1,T_arg2, T_accumulator>
{
public:
  typedef ::sigc::signal2<T_return, T_arg1,T_arg2, T_accumulator> parent_type;
  typedef typename parent_type::result_type result_type;
  typedef typename parent_type::slot_type slot_type;
  Signal2() {}
  Signal2(const Signal2& src)
    : ::sigc::signal2<T_return, T_arg1,T_arg2, T_accumulator>(src) {}
  slot_type slot() const
    { return ::sigc::bound_const_mem_functor2<result_type, parent_type, typename ::sigc::type_trait<T_arg1>::take,typename ::sigc::type_trait<T_arg2>::take>(this, &parent_type::emit); }
};
template <class T_return, class T_arg1,class T_arg2,class T_arg3, class T_accumulator=::sigc::nil>
class Signal3
  : public ::sigc::signal3<T_return, T_arg1,T_arg2,T_arg3, T_accumulator>
{
public:
  typedef ::sigc::signal3<T_return, T_arg1,T_arg2,T_arg3, T_accumulator> parent_type;
  typedef typename parent_type::result_type result_type;
  typedef typename parent_type::slot_type slot_type;
  Signal3() {}
  Signal3(const Signal3& src)
    : ::sigc::signal3<T_return, T_arg1,T_arg2,T_arg3, T_accumulator>(src) {}
  slot_type slot() const
    { return ::sigc::bound_const_mem_functor3<result_type, parent_type, typename ::sigc::type_trait<T_arg1>::take,typename ::sigc::type_trait<T_arg2>::take,typename ::sigc::type_trait<T_arg3>::take>(this, &parent_type::emit); }
};
template <class T_return, class T_arg1,class T_arg2,class T_arg3,class T_arg4, class T_accumulator=::sigc::nil>
class Signal4
  : public ::sigc::signal4<T_return, T_arg1,T_arg2,T_arg3,T_arg4, T_accumulator>
{
public:
  typedef ::sigc::signal4<T_return, T_arg1,T_arg2,T_arg3,T_arg4, T_accumulator> parent_type;
  typedef typename parent_type::result_type result_type;
  typedef typename parent_type::slot_type slot_type;
  Signal4() {}
  Signal4(const Signal4& src)
    : ::sigc::signal4<T_return, T_arg1,T_arg2,T_arg3,T_arg4, T_accumulator>(src) {}
  slot_type slot() const
    { return ::sigc::bound_const_mem_functor4<result_type, parent_type, typename ::sigc::type_trait<T_arg1>::take,typename ::sigc::type_trait<T_arg2>::take,typename ::sigc::type_trait<T_arg3>::take,typename ::sigc::type_trait<T_arg4>::take>(this, &parent_type::emit); }
};
template <class T_return, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5, class T_accumulator=::sigc::nil>
class Signal5
  : public ::sigc::signal5<T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5, T_accumulator>
{
public:
  typedef ::sigc::signal5<T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5, T_accumulator> parent_type;
  typedef typename parent_type::result_type result_type;
  typedef typename parent_type::slot_type slot_type;
  Signal5() {}
  Signal5(const Signal5& src)
    : ::sigc::signal5<T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5, T_accumulator>(src) {}
  slot_type slot() const
    { return ::sigc::bound_const_mem_functor5<result_type, parent_type, typename ::sigc::type_trait<T_arg1>::take,typename ::sigc::type_trait<T_arg2>::take,typename ::sigc::type_trait<T_arg3>::take,typename ::sigc::type_trait<T_arg4>::take,typename ::sigc::type_trait<T_arg5>::take>(this, &parent_type::emit); }
};
template <class T_return, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6, class T_accumulator=::sigc::nil>
class Signal6
  : public ::sigc::signal6<T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6, T_accumulator>
{
public:
  typedef ::sigc::signal6<T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6, T_accumulator> parent_type;
  typedef typename parent_type::result_type result_type;
  typedef typename parent_type::slot_type slot_type;
  Signal6() {}
  Signal6(const Signal6& src)
    : ::sigc::signal6<T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6, T_accumulator>(src) {}
  slot_type slot() const
    { return ::sigc::bound_const_mem_functor6<result_type, parent_type, typename ::sigc::type_trait<T_arg1>::take,typename ::sigc::type_trait<T_arg2>::take,typename ::sigc::type_trait<T_arg3>::take,typename ::sigc::type_trait<T_arg4>::take,typename ::sigc::type_trait<T_arg5>::take,typename ::sigc::type_trait<T_arg6>::take>(this, &parent_type::emit); }
};
template <class T_return, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7, class T_accumulator=::sigc::nil>
class Signal7
  : public ::sigc::signal7<T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7, T_accumulator>
{
public:
  typedef ::sigc::signal7<T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7, T_accumulator> parent_type;
  typedef typename parent_type::result_type result_type;
  typedef typename parent_type::slot_type slot_type;
  Signal7() {}
  Signal7(const Signal7& src)
    : ::sigc::signal7<T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7, T_accumulator>(src) {}
  slot_type slot() const
    { return ::sigc::bound_const_mem_functor7<result_type, parent_type, typename ::sigc::type_trait<T_arg1>::take,typename ::sigc::type_trait<T_arg2>::take,typename ::sigc::type_trait<T_arg3>::take,typename ::sigc::type_trait<T_arg4>::take,typename ::sigc::type_trait<T_arg5>::take,typename ::sigc::type_trait<T_arg6>::take,typename ::sigc::type_trait<T_arg7>::take>(this, &parent_type::emit); }
};
}
namespace sigc {
struct connection
{
  connection();
  connection(const connection& c);
  template <typename T_slot>
  connection(const slot_iterator<T_slot>& it) : slot_(&(*it))
    { if (slot_) slot_->add_destroy_notify_callback(this, &notify); }
  explicit connection(slot_base& sl);
  connection& operator=(const connection& c);
  template <typename T_slot>
  connection& operator=(const slot_iterator<T_slot>& it)
    { set_slot(&(*it)); return *this; }
  ~connection();
  bool empty() const;
  bool connected() const;
  bool blocked() const;
  bool block(bool should_block = true);
  bool unblock();
  void disconnect();
  operator bool();
  static void* notify(void* data);
private:
  void set_slot(slot_base* sl);
  slot_base* slot_;
};
}
namespace SigC {
typedef ::sigc::connection Connection;
}
namespace sigc {
template <class T_type>
struct reference_wrapper
{
  explicit reference_wrapper(T_type& v)
    : value_(v) {}
  operator T_type& () const
    { return value_; }
  T_type& value_;
};
template <class T_type>
struct const_reference_wrapper
{
  explicit const_reference_wrapper(const T_type& v)
    : value_(v) {}
  operator const T_type& () const
    { return value_; }
  const T_type& value_;
};
template <class T_type>
reference_wrapper<T_type> ref(T_type& v)
{ return reference_wrapper<T_type>(v); }
template <class T_type>
const_reference_wrapper<T_type> ref(const T_type& v)
{ return const_reference_wrapper<T_type>(v); }
template <class T_type>
struct unwrap_reference
{
  typedef T_type type;
};
template <class T_type>
struct unwrap_reference<reference_wrapper<T_type> >
{
  typedef T_type& type;
};
template <class T_type>
struct unwrap_reference<const_reference_wrapper<T_type> >
{
  typedef const T_type& type;
};
template <class T_type>
T_type& unwrap(const reference_wrapper<T_type>& v)
{ return v; }
template <class T_type>
const T_type& unwrap(const const_reference_wrapper<T_type>& v)
{ return v; }
}
namespace sigc {
template <class T_type>
class bound_argument
{
public:
  bound_argument(const T_type& _A_argument)
    : visited_(_A_argument)
    {}
  inline const T_type& visit() const
    { return visited_; }
  inline T_type& invoke()
    { return visited_; }
private:
  T_type visited_;
};
template <class T_wrapped>
class bound_argument< reference_wrapper<T_wrapped> >
{
public:
  bound_argument(const reference_wrapper<T_wrapped>& _A_argument)
    : visited_(unwrap(_A_argument))
    {}
  inline const limit_reference<T_wrapped>& visit() const
    { return visited_; }
  inline T_wrapped& invoke()
    { return visited_.invoke(); }
private:
  limit_reference<T_wrapped> visited_;
};
template <class T_wrapped>
class bound_argument< const_reference_wrapper<T_wrapped> >
{
public:
  bound_argument(const const_reference_wrapper<T_wrapped>& _A_argument)
    : visited_(unwrap(_A_argument))
    {}
  inline const const_limit_reference<T_wrapped>& visit() const
    { return visited_; }
  inline const T_wrapped& invoke()
    { return visited_.invoke(); }
private:
  const_limit_reference<T_wrapped> visited_;
};
template <class T_action, class T_type>
void
visit_each(const T_action& _A_action,
           const bound_argument<T_type>& _A_argument)
{
  visit_each(_A_action, _A_argument.visit());
}
}
namespace sigc {
namespace internal {
template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
struct count_void
  { static const int value=0; };
template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
struct count_void<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,void>
  { static const int value=1; };
template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
struct count_void<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,void,void>
  { static const int value=2; };
template <class T_arg1,class T_arg2,class T_arg3,class T_arg4>
struct count_void<T_arg1,T_arg2,T_arg3,T_arg4,void,void,void>
  { static const int value=3; };
template <class T_arg1,class T_arg2,class T_arg3>
struct count_void<T_arg1,T_arg2,T_arg3,void,void,void,void>
  { static const int value=4; };
template <class T_arg1,class T_arg2>
struct count_void<T_arg1,T_arg2,void,void,void,void,void>
  { static const int value=5; };
template <class T_arg1>
struct count_void<T_arg1,void,void,void,void,void,void>
  { static const int value=6; };
template <>
struct count_void<void,void,void,void,void,void,void>
  { static const int value=7; };
}
template <int I_location, class T_functor, class T_type1=nil,class T_type2=nil,class T_type3=nil,class T_type4=nil,class T_type5=nil,class T_type6=nil,class T_type7=nil>
struct bind_functor;
template <class T_functor, class T_bound>
struct bind_functor<0, T_functor, T_bound, nil,nil,nil,nil,nil,nil> : public adapts<T_functor>
{
  typedef typename adapts<T_functor>::adaptor_type adaptor_type;
  template <class T_arg1=void,class T_arg2=void,class T_arg3=void,class T_arg4=void,class T_arg5=void,class T_arg6=void,class T_arg7=void>
  struct deduce_result_type
    { typedef typename adaptor_type::template deduce_result_type<typename type_trait<typename unwrap_reference<T_bound>::type>::pass, typename type_trait<T_arg1>::pass, typename type_trait<T_arg2>::pass, typename type_trait<T_arg3>::pass, typename type_trait<T_arg4>::pass, typename type_trait<T_arg5>::pass, typename type_trait<T_arg6>::pass>::type type; };
  typedef typename adaptor_type::result_type result_type;
  result_type
  operator()()
  {
    return this->functor_.template operator()<typename type_trait<typename unwrap_reference<T_bound>::type>::pass> (bound_.invoke());
  }
  template <class T_arg1>
  typename deduce_result_type<T_arg1>::type
  operator()(T_arg1 _A_arg1)
    { return this->functor_.template operator()<typename type_trait<typename unwrap_reference<T_bound>::type>::pass, typename type_trait<T_arg1>::pass>
        (bound_.invoke(), _A_arg1);
    }
  template <class T_arg1,class T_arg2>
  typename deduce_result_type<T_arg1,T_arg2>::type
  operator()(T_arg1 _A_arg1,T_arg2 _A_arg2)
    { return this->functor_.template operator()<typename type_trait<typename unwrap_reference<T_bound>::type>::pass, typename type_trait<T_arg1>::pass, typename type_trait<T_arg2>::pass>
        (bound_.invoke(), _A_arg1, _A_arg2);
    }
  template <class T_arg1,class T_arg2,class T_arg3>
  typename deduce_result_type<T_arg1,T_arg2,T_arg3>::type
  operator()(T_arg1 _A_arg1,T_arg2 _A_arg2,T_arg3 _A_arg3)
    { return this->functor_.template operator()<typename type_trait<typename unwrap_reference<T_bound>::type>::pass, typename type_trait<T_arg1>::pass, typename type_trait<T_arg2>::pass, typename type_trait<T_arg3>::pass>
        (bound_.invoke(), _A_arg1, _A_arg2, _A_arg3);
    }
  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4>
  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4>::type
  operator()(T_arg1 _A_arg1,T_arg2 _A_arg2,T_arg3 _A_arg3,T_arg4 _A_arg4)
    { return this->functor_.template operator()<typename type_trait<typename unwrap_reference<T_bound>::type>::pass, typename type_trait<T_arg1>::pass, typename type_trait<T_arg2>::pass, typename type_trait<T_arg3>::pass, typename type_trait<T_arg4>::pass>
        (bound_.invoke(), _A_arg1, _A_arg2, _A_arg3, _A_arg4);
    }
  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>::type
  operator()(T_arg1 _A_arg1,T_arg2 _A_arg2,T_arg3 _A_arg3,T_arg4 _A_arg4,T_arg5 _A_arg5)
    { return this->functor_.template operator()<typename type_trait<typename unwrap_reference<T_bound>::type>::pass, typename type_trait<T_arg1>::pass, typename type_trait<T_arg2>::pass, typename type_trait<T_arg3>::pass, typename type_trait<T_arg4>::pass, typename type_trait<T_arg5>::pass>
        (bound_.invoke(), _A_arg1, _A_arg2, _A_arg3, _A_arg4, _A_arg5);
    }
  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>::type
  operator()(T_arg1 _A_arg1,T_arg2 _A_arg2,T_arg3 _A_arg3,T_arg4 _A_arg4,T_arg5 _A_arg5,T_arg6 _A_arg6)
    { return this->functor_.template operator()<typename type_trait<typename unwrap_reference<T_bound>::type>::pass, typename type_trait<T_arg1>::pass, typename type_trait<T_arg2>::pass, typename type_trait<T_arg3>::pass, typename type_trait<T_arg4>::pass, typename type_trait<T_arg5>::pass, typename type_trait<T_arg6>::pass>
        (bound_.invoke(), _A_arg1, _A_arg2, _A_arg3, _A_arg4, _A_arg5, _A_arg6);
    }
  bind_functor(typename type_trait<T_functor>::take _A_func, typename type_trait<T_bound>::take _A_bound)
    : adapts<T_functor>(_A_func), bound_(_A_bound)
    {}
  bound_argument<T_bound> bound_;
};
template <class T_functor, class T_bound>
struct bind_functor<1, T_functor, T_bound, nil,nil,nil,nil,nil,nil> : public adapts<T_functor>
{
  typedef typename adapts<T_functor>::adaptor_type adaptor_type;
  template <class T_arg1=void,class T_arg2=void,class T_arg3=void,class T_arg4=void,class T_arg5=void,class T_arg6=void,class T_arg7=void>
  struct deduce_result_type
    { typedef typename adaptor_type::template deduce_result_type<typename type_trait<T_arg1>::pass, typename type_trait<typename unwrap_reference<T_bound>::type>::pass, typename type_trait<T_arg2>::pass, typename type_trait<T_arg3>::pass, typename type_trait<T_arg4>::pass, typename type_trait<T_arg5>::pass, typename type_trait<T_arg6>::pass>::type type; };
  typedef typename adaptor_type::result_type result_type;
  result_type
  operator()()
  {
    return this->functor_.template operator()<typename type_trait<typename unwrap_reference<T_bound>::type>::pass> (bound_.invoke());
  }
  template <class T_arg1>
  typename deduce_result_type<T_arg1>::type
  operator()(T_arg1 _A_arg1)
    { return this->functor_.template operator()<typename type_trait<T_arg1>::pass, typename type_trait<typename unwrap_reference<T_bound>::type>::pass>
        (_A_arg1, bound_.invoke());
    }
  template <class T_arg1,class T_arg2>
  typename deduce_result_type<T_arg1,T_arg2>::type
  operator()(T_arg1 _A_arg1,T_arg2 _A_arg2)
    { return this->functor_.template operator()<typename type_trait<T_arg1>::pass, typename type_trait<typename unwrap_reference<T_bound>::type>::pass, typename type_trait<T_arg2>::pass>
        (_A_arg1, bound_.invoke(), _A_arg2);
    }
  template <class T_arg1,class T_arg2,class T_arg3>
  typename deduce_result_type<T_arg1,T_arg2,T_arg3>::type
  operator()(T_arg1 _A_arg1,T_arg2 _A_arg2,T_arg3 _A_arg3)
    { return this->functor_.template operator()<typename type_trait<T_arg1>::pass, typename type_trait<typename unwrap_reference<T_bound>::type>::pass, typename type_trait<T_arg2>::pass, typename type_trait<T_arg3>::pass>
        (_A_arg1, bound_.invoke(), _A_arg2, _A_arg3);
    }
  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4>
  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4>::type
  operator()(T_arg1 _A_arg1,T_arg2 _A_arg2,T_arg3 _A_arg3,T_arg4 _A_arg4)
    { return this->functor_.template operator()<typename type_trait<T_arg1>::pass, typename type_trait<typename unwrap_reference<T_bound>::type>::pass, typename type_trait<T_arg2>::pass, typename type_trait<T_arg3>::pass, typename type_trait<T_arg4>::pass>
        (_A_arg1, bound_.invoke(), _A_arg2, _A_arg3, _A_arg4);
    }
  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>::type
  operator()(T_arg1 _A_arg1,T_arg2 _A_arg2,T_arg3 _A_arg3,T_arg4 _A_arg4,T_arg5 _A_arg5)
    { return this->functor_.template operator()<typename type_trait<T_arg1>::pass, typename type_trait<typename unwrap_reference<T_bound>::type>::pass, typename type_trait<T_arg2>::pass, typename type_trait<T_arg3>::pass, typename type_trait<T_arg4>::pass, typename type_trait<T_arg5>::pass>
        (_A_arg1, bound_.invoke(), _A_arg2, _A_arg3, _A_arg4, _A_arg5);
    }
  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>::type
  operator()(T_arg1 _A_arg1,T_arg2 _A_arg2,T_arg3 _A_arg3,T_arg4 _A_arg4,T_arg5 _A_arg5,T_arg6 _A_arg6)
    { return this->functor_.template operator()<typename type_trait<T_arg1>::pass, typename type_trait<typename unwrap_reference<T_bound>::type>::pass, typename type_trait<T_arg2>::pass, typename type_trait<T_arg3>::pass, typename type_trait<T_arg4>::pass, typename type_trait<T_arg5>::pass, typename type_trait<T_arg6>::pass>
        (_A_arg1, bound_.invoke(), _A_arg2, _A_arg3, _A_arg4, _A_arg5, _A_arg6);
    }
  bind_functor(typename type_trait<T_functor>::take _A_func, typename type_trait<T_bound>::take _A_bound)
    : adapts<T_functor>(_A_func), bound_(_A_bound)
    {}
  bound_argument<T_bound> bound_;
};
template <class T_functor, class T_bound>
struct bind_functor<2, T_functor, T_bound, nil,nil,nil,nil,nil,nil> : public adapts<T_functor>
{
  typedef typename adapts<T_functor>::adaptor_type adaptor_type;
  template <class T_arg1=void,class T_arg2=void,class T_arg3=void,class T_arg4=void,class T_arg5=void,class T_arg6=void,class T_arg7=void>
  struct deduce_result_type
    { typedef typename adaptor_type::template deduce_result_type<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass, typename type_trait<typename unwrap_reference<T_bound>::type>::pass, typename type_trait<T_arg3>::pass, typename type_trait<T_arg4>::pass, typename type_trait<T_arg5>::pass, typename type_trait<T_arg6>::pass>::type type; };
  typedef typename adaptor_type::result_type result_type;
  result_type
  operator()()
  {
    return this->functor_.template operator()<typename type_trait<typename unwrap_reference<T_bound>::type>::pass> (bound_.invoke());
  }
  template <class T_arg1,class T_arg2>
  typename deduce_result_type<T_arg1,T_arg2>::type
  operator()(T_arg1 _A_arg1,T_arg2 _A_arg2)
    { return this->functor_.template operator()<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass, typename type_trait<typename unwrap_reference<T_bound>::type>::pass>
        (_A_arg1,_A_arg2, bound_.invoke());
    }
  template <class T_arg1,class T_arg2,class T_arg3>
  typename deduce_result_type<T_arg1,T_arg2,T_arg3>::type
  operator()(T_arg1 _A_arg1,T_arg2 _A_arg2,T_arg3 _A_arg3)
    { return this->functor_.template operator()<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass, typename type_trait<typename unwrap_reference<T_bound>::type>::pass, typename type_trait<T_arg3>::pass>
        (_A_arg1,_A_arg2, bound_.invoke(), _A_arg3);
    }
  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4>
  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4>::type
  operator()(T_arg1 _A_arg1,T_arg2 _A_arg2,T_arg3 _A_arg3,T_arg4 _A_arg4)
    { return this->functor_.template operator()<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass, typename type_trait<typename unwrap_reference<T_bound>::type>::pass, typename type_trait<T_arg3>::pass, typename type_trait<T_arg4>::pass>
        (_A_arg1,_A_arg2, bound_.invoke(), _A_arg3, _A_arg4);
    }
  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>::type
  operator()(T_arg1 _A_arg1,T_arg2 _A_arg2,T_arg3 _A_arg3,T_arg4 _A_arg4,T_arg5 _A_arg5)
    { return this->functor_.template operator()<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass, typename type_trait<typename unwrap_reference<T_bound>::type>::pass, typename type_trait<T_arg3>::pass, typename type_trait<T_arg4>::pass, typename type_trait<T_arg5>::pass>
        (_A_arg1,_A_arg2, bound_.invoke(), _A_arg3, _A_arg4, _A_arg5);
    }
  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>::type
  operator()(T_arg1 _A_arg1,T_arg2 _A_arg2,T_arg3 _A_arg3,T_arg4 _A_arg4,T_arg5 _A_arg5,T_arg6 _A_arg6)
    { return this->functor_.template operator()<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass, typename type_trait<typename unwrap_reference<T_bound>::type>::pass, typename type_trait<T_arg3>::pass, typename type_trait<T_arg4>::pass, typename type_trait<T_arg5>::pass, typename type_trait<T_arg6>::pass>
        (_A_arg1,_A_arg2, bound_.invoke(), _A_arg3, _A_arg4, _A_arg5, _A_arg6);
    }
  bind_functor(typename type_trait<T_functor>::take _A_func, typename type_trait<T_bound>::take _A_bound)
    : adapts<T_functor>(_A_func), bound_(_A_bound)
    {}
  bound_argument<T_bound> bound_;
};
template <class T_functor, class T_bound>
struct bind_functor<3, T_functor, T_bound, nil,nil,nil,nil,nil,nil> : public adapts<T_functor>
{
  typedef typename adapts<T_functor>::adaptor_type adaptor_type;
  template <class T_arg1=void,class T_arg2=void,class T_arg3=void,class T_arg4=void,class T_arg5=void,class T_arg6=void,class T_arg7=void>
  struct deduce_result_type
    { typedef typename adaptor_type::template deduce_result_type<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass, typename type_trait<typename unwrap_reference<T_bound>::type>::pass, typename type_trait<T_arg4>::pass, typename type_trait<T_arg5>::pass, typename type_trait<T_arg6>::pass>::type type; };
  typedef typename adaptor_type::result_type result_type;
  result_type
  operator()()
  {
    return this->functor_.template operator()<typename type_trait<typename unwrap_reference<T_bound>::type>::pass> (bound_.invoke());
  }
  template <class T_arg1,class T_arg2,class T_arg3>
  typename deduce_result_type<T_arg1,T_arg2,T_arg3>::type
  operator()(T_arg1 _A_arg1,T_arg2 _A_arg2,T_arg3 _A_arg3)
    { return this->functor_.template operator()<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass, typename type_trait<typename unwrap_reference<T_bound>::type>::pass>
        (_A_arg1,_A_arg2,_A_arg3, bound_.invoke());
    }
  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4>
  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4>::type
  operator()(T_arg1 _A_arg1,T_arg2 _A_arg2,T_arg3 _A_arg3,T_arg4 _A_arg4)
    { return this->functor_.template operator()<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass, typename type_trait<typename unwrap_reference<T_bound>::type>::pass, typename type_trait<T_arg4>::pass>
        (_A_arg1,_A_arg2,_A_arg3, bound_.invoke(), _A_arg4);
    }
  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>::type
  operator()(T_arg1 _A_arg1,T_arg2 _A_arg2,T_arg3 _A_arg3,T_arg4 _A_arg4,T_arg5 _A_arg5)
    { return this->functor_.template operator()<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass, typename type_trait<typename unwrap_reference<T_bound>::type>::pass, typename type_trait<T_arg4>::pass, typename type_trait<T_arg5>::pass>
        (_A_arg1,_A_arg2,_A_arg3, bound_.invoke(), _A_arg4, _A_arg5);
    }
  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>::type
  operator()(T_arg1 _A_arg1,T_arg2 _A_arg2,T_arg3 _A_arg3,T_arg4 _A_arg4,T_arg5 _A_arg5,T_arg6 _A_arg6)
    { return this->functor_.template operator()<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass, typename type_trait<typename unwrap_reference<T_bound>::type>::pass, typename type_trait<T_arg4>::pass, typename type_trait<T_arg5>::pass, typename type_trait<T_arg6>::pass>
        (_A_arg1,_A_arg2,_A_arg3, bound_.invoke(), _A_arg4, _A_arg5, _A_arg6);
    }
  bind_functor(typename type_trait<T_functor>::take _A_func, typename type_trait<T_bound>::take _A_bound)
    : adapts<T_functor>(_A_func), bound_(_A_bound)
    {}
  bound_argument<T_bound> bound_;
};
template <class T_functor, class T_bound>
struct bind_functor<4, T_functor, T_bound, nil,nil,nil,nil,nil,nil> : public adapts<T_functor>
{
  typedef typename adapts<T_functor>::adaptor_type adaptor_type;
  template <class T_arg1=void,class T_arg2=void,class T_arg3=void,class T_arg4=void,class T_arg5=void,class T_arg6=void,class T_arg7=void>
  struct deduce_result_type
    { typedef typename adaptor_type::template deduce_result_type<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass, typename type_trait<typename unwrap_reference<T_bound>::type>::pass, typename type_trait<T_arg5>::pass, typename type_trait<T_arg6>::pass>::type type; };
  typedef typename adaptor_type::result_type result_type;
  result_type
  operator()()
  {
    return this->functor_.template operator()<typename type_trait<typename unwrap_reference<T_bound>::type>::pass> (bound_.invoke());
  }
  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4>
  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4>::type
  operator()(T_arg1 _A_arg1,T_arg2 _A_arg2,T_arg3 _A_arg3,T_arg4 _A_arg4)
    { return this->functor_.template operator()<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass, typename type_trait<typename unwrap_reference<T_bound>::type>::pass>
        (_A_arg1,_A_arg2,_A_arg3,_A_arg4, bound_.invoke());
    }
  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>::type
  operator()(T_arg1 _A_arg1,T_arg2 _A_arg2,T_arg3 _A_arg3,T_arg4 _A_arg4,T_arg5 _A_arg5)
    { return this->functor_.template operator()<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass, typename type_trait<typename unwrap_reference<T_bound>::type>::pass, typename type_trait<T_arg5>::pass>
        (_A_arg1,_A_arg2,_A_arg3,_A_arg4, bound_.invoke(), _A_arg5);
    }
  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>::type
  operator()(T_arg1 _A_arg1,T_arg2 _A_arg2,T_arg3 _A_arg3,T_arg4 _A_arg4,T_arg5 _A_arg5,T_arg6 _A_arg6)
    { return this->functor_.template operator()<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass, typename type_trait<typename unwrap_reference<T_bound>::type>::pass, typename type_trait<T_arg5>::pass, typename type_trait<T_arg6>::pass>
        (_A_arg1,_A_arg2,_A_arg3,_A_arg4, bound_.invoke(), _A_arg5, _A_arg6);
    }
  bind_functor(typename type_trait<T_functor>::take _A_func, typename type_trait<T_bound>::take _A_bound)
    : adapts<T_functor>(_A_func), bound_(_A_bound)
    {}
  bound_argument<T_bound> bound_;
};
template <class T_functor, class T_bound>
struct bind_functor<5, T_functor, T_bound, nil,nil,nil,nil,nil,nil> : public adapts<T_functor>
{
  typedef typename adapts<T_functor>::adaptor_type adaptor_type;
  template <class T_arg1=void,class T_arg2=void,class T_arg3=void,class T_arg4=void,class T_arg5=void,class T_arg6=void,class T_arg7=void>
  struct deduce_result_type
    { typedef typename adaptor_type::template deduce_result_type<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass, typename type_trait<typename unwrap_reference<T_bound>::type>::pass, typename type_trait<T_arg6>::pass>::type type; };
  typedef typename adaptor_type::result_type result_type;
  result_type
  operator()()
  {
    return this->functor_.template operator()<typename type_trait<typename unwrap_reference<T_bound>::type>::pass> (bound_.invoke());
  }
  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>::type
  operator()(T_arg1 _A_arg1,T_arg2 _A_arg2,T_arg3 _A_arg3,T_arg4 _A_arg4,T_arg5 _A_arg5)
    { return this->functor_.template operator()<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass, typename type_trait<typename unwrap_reference<T_bound>::type>::pass>
        (_A_arg1,_A_arg2,_A_arg3,_A_arg4,_A_arg5, bound_.invoke());
    }
  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>::type
  operator()(T_arg1 _A_arg1,T_arg2 _A_arg2,T_arg3 _A_arg3,T_arg4 _A_arg4,T_arg5 _A_arg5,T_arg6 _A_arg6)
    { return this->functor_.template operator()<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass, typename type_trait<typename unwrap_reference<T_bound>::type>::pass, typename type_trait<T_arg6>::pass>
        (_A_arg1,_A_arg2,_A_arg3,_A_arg4,_A_arg5, bound_.invoke(), _A_arg6);
    }
  bind_functor(typename type_trait<T_functor>::take _A_func, typename type_trait<T_bound>::take _A_bound)
    : adapts<T_functor>(_A_func), bound_(_A_bound)
    {}
  bound_argument<T_bound> bound_;
};
template <class T_functor, class T_bound>
struct bind_functor<6, T_functor, T_bound, nil,nil,nil,nil,nil,nil> : public adapts<T_functor>
{
  typedef typename adapts<T_functor>::adaptor_type adaptor_type;
  template <class T_arg1=void,class T_arg2=void,class T_arg3=void,class T_arg4=void,class T_arg5=void,class T_arg6=void,class T_arg7=void>
  struct deduce_result_type
    { typedef typename adaptor_type::template deduce_result_type<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass,typename type_trait<T_arg6>::pass, typename type_trait<typename unwrap_reference<T_bound>::type>::pass>::type type; };
  typedef typename adaptor_type::result_type result_type;
  result_type
  operator()()
  {
    return this->functor_.template operator()<typename type_trait<typename unwrap_reference<T_bound>::type>::pass> (bound_.invoke());
  }
  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>::type
  operator()(T_arg1 _A_arg1,T_arg2 _A_arg2,T_arg3 _A_arg3,T_arg4 _A_arg4,T_arg5 _A_arg5,T_arg6 _A_arg6)
    { return this->functor_.template operator()<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass,typename type_trait<T_arg6>::pass, typename type_trait<typename unwrap_reference<T_bound>::type>::pass>
        (_A_arg1,_A_arg2,_A_arg3,_A_arg4,_A_arg5,_A_arg6, bound_.invoke());
    }
  bind_functor(typename type_trait<T_functor>::take _A_func, typename type_trait<T_bound>::take _A_bound)
    : adapts<T_functor>(_A_func), bound_(_A_bound)
    {}
  bound_argument<T_bound> bound_;
};
template <class T_action, int T_loc, class T_functor, class T_bound>
void visit_each(const T_action& _A_action,
                const bind_functor<T_loc, T_functor, T_bound>& _A_target)
{
  visit_each(_A_action, _A_target.functor_);
  visit_each(_A_action, _A_target.bound_);
}
template <class T_functor, class T_type1>
struct bind_functor<-1, T_functor, T_type1, nil, nil, nil, nil, nil, nil> : public adapts<T_functor>
{
  typedef typename adapts<T_functor>::adaptor_type adaptor_type;
  template <int count, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
  struct deduce_result_type_internal
    { typedef typename adaptor_type::template deduce_result_type<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass,typename type_trait<T_arg6>::pass, typename type_trait<typename unwrap_reference<T_type1>::type>::pass>::type type; };
  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
  struct deduce_result_type_internal<2, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>
    { typedef typename adaptor_type::template deduce_result_type<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass, typename type_trait<typename unwrap_reference<T_type1>::type>::pass>::type type; };
  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
  struct deduce_result_type_internal<3, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>
    { typedef typename adaptor_type::template deduce_result_type<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass, typename type_trait<typename unwrap_reference<T_type1>::type>::pass>::type type; };
  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
  struct deduce_result_type_internal<4, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>
    { typedef typename adaptor_type::template deduce_result_type<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass, typename type_trait<typename unwrap_reference<T_type1>::type>::pass>::type type; };
  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
  struct deduce_result_type_internal<5, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>
    { typedef typename adaptor_type::template deduce_result_type<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass, typename type_trait<typename unwrap_reference<T_type1>::type>::pass>::type type; };
  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
  struct deduce_result_type_internal<6, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>
    { typedef typename adaptor_type::template deduce_result_type<typename type_trait<T_arg1>::pass, typename type_trait<typename unwrap_reference<T_type1>::type>::pass>::type type; };
  template <class T_arg1=void,class T_arg2=void,class T_arg3=void,class T_arg4=void,class T_arg5=void,class T_arg6=void,class T_arg7=void>
  struct deduce_result_type {
    typedef typename deduce_result_type_internal<internal::count_void<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>::value,
                                                 T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>::type type;
  };
  typedef typename adaptor_type::result_type result_type;
  result_type
  operator()()
  {
    return this->functor_.template operator()<typename type_trait<typename unwrap_reference<T_type1>::type>::pass> (bound1_.invoke());
  }
  template <class T_arg1>
  typename deduce_result_type<T_arg1>::type
  operator()(T_arg1 _A_arg1)
    { return this->functor_.template operator()<typename type_trait<T_arg1>::pass, typename type_trait<typename unwrap_reference<T_type1>::type>::pass>
        (_A_arg1, bound1_.invoke());
    }
  template <class T_arg1,class T_arg2>
  typename deduce_result_type<T_arg1,T_arg2>::type
  operator()(T_arg1 _A_arg1,T_arg2 _A_arg2)
    { return this->functor_.template operator()<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass, typename type_trait<typename unwrap_reference<T_type1>::type>::pass>
        (_A_arg1,_A_arg2, bound1_.invoke());
    }
  template <class T_arg1,class T_arg2,class T_arg3>
  typename deduce_result_type<T_arg1,T_arg2,T_arg3>::type
  operator()(T_arg1 _A_arg1,T_arg2 _A_arg2,T_arg3 _A_arg3)
    { return this->functor_.template operator()<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass, typename type_trait<typename unwrap_reference<T_type1>::type>::pass>
        (_A_arg1,_A_arg2,_A_arg3, bound1_.invoke());
    }
  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4>
  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4>::type
  operator()(T_arg1 _A_arg1,T_arg2 _A_arg2,T_arg3 _A_arg3,T_arg4 _A_arg4)
    { return this->functor_.template operator()<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass, typename type_trait<typename unwrap_reference<T_type1>::type>::pass>
        (_A_arg1,_A_arg2,_A_arg3,_A_arg4, bound1_.invoke());
    }
  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>::type
  operator()(T_arg1 _A_arg1,T_arg2 _A_arg2,T_arg3 _A_arg3,T_arg4 _A_arg4,T_arg5 _A_arg5)
    { return this->functor_.template operator()<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass, typename type_trait<typename unwrap_reference<T_type1>::type>::pass>
        (_A_arg1,_A_arg2,_A_arg3,_A_arg4,_A_arg5, bound1_.invoke());
    }
  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>::type
  operator()(T_arg1 _A_arg1,T_arg2 _A_arg2,T_arg3 _A_arg3,T_arg4 _A_arg4,T_arg5 _A_arg5,T_arg6 _A_arg6)
    { return this->functor_.template operator()<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass,typename type_trait<T_arg6>::pass, typename type_trait<typename unwrap_reference<T_type1>::type>::pass>
        (_A_arg1,_A_arg2,_A_arg3,_A_arg4,_A_arg5,_A_arg6, bound1_.invoke());
    }
  bind_functor(typename type_trait<T_functor>::take _A_func, typename type_trait<T_type1>::take _A_bound1)
    : adapts<T_functor>(_A_func), bound1_(_A_bound1)
    {}
  bound_argument<T_type1> bound1_;
};
template <class T_action, class T_functor, class T_type1>
void visit_each(const T_action& _A_action,
                const bind_functor<-1, T_functor, T_type1>& _A_target)
{
  visit_each(_A_action, _A_target.functor_);
  visit_each(_A_action, _A_target.bound1_);
}
template <class T_functor, class T_type1,class T_type2>
struct bind_functor<-1, T_functor, T_type1, T_type2, nil, nil, nil, nil, nil> : public adapts<T_functor>
{
  typedef typename adapts<T_functor>::adaptor_type adaptor_type;
  template <int count, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
  struct deduce_result_type_internal
    { typedef typename adaptor_type::template deduce_result_type<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass, typename type_trait<typename unwrap_reference<T_type1>::type>::pass,typename type_trait<typename unwrap_reference<T_type2>::type>::pass>::type type; };
  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
  struct deduce_result_type_internal<3, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>
    { typedef typename adaptor_type::template deduce_result_type<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass, typename type_trait<typename unwrap_reference<T_type1>::type>::pass,typename type_trait<typename unwrap_reference<T_type2>::type>::pass>::type type; };
  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
  struct deduce_result_type_internal<4, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>
    { typedef typename adaptor_type::template deduce_result_type<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass, typename type_trait<typename unwrap_reference<T_type1>::type>::pass,typename type_trait<typename unwrap_reference<T_type2>::type>::pass>::type type; };
  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
  struct deduce_result_type_internal<5, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>
    { typedef typename adaptor_type::template deduce_result_type<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass, typename type_trait<typename unwrap_reference<T_type1>::type>::pass,typename type_trait<typename unwrap_reference<T_type2>::type>::pass>::type type; };
  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
  struct deduce_result_type_internal<6, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>
    { typedef typename adaptor_type::template deduce_result_type<typename type_trait<T_arg1>::pass, typename type_trait<typename unwrap_reference<T_type1>::type>::pass,typename type_trait<typename unwrap_reference<T_type2>::type>::pass>::type type; };
  template <class T_arg1=void,class T_arg2=void,class T_arg3=void,class T_arg4=void,class T_arg5=void,class T_arg6=void,class T_arg7=void>
  struct deduce_result_type {
    typedef typename deduce_result_type_internal<internal::count_void<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>::value,
                                                 T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>::type type;
  };
  typedef typename adaptor_type::result_type result_type;
  result_type
  operator()()
  {
    return this->functor_.template operator()<typename type_trait<typename unwrap_reference<T_type1>::type>::pass,typename type_trait<typename unwrap_reference<T_type2>::type>::pass> (bound1_.invoke(),bound2_.invoke());
  }
  template <class T_arg1>
  typename deduce_result_type<T_arg1>::type
  operator()(T_arg1 _A_arg1)
    { return this->functor_.template operator()<typename type_trait<T_arg1>::pass, typename type_trait<typename unwrap_reference<T_type1>::type>::pass,typename type_trait<typename unwrap_reference<T_type2>::type>::pass>
        (_A_arg1, bound1_.invoke(),bound2_.invoke());
    }
  template <class T_arg1,class T_arg2>
  typename deduce_result_type<T_arg1,T_arg2>::type
  operator()(T_arg1 _A_arg1,T_arg2 _A_arg2)
    { return this->functor_.template operator()<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass, typename type_trait<typename unwrap_reference<T_type1>::type>::pass,typename type_trait<typename unwrap_reference<T_type2>::type>::pass>
        (_A_arg1,_A_arg2, bound1_.invoke(),bound2_.invoke());
    }
  template <class T_arg1,class T_arg2,class T_arg3>
  typename deduce_result_type<T_arg1,T_arg2,T_arg3>::type
  operator()(T_arg1 _A_arg1,T_arg2 _A_arg2,T_arg3 _A_arg3)
    { return this->functor_.template operator()<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass, typename type_trait<typename unwrap_reference<T_type1>::type>::pass,typename type_trait<typename unwrap_reference<T_type2>::type>::pass>
        (_A_arg1,_A_arg2,_A_arg3, bound1_.invoke(),bound2_.invoke());
    }
  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4>
  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4>::type
  operator()(T_arg1 _A_arg1,T_arg2 _A_arg2,T_arg3 _A_arg3,T_arg4 _A_arg4)
    { return this->functor_.template operator()<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass, typename type_trait<typename unwrap_reference<T_type1>::type>::pass,typename type_trait<typename unwrap_reference<T_type2>::type>::pass>
        (_A_arg1,_A_arg2,_A_arg3,_A_arg4, bound1_.invoke(),bound2_.invoke());
    }
  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>::type
  operator()(T_arg1 _A_arg1,T_arg2 _A_arg2,T_arg3 _A_arg3,T_arg4 _A_arg4,T_arg5 _A_arg5)
    { return this->functor_.template operator()<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass, typename type_trait<typename unwrap_reference<T_type1>::type>::pass,typename type_trait<typename unwrap_reference<T_type2>::type>::pass>
        (_A_arg1,_A_arg2,_A_arg3,_A_arg4,_A_arg5, bound1_.invoke(),bound2_.invoke());
    }
  bind_functor(typename type_trait<T_functor>::take _A_func, typename type_trait<T_type1>::take _A_bound1,typename type_trait<T_type2>::take _A_bound2)
    : adapts<T_functor>(_A_func), bound1_(_A_bound1),bound2_(_A_bound2)
    {}
  bound_argument<T_type1> bound1_;
  bound_argument<T_type2> bound2_;
};
template <class T_action, class T_functor, class T_type1,class T_type2>
void visit_each(const T_action& _A_action,
                const bind_functor<-1, T_functor, T_type1,T_type2>& _A_target)
{
  visit_each(_A_action, _A_target.functor_);
  visit_each(_A_action, _A_target.bound1_);
  visit_each(_A_action, _A_target.bound2_);
}
template <class T_functor, class T_type1,class T_type2,class T_type3>
struct bind_functor<-1, T_functor, T_type1, T_type2, T_type3, nil, nil, nil, nil> : public adapts<T_functor>
{
  typedef typename adapts<T_functor>::adaptor_type adaptor_type;
  template <int count, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
  struct deduce_result_type_internal
    { typedef typename adaptor_type::template deduce_result_type<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass, typename type_trait<typename unwrap_reference<T_type1>::type>::pass,typename type_trait<typename unwrap_reference<T_type2>::type>::pass,typename type_trait<typename unwrap_reference<T_type3>::type>::pass>::type type; };
  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
  struct deduce_result_type_internal<4, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>
    { typedef typename adaptor_type::template deduce_result_type<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass, typename type_trait<typename unwrap_reference<T_type1>::type>::pass,typename type_trait<typename unwrap_reference<T_type2>::type>::pass,typename type_trait<typename unwrap_reference<T_type3>::type>::pass>::type type; };
  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
  struct deduce_result_type_internal<5, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>
    { typedef typename adaptor_type::template deduce_result_type<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass, typename type_trait<typename unwrap_reference<T_type1>::type>::pass,typename type_trait<typename unwrap_reference<T_type2>::type>::pass,typename type_trait<typename unwrap_reference<T_type3>::type>::pass>::type type; };
  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
  struct deduce_result_type_internal<6, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>
    { typedef typename adaptor_type::template deduce_result_type<typename type_trait<T_arg1>::pass, typename type_trait<typename unwrap_reference<T_type1>::type>::pass,typename type_trait<typename unwrap_reference<T_type2>::type>::pass,typename type_trait<typename unwrap_reference<T_type3>::type>::pass>::type type; };
  template <class T_arg1=void,class T_arg2=void,class T_arg3=void,class T_arg4=void,class T_arg5=void,class T_arg6=void,class T_arg7=void>
  struct deduce_result_type {
    typedef typename deduce_result_type_internal<internal::count_void<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>::value,
                                                 T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>::type type;
  };
  typedef typename adaptor_type::result_type result_type;
  result_type
  operator()()
  {
    return this->functor_.template operator()<typename type_trait<typename unwrap_reference<T_type1>::type>::pass,typename type_trait<typename unwrap_reference<T_type2>::type>::pass,typename type_trait<typename unwrap_reference<T_type3>::type>::pass> (bound1_.invoke(),bound2_.invoke(),bound3_.invoke());
  }
  template <class T_arg1>
  typename deduce_result_type<T_arg1>::type
  operator()(T_arg1 _A_arg1)
    { return this->functor_.template operator()<typename type_trait<T_arg1>::pass, typename type_trait<typename unwrap_reference<T_type1>::type>::pass,typename type_trait<typename unwrap_reference<T_type2>::type>::pass,typename type_trait<typename unwrap_reference<T_type3>::type>::pass>
        (_A_arg1, bound1_.invoke(),bound2_.invoke(),bound3_.invoke());
    }
  template <class T_arg1,class T_arg2>
  typename deduce_result_type<T_arg1,T_arg2>::type
  operator()(T_arg1 _A_arg1,T_arg2 _A_arg2)
    { return this->functor_.template operator()<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass, typename type_trait<typename unwrap_reference<T_type1>::type>::pass,typename type_trait<typename unwrap_reference<T_type2>::type>::pass,typename type_trait<typename unwrap_reference<T_type3>::type>::pass>
        (_A_arg1,_A_arg2, bound1_.invoke(),bound2_.invoke(),bound3_.invoke());
    }
  template <class T_arg1,class T_arg2,class T_arg3>
  typename deduce_result_type<T_arg1,T_arg2,T_arg3>::type
  operator()(T_arg1 _A_arg1,T_arg2 _A_arg2,T_arg3 _A_arg3)
    { return this->functor_.template operator()<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass, typename type_trait<typename unwrap_reference<T_type1>::type>::pass,typename type_trait<typename unwrap_reference<T_type2>::type>::pass,typename type_trait<typename unwrap_reference<T_type3>::type>::pass>
        (_A_arg1,_A_arg2,_A_arg3, bound1_.invoke(),bound2_.invoke(),bound3_.invoke());
    }
  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4>
  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4>::type
  operator()(T_arg1 _A_arg1,T_arg2 _A_arg2,T_arg3 _A_arg3,T_arg4 _A_arg4)
    { return this->functor_.template operator()<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass, typename type_trait<typename unwrap_reference<T_type1>::type>::pass,typename type_trait<typename unwrap_reference<T_type2>::type>::pass,typename type_trait<typename unwrap_reference<T_type3>::type>::pass>
        (_A_arg1,_A_arg2,_A_arg3,_A_arg4, bound1_.invoke(),bound2_.invoke(),bound3_.invoke());
    }
  bind_functor(typename type_trait<T_functor>::take _A_func, typename type_trait<T_type1>::take _A_bound1,typename type_trait<T_type2>::take _A_bound2,typename type_trait<T_type3>::take _A_bound3)
    : adapts<T_functor>(_A_func), bound1_(_A_bound1),bound2_(_A_bound2),bound3_(_A_bound3)
    {}
  bound_argument<T_type1> bound1_;
  bound_argument<T_type2> bound2_;
  bound_argument<T_type3> bound3_;
};
template <class T_action, class T_functor, class T_type1,class T_type2,class T_type3>
void visit_each(const T_action& _A_action,
                const bind_functor<-1, T_functor, T_type1,T_type2,T_type3>& _A_target)
{
  visit_each(_A_action, _A_target.functor_);
  visit_each(_A_action, _A_target.bound1_);
  visit_each(_A_action, _A_target.bound2_);
  visit_each(_A_action, _A_target.bound3_);
}
template <class T_functor, class T_type1,class T_type2,class T_type3,class T_type4>
struct bind_functor<-1, T_functor, T_type1, T_type2, T_type3, T_type4, nil, nil, nil> : public adapts<T_functor>
{
  typedef typename adapts<T_functor>::adaptor_type adaptor_type;
  template <int count, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
  struct deduce_result_type_internal
    { typedef typename adaptor_type::template deduce_result_type<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass, typename type_trait<typename unwrap_reference<T_type1>::type>::pass,typename type_trait<typename unwrap_reference<T_type2>::type>::pass,typename type_trait<typename unwrap_reference<T_type3>::type>::pass,typename type_trait<typename unwrap_reference<T_type4>::type>::pass>::type type; };
  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
  struct deduce_result_type_internal<5, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>
    { typedef typename adaptor_type::template deduce_result_type<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass, typename type_trait<typename unwrap_reference<T_type1>::type>::pass,typename type_trait<typename unwrap_reference<T_type2>::type>::pass,typename type_trait<typename unwrap_reference<T_type3>::type>::pass,typename type_trait<typename unwrap_reference<T_type4>::type>::pass>::type type; };
  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
  struct deduce_result_type_internal<6, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>
    { typedef typename adaptor_type::template deduce_result_type<typename type_trait<T_arg1>::pass, typename type_trait<typename unwrap_reference<T_type1>::type>::pass,typename type_trait<typename unwrap_reference<T_type2>::type>::pass,typename type_trait<typename unwrap_reference<T_type3>::type>::pass,typename type_trait<typename unwrap_reference<T_type4>::type>::pass>::type type; };
  template <class T_arg1=void,class T_arg2=void,class T_arg3=void,class T_arg4=void,class T_arg5=void,class T_arg6=void,class T_arg7=void>
  struct deduce_result_type {
    typedef typename deduce_result_type_internal<internal::count_void<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>::value,
                                                 T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>::type type;
  };
  typedef typename adaptor_type::result_type result_type;
  result_type
  operator()()
  {
    return this->functor_.template operator()<typename type_trait<typename unwrap_reference<T_type1>::type>::pass,typename type_trait<typename unwrap_reference<T_type2>::type>::pass,typename type_trait<typename unwrap_reference<T_type3>::type>::pass,typename type_trait<typename unwrap_reference<T_type4>::type>::pass> (bound1_.invoke(),bound2_.invoke(),bound3_.invoke(),bound4_.invoke());
  }
  template <class T_arg1>
  typename deduce_result_type<T_arg1>::type
  operator()(T_arg1 _A_arg1)
    { return this->functor_.template operator()<typename type_trait<T_arg1>::pass, typename type_trait<typename unwrap_reference<T_type1>::type>::pass,typename type_trait<typename unwrap_reference<T_type2>::type>::pass,typename type_trait<typename unwrap_reference<T_type3>::type>::pass,typename type_trait<typename unwrap_reference<T_type4>::type>::pass>
        (_A_arg1, bound1_.invoke(),bound2_.invoke(),bound3_.invoke(),bound4_.invoke());
    }
  template <class T_arg1,class T_arg2>
  typename deduce_result_type<T_arg1,T_arg2>::type
  operator()(T_arg1 _A_arg1,T_arg2 _A_arg2)
    { return this->functor_.template operator()<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass, typename type_trait<typename unwrap_reference<T_type1>::type>::pass,typename type_trait<typename unwrap_reference<T_type2>::type>::pass,typename type_trait<typename unwrap_reference<T_type3>::type>::pass,typename type_trait<typename unwrap_reference<T_type4>::type>::pass>
        (_A_arg1,_A_arg2, bound1_.invoke(),bound2_.invoke(),bound3_.invoke(),bound4_.invoke());
    }
  template <class T_arg1,class T_arg2,class T_arg3>
  typename deduce_result_type<T_arg1,T_arg2,T_arg3>::type
  operator()(T_arg1 _A_arg1,T_arg2 _A_arg2,T_arg3 _A_arg3)
    { return this->functor_.template operator()<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass, typename type_trait<typename unwrap_reference<T_type1>::type>::pass,typename type_trait<typename unwrap_reference<T_type2>::type>::pass,typename type_trait<typename unwrap_reference<T_type3>::type>::pass,typename type_trait<typename unwrap_reference<T_type4>::type>::pass>
        (_A_arg1,_A_arg2,_A_arg3, bound1_.invoke(),bound2_.invoke(),bound3_.invoke(),bound4_.invoke());
    }
  bind_functor(typename type_trait<T_functor>::take _A_func, typename type_trait<T_type1>::take _A_bound1,typename type_trait<T_type2>::take _A_bound2,typename type_trait<T_type3>::take _A_bound3,typename type_trait<T_type4>::take _A_bound4)
    : adapts<T_functor>(_A_func), bound1_(_A_bound1),bound2_(_A_bound2),bound3_(_A_bound3),bound4_(_A_bound4)
    {}
  bound_argument<T_type1> bound1_;
  bound_argument<T_type2> bound2_;
  bound_argument<T_type3> bound3_;
  bound_argument<T_type4> bound4_;
};
template <class T_action, class T_functor, class T_type1,class T_type2,class T_type3,class T_type4>
void visit_each(const T_action& _A_action,
                const bind_functor<-1, T_functor, T_type1,T_type2,T_type3,T_type4>& _A_target)
{
  visit_each(_A_action, _A_target.functor_);
  visit_each(_A_action, _A_target.bound1_);
  visit_each(_A_action, _A_target.bound2_);
  visit_each(_A_action, _A_target.bound3_);
  visit_each(_A_action, _A_target.bound4_);
}
template <class T_functor, class T_type1,class T_type2,class T_type3,class T_type4,class T_type5>
struct bind_functor<-1, T_functor, T_type1, T_type2, T_type3, T_type4, T_type5, nil, nil> : public adapts<T_functor>
{
  typedef typename adapts<T_functor>::adaptor_type adaptor_type;
  template <int count, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
  struct deduce_result_type_internal
    { typedef typename adaptor_type::template deduce_result_type<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass, typename type_trait<typename unwrap_reference<T_type1>::type>::pass,typename type_trait<typename unwrap_reference<T_type2>::type>::pass,typename type_trait<typename unwrap_reference<T_type3>::type>::pass,typename type_trait<typename unwrap_reference<T_type4>::type>::pass,typename type_trait<typename unwrap_reference<T_type5>::type>::pass>::type type; };
  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
  struct deduce_result_type_internal<6, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>
    { typedef typename adaptor_type::template deduce_result_type<typename type_trait<T_arg1>::pass, typename type_trait<typename unwrap_reference<T_type1>::type>::pass,typename type_trait<typename unwrap_reference<T_type2>::type>::pass,typename type_trait<typename unwrap_reference<T_type3>::type>::pass,typename type_trait<typename unwrap_reference<T_type4>::type>::pass,typename type_trait<typename unwrap_reference<T_type5>::type>::pass>::type type; };
  template <class T_arg1=void,class T_arg2=void,class T_arg3=void,class T_arg4=void,class T_arg5=void,class T_arg6=void,class T_arg7=void>
  struct deduce_result_type {
    typedef typename deduce_result_type_internal<internal::count_void<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>::value,
                                                 T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>::type type;
  };
  typedef typename adaptor_type::result_type result_type;
  result_type
  operator()()
  {
    return this->functor_.template operator()<typename type_trait<typename unwrap_reference<T_type1>::type>::pass,typename type_trait<typename unwrap_reference<T_type2>::type>::pass,typename type_trait<typename unwrap_reference<T_type3>::type>::pass,typename type_trait<typename unwrap_reference<T_type4>::type>::pass,typename type_trait<typename unwrap_reference<T_type5>::type>::pass> (bound1_.invoke(),bound2_.invoke(),bound3_.invoke(),bound4_.invoke(),bound5_.invoke());
  }
  template <class T_arg1>
  typename deduce_result_type<T_arg1>::type
  operator()(T_arg1 _A_arg1)
    { return this->functor_.template operator()<typename type_trait<T_arg1>::pass, typename type_trait<typename unwrap_reference<T_type1>::type>::pass,typename type_trait<typename unwrap_reference<T_type2>::type>::pass,typename type_trait<typename unwrap_reference<T_type3>::type>::pass,typename type_trait<typename unwrap_reference<T_type4>::type>::pass,typename type_trait<typename unwrap_reference<T_type5>::type>::pass>
        (_A_arg1, bound1_.invoke(),bound2_.invoke(),bound3_.invoke(),bound4_.invoke(),bound5_.invoke());
    }
  template <class T_arg1,class T_arg2>
  typename deduce_result_type<T_arg1,T_arg2>::type
  operator()(T_arg1 _A_arg1,T_arg2 _A_arg2)
    { return this->functor_.template operator()<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass, typename type_trait<typename unwrap_reference<T_type1>::type>::pass,typename type_trait<typename unwrap_reference<T_type2>::type>::pass,typename type_trait<typename unwrap_reference<T_type3>::type>::pass,typename type_trait<typename unwrap_reference<T_type4>::type>::pass,typename type_trait<typename unwrap_reference<T_type5>::type>::pass>
        (_A_arg1,_A_arg2, bound1_.invoke(),bound2_.invoke(),bound3_.invoke(),bound4_.invoke(),bound5_.invoke());
    }
  bind_functor(typename type_trait<T_functor>::take _A_func, typename type_trait<T_type1>::take _A_bound1,typename type_trait<T_type2>::take _A_bound2,typename type_trait<T_type3>::take _A_bound3,typename type_trait<T_type4>::take _A_bound4,typename type_trait<T_type5>::take _A_bound5)
    : adapts<T_functor>(_A_func), bound1_(_A_bound1),bound2_(_A_bound2),bound3_(_A_bound3),bound4_(_A_bound4),bound5_(_A_bound5)
    {}
  bound_argument<T_type1> bound1_;
  bound_argument<T_type2> bound2_;
  bound_argument<T_type3> bound3_;
  bound_argument<T_type4> bound4_;
  bound_argument<T_type5> bound5_;
};
template <class T_action, class T_functor, class T_type1,class T_type2,class T_type3,class T_type4,class T_type5>
void visit_each(const T_action& _A_action,
                const bind_functor<-1, T_functor, T_type1,T_type2,T_type3,T_type4,T_type5>& _A_target)
{
  visit_each(_A_action, _A_target.functor_);
  visit_each(_A_action, _A_target.bound1_);
  visit_each(_A_action, _A_target.bound2_);
  visit_each(_A_action, _A_target.bound3_);
  visit_each(_A_action, _A_target.bound4_);
  visit_each(_A_action, _A_target.bound5_);
}
template <class T_functor, class T_type1,class T_type2,class T_type3,class T_type4,class T_type5,class T_type6>
struct bind_functor<-1, T_functor, T_type1, T_type2, T_type3, T_type4, T_type5, T_type6, nil> : public adapts<T_functor>
{
  typedef typename adapts<T_functor>::adaptor_type adaptor_type;
  template <int count, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
  struct deduce_result_type_internal
    { typedef typename adaptor_type::template deduce_result_type<typename type_trait<T_arg1>::pass, typename type_trait<typename unwrap_reference<T_type1>::type>::pass,typename type_trait<typename unwrap_reference<T_type2>::type>::pass,typename type_trait<typename unwrap_reference<T_type3>::type>::pass,typename type_trait<typename unwrap_reference<T_type4>::type>::pass,typename type_trait<typename unwrap_reference<T_type5>::type>::pass,typename type_trait<typename unwrap_reference<T_type6>::type>::pass>::type type; };
  template <class T_arg1=void,class T_arg2=void,class T_arg3=void,class T_arg4=void,class T_arg5=void,class T_arg6=void,class T_arg7=void>
  struct deduce_result_type {
    typedef typename deduce_result_type_internal<internal::count_void<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>::value,
                                                 T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>::type type;
  };
  typedef typename adaptor_type::result_type result_type;
  result_type
  operator()()
  {
    return this->functor_.template operator()<typename type_trait<typename unwrap_reference<T_type1>::type>::pass,typename type_trait<typename unwrap_reference<T_type2>::type>::pass,typename type_trait<typename unwrap_reference<T_type3>::type>::pass,typename type_trait<typename unwrap_reference<T_type4>::type>::pass,typename type_trait<typename unwrap_reference<T_type5>::type>::pass,typename type_trait<typename unwrap_reference<T_type6>::type>::pass> (bound1_.invoke(),bound2_.invoke(),bound3_.invoke(),bound4_.invoke(),bound5_.invoke(),bound6_.invoke());
  }
  template <class T_arg1>
  typename deduce_result_type<T_arg1>::type
  operator()(T_arg1 _A_arg1)
    { return this->functor_.template operator()<typename type_trait<T_arg1>::pass, typename type_trait<typename unwrap_reference<T_type1>::type>::pass,typename type_trait<typename unwrap_reference<T_type2>::type>::pass,typename type_trait<typename unwrap_reference<T_type3>::type>::pass,typename type_trait<typename unwrap_reference<T_type4>::type>::pass,typename type_trait<typename unwrap_reference<T_type5>::type>::pass,typename type_trait<typename unwrap_reference<T_type6>::type>::pass>
        (_A_arg1, bound1_.invoke(),bound2_.invoke(),bound3_.invoke(),bound4_.invoke(),bound5_.invoke(),bound6_.invoke());
    }
  bind_functor(typename type_trait<T_functor>::take _A_func, typename type_trait<T_type1>::take _A_bound1,typename type_trait<T_type2>::take _A_bound2,typename type_trait<T_type3>::take _A_bound3,typename type_trait<T_type4>::take _A_bound4,typename type_trait<T_type5>::take _A_bound5,typename type_trait<T_type6>::take _A_bound6)
    : adapts<T_functor>(_A_func), bound1_(_A_bound1),bound2_(_A_bound2),bound3_(_A_bound3),bound4_(_A_bound4),bound5_(_A_bound5),bound6_(_A_bound6)
    {}
  bound_argument<T_type1> bound1_;
  bound_argument<T_type2> bound2_;
  bound_argument<T_type3> bound3_;
  bound_argument<T_type4> bound4_;
  bound_argument<T_type5> bound5_;
  bound_argument<T_type6> bound6_;
};
template <class T_action, class T_functor, class T_type1,class T_type2,class T_type3,class T_type4,class T_type5,class T_type6>
void visit_each(const T_action& _A_action,
                const bind_functor<-1, T_functor, T_type1,T_type2,T_type3,T_type4,T_type5,T_type6>& _A_target)
{
  visit_each(_A_action, _A_target.functor_);
  visit_each(_A_action, _A_target.bound1_);
  visit_each(_A_action, _A_target.bound2_);
  visit_each(_A_action, _A_target.bound3_);
  visit_each(_A_action, _A_target.bound4_);
  visit_each(_A_action, _A_target.bound5_);
  visit_each(_A_action, _A_target.bound6_);
}
template <class T_functor, class T_type1,class T_type2,class T_type3,class T_type4,class T_type5,class T_type6,class T_type7>
struct bind_functor<-1, T_functor, T_type1, T_type2, T_type3, T_type4, T_type5, T_type6, T_type7> : public adapts<T_functor>
{
  typedef typename adapts<T_functor>::adaptor_type adaptor_type;
  template <int count, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
  struct deduce_result_type_internal
    { typedef typename adaptor_type::template deduce_result_type<typename type_trait<typename unwrap_reference<T_type1>::type>::pass,typename type_trait<typename unwrap_reference<T_type2>::type>::pass,typename type_trait<typename unwrap_reference<T_type3>::type>::pass,typename type_trait<typename unwrap_reference<T_type4>::type>::pass,typename type_trait<typename unwrap_reference<T_type5>::type>::pass,typename type_trait<typename unwrap_reference<T_type6>::type>::pass,typename type_trait<typename unwrap_reference<T_type7>::type>::pass>::type type; };
  template <class T_arg1=void,class T_arg2=void,class T_arg3=void,class T_arg4=void,class T_arg5=void,class T_arg6=void,class T_arg7=void>
  struct deduce_result_type {
    typedef typename deduce_result_type_internal<internal::count_void<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>::value,
                                                 T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>::type type;
  };
  typedef typename adaptor_type::result_type result_type;
  result_type
  operator()()
  {
    return this->functor_.template operator()<typename type_trait<typename unwrap_reference<T_type1>::type>::pass,typename type_trait<typename unwrap_reference<T_type2>::type>::pass,typename type_trait<typename unwrap_reference<T_type3>::type>::pass,typename type_trait<typename unwrap_reference<T_type4>::type>::pass,typename type_trait<typename unwrap_reference<T_type5>::type>::pass,typename type_trait<typename unwrap_reference<T_type6>::type>::pass,typename type_trait<typename unwrap_reference<T_type7>::type>::pass> (bound1_.invoke(),bound2_.invoke(),bound3_.invoke(),bound4_.invoke(),bound5_.invoke(),bound6_.invoke(),bound7_.invoke());
  }
  bind_functor(typename type_trait<T_functor>::take _A_func, typename type_trait<T_type1>::take _A_bound1,typename type_trait<T_type2>::take _A_bound2,typename type_trait<T_type3>::take _A_bound3,typename type_trait<T_type4>::take _A_bound4,typename type_trait<T_type5>::take _A_bound5,typename type_trait<T_type6>::take _A_bound6,typename type_trait<T_type7>::take _A_bound7)
    : adapts<T_functor>(_A_func), bound1_(_A_bound1),bound2_(_A_bound2),bound3_(_A_bound3),bound4_(_A_bound4),bound5_(_A_bound5),bound6_(_A_bound6),bound7_(_A_bound7)
    {}
  bound_argument<T_type1> bound1_;
  bound_argument<T_type2> bound2_;
  bound_argument<T_type3> bound3_;
  bound_argument<T_type4> bound4_;
  bound_argument<T_type5> bound5_;
  bound_argument<T_type6> bound6_;
  bound_argument<T_type7> bound7_;
};
template <class T_action, class T_functor, class T_type1,class T_type2,class T_type3,class T_type4,class T_type5,class T_type6,class T_type7>
void visit_each(const T_action& _A_action,
                const bind_functor<-1, T_functor, T_type1,T_type2,T_type3,T_type4,T_type5,T_type6,T_type7>& _A_target)
{
  visit_each(_A_action, _A_target.functor_);
  visit_each(_A_action, _A_target.bound1_);
  visit_each(_A_action, _A_target.bound2_);
  visit_each(_A_action, _A_target.bound3_);
  visit_each(_A_action, _A_target.bound4_);
  visit_each(_A_action, _A_target.bound5_);
  visit_each(_A_action, _A_target.bound6_);
  visit_each(_A_action, _A_target.bound7_);
}
template <int I_location, class T_bound1, class T_functor>
inline bind_functor<I_location, T_functor, T_bound1>
bind(const T_functor& _A_func, T_bound1 _A_b1)
{
  return bind_functor<I_location, T_functor, T_bound1>
           (_A_func, _A_b1);
}
template <class T_type1, class T_functor>
inline bind_functor<-1, T_functor,
                    T_type1>
bind(const T_functor& _A_func, T_type1 _A_b1)
{ return bind_functor<-1, T_functor,
                    T_type1>
                    (_A_func, _A_b1);
}
template <class T_type1,class T_type2, class T_functor>
inline bind_functor<-1, T_functor,
                    T_type1,
                    T_type2>
bind(const T_functor& _A_func, T_type1 _A_b1,T_type2 _A_b2)
{ return bind_functor<-1, T_functor,
                    T_type1,
                    T_type2>
                    (_A_func, _A_b1,_A_b2);
}
template <class T_type1,class T_type2,class T_type3, class T_functor>
inline bind_functor<-1, T_functor,
                    T_type1,
                    T_type2,
                    T_type3>
bind(const T_functor& _A_func, T_type1 _A_b1,T_type2 _A_b2,T_type3 _A_b3)
{ return bind_functor<-1, T_functor,
                    T_type1,
                    T_type2,
                    T_type3>
                    (_A_func, _A_b1,_A_b2,_A_b3);
}
template <class T_type1,class T_type2,class T_type3,class T_type4, class T_functor>
inline bind_functor<-1, T_functor,
                    T_type1,
                    T_type2,
                    T_type3,
                    T_type4>
bind(const T_functor& _A_func, T_type1 _A_b1,T_type2 _A_b2,T_type3 _A_b3,T_type4 _A_b4)
{ return bind_functor<-1, T_functor,
                    T_type1,
                    T_type2,
                    T_type3,
                    T_type4>
                    (_A_func, _A_b1,_A_b2,_A_b3,_A_b4);
}
template <class T_type1,class T_type2,class T_type3,class T_type4,class T_type5, class T_functor>
inline bind_functor<-1, T_functor,
                    T_type1,
                    T_type2,
                    T_type3,
                    T_type4,
                    T_type5>
bind(const T_functor& _A_func, T_type1 _A_b1,T_type2 _A_b2,T_type3 _A_b3,T_type4 _A_b4,T_type5 _A_b5)
{ return bind_functor<-1, T_functor,
                    T_type1,
                    T_type2,
                    T_type3,
                    T_type4,
                    T_type5>
                    (_A_func, _A_b1,_A_b2,_A_b3,_A_b4,_A_b5);
}
template <class T_type1,class T_type2,class T_type3,class T_type4,class T_type5,class T_type6, class T_functor>
inline bind_functor<-1, T_functor,
                    T_type1,
                    T_type2,
                    T_type3,
                    T_type4,
                    T_type5,
                    T_type6>
bind(const T_functor& _A_func, T_type1 _A_b1,T_type2 _A_b2,T_type3 _A_b3,T_type4 _A_b4,T_type5 _A_b5,T_type6 _A_b6)
{ return bind_functor<-1, T_functor,
                    T_type1,
                    T_type2,
                    T_type3,
                    T_type4,
                    T_type5,
                    T_type6>
                    (_A_func, _A_b1,_A_b2,_A_b3,_A_b4,_A_b5,_A_b6);
}
template <class T_type1,class T_type2,class T_type3,class T_type4,class T_type5,class T_type6,class T_type7, class T_functor>
inline bind_functor<-1, T_functor,
                    T_type1,
                    T_type2,
                    T_type3,
                    T_type4,
                    T_type5,
                    T_type6,
                    T_type7>
bind(const T_functor& _A_func, T_type1 _A_b1,T_type2 _A_b2,T_type3 _A_b3,T_type4 _A_b4,T_type5 _A_b5,T_type6 _A_b6,T_type7 _A_b7)
{ return bind_functor<-1, T_functor,
                    T_type1,
                    T_type2,
                    T_type3,
                    T_type4,
                    T_type5,
                    T_type6,
                    T_type7>
                    (_A_func, _A_b1,_A_b2,_A_b3,_A_b4,_A_b5,_A_b6,_A_b7);
}
}
namespace sigc {
template <class T_return, class T_functor>
struct bind_return_functor : public adapts<T_functor>
{
  template <class T_arg1=void,class T_arg2=void,class T_arg3=void,class T_arg4=void,class T_arg5=void,class T_arg6=void,class T_arg7=void>
  struct deduce_result_type
    { typedef typename unwrap_reference<T_return>::type type; };
  typedef typename unwrap_reference<T_return>::type result_type;
  typename unwrap_reference<T_return>::type operator()();
  template <class T_arg1>
  inline typename unwrap_reference<T_return>::type operator()(T_arg1 _A_a1)
    { this->functor_.template operator()<typename type_trait<T_arg1>::pass>
        (_A_a1); return ret_value_.invoke();
    }
  template <class T_arg1,class T_arg2>
  inline typename unwrap_reference<T_return>::type operator()(T_arg1 _A_a1,T_arg2 _A_a2)
    { this->functor_.template operator()<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass>
        (_A_a1,_A_a2); return ret_value_.invoke();
    }
  template <class T_arg1,class T_arg2,class T_arg3>
  inline typename unwrap_reference<T_return>::type operator()(T_arg1 _A_a1,T_arg2 _A_a2,T_arg3 _A_a3)
    { this->functor_.template operator()<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass>
        (_A_a1,_A_a2,_A_a3); return ret_value_.invoke();
    }
  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4>
  inline typename unwrap_reference<T_return>::type operator()(T_arg1 _A_a1,T_arg2 _A_a2,T_arg3 _A_a3,T_arg4 _A_a4)
    { this->functor_.template operator()<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass>
        (_A_a1,_A_a2,_A_a3,_A_a4); return ret_value_.invoke();
    }
  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
  inline typename unwrap_reference<T_return>::type operator()(T_arg1 _A_a1,T_arg2 _A_a2,T_arg3 _A_a3,T_arg4 _A_a4,T_arg5 _A_a5)
    { this->functor_.template operator()<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass>
        (_A_a1,_A_a2,_A_a3,_A_a4,_A_a5); return ret_value_.invoke();
    }
  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
  inline typename unwrap_reference<T_return>::type operator()(T_arg1 _A_a1,T_arg2 _A_a2,T_arg3 _A_a3,T_arg4 _A_a4,T_arg5 _A_a5,T_arg6 _A_a6)
    { this->functor_.template operator()<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass,typename type_trait<T_arg6>::pass>
        (_A_a1,_A_a2,_A_a3,_A_a4,_A_a5,_A_a6); return ret_value_.invoke();
    }
  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
  inline typename unwrap_reference<T_return>::type operator()(T_arg1 _A_a1,T_arg2 _A_a2,T_arg3 _A_a3,T_arg4 _A_a4,T_arg5 _A_a5,T_arg6 _A_a6,T_arg7 _A_a7)
    { this->functor_.template operator()<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass,typename type_trait<T_arg6>::pass,typename type_trait<T_arg7>::pass>
        (_A_a1,_A_a2,_A_a3,_A_a4,_A_a5,_A_a6,_A_a7); return ret_value_.invoke();
    }
  bind_return_functor(typename type_trait<T_functor>::take _A_functor, typename type_trait<T_return>::take _A_ret_value)
    : adapts<T_functor>(_A_functor), ret_value_(_A_ret_value)
    {}
  bound_argument<T_return> ret_value_;
};
template <class T_return, class T_functor>
typename unwrap_reference<T_return>::type bind_return_functor<T_return, T_functor>::operator()()
  { this->functor_(); return ret_value_.invoke(); }
template <class T_action, class T_return, class T_functor>
void visit_each(const T_action& _A_action,
                const bind_return_functor<T_return, T_functor>& _A_target)
{
  visit_each(_A_action, _A_target.ret_value_);
  visit_each(_A_action, _A_target.functor_);
}
template <class T_return, class T_functor>
inline bind_return_functor<T_return, T_functor>
bind_return(const T_functor& _A_functor, T_return _A_ret_value)
{ return bind_return_functor<T_return, T_functor>(_A_functor, _A_ret_value); }
}
namespace sigc {
template <int I_location, class T_functor>
struct hide_functor;
template <class T_functor>
struct hide_functor <-1, T_functor> : public adapts<T_functor>
{
  typedef typename adapts<T_functor>::adaptor_type adaptor_type;
  template <class T_arg1=void,class T_arg2=void,class T_arg3=void,class T_arg4=void,class T_arg5=void,class T_arg6=void,class T_arg7=void>
  struct deduce_result_type
    { typedef typename adaptor_type::template deduce_result_type<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass,typename type_trait<T_arg6>::pass>::type type; };
  typedef typename adaptor_type::result_type result_type;
  template <class T_arg1>
  typename deduce_result_type<T_arg1>::type
  operator()(T_arg1)
    { return this->functor_(); }
  template <class T_arg1,class T_arg2>
  typename deduce_result_type<T_arg1,T_arg2>::type
  operator()(T_arg1 _A_a1, T_arg2)
    { return this->functor_.template operator()<typename type_trait<T_arg1>::pass>
        (_A_a1); }
  template <class T_arg1,class T_arg2,class T_arg3>
  typename deduce_result_type<T_arg1,T_arg2,T_arg3>::type
  operator()(T_arg1 _A_a1,T_arg2 _A_a2, T_arg3)
    { return this->functor_.template operator()<typename type_trait<T_arg1>::pass, typename type_trait<T_arg2>::pass>
        (_A_a1, _A_a2); }
  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4>
  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4>::type
  operator()(T_arg1 _A_a1,T_arg2 _A_a2,T_arg3 _A_a3, T_arg4)
    { return this->functor_.template operator()<typename type_trait<T_arg1>::pass, typename type_trait<T_arg2>::pass, typename type_trait<T_arg3>::pass>
        (_A_a1, _A_a2, _A_a3); }
  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>::type
  operator()(T_arg1 _A_a1,T_arg2 _A_a2,T_arg3 _A_a3,T_arg4 _A_a4, T_arg5)
    { return this->functor_.template operator()<typename type_trait<T_arg1>::pass, typename type_trait<T_arg2>::pass, typename type_trait<T_arg3>::pass, typename type_trait<T_arg4>::pass>
        (_A_a1, _A_a2, _A_a3, _A_a4); }
  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>::type
  operator()(T_arg1 _A_a1,T_arg2 _A_a2,T_arg3 _A_a3,T_arg4 _A_a4,T_arg5 _A_a5, T_arg6)
    { return this->functor_.template operator()<typename type_trait<T_arg1>::pass, typename type_trait<T_arg2>::pass, typename type_trait<T_arg3>::pass, typename type_trait<T_arg4>::pass, typename type_trait<T_arg5>::pass>
        (_A_a1, _A_a2, _A_a3, _A_a4, _A_a5); }
  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>::type
  operator()(T_arg1 _A_a1,T_arg2 _A_a2,T_arg3 _A_a3,T_arg4 _A_a4,T_arg5 _A_a5,T_arg6 _A_a6, T_arg7)
    { return this->functor_.template operator()<typename type_trait<T_arg1>::pass, typename type_trait<T_arg2>::pass, typename type_trait<T_arg3>::pass, typename type_trait<T_arg4>::pass, typename type_trait<T_arg5>::pass, typename type_trait<T_arg6>::pass>
        (_A_a1, _A_a2, _A_a3, _A_a4, _A_a5, _A_a6); }
  explicit hide_functor(const T_functor& _A_func)
    : adapts<T_functor>(_A_func)
    {}
};
template <class T_functor>
struct hide_functor <0, T_functor> : public adapts<T_functor>
{
  typedef typename adapts<T_functor>::adaptor_type adaptor_type;
  template <class T_arg1=void,class T_arg2=void,class T_arg3=void,class T_arg4=void,class T_arg5=void,class T_arg6=void,class T_arg7=void>
  struct deduce_result_type
    { typedef typename adaptor_type::template deduce_result_type<typename type_trait<T_arg2>::pass, typename type_trait<T_arg3>::pass, typename type_trait<T_arg4>::pass, typename type_trait<T_arg5>::pass, typename type_trait<T_arg6>::pass, typename type_trait<T_arg7>::pass>::type type; };
  typedef typename adaptor_type::result_type result_type;
  template <class T_arg1>
  typename deduce_result_type<T_arg1>::type
  operator()(T_arg1)
    { return this->functor_(); }
  template <class T_arg1,class T_arg2>
  typename deduce_result_type<T_arg1,T_arg2>::type
  operator()(T_arg1, T_arg2 _A_a2)
    { return this->functor_.template operator()<typename type_trait<T_arg2>::pass>
        (_A_a2); }
  template <class T_arg1,class T_arg2,class T_arg3>
  typename deduce_result_type<T_arg1,T_arg2,T_arg3>::type
  operator()(T_arg1, T_arg2 _A_a2, T_arg3 _A_a3)
    { return this->functor_.template operator()<typename type_trait<T_arg2>::pass, typename type_trait<T_arg3>::pass>
        (_A_a2, _A_a3); }
  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4>
  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4>::type
  operator()(T_arg1, T_arg2 _A_a2, T_arg3 _A_a3, T_arg4 _A_a4)
    { return this->functor_.template operator()<typename type_trait<T_arg2>::pass, typename type_trait<T_arg3>::pass, typename type_trait<T_arg4>::pass>
        (_A_a2, _A_a3, _A_a4); }
  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>::type
  operator()(T_arg1, T_arg2 _A_a2, T_arg3 _A_a3, T_arg4 _A_a4, T_arg5 _A_a5)
    { return this->functor_.template operator()<typename type_trait<T_arg2>::pass, typename type_trait<T_arg3>::pass, typename type_trait<T_arg4>::pass, typename type_trait<T_arg5>::pass>
        (_A_a2, _A_a3, _A_a4, _A_a5); }
  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>::type
  operator()(T_arg1, T_arg2 _A_a2, T_arg3 _A_a3, T_arg4 _A_a4, T_arg5 _A_a5, T_arg6 _A_a6)
    { return this->functor_.template operator()<typename type_trait<T_arg2>::pass, typename type_trait<T_arg3>::pass, typename type_trait<T_arg4>::pass, typename type_trait<T_arg5>::pass, typename type_trait<T_arg6>::pass>
        (_A_a2, _A_a3, _A_a4, _A_a5, _A_a6); }
  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>::type
  operator()(T_arg1, T_arg2 _A_a2, T_arg3 _A_a3, T_arg4 _A_a4, T_arg5 _A_a5, T_arg6 _A_a6, T_arg7 _A_a7)
    { return this->functor_.template operator()<typename type_trait<T_arg2>::pass, typename type_trait<T_arg3>::pass, typename type_trait<T_arg4>::pass, typename type_trait<T_arg5>::pass, typename type_trait<T_arg6>::pass, typename type_trait<T_arg7>::pass>
        (_A_a2, _A_a3, _A_a4, _A_a5, _A_a6, _A_a7); }
  explicit hide_functor(const T_functor& _A_func)
    : adapts<T_functor>(_A_func)
    {}
};
template <class T_functor>
struct hide_functor <1, T_functor> : public adapts<T_functor>
{
  typedef typename adapts<T_functor>::adaptor_type adaptor_type;
  template <class T_arg1=void,class T_arg2=void,class T_arg3=void,class T_arg4=void,class T_arg5=void,class T_arg6=void,class T_arg7=void>
  struct deduce_result_type
    { typedef typename adaptor_type::template deduce_result_type<typename type_trait<T_arg1>::pass, typename type_trait<T_arg3>::pass, typename type_trait<T_arg4>::pass, typename type_trait<T_arg5>::pass, typename type_trait<T_arg6>::pass, typename type_trait<T_arg7>::pass>::type type; };
  typedef typename adaptor_type::result_type result_type;
  template <class T_arg1,class T_arg2>
  typename deduce_result_type<T_arg1,T_arg2>::type
  operator()(T_arg1 _A_a1, T_arg2)
    { return this->functor_.template operator()<typename type_trait<T_arg1>::pass>
        (_A_a1); }
  template <class T_arg1,class T_arg2,class T_arg3>
  typename deduce_result_type<T_arg1,T_arg2,T_arg3>::type
  operator()(T_arg1 _A_a1, T_arg2, T_arg3 _A_a3)
    { return this->functor_.template operator()<typename type_trait<T_arg1>::pass, typename type_trait<T_arg3>::pass>
        (_A_a1, _A_a3); }
  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4>
  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4>::type
  operator()(T_arg1 _A_a1, T_arg2, T_arg3 _A_a3, T_arg4 _A_a4)
    { return this->functor_.template operator()<typename type_trait<T_arg1>::pass, typename type_trait<T_arg3>::pass, typename type_trait<T_arg4>::pass>
        (_A_a1, _A_a3, _A_a4); }
  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>::type
  operator()(T_arg1 _A_a1, T_arg2, T_arg3 _A_a3, T_arg4 _A_a4, T_arg5 _A_a5)
    { return this->functor_.template operator()<typename type_trait<T_arg1>::pass, typename type_trait<T_arg3>::pass, typename type_trait<T_arg4>::pass, typename type_trait<T_arg5>::pass>
        (_A_a1, _A_a3, _A_a4, _A_a5); }
  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>::type
  operator()(T_arg1 _A_a1, T_arg2, T_arg3 _A_a3, T_arg4 _A_a4, T_arg5 _A_a5, T_arg6 _A_a6)
    { return this->functor_.template operator()<typename type_trait<T_arg1>::pass, typename type_trait<T_arg3>::pass, typename type_trait<T_arg4>::pass, typename type_trait<T_arg5>::pass, typename type_trait<T_arg6>::pass>
        (_A_a1, _A_a3, _A_a4, _A_a5, _A_a6); }
  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>::type
  operator()(T_arg1 _A_a1, T_arg2, T_arg3 _A_a3, T_arg4 _A_a4, T_arg5 _A_a5, T_arg6 _A_a6, T_arg7 _A_a7)
    { return this->functor_.template operator()<typename type_trait<T_arg1>::pass, typename type_trait<T_arg3>::pass, typename type_trait<T_arg4>::pass, typename type_trait<T_arg5>::pass, typename type_trait<T_arg6>::pass, typename type_trait<T_arg7>::pass>
        (_A_a1, _A_a3, _A_a4, _A_a5, _A_a6, _A_a7); }
  explicit hide_functor(const T_functor& _A_func)
    : adapts<T_functor>(_A_func)
    {}
};
template <class T_functor>
struct hide_functor <2, T_functor> : public adapts<T_functor>
{
  typedef typename adapts<T_functor>::adaptor_type adaptor_type;
  template <class T_arg1=void,class T_arg2=void,class T_arg3=void,class T_arg4=void,class T_arg5=void,class T_arg6=void,class T_arg7=void>
  struct deduce_result_type
    { typedef typename adaptor_type::template deduce_result_type<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass, typename type_trait<T_arg4>::pass, typename type_trait<T_arg5>::pass, typename type_trait<T_arg6>::pass, typename type_trait<T_arg7>::pass>::type type; };
  typedef typename adaptor_type::result_type result_type;
  template <class T_arg1,class T_arg2,class T_arg3>
  typename deduce_result_type<T_arg1,T_arg2,T_arg3>::type
  operator()(T_arg1 _A_a1, T_arg2 _A_a2, T_arg3)
    { return this->functor_.template operator()<typename type_trait<T_arg1>::pass, typename type_trait<T_arg2>::pass>
        (_A_a1, _A_a2); }
  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4>
  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4>::type
  operator()(T_arg1 _A_a1, T_arg2 _A_a2, T_arg3, T_arg4 _A_a4)
    { return this->functor_.template operator()<typename type_trait<T_arg1>::pass, typename type_trait<T_arg2>::pass, typename type_trait<T_arg4>::pass>
        (_A_a1, _A_a2, _A_a4); }
  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>::type
  operator()(T_arg1 _A_a1, T_arg2 _A_a2, T_arg3, T_arg4 _A_a4, T_arg5 _A_a5)
    { return this->functor_.template operator()<typename type_trait<T_arg1>::pass, typename type_trait<T_arg2>::pass, typename type_trait<T_arg4>::pass, typename type_trait<T_arg5>::pass>
        (_A_a1, _A_a2, _A_a4, _A_a5); }
  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>::type
  operator()(T_arg1 _A_a1, T_arg2 _A_a2, T_arg3, T_arg4 _A_a4, T_arg5 _A_a5, T_arg6 _A_a6)
    { return this->functor_.template operator()<typename type_trait<T_arg1>::pass, typename type_trait<T_arg2>::pass, typename type_trait<T_arg4>::pass, typename type_trait<T_arg5>::pass, typename type_trait<T_arg6>::pass>
        (_A_a1, _A_a2, _A_a4, _A_a5, _A_a6); }
  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>::type
  operator()(T_arg1 _A_a1, T_arg2 _A_a2, T_arg3, T_arg4 _A_a4, T_arg5 _A_a5, T_arg6 _A_a6, T_arg7 _A_a7)
    { return this->functor_.template operator()<typename type_trait<T_arg1>::pass, typename type_trait<T_arg2>::pass, typename type_trait<T_arg4>::pass, typename type_trait<T_arg5>::pass, typename type_trait<T_arg6>::pass, typename type_trait<T_arg7>::pass>
        (_A_a1, _A_a2, _A_a4, _A_a5, _A_a6, _A_a7); }
  explicit hide_functor(const T_functor& _A_func)
    : adapts<T_functor>(_A_func)
    {}
};
template <class T_functor>
struct hide_functor <3, T_functor> : public adapts<T_functor>
{
  typedef typename adapts<T_functor>::adaptor_type adaptor_type;
  template <class T_arg1=void,class T_arg2=void,class T_arg3=void,class T_arg4=void,class T_arg5=void,class T_arg6=void,class T_arg7=void>
  struct deduce_result_type
    { typedef typename adaptor_type::template deduce_result_type<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass, typename type_trait<T_arg5>::pass, typename type_trait<T_arg6>::pass, typename type_trait<T_arg7>::pass>::type type; };
  typedef typename adaptor_type::result_type result_type;
  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4>
  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4>::type
  operator()(T_arg1 _A_a1, T_arg2 _A_a2, T_arg3 _A_a3, T_arg4)
    { return this->functor_.template operator()<typename type_trait<T_arg1>::pass, typename type_trait<T_arg2>::pass, typename type_trait<T_arg3>::pass>
        (_A_a1, _A_a2, _A_a3); }
  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>::type
  operator()(T_arg1 _A_a1, T_arg2 _A_a2, T_arg3 _A_a3, T_arg4, T_arg5 _A_a5)
    { return this->functor_.template operator()<typename type_trait<T_arg1>::pass, typename type_trait<T_arg2>::pass, typename type_trait<T_arg3>::pass, typename type_trait<T_arg5>::pass>
        (_A_a1, _A_a2, _A_a3, _A_a5); }
  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>::type
  operator()(T_arg1 _A_a1, T_arg2 _A_a2, T_arg3 _A_a3, T_arg4, T_arg5 _A_a5, T_arg6 _A_a6)
    { return this->functor_.template operator()<typename type_trait<T_arg1>::pass, typename type_trait<T_arg2>::pass, typename type_trait<T_arg3>::pass, typename type_trait<T_arg5>::pass, typename type_trait<T_arg6>::pass>
        (_A_a1, _A_a2, _A_a3, _A_a5, _A_a6); }
  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>::type
  operator()(T_arg1 _A_a1, T_arg2 _A_a2, T_arg3 _A_a3, T_arg4, T_arg5 _A_a5, T_arg6 _A_a6, T_arg7 _A_a7)
    { return this->functor_.template operator()<typename type_trait<T_arg1>::pass, typename type_trait<T_arg2>::pass, typename type_trait<T_arg3>::pass, typename type_trait<T_arg5>::pass, typename type_trait<T_arg6>::pass, typename type_trait<T_arg7>::pass>
        (_A_a1, _A_a2, _A_a3, _A_a5, _A_a6, _A_a7); }
  explicit hide_functor(const T_functor& _A_func)
    : adapts<T_functor>(_A_func)
    {}
};
template <class T_functor>
struct hide_functor <4, T_functor> : public adapts<T_functor>
{
  typedef typename adapts<T_functor>::adaptor_type adaptor_type;
  template <class T_arg1=void,class T_arg2=void,class T_arg3=void,class T_arg4=void,class T_arg5=void,class T_arg6=void,class T_arg7=void>
  struct deduce_result_type
    { typedef typename adaptor_type::template deduce_result_type<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass, typename type_trait<T_arg6>::pass, typename type_trait<T_arg7>::pass>::type type; };
  typedef typename adaptor_type::result_type result_type;
  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>::type
  operator()(T_arg1 _A_a1, T_arg2 _A_a2, T_arg3 _A_a3, T_arg4 _A_a4, T_arg5)
    { return this->functor_.template operator()<typename type_trait<T_arg1>::pass, typename type_trait<T_arg2>::pass, typename type_trait<T_arg3>::pass, typename type_trait<T_arg4>::pass>
        (_A_a1, _A_a2, _A_a3, _A_a4); }
  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>::type
  operator()(T_arg1 _A_a1, T_arg2 _A_a2, T_arg3 _A_a3, T_arg4 _A_a4, T_arg5, T_arg6 _A_a6)
    { return this->functor_.template operator()<typename type_trait<T_arg1>::pass, typename type_trait<T_arg2>::pass, typename type_trait<T_arg3>::pass, typename type_trait<T_arg4>::pass, typename type_trait<T_arg6>::pass>
        (_A_a1, _A_a2, _A_a3, _A_a4, _A_a6); }
  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>::type
  operator()(T_arg1 _A_a1, T_arg2 _A_a2, T_arg3 _A_a3, T_arg4 _A_a4, T_arg5, T_arg6 _A_a6, T_arg7 _A_a7)
    { return this->functor_.template operator()<typename type_trait<T_arg1>::pass, typename type_trait<T_arg2>::pass, typename type_trait<T_arg3>::pass, typename type_trait<T_arg4>::pass, typename type_trait<T_arg6>::pass, typename type_trait<T_arg7>::pass>
        (_A_a1, _A_a2, _A_a3, _A_a4, _A_a6, _A_a7); }
  explicit hide_functor(const T_functor& _A_func)
    : adapts<T_functor>(_A_func)
    {}
};
template <class T_functor>
struct hide_functor <5, T_functor> : public adapts<T_functor>
{
  typedef typename adapts<T_functor>::adaptor_type adaptor_type;
  template <class T_arg1=void,class T_arg2=void,class T_arg3=void,class T_arg4=void,class T_arg5=void,class T_arg6=void,class T_arg7=void>
  struct deduce_result_type
    { typedef typename adaptor_type::template deduce_result_type<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass, typename type_trait<T_arg7>::pass>::type type; };
  typedef typename adaptor_type::result_type result_type;
  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>::type
  operator()(T_arg1 _A_a1, T_arg2 _A_a2, T_arg3 _A_a3, T_arg4 _A_a4, T_arg5 _A_a5, T_arg6)
    { return this->functor_.template operator()<typename type_trait<T_arg1>::pass, typename type_trait<T_arg2>::pass, typename type_trait<T_arg3>::pass, typename type_trait<T_arg4>::pass, typename type_trait<T_arg5>::pass>
        (_A_a1, _A_a2, _A_a3, _A_a4, _A_a5); }
  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>::type
  operator()(T_arg1 _A_a1, T_arg2 _A_a2, T_arg3 _A_a3, T_arg4 _A_a4, T_arg5 _A_a5, T_arg6, T_arg7 _A_a7)
    { return this->functor_.template operator()<typename type_trait<T_arg1>::pass, typename type_trait<T_arg2>::pass, typename type_trait<T_arg3>::pass, typename type_trait<T_arg4>::pass, typename type_trait<T_arg5>::pass, typename type_trait<T_arg7>::pass>
        (_A_a1, _A_a2, _A_a3, _A_a4, _A_a5, _A_a7); }
  explicit hide_functor(const T_functor& _A_func)
    : adapts<T_functor>(_A_func)
    {}
};
template <class T_functor>
struct hide_functor <6, T_functor> : public adapts<T_functor>
{
  typedef typename adapts<T_functor>::adaptor_type adaptor_type;
  template <class T_arg1=void,class T_arg2=void,class T_arg3=void,class T_arg4=void,class T_arg5=void,class T_arg6=void,class T_arg7=void>
  struct deduce_result_type
    { typedef typename adaptor_type::template deduce_result_type<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass,typename type_trait<T_arg6>::pass>::type type; };
  typedef typename adaptor_type::result_type result_type;
  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>::type
  operator()(T_arg1 _A_a1, T_arg2 _A_a2, T_arg3 _A_a3, T_arg4 _A_a4, T_arg5 _A_a5, T_arg6 _A_a6, T_arg7)
    { return this->functor_.template operator()<typename type_trait<T_arg1>::pass, typename type_trait<T_arg2>::pass, typename type_trait<T_arg3>::pass, typename type_trait<T_arg4>::pass, typename type_trait<T_arg5>::pass, typename type_trait<T_arg6>::pass>
        (_A_a1, _A_a2, _A_a3, _A_a4, _A_a5, _A_a6); }
  explicit hide_functor(const T_functor& _A_func)
    : adapts<T_functor>(_A_func)
    {}
};
template <class T_action, int I_location, class T_functor>
void visit_each(const T_action& _A_action,
                const hide_functor<I_location, T_functor>& _A_target)
{
  visit_each(_A_action, _A_target.functor_);
}
template <int I_location, class T_functor>
inline hide_functor<I_location, T_functor>
hide(const T_functor& _A_func)
  { return hide_functor<I_location, T_functor>(_A_func); }
template <class T_functor>
inline hide_functor<-1, T_functor>
hide(const T_functor& _A_func)
  { return hide_functor<-1, T_functor> (_A_func); }
}
namespace sigc {
template <class T_return, class T_functor>
struct retype_return_functor : public adapts<T_functor>
{
  template <class T_arg1=void,class T_arg2=void,class T_arg3=void,class T_arg4=void,class T_arg5=void,class T_arg6=void,class T_arg7=void>
  struct deduce_result_type
    { typedef T_return type; };
  typedef T_return result_type;
  T_return operator()();
  template <class T_arg1>
  inline T_return operator()(T_arg1 _A_a1)
    { return T_return(this->functor_.template operator()<typename type_trait<T_arg1>::pass>
        (_A_a1));
    }
  template <class T_arg1,class T_arg2>
  inline T_return operator()(T_arg1 _A_a1,T_arg2 _A_a2)
    { return T_return(this->functor_.template operator()<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass>
        (_A_a1,_A_a2));
    }
  template <class T_arg1,class T_arg2,class T_arg3>
  inline T_return operator()(T_arg1 _A_a1,T_arg2 _A_a2,T_arg3 _A_a3)
    { return T_return(this->functor_.template operator()<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass>
        (_A_a1,_A_a2,_A_a3));
    }
  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4>
  inline T_return operator()(T_arg1 _A_a1,T_arg2 _A_a2,T_arg3 _A_a3,T_arg4 _A_a4)
    { return T_return(this->functor_.template operator()<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass>
        (_A_a1,_A_a2,_A_a3,_A_a4));
    }
  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
  inline T_return operator()(T_arg1 _A_a1,T_arg2 _A_a2,T_arg3 _A_a3,T_arg4 _A_a4,T_arg5 _A_a5)
    { return T_return(this->functor_.template operator()<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass>
        (_A_a1,_A_a2,_A_a3,_A_a4,_A_a5));
    }
  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
  inline T_return operator()(T_arg1 _A_a1,T_arg2 _A_a2,T_arg3 _A_a3,T_arg4 _A_a4,T_arg5 _A_a5,T_arg6 _A_a6)
    { return T_return(this->functor_.template operator()<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass,typename type_trait<T_arg6>::pass>
        (_A_a1,_A_a2,_A_a3,_A_a4,_A_a5,_A_a6));
    }
  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
  inline T_return operator()(T_arg1 _A_a1,T_arg2 _A_a2,T_arg3 _A_a3,T_arg4 _A_a4,T_arg5 _A_a5,T_arg6 _A_a6,T_arg7 _A_a7)
    { return T_return(this->functor_.template operator()<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass,typename type_trait<T_arg6>::pass,typename type_trait<T_arg7>::pass>
        (_A_a1,_A_a2,_A_a3,_A_a4,_A_a5,_A_a6,_A_a7));
    }
  retype_return_functor() {}
  explicit retype_return_functor(typename type_trait<T_functor>::take _A_functor)
    : adapts<T_functor>(_A_functor)
    {}
};
template <class T_return, class T_functor>
T_return retype_return_functor<T_return, T_functor>::operator()()
  { return T_return(this->functor_()); }
template <class T_functor>
struct retype_return_functor<void, T_functor> : public adapts<T_functor>
{
  template <class T_arg1=void,class T_arg2=void,class T_arg3=void,class T_arg4=void,class T_arg5=void,class T_arg6=void,class T_arg7=void>
  struct deduce_result_type
    { typedef void type; };
  typedef void result_type;
  void operator()();
  template <class T_arg1>
  inline void operator()(T_arg1 _A_a1)
    { this->functor_.template operator()<typename type_trait<T_arg1>::pass>
        (_A_a1);
    }
  template <class T_arg1,class T_arg2>
  inline void operator()(T_arg1 _A_a1,T_arg2 _A_a2)
    { this->functor_.template operator()<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass>
        (_A_a1,_A_a2);
    }
  template <class T_arg1,class T_arg2,class T_arg3>
  inline void operator()(T_arg1 _A_a1,T_arg2 _A_a2,T_arg3 _A_a3)
    { this->functor_.template operator()<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass>
        (_A_a1,_A_a2,_A_a3);
    }
  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4>
  inline void operator()(T_arg1 _A_a1,T_arg2 _A_a2,T_arg3 _A_a3,T_arg4 _A_a4)
    { this->functor_.template operator()<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass>
        (_A_a1,_A_a2,_A_a3,_A_a4);
    }
  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
  inline void operator()(T_arg1 _A_a1,T_arg2 _A_a2,T_arg3 _A_a3,T_arg4 _A_a4,T_arg5 _A_a5)
    { this->functor_.template operator()<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass>
        (_A_a1,_A_a2,_A_a3,_A_a4,_A_a5);
    }
  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
  inline void operator()(T_arg1 _A_a1,T_arg2 _A_a2,T_arg3 _A_a3,T_arg4 _A_a4,T_arg5 _A_a5,T_arg6 _A_a6)
    { this->functor_.template operator()<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass,typename type_trait<T_arg6>::pass>
        (_A_a1,_A_a2,_A_a3,_A_a4,_A_a5,_A_a6);
    }
  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
  inline void operator()(T_arg1 _A_a1,T_arg2 _A_a2,T_arg3 _A_a3,T_arg4 _A_a4,T_arg5 _A_a5,T_arg6 _A_a6,T_arg7 _A_a7)
    { this->functor_.template operator()<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass,typename type_trait<T_arg6>::pass,typename type_trait<T_arg7>::pass>
        (_A_a1,_A_a2,_A_a3,_A_a4,_A_a5,_A_a6,_A_a7);
    }
  retype_return_functor() {}
  retype_return_functor(typename type_trait<T_functor>::take _A_functor)
    : adapts<T_functor>(_A_functor)
    {}
};
template <class T_functor>
void retype_return_functor<void, T_functor>::operator()()
  { this->functor_(); }
template <class T_action, class T_return, class T_functor>
void visit_each(const T_action& _A_action,
                const retype_return_functor<T_return, T_functor>& _A_target)
{
  visit_each(_A_action, _A_target.functor_);
}
template <class T_return, class T_functor>
inline retype_return_functor<T_return, T_functor>
retype_return(const T_functor& _A_functor)
  { return retype_return_functor<T_return, T_functor>(_A_functor); }
template <class T_functor>
inline retype_return_functor<void, T_functor>
hide_return(const T_functor& _A_functor)
  { return retype_return_functor<void, T_functor>(_A_functor); }
}
namespace sigc {
template <class T_functor, class T_type1=nil,class T_type2=nil,class T_type3=nil,class T_type4=nil,class T_type5=nil,class T_type6=nil,class T_type7=nil>
struct retype_functor
  : public adapts<T_functor>
{
  typedef typename adapts<T_functor>::adaptor_type adaptor_type;
  template <class T_arg1=void,class T_arg2=void,class T_arg3=void,class T_arg4=void,class T_arg5=void,class T_arg6=void,class T_arg7=void>
  struct deduce_result_type
    { typedef typename adaptor_type::template deduce_result_type<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass,typename type_trait<T_arg6>::pass,typename type_trait<T_arg7>::pass>::type type; };
  typedef typename adapts<T_functor>::result_type result_type;
  result_type operator()();
  template <class T_arg1>
  typename deduce_result_type<T_arg1>::type
  operator()(T_arg1 _A_a1)
    { return this->functor_.template operator()<typename type_trait<T_type1>::take>
        (static_cast<T_type1>(_A_a1));
    }
  template <class T_arg1,class T_arg2>
  typename deduce_result_type<T_arg1,T_arg2>::type
  operator()(T_arg1 _A_a1,T_arg2 _A_a2)
    { return this->functor_.template operator()<typename type_trait<T_type1>::take,typename type_trait<T_type2>::take>
        (static_cast<T_type1>(_A_a1),static_cast<T_type2>(_A_a2));
    }
  template <class T_arg1,class T_arg2,class T_arg3>
  typename deduce_result_type<T_arg1,T_arg2,T_arg3>::type
  operator()(T_arg1 _A_a1,T_arg2 _A_a2,T_arg3 _A_a3)
    { return this->functor_.template operator()<typename type_trait<T_type1>::take,typename type_trait<T_type2>::take,typename type_trait<T_type3>::take>
        (static_cast<T_type1>(_A_a1),static_cast<T_type2>(_A_a2),static_cast<T_type3>(_A_a3));
    }
  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4>
  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4>::type
  operator()(T_arg1 _A_a1,T_arg2 _A_a2,T_arg3 _A_a3,T_arg4 _A_a4)
    { return this->functor_.template operator()<typename type_trait<T_type1>::take,typename type_trait<T_type2>::take,typename type_trait<T_type3>::take,typename type_trait<T_type4>::take>
        (static_cast<T_type1>(_A_a1),static_cast<T_type2>(_A_a2),static_cast<T_type3>(_A_a3),static_cast<T_type4>(_A_a4));
    }
  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>::type
  operator()(T_arg1 _A_a1,T_arg2 _A_a2,T_arg3 _A_a3,T_arg4 _A_a4,T_arg5 _A_a5)
    { return this->functor_.template operator()<typename type_trait<T_type1>::take,typename type_trait<T_type2>::take,typename type_trait<T_type3>::take,typename type_trait<T_type4>::take,typename type_trait<T_type5>::take>
        (static_cast<T_type1>(_A_a1),static_cast<T_type2>(_A_a2),static_cast<T_type3>(_A_a3),static_cast<T_type4>(_A_a4),static_cast<T_type5>(_A_a5));
    }
  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>::type
  operator()(T_arg1 _A_a1,T_arg2 _A_a2,T_arg3 _A_a3,T_arg4 _A_a4,T_arg5 _A_a5,T_arg6 _A_a6)
    { return this->functor_.template operator()<typename type_trait<T_type1>::take,typename type_trait<T_type2>::take,typename type_trait<T_type3>::take,typename type_trait<T_type4>::take,typename type_trait<T_type5>::take,typename type_trait<T_type6>::take>
        (static_cast<T_type1>(_A_a1),static_cast<T_type2>(_A_a2),static_cast<T_type3>(_A_a3),static_cast<T_type4>(_A_a4),static_cast<T_type5>(_A_a5),static_cast<T_type6>(_A_a6));
    }
  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>::type
  operator()(T_arg1 _A_a1,T_arg2 _A_a2,T_arg3 _A_a3,T_arg4 _A_a4,T_arg5 _A_a5,T_arg6 _A_a6,T_arg7 _A_a7)
    { return this->functor_.template operator()<typename type_trait<T_type1>::take,typename type_trait<T_type2>::take,typename type_trait<T_type3>::take,typename type_trait<T_type4>::take,typename type_trait<T_type5>::take,typename type_trait<T_type6>::take,typename type_trait<T_type7>::take>
        (static_cast<T_type1>(_A_a1),static_cast<T_type2>(_A_a2),static_cast<T_type3>(_A_a3),static_cast<T_type4>(_A_a4),static_cast<T_type5>(_A_a5),static_cast<T_type6>(_A_a6),static_cast<T_type7>(_A_a7));
    }
  explicit retype_functor(typename type_trait<T_functor>::take _A_functor)
    : adapts<T_functor>(_A_functor)
    {}
};
template <class T_functor, class T_type1,class T_type2,class T_type3,class T_type4,class T_type5,class T_type6,class T_type7>
typename retype_functor<T_functor, T_type1,T_type2,T_type3,T_type4,T_type5,T_type6,T_type7>::result_type
retype_functor<T_functor, T_type1,T_type2,T_type3,T_type4,T_type5,T_type6,T_type7>::operator()()
  { return this->functor_(); }
template <class T_action, class T_functor, class T_type1,class T_type2,class T_type3,class T_type4,class T_type5,class T_type6,class T_type7>
void visit_each(const T_action& _A_action,
                const retype_functor<T_functor, T_type1,T_type2,T_type3,T_type4,T_type5,T_type6,T_type7>& _A_target)
{
  visit_each(_A_action, _A_target.functor_);
}
template <class T_return, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
inline retype_functor<slot<T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7>, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7 >
retype(const slot<T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>& _A_functor)
{ return retype_functor<slot<T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7>, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7 >
    (_A_functor); }
template <class T_return>
inline retype_functor<pointer_functor0<T_return> >
retype(const pointer_functor0<T_return>& _A_functor)
{ return retype_functor<pointer_functor0<T_return> >
    (_A_functor); }
template <class T_arg1, class T_return>
inline retype_functor<pointer_functor1<T_arg1, T_return>, T_arg1 >
retype(const pointer_functor1<T_arg1, T_return>& _A_functor)
{ return retype_functor<pointer_functor1<T_arg1, T_return>, T_arg1 >
    (_A_functor); }
template <class T_arg1,class T_arg2, class T_return>
inline retype_functor<pointer_functor2<T_arg1, T_arg2, T_return>, T_arg1,T_arg2 >
retype(const pointer_functor2<T_arg1,T_arg2, T_return>& _A_functor)
{ return retype_functor<pointer_functor2<T_arg1, T_arg2, T_return>, T_arg1,T_arg2 >
    (_A_functor); }
template <class T_arg1,class T_arg2,class T_arg3, class T_return>
inline retype_functor<pointer_functor3<T_arg1, T_arg2, T_arg3, T_return>, T_arg1,T_arg2,T_arg3 >
retype(const pointer_functor3<T_arg1,T_arg2,T_arg3, T_return>& _A_functor)
{ return retype_functor<pointer_functor3<T_arg1, T_arg2, T_arg3, T_return>, T_arg1,T_arg2,T_arg3 >
    (_A_functor); }
template <class T_arg1,class T_arg2,class T_arg3,class T_arg4, class T_return>
inline retype_functor<pointer_functor4<T_arg1, T_arg2, T_arg3, T_arg4, T_return>, T_arg1,T_arg2,T_arg3,T_arg4 >
retype(const pointer_functor4<T_arg1,T_arg2,T_arg3,T_arg4, T_return>& _A_functor)
{ return retype_functor<pointer_functor4<T_arg1, T_arg2, T_arg3, T_arg4, T_return>, T_arg1,T_arg2,T_arg3,T_arg4 >
    (_A_functor); }
template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5, class T_return>
inline retype_functor<pointer_functor5<T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_return>, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5 >
retype(const pointer_functor5<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5, T_return>& _A_functor)
{ return retype_functor<pointer_functor5<T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_return>, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5 >
    (_A_functor); }
template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6, class T_return>
inline retype_functor<pointer_functor6<T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_return>, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6 >
retype(const pointer_functor6<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6, T_return>& _A_functor)
{ return retype_functor<pointer_functor6<T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_return>, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6 >
    (_A_functor); }
template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7, class T_return>
inline retype_functor<pointer_functor7<T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7, T_return>, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7 >
retype(const pointer_functor7<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7, T_return>& _A_functor)
{ return retype_functor<pointer_functor7<T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7, T_return>, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7 >
    (_A_functor); }
template <class T_return, class T_obj>
inline retype_functor<mem_functor0<T_return, T_obj> >
retype(const mem_functor0<T_return, T_obj>& _A_functor)
{ return retype_functor<mem_functor0<T_return, T_obj> >
    (_A_functor); }
template <class T_return, class T_obj, class T_arg1>
inline retype_functor<mem_functor1<T_return, T_obj, T_arg1>, T_arg1 >
retype(const mem_functor1<T_return, T_obj, T_arg1>& _A_functor)
{ return retype_functor<mem_functor1<T_return, T_obj, T_arg1>, T_arg1 >
    (_A_functor); }
template <class T_return, class T_obj, class T_arg1,class T_arg2>
inline retype_functor<mem_functor2<T_return, T_obj, T_arg1, T_arg2>, T_arg1,T_arg2 >
retype(const mem_functor2<T_return, T_obj, T_arg1,T_arg2>& _A_functor)
{ return retype_functor<mem_functor2<T_return, T_obj, T_arg1, T_arg2>, T_arg1,T_arg2 >
    (_A_functor); }
template <class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3>
inline retype_functor<mem_functor3<T_return, T_obj, T_arg1, T_arg2, T_arg3>, T_arg1,T_arg2,T_arg3 >
retype(const mem_functor3<T_return, T_obj, T_arg1,T_arg2,T_arg3>& _A_functor)
{ return retype_functor<mem_functor3<T_return, T_obj, T_arg1, T_arg2, T_arg3>, T_arg1,T_arg2,T_arg3 >
    (_A_functor); }
template <class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3,class T_arg4>
inline retype_functor<mem_functor4<T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4>, T_arg1,T_arg2,T_arg3,T_arg4 >
retype(const mem_functor4<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4>& _A_functor)
{ return retype_functor<mem_functor4<T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4>, T_arg1,T_arg2,T_arg3,T_arg4 >
    (_A_functor); }
template <class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
inline retype_functor<mem_functor5<T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5>, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5 >
retype(const mem_functor5<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>& _A_functor)
{ return retype_functor<mem_functor5<T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5>, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5 >
    (_A_functor); }
template <class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
inline retype_functor<mem_functor6<T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6>, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6 >
retype(const mem_functor6<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>& _A_functor)
{ return retype_functor<mem_functor6<T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6>, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6 >
    (_A_functor); }
template <class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
inline retype_functor<mem_functor7<T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7>, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7 >
retype(const mem_functor7<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>& _A_functor)
{ return retype_functor<mem_functor7<T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7>, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7 >
    (_A_functor); }
template <class T_return, class T_obj>
inline retype_functor<const_mem_functor0<T_return, T_obj> >
retype(const const_mem_functor0<T_return, T_obj>& _A_functor)
{ return retype_functor<const_mem_functor0<T_return, T_obj> >
    (_A_functor); }
template <class T_return, class T_obj, class T_arg1>
inline retype_functor<const_mem_functor1<T_return, T_obj, T_arg1>, T_arg1 >
retype(const const_mem_functor1<T_return, T_obj, T_arg1>& _A_functor)
{ return retype_functor<const_mem_functor1<T_return, T_obj, T_arg1>, T_arg1 >
    (_A_functor); }
template <class T_return, class T_obj, class T_arg1,class T_arg2>
inline retype_functor<const_mem_functor2<T_return, T_obj, T_arg1, T_arg2>, T_arg1,T_arg2 >
retype(const const_mem_functor2<T_return, T_obj, T_arg1,T_arg2>& _A_functor)
{ return retype_functor<const_mem_functor2<T_return, T_obj, T_arg1, T_arg2>, T_arg1,T_arg2 >
    (_A_functor); }
template <class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3>
inline retype_functor<const_mem_functor3<T_return, T_obj, T_arg1, T_arg2, T_arg3>, T_arg1,T_arg2,T_arg3 >
retype(const const_mem_functor3<T_return, T_obj, T_arg1,T_arg2,T_arg3>& _A_functor)
{ return retype_functor<const_mem_functor3<T_return, T_obj, T_arg1, T_arg2, T_arg3>, T_arg1,T_arg2,T_arg3 >
    (_A_functor); }
template <class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3,class T_arg4>
inline retype_functor<const_mem_functor4<T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4>, T_arg1,T_arg2,T_arg3,T_arg4 >
retype(const const_mem_functor4<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4>& _A_functor)
{ return retype_functor<const_mem_functor4<T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4>, T_arg1,T_arg2,T_arg3,T_arg4 >
    (_A_functor); }
template <class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
inline retype_functor<const_mem_functor5<T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5>, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5 >
retype(const const_mem_functor5<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>& _A_functor)
{ return retype_functor<const_mem_functor5<T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5>, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5 >
    (_A_functor); }
template <class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
inline retype_functor<const_mem_functor6<T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6>, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6 >
retype(const const_mem_functor6<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>& _A_functor)
{ return retype_functor<const_mem_functor6<T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6>, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6 >
    (_A_functor); }
template <class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
inline retype_functor<const_mem_functor7<T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7>, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7 >
retype(const const_mem_functor7<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>& _A_functor)
{ return retype_functor<const_mem_functor7<T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7>, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7 >
    (_A_functor); }
template <class T_return, class T_obj>
inline retype_functor<volatile_mem_functor0<T_return, T_obj> >
retype(const volatile_mem_functor0<T_return, T_obj>& _A_functor)
{ return retype_functor<volatile_mem_functor0<T_return, T_obj> >
    (_A_functor); }
template <class T_return, class T_obj, class T_arg1>
inline retype_functor<volatile_mem_functor1<T_return, T_obj, T_arg1>, T_arg1 >
retype(const volatile_mem_functor1<T_return, T_obj, T_arg1>& _A_functor)
{ return retype_functor<volatile_mem_functor1<T_return, T_obj, T_arg1>, T_arg1 >
    (_A_functor); }
template <class T_return, class T_obj, class T_arg1,class T_arg2>
inline retype_functor<volatile_mem_functor2<T_return, T_obj, T_arg1, T_arg2>, T_arg1,T_arg2 >
retype(const volatile_mem_functor2<T_return, T_obj, T_arg1,T_arg2>& _A_functor)
{ return retype_functor<volatile_mem_functor2<T_return, T_obj, T_arg1, T_arg2>, T_arg1,T_arg2 >
    (_A_functor); }
template <class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3>
inline retype_functor<volatile_mem_functor3<T_return, T_obj, T_arg1, T_arg2, T_arg3>, T_arg1,T_arg2,T_arg3 >
retype(const volatile_mem_functor3<T_return, T_obj, T_arg1,T_arg2,T_arg3>& _A_functor)
{ return retype_functor<volatile_mem_functor3<T_return, T_obj, T_arg1, T_arg2, T_arg3>, T_arg1,T_arg2,T_arg3 >
    (_A_functor); }
template <class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3,class T_arg4>
inline retype_functor<volatile_mem_functor4<T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4>, T_arg1,T_arg2,T_arg3,T_arg4 >
retype(const volatile_mem_functor4<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4>& _A_functor)
{ return retype_functor<volatile_mem_functor4<T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4>, T_arg1,T_arg2,T_arg3,T_arg4 >
    (_A_functor); }
template <class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
inline retype_functor<volatile_mem_functor5<T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5>, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5 >
retype(const volatile_mem_functor5<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>& _A_functor)
{ return retype_functor<volatile_mem_functor5<T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5>, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5 >
    (_A_functor); }
template <class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
inline retype_functor<volatile_mem_functor6<T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6>, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6 >
retype(const volatile_mem_functor6<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>& _A_functor)
{ return retype_functor<volatile_mem_functor6<T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6>, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6 >
    (_A_functor); }
template <class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
inline retype_functor<volatile_mem_functor7<T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7>, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7 >
retype(const volatile_mem_functor7<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>& _A_functor)
{ return retype_functor<volatile_mem_functor7<T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7>, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7 >
    (_A_functor); }
template <class T_return, class T_obj>
inline retype_functor<const_volatile_mem_functor0<T_return, T_obj> >
retype(const const_volatile_mem_functor0<T_return, T_obj>& _A_functor)
{ return retype_functor<const_volatile_mem_functor0<T_return, T_obj> >
    (_A_functor); }
template <class T_return, class T_obj, class T_arg1>
inline retype_functor<const_volatile_mem_functor1<T_return, T_obj, T_arg1>, T_arg1 >
retype(const const_volatile_mem_functor1<T_return, T_obj, T_arg1>& _A_functor)
{ return retype_functor<const_volatile_mem_functor1<T_return, T_obj, T_arg1>, T_arg1 >
    (_A_functor); }
template <class T_return, class T_obj, class T_arg1,class T_arg2>
inline retype_functor<const_volatile_mem_functor2<T_return, T_obj, T_arg1, T_arg2>, T_arg1,T_arg2 >
retype(const const_volatile_mem_functor2<T_return, T_obj, T_arg1,T_arg2>& _A_functor)
{ return retype_functor<const_volatile_mem_functor2<T_return, T_obj, T_arg1, T_arg2>, T_arg1,T_arg2 >
    (_A_functor); }
template <class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3>
inline retype_functor<const_volatile_mem_functor3<T_return, T_obj, T_arg1, T_arg2, T_arg3>, T_arg1,T_arg2,T_arg3 >
retype(const const_volatile_mem_functor3<T_return, T_obj, T_arg1,T_arg2,T_arg3>& _A_functor)
{ return retype_functor<const_volatile_mem_functor3<T_return, T_obj, T_arg1, T_arg2, T_arg3>, T_arg1,T_arg2,T_arg3 >
    (_A_functor); }
template <class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3,class T_arg4>
inline retype_functor<const_volatile_mem_functor4<T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4>, T_arg1,T_arg2,T_arg3,T_arg4 >
retype(const const_volatile_mem_functor4<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4>& _A_functor)
{ return retype_functor<const_volatile_mem_functor4<T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4>, T_arg1,T_arg2,T_arg3,T_arg4 >
    (_A_functor); }
template <class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
inline retype_functor<const_volatile_mem_functor5<T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5>, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5 >
retype(const const_volatile_mem_functor5<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>& _A_functor)
{ return retype_functor<const_volatile_mem_functor5<T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5>, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5 >
    (_A_functor); }
template <class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
inline retype_functor<const_volatile_mem_functor6<T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6>, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6 >
retype(const const_volatile_mem_functor6<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>& _A_functor)
{ return retype_functor<const_volatile_mem_functor6<T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6>, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6 >
    (_A_functor); }
template <class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
inline retype_functor<const_volatile_mem_functor7<T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7>, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7 >
retype(const const_volatile_mem_functor7<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>& _A_functor)
{ return retype_functor<const_volatile_mem_functor7<T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7>, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7 >
    (_A_functor); }
template <class T_return, class T_obj>
inline retype_functor<bound_mem_functor0<T_return, T_obj> >
retype(const bound_mem_functor0<T_return, T_obj>& _A_functor)
{ return retype_functor<bound_mem_functor0<T_return, T_obj> >
    (_A_functor); }
template <class T_return, class T_obj, class T_arg1>
inline retype_functor<bound_mem_functor1<T_return, T_obj, T_arg1>, T_arg1 >
retype(const bound_mem_functor1<T_return, T_obj, T_arg1>& _A_functor)
{ return retype_functor<bound_mem_functor1<T_return, T_obj, T_arg1>, T_arg1 >
    (_A_functor); }
template <class T_return, class T_obj, class T_arg1,class T_arg2>
inline retype_functor<bound_mem_functor2<T_return, T_obj, T_arg1, T_arg2>, T_arg1,T_arg2 >
retype(const bound_mem_functor2<T_return, T_obj, T_arg1,T_arg2>& _A_functor)
{ return retype_functor<bound_mem_functor2<T_return, T_obj, T_arg1, T_arg2>, T_arg1,T_arg2 >
    (_A_functor); }
template <class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3>
inline retype_functor<bound_mem_functor3<T_return, T_obj, T_arg1, T_arg2, T_arg3>, T_arg1,T_arg2,T_arg3 >
retype(const bound_mem_functor3<T_return, T_obj, T_arg1,T_arg2,T_arg3>& _A_functor)
{ return retype_functor<bound_mem_functor3<T_return, T_obj, T_arg1, T_arg2, T_arg3>, T_arg1,T_arg2,T_arg3 >
    (_A_functor); }
template <class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3,class T_arg4>
inline retype_functor<bound_mem_functor4<T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4>, T_arg1,T_arg2,T_arg3,T_arg4 >
retype(const bound_mem_functor4<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4>& _A_functor)
{ return retype_functor<bound_mem_functor4<T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4>, T_arg1,T_arg2,T_arg3,T_arg4 >
    (_A_functor); }
template <class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
inline retype_functor<bound_mem_functor5<T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5>, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5 >
retype(const bound_mem_functor5<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>& _A_functor)
{ return retype_functor<bound_mem_functor5<T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5>, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5 >
    (_A_functor); }
template <class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
inline retype_functor<bound_mem_functor6<T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6>, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6 >
retype(const bound_mem_functor6<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>& _A_functor)
{ return retype_functor<bound_mem_functor6<T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6>, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6 >
    (_A_functor); }
template <class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
inline retype_functor<bound_mem_functor7<T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7>, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7 >
retype(const bound_mem_functor7<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>& _A_functor)
{ return retype_functor<bound_mem_functor7<T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7>, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7 >
    (_A_functor); }
template <class T_return, class T_obj>
inline retype_functor<bound_const_mem_functor0<T_return, T_obj> >
retype(const bound_const_mem_functor0<T_return, T_obj>& _A_functor)
{ return retype_functor<bound_const_mem_functor0<T_return, T_obj> >
    (_A_functor); }
template <class T_return, class T_obj, class T_arg1>
inline retype_functor<bound_const_mem_functor1<T_return, T_obj, T_arg1>, T_arg1 >
retype(const bound_const_mem_functor1<T_return, T_obj, T_arg1>& _A_functor)
{ return retype_functor<bound_const_mem_functor1<T_return, T_obj, T_arg1>, T_arg1 >
    (_A_functor); }
template <class T_return, class T_obj, class T_arg1,class T_arg2>
inline retype_functor<bound_const_mem_functor2<T_return, T_obj, T_arg1, T_arg2>, T_arg1,T_arg2 >
retype(const bound_const_mem_functor2<T_return, T_obj, T_arg1,T_arg2>& _A_functor)
{ return retype_functor<bound_const_mem_functor2<T_return, T_obj, T_arg1, T_arg2>, T_arg1,T_arg2 >
    (_A_functor); }
template <class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3>
inline retype_functor<bound_const_mem_functor3<T_return, T_obj, T_arg1, T_arg2, T_arg3>, T_arg1,T_arg2,T_arg3 >
retype(const bound_const_mem_functor3<T_return, T_obj, T_arg1,T_arg2,T_arg3>& _A_functor)
{ return retype_functor<bound_const_mem_functor3<T_return, T_obj, T_arg1, T_arg2, T_arg3>, T_arg1,T_arg2,T_arg3 >
    (_A_functor); }
template <class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3,class T_arg4>
inline retype_functor<bound_const_mem_functor4<T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4>, T_arg1,T_arg2,T_arg3,T_arg4 >
retype(const bound_const_mem_functor4<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4>& _A_functor)
{ return retype_functor<bound_const_mem_functor4<T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4>, T_arg1,T_arg2,T_arg3,T_arg4 >
    (_A_functor); }
template <class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
inline retype_functor<bound_const_mem_functor5<T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5>, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5 >
retype(const bound_const_mem_functor5<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>& _A_functor)
{ return retype_functor<bound_const_mem_functor5<T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5>, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5 >
    (_A_functor); }
template <class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
inline retype_functor<bound_const_mem_functor6<T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6>, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6 >
retype(const bound_const_mem_functor6<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>& _A_functor)
{ return retype_functor<bound_const_mem_functor6<T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6>, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6 >
    (_A_functor); }
template <class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
inline retype_functor<bound_const_mem_functor7<T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7>, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7 >
retype(const bound_const_mem_functor7<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>& _A_functor)
{ return retype_functor<bound_const_mem_functor7<T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7>, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7 >
    (_A_functor); }
template <class T_return, class T_obj>
inline retype_functor<bound_volatile_mem_functor0<T_return, T_obj> >
retype(const bound_volatile_mem_functor0<T_return, T_obj>& _A_functor)
{ return retype_functor<bound_volatile_mem_functor0<T_return, T_obj> >
    (_A_functor); }
template <class T_return, class T_obj, class T_arg1>
inline retype_functor<bound_volatile_mem_functor1<T_return, T_obj, T_arg1>, T_arg1 >
retype(const bound_volatile_mem_functor1<T_return, T_obj, T_arg1>& _A_functor)
{ return retype_functor<bound_volatile_mem_functor1<T_return, T_obj, T_arg1>, T_arg1 >
    (_A_functor); }
template <class T_return, class T_obj, class T_arg1,class T_arg2>
inline retype_functor<bound_volatile_mem_functor2<T_return, T_obj, T_arg1, T_arg2>, T_arg1,T_arg2 >
retype(const bound_volatile_mem_functor2<T_return, T_obj, T_arg1,T_arg2>& _A_functor)
{ return retype_functor<bound_volatile_mem_functor2<T_return, T_obj, T_arg1, T_arg2>, T_arg1,T_arg2 >
    (_A_functor); }
template <class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3>
inline retype_functor<bound_volatile_mem_functor3<T_return, T_obj, T_arg1, T_arg2, T_arg3>, T_arg1,T_arg2,T_arg3 >
retype(const bound_volatile_mem_functor3<T_return, T_obj, T_arg1,T_arg2,T_arg3>& _A_functor)
{ return retype_functor<bound_volatile_mem_functor3<T_return, T_obj, T_arg1, T_arg2, T_arg3>, T_arg1,T_arg2,T_arg3 >
    (_A_functor); }
template <class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3,class T_arg4>
inline retype_functor<bound_volatile_mem_functor4<T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4>, T_arg1,T_arg2,T_arg3,T_arg4 >
retype(const bound_volatile_mem_functor4<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4>& _A_functor)
{ return retype_functor<bound_volatile_mem_functor4<T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4>, T_arg1,T_arg2,T_arg3,T_arg4 >
    (_A_functor); }
template <class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
inline retype_functor<bound_volatile_mem_functor5<T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5>, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5 >
retype(const bound_volatile_mem_functor5<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>& _A_functor)
{ return retype_functor<bound_volatile_mem_functor5<T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5>, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5 >
    (_A_functor); }
template <class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
inline retype_functor<bound_volatile_mem_functor6<T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6>, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6 >
retype(const bound_volatile_mem_functor6<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>& _A_functor)
{ return retype_functor<bound_volatile_mem_functor6<T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6>, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6 >
    (_A_functor); }
template <class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
inline retype_functor<bound_volatile_mem_functor7<T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7>, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7 >
retype(const bound_volatile_mem_functor7<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>& _A_functor)
{ return retype_functor<bound_volatile_mem_functor7<T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7>, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7 >
    (_A_functor); }
template <class T_return, class T_obj>
inline retype_functor<bound_const_volatile_mem_functor0<T_return, T_obj> >
retype(const bound_const_volatile_mem_functor0<T_return, T_obj>& _A_functor)
{ return retype_functor<bound_const_volatile_mem_functor0<T_return, T_obj> >
    (_A_functor); }
template <class T_return, class T_obj, class T_arg1>
inline retype_functor<bound_const_volatile_mem_functor1<T_return, T_obj, T_arg1>, T_arg1 >
retype(const bound_const_volatile_mem_functor1<T_return, T_obj, T_arg1>& _A_functor)
{ return retype_functor<bound_const_volatile_mem_functor1<T_return, T_obj, T_arg1>, T_arg1 >
    (_A_functor); }
template <class T_return, class T_obj, class T_arg1,class T_arg2>
inline retype_functor<bound_const_volatile_mem_functor2<T_return, T_obj, T_arg1, T_arg2>, T_arg1,T_arg2 >
retype(const bound_const_volatile_mem_functor2<T_return, T_obj, T_arg1,T_arg2>& _A_functor)
{ return retype_functor<bound_const_volatile_mem_functor2<T_return, T_obj, T_arg1, T_arg2>, T_arg1,T_arg2 >
    (_A_functor); }
template <class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3>
inline retype_functor<bound_const_volatile_mem_functor3<T_return, T_obj, T_arg1, T_arg2, T_arg3>, T_arg1,T_arg2,T_arg3 >
retype(const bound_const_volatile_mem_functor3<T_return, T_obj, T_arg1,T_arg2,T_arg3>& _A_functor)
{ return retype_functor<bound_const_volatile_mem_functor3<T_return, T_obj, T_arg1, T_arg2, T_arg3>, T_arg1,T_arg2,T_arg3 >
    (_A_functor); }
template <class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3,class T_arg4>
inline retype_functor<bound_const_volatile_mem_functor4<T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4>, T_arg1,T_arg2,T_arg3,T_arg4 >
retype(const bound_const_volatile_mem_functor4<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4>& _A_functor)
{ return retype_functor<bound_const_volatile_mem_functor4<T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4>, T_arg1,T_arg2,T_arg3,T_arg4 >
    (_A_functor); }
template <class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
inline retype_functor<bound_const_volatile_mem_functor5<T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5>, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5 >
retype(const bound_const_volatile_mem_functor5<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>& _A_functor)
{ return retype_functor<bound_const_volatile_mem_functor5<T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5>, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5 >
    (_A_functor); }
template <class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
inline retype_functor<bound_const_volatile_mem_functor6<T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6>, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6 >
retype(const bound_const_volatile_mem_functor6<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>& _A_functor)
{ return retype_functor<bound_const_volatile_mem_functor6<T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6>, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6 >
    (_A_functor); }
template <class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
inline retype_functor<bound_const_volatile_mem_functor7<T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7>, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7 >
retype(const bound_const_volatile_mem_functor7<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>& _A_functor)
{ return retype_functor<bound_const_volatile_mem_functor7<T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7>, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7 >
    (_A_functor); }
}
namespace sigc {
template <class T_setter, class T_getter>
struct compose1_functor : public adapts<T_setter>
{
  typedef typename adapts<T_setter>::adaptor_type adaptor_type;
  typedef T_setter setter_type;
  typedef T_getter getter_type;
  template <class T_arg1 = void,class T_arg2 = void,class T_arg3 = void,class T_arg4 = void,class T_arg5 = void,class T_arg6 = void,class T_arg7 = void>
  struct deduce_result_type
    { typedef typename adaptor_type::template deduce_result_type<
        typename sigc::deduce_result_type<T_getter, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>::type
          >::type type; };
  typedef typename adaptor_type::result_type result_type;
  result_type
  operator()();
  template <class T_arg1>
  typename deduce_result_type<T_arg1>::type
  operator()(T_arg1 _A_a1)
    { return this->functor_.template operator()<typename sigc::deduce_result_type<T_getter, T_arg1>::type>
        (get_(_A_a1));
    }
  template <class T_arg1,class T_arg2>
  typename deduce_result_type<T_arg1,T_arg2>::type
  operator()(T_arg1 _A_a1,T_arg2 _A_a2)
    { return this->functor_.template operator()<typename sigc::deduce_result_type<T_getter, T_arg1,T_arg2>::type>
        (get_(_A_a1,_A_a2));
    }
  template <class T_arg1,class T_arg2,class T_arg3>
  typename deduce_result_type<T_arg1,T_arg2,T_arg3>::type
  operator()(T_arg1 _A_a1,T_arg2 _A_a2,T_arg3 _A_a3)
    { return this->functor_.template operator()<typename sigc::deduce_result_type<T_getter, T_arg1,T_arg2,T_arg3>::type>
        (get_(_A_a1,_A_a2,_A_a3));
    }
  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4>
  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4>::type
  operator()(T_arg1 _A_a1,T_arg2 _A_a2,T_arg3 _A_a3,T_arg4 _A_a4)
    { return this->functor_.template operator()<typename sigc::deduce_result_type<T_getter, T_arg1,T_arg2,T_arg3,T_arg4>::type>
        (get_(_A_a1,_A_a2,_A_a3,_A_a4));
    }
  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>::type
  operator()(T_arg1 _A_a1,T_arg2 _A_a2,T_arg3 _A_a3,T_arg4 _A_a4,T_arg5 _A_a5)
    { return this->functor_.template operator()<typename sigc::deduce_result_type<T_getter, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>::type>
        (get_(_A_a1,_A_a2,_A_a3,_A_a4,_A_a5));
    }
  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>::type
  operator()(T_arg1 _A_a1,T_arg2 _A_a2,T_arg3 _A_a3,T_arg4 _A_a4,T_arg5 _A_a5,T_arg6 _A_a6)
    { return this->functor_.template operator()<typename sigc::deduce_result_type<T_getter, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>::type>
        (get_(_A_a1,_A_a2,_A_a3,_A_a4,_A_a5,_A_a6));
    }
  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>::type
  operator()(T_arg1 _A_a1,T_arg2 _A_a2,T_arg3 _A_a3,T_arg4 _A_a4,T_arg5 _A_a5,T_arg6 _A_a6,T_arg7 _A_a7)
    { return this->functor_.template operator()<typename sigc::deduce_result_type<T_getter, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>::type>
        (get_(_A_a1,_A_a2,_A_a3,_A_a4,_A_a5,_A_a6,_A_a7));
    }
  compose1_functor(const T_setter& _A_setter, const T_getter& _A_getter)
    : adapts<T_setter>(_A_setter), get_(_A_getter)
    {}
  getter_type get_;
};
template <class T_setter, class T_getter>
typename compose1_functor<T_setter, T_getter>::result_type
compose1_functor<T_setter, T_getter>::operator()()
  { return this->functor_(get_()); }
template <class T_setter, class T_getter1, class T_getter2>
struct compose2_functor : public adapts<T_setter>
{
  typedef typename adapts<T_setter>::adaptor_type adaptor_type;
  typedef T_setter setter_type;
  typedef T_getter1 getter1_type;
  typedef T_getter2 getter2_type;
  template <class T_arg1=void,class T_arg2=void,class T_arg3=void,class T_arg4=void,class T_arg5=void,class T_arg6=void,class T_arg7=void>
  struct deduce_result_type
    { typedef typename adaptor_type::template deduce_result_type<
        typename sigc::deduce_result_type<T_getter1, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>::type,
        typename sigc::deduce_result_type<T_getter2, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>::type
          >::type result_type; };
  typedef typename adaptor_type::result_type result_type;
  result_type
  operator()();
  template <class T_arg1>
  typename deduce_result_type<T_arg1>::type
  operator()(T_arg1 _A_a1)
    { return this->functor_.template operator()<typename sigc::deduce_result_type<T_getter1, T_arg1>::type,
                                                         typename sigc::deduce_result_type<T_getter2, T_arg1>::type>
        (get1_(_A_a1), get2_(_A_a1));
    }
  template <class T_arg1,class T_arg2>
  typename deduce_result_type<T_arg1,T_arg2>::type
  operator()(T_arg1 _A_a1,T_arg2 _A_a2)
    { return this->functor_.template operator()<typename sigc::deduce_result_type<T_getter1, T_arg1,T_arg2>::type,
                                                         typename sigc::deduce_result_type<T_getter2, T_arg1,T_arg2>::type>
        (get1_(_A_a1,_A_a2), get2_(_A_a1,_A_a2));
    }
  template <class T_arg1,class T_arg2,class T_arg3>
  typename deduce_result_type<T_arg1,T_arg2,T_arg3>::type
  operator()(T_arg1 _A_a1,T_arg2 _A_a2,T_arg3 _A_a3)
    { return this->functor_.template operator()<typename sigc::deduce_result_type<T_getter1, T_arg1,T_arg2,T_arg3>::type,
                                                         typename sigc::deduce_result_type<T_getter2, T_arg1,T_arg2,T_arg3>::type>
        (get1_(_A_a1,_A_a2,_A_a3), get2_(_A_a1,_A_a2,_A_a3));
    }
  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4>
  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4>::type
  operator()(T_arg1 _A_a1,T_arg2 _A_a2,T_arg3 _A_a3,T_arg4 _A_a4)
    { return this->functor_.template operator()<typename sigc::deduce_result_type<T_getter1, T_arg1,T_arg2,T_arg3,T_arg4>::type,
                                                         typename sigc::deduce_result_type<T_getter2, T_arg1,T_arg2,T_arg3,T_arg4>::type>
        (get1_(_A_a1,_A_a2,_A_a3,_A_a4), get2_(_A_a1,_A_a2,_A_a3,_A_a4));
    }
  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>::type
  operator()(T_arg1 _A_a1,T_arg2 _A_a2,T_arg3 _A_a3,T_arg4 _A_a4,T_arg5 _A_a5)
    { return this->functor_.template operator()<typename sigc::deduce_result_type<T_getter1, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>::type,
                                                         typename sigc::deduce_result_type<T_getter2, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>::type>
        (get1_(_A_a1,_A_a2,_A_a3,_A_a4,_A_a5), get2_(_A_a1,_A_a2,_A_a3,_A_a4,_A_a5));
    }
  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>::type
  operator()(T_arg1 _A_a1,T_arg2 _A_a2,T_arg3 _A_a3,T_arg4 _A_a4,T_arg5 _A_a5,T_arg6 _A_a6)
    { return this->functor_.template operator()<typename sigc::deduce_result_type<T_getter1, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>::type,
                                                         typename sigc::deduce_result_type<T_getter2, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>::type>
        (get1_(_A_a1,_A_a2,_A_a3,_A_a4,_A_a5,_A_a6), get2_(_A_a1,_A_a2,_A_a3,_A_a4,_A_a5,_A_a6));
    }
  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>::type
  operator()(T_arg1 _A_a1,T_arg2 _A_a2,T_arg3 _A_a3,T_arg4 _A_a4,T_arg5 _A_a5,T_arg6 _A_a6,T_arg7 _A_a7)
    { return this->functor_.template operator()<typename sigc::deduce_result_type<T_getter1, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>::type,
                                                         typename sigc::deduce_result_type<T_getter2, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>::type>
        (get1_(_A_a1,_A_a2,_A_a3,_A_a4,_A_a5,_A_a6,_A_a7), get2_(_A_a1,_A_a2,_A_a3,_A_a4,_A_a5,_A_a6,_A_a7));
    }
  compose2_functor(const T_setter& _A_setter,
                   const T_getter1& _A_getter1,
                   const T_getter2& _A_getter2)
    : adapts<T_setter>(_A_setter), get1_(_A_getter1), get2_(_A_getter2)
    {}
  getter1_type get1_;
  getter2_type get2_;
};
template <class T_setter, class T_getter1, class T_getter2>
typename compose2_functor<T_setter, T_getter1, T_getter2>::result_type
compose2_functor<T_setter, T_getter1, T_getter2>::operator()()
  { return this->functor_(get1_(), get2_()); }
template <class T_action, class T_setter, class T_getter>
void visit_each(const T_action& _A_action,
                const compose1_functor<T_setter, T_getter>& _A_target)
{
  typedef compose1_functor<T_setter, T_getter> type_functor;
  typedef typename type_functor::setter_type type_functor1;
  visit_each<T_action, type_functor1>(_A_action, _A_target.functor_);
  typedef typename type_functor::getter_type type_functor_getter;
  visit_each<T_action, type_functor_getter>(_A_action, _A_target.get_);
}
template <class T_action, class T_setter, class T_getter1, class T_getter2>
void visit_each(const T_action& _A_action,
                const compose2_functor<T_setter, T_getter1, T_getter2>& _A_target)
{
  typedef compose2_functor<T_setter, T_getter1, T_getter2> type_functor;
  typedef typename type_functor::setter_type type_functor1;
  visit_each<T_action, type_functor1>(_A_action, _A_target.functor_);
  typedef typename type_functor::getter1_type type_functor_getter1;
  visit_each<T_action, type_functor_getter1>(_A_action, _A_target.get1_);
  typedef typename type_functor::getter2_type type_functor_getter2;
  visit_each<T_action, type_functor_getter2>(_A_action, _A_target.get2_);
}
template <class T_setter, class T_getter>
inline compose1_functor<T_setter, T_getter>
compose(const T_setter& _A_setter, const T_getter& _A_getter)
  { return compose1_functor<T_setter, T_getter>(_A_setter, _A_getter); }
template <class T_setter, class T_getter1, class T_getter2>
inline compose2_functor<T_setter, T_getter1, T_getter2>
compose(const T_setter& _A_setter, const T_getter1& _A_getter1, const T_getter2& _A_getter2)
  { return compose2_functor<T_setter, T_getter1, T_getter2>(_A_setter, _A_getter1, _A_getter2); }
}
namespace sigc {
template <class T_functor, class T_catcher, class T_return = typename adapts<T_functor>::result_type>
struct exception_catch_functor : public adapts<T_functor>
{
  typedef typename adapts<T_functor>::adaptor_type adaptor_type;
  template <class T_arg1=void,class T_arg2=void,class T_arg3=void,class T_arg4=void,class T_arg5=void,class T_arg6=void,class T_arg7=void>
  struct deduce_result_type
    { typedef typename adaptor_type::template deduce_result_type<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass,typename type_trait<T_arg6>::pass,typename type_trait<T_arg7>::pass>::type type; };
  typedef T_return result_type;
  result_type
  operator()();
  template <class T_arg1>
  typename deduce_result_type<T_arg1>::type
  operator()(T_arg1 _A_a1)
    {
      try
        {
          return this->functor_.template operator()<typename type_trait<T_arg1>::pass>
            (_A_a1);
        }
      catch (...)
        { return catcher_(); }
    }
  template <class T_arg1,class T_arg2>
  typename deduce_result_type<T_arg1,T_arg2>::type
  operator()(T_arg1 _A_a1,T_arg2 _A_a2)
    {
      try
        {
          return this->functor_.template operator()<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass>
            (_A_a1,_A_a2);
        }
      catch (...)
        { return catcher_(); }
    }
  template <class T_arg1,class T_arg2,class T_arg3>
  typename deduce_result_type<T_arg1,T_arg2,T_arg3>::type
  operator()(T_arg1 _A_a1,T_arg2 _A_a2,T_arg3 _A_a3)
    {
      try
        {
          return this->functor_.template operator()<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass>
            (_A_a1,_A_a2,_A_a3);
        }
      catch (...)
        { return catcher_(); }
    }
  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4>
  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4>::type
  operator()(T_arg1 _A_a1,T_arg2 _A_a2,T_arg3 _A_a3,T_arg4 _A_a4)
    {
      try
        {
          return this->functor_.template operator()<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass>
            (_A_a1,_A_a2,_A_a3,_A_a4);
        }
      catch (...)
        { return catcher_(); }
    }
  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>::type
  operator()(T_arg1 _A_a1,T_arg2 _A_a2,T_arg3 _A_a3,T_arg4 _A_a4,T_arg5 _A_a5)
    {
      try
        {
          return this->functor_.template operator()<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass>
            (_A_a1,_A_a2,_A_a3,_A_a4,_A_a5);
        }
      catch (...)
        { return catcher_(); }
    }
  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>::type
  operator()(T_arg1 _A_a1,T_arg2 _A_a2,T_arg3 _A_a3,T_arg4 _A_a4,T_arg5 _A_a5,T_arg6 _A_a6)
    {
      try
        {
          return this->functor_.template operator()<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass,typename type_trait<T_arg6>::pass>
            (_A_a1,_A_a2,_A_a3,_A_a4,_A_a5,_A_a6);
        }
      catch (...)
        { return catcher_(); }
    }
  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>::type
  operator()(T_arg1 _A_a1,T_arg2 _A_a2,T_arg3 _A_a3,T_arg4 _A_a4,T_arg5 _A_a5,T_arg6 _A_a6,T_arg7 _A_a7)
    {
      try
        {
          return this->functor_.template operator()<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass,typename type_trait<T_arg6>::pass,typename type_trait<T_arg7>::pass>
            (_A_a1,_A_a2,_A_a3,_A_a4,_A_a5,_A_a6,_A_a7);
        }
      catch (...)
        { return catcher_(); }
    }
  exception_catch_functor(const T_functor& _A_func,
                          const T_catcher& _A_catcher)
    : adapts<T_functor>(_A_func), catcher_(_A_catcher)
    {}
  T_catcher catcher_;
};
template <class T_functor, class T_catcher, class T_return>
typename exception_catch_functor<T_functor, T_catcher, T_return>::result_type
exception_catch_functor<T_functor, T_catcher, T_return>::operator()()
  {
    try
      { return this->functor_(); }
    catch (...)
      { return catcher_(); }
  }
template <class T_functor, class T_catcher>
struct exception_catch_functor<T_functor, T_catcher, void> : public adapts<T_functor>
{
  typedef void result_type;
  typedef typename adapts<T_functor>::adaptor_type adaptor_type;
  void
  operator()();
  template <class T_arg1>
  typename deduce_result_type<T_arg1>::type
  operator()(T_arg1 _A_a1)
    {
      try
        {
          return this->functor_.template operator()<typename type_trait<T_arg1>::pass>
            (_A_a1);
        }
      catch (...)
        { return catcher_(); }
    }
  template <class T_arg1,class T_arg2>
  typename deduce_result_type<T_arg1,T_arg2>::type
  operator()(T_arg1 _A_a1,T_arg2 _A_a2)
    {
      try
        {
          return this->functor_.template operator()<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass>
            (_A_a1,_A_a2);
        }
      catch (...)
        { return catcher_(); }
    }
  template <class T_arg1,class T_arg2,class T_arg3>
  typename deduce_result_type<T_arg1,T_arg2,T_arg3>::type
  operator()(T_arg1 _A_a1,T_arg2 _A_a2,T_arg3 _A_a3)
    {
      try
        {
          return this->functor_.template operator()<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass>
            (_A_a1,_A_a2,_A_a3);
        }
      catch (...)
        { return catcher_(); }
    }
  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4>
  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4>::type
  operator()(T_arg1 _A_a1,T_arg2 _A_a2,T_arg3 _A_a3,T_arg4 _A_a4)
    {
      try
        {
          return this->functor_.template operator()<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass>
            (_A_a1,_A_a2,_A_a3,_A_a4);
        }
      catch (...)
        { return catcher_(); }
    }
  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>::type
  operator()(T_arg1 _A_a1,T_arg2 _A_a2,T_arg3 _A_a3,T_arg4 _A_a4,T_arg5 _A_a5)
    {
      try
        {
          return this->functor_.template operator()<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass>
            (_A_a1,_A_a2,_A_a3,_A_a4,_A_a5);
        }
      catch (...)
        { return catcher_(); }
    }
  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>::type
  operator()(T_arg1 _A_a1,T_arg2 _A_a2,T_arg3 _A_a3,T_arg4 _A_a4,T_arg5 _A_a5,T_arg6 _A_a6)
    {
      try
        {
          return this->functor_.template operator()<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass,typename type_trait<T_arg6>::pass>
            (_A_a1,_A_a2,_A_a3,_A_a4,_A_a5,_A_a6);
        }
      catch (...)
        { return catcher_(); }
    }
  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>::type
  operator()(T_arg1 _A_a1,T_arg2 _A_a2,T_arg3 _A_a3,T_arg4 _A_a4,T_arg5 _A_a5,T_arg6 _A_a6,T_arg7 _A_a7)
    {
      try
        {
          return this->functor_.template operator()<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass,typename type_trait<T_arg6>::pass,typename type_trait<T_arg7>::pass>
            (_A_a1,_A_a2,_A_a3,_A_a4,_A_a5,_A_a6,_A_a7);
        }
      catch (...)
        { return catcher_(); }
    }
  exception_catch_functor() {}
  exception_catch_functor(const T_functor& _A_func,
                          const T_catcher& _A_catcher)
    : adapts<T_functor>(_A_func), catcher_(_A_catcher)
    {}
  ~exception_catch_functor() {}
    T_catcher catcher_;
};
template <class T_functor, class T_catcher>
void exception_catch_functor<T_functor, T_catcher, void>::operator()()
  {
    try
      { this->functor_(); }
    catch (...)
      { this->catcher_(); }
  }
template <class T_action, class T_functor, class T_catcher, class T_return>
void visit_each(const T_action& _A_action,
                const exception_catch_functor<T_functor, T_catcher, T_return>& _A_target)
{
  visit_each(_A_action, _A_target.functor_);
  visit_each(_A_action, _A_target.catcher_);
}
template <class T_functor, class T_catcher>
inline exception_catch_functor<T_functor, T_catcher>
exception_catch(const T_functor& _A_func, const T_catcher& _A_catcher)
  { return exception_catch_functor<T_functor, T_catcher>(_A_func, _A_catcher); }
}
namespace sigc {
struct lambda_base : public adaptor_base {};
template <class T_type> struct lambda;
namespace internal {
template <class T_type, bool I_islambda = is_base_and_derived<lambda_base, T_type>::value> struct lambda_core;
template <class T_type>
struct lambda_core<T_type, true> : public lambda_base
{
  template <class T_arg1=void,class T_arg2=void,class T_arg3=void,class T_arg4=void,class T_arg5=void,class T_arg6=void,class T_arg7=void>
  struct deduce_result_type
    { typedef typename T_type::template deduce_result_type<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass,typename type_trait<T_arg6>::pass,typename type_trait<T_arg7>::pass>::type type; };
  typedef typename T_type::result_type result_type;
  typedef T_type lambda_type;
  result_type
  operator()() const;
  template <class T_arg1>
  typename deduce_result_type<T_arg1>::type
  operator ()(T_arg1 _A_1) const
    { return value_.template operator()<typename type_trait<T_arg1>::pass>
             (_A_1);
    }
  template <class T_arg1,class T_arg2>
  typename deduce_result_type<T_arg1,T_arg2>::type
  operator ()(T_arg1 _A_1,T_arg2 _A_2) const
    { return value_.template operator()<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass>
             (_A_1,_A_2);
    }
  template <class T_arg1,class T_arg2,class T_arg3>
  typename deduce_result_type<T_arg1,T_arg2,T_arg3>::type
  operator ()(T_arg1 _A_1,T_arg2 _A_2,T_arg3 _A_3) const
    { return value_.template operator()<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass>
             (_A_1,_A_2,_A_3);
    }
  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4>
  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4>::type
  operator ()(T_arg1 _A_1,T_arg2 _A_2,T_arg3 _A_3,T_arg4 _A_4) const
    { return value_.template operator()<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass>
             (_A_1,_A_2,_A_3,_A_4);
    }
  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>::type
  operator ()(T_arg1 _A_1,T_arg2 _A_2,T_arg3 _A_3,T_arg4 _A_4,T_arg5 _A_5) const
    { return value_.template operator()<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass>
             (_A_1,_A_2,_A_3,_A_4,_A_5);
    }
  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>::type
  operator ()(T_arg1 _A_1,T_arg2 _A_2,T_arg3 _A_3,T_arg4 _A_4,T_arg5 _A_5,T_arg6 _A_6) const
    { return value_.template operator()<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass,typename type_trait<T_arg6>::pass>
             (_A_1,_A_2,_A_3,_A_4,_A_5,_A_6);
    }
  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>::type
  operator ()(T_arg1 _A_1,T_arg2 _A_2,T_arg3 _A_3,T_arg4 _A_4,T_arg5 _A_5,T_arg6 _A_6,T_arg7 _A_7) const
    { return value_.template operator()<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass,typename type_trait<T_arg6>::pass,typename type_trait<T_arg7>::pass>
             (_A_1,_A_2,_A_3,_A_4,_A_5,_A_6,_A_7);
    }
  lambda_core() {}
  explicit lambda_core(const T_type& v)
    : value_(v) {}
  T_type value_;
};
template <class T_type>
typename lambda_core<T_type, true>::result_type
lambda_core<T_type, true>::operator()() const
  { return value_(); }
template <class T_type>
struct lambda_core<T_type, false> : public lambda_base
{
  template <class T_arg1=void,class T_arg2=void,class T_arg3=void,class T_arg4=void,class T_arg5=void,class T_arg6=void,class T_arg7=void>
  struct deduce_result_type
    { typedef T_type type; };
  typedef T_type result_type;
  typedef lambda<T_type> lambda_type;
  result_type operator()() const;
  template <class T_arg1>
  result_type operator ()(T_arg1) const
    { return value_; }
  template <class T_arg1,class T_arg2>
  result_type operator ()(T_arg1,T_arg2) const
    { return value_; }
  template <class T_arg1,class T_arg2,class T_arg3>
  result_type operator ()(T_arg1,T_arg2,T_arg3) const
    { return value_; }
  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4>
  result_type operator ()(T_arg1,T_arg2,T_arg3,T_arg4) const
    { return value_; }
  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
  result_type operator ()(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5) const
    { return value_; }
  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
  result_type operator ()(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6) const
    { return value_; }
  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
  result_type operator ()(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7) const
    { return value_; }
  explicit lambda_core(typename type_trait<T_type>::take v)
    : value_(v) {}
  T_type value_;
};
template <class T_type>
typename lambda_core<T_type, false>::result_type lambda_core<T_type, false>::operator()() const
  { return value_; }
}
template <class T_action, class T_functor, bool I_islambda>
void visit_each(const T_action& _A_action,
                const internal::lambda_core<T_functor, I_islambda>& _A_target)
{
  visit_each(_A_action, _A_target.value_);
}
template <class T_type>
struct other;
struct subscript;
struct assign;
template <class T_action, class T_type1, class T_type2>
struct lambda_operator;
template <class T_type>
struct unwrap_lambda_type;
template <class T_type>
struct lambda : public internal::lambda_core<T_type>
{
  typedef lambda<T_type> self;
  lambda()
    {}
  lambda(typename type_trait<T_type>::take v)
    : internal::lambda_core<T_type>(v)
    {}
  template <class T_arg>
  lambda<lambda_operator<other<subscript>, self, typename unwrap_lambda_type<T_arg>::type> >
  operator [] (const T_arg& a) const
    { typedef lambda_operator<other<subscript>, self, typename unwrap_lambda_type<T_arg>::type> lambda_operator_type;
      return lambda<lambda_operator_type>(lambda_operator_type(this->value_, unwrap_lambda_value(a))); }
  template <class T_arg>
  lambda<lambda_operator<other<assign>, self, typename unwrap_lambda_type<T_arg>::type> >
  operator = (const T_arg& a) const
    { typedef lambda_operator<other<assign>, self, typename unwrap_lambda_type<T_arg>::type> lambda_operator_type;
      return lambda<lambda_operator_type>(lambda_operator_type(this->value_, unwrap_lambda_value(a))); }
};
template <class T_action, class T_type>
void visit_each(const T_action& _A_action,
                const lambda<T_type>& _A_target)
{
  visit_each(_A_action, _A_target.value_);
}
template <class T_type>
lambda<T_type&> var(T_type& v)
{ return lambda<T_type&>(v); }
template <class T_type>
lambda<const T_type&> var(const T_type& v)
{ return lambda<const T_type&>(v); }
template <class T_type>
struct unwrap_lambda_type
{ typedef typename unwrap_reference<T_type>::type type; };
template <class T_type>
struct unwrap_lambda_type<lambda<T_type> >
{ typedef T_type type; };
template <class T_type>
T_type& unwrap_lambda_value(T_type& a)
{ return a; }
template <class T_type>
const T_type& unwrap_lambda_value(const T_type& a)
{ return a; }
template <class T_type>
const T_type& unwrap_lambda_value(const lambda<T_type>& a)
{ return a.value_; }
}
namespace sigc {
namespace internal {
struct lambda_select1 : public lambda_base
{
  template <class T_arg1=void,class T_arg2=void,class T_arg3=void,class T_arg4=void,class T_arg5=void,class T_arg6=void,class T_arg7=void>
  struct deduce_result_type
    { typedef T_arg1 type; };
  typedef void result_type;
  void operator ()() const;
  template <class T_arg1>
  T_arg1 operator ()(T_arg1 _A_1) const { return _A_1; }
  template <class T_arg1,class T_arg2>
  T_arg1 operator ()(T_arg1 _A_1, T_arg2) const { return _A_1; }
  template <class T_arg1,class T_arg2,class T_arg3>
  T_arg1 operator ()(T_arg1 _A_1, T_arg2, T_arg3) const { return _A_1; }
  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4>
  T_arg1 operator ()(T_arg1 _A_1, T_arg2, T_arg3, T_arg4) const { return _A_1; }
  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
  T_arg1 operator ()(T_arg1 _A_1, T_arg2, T_arg3, T_arg4, T_arg5) const { return _A_1; }
  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
  T_arg1 operator ()(T_arg1 _A_1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6) const { return _A_1; }
  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
  T_arg1 operator ()(T_arg1 _A_1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7) const { return _A_1; }
};
struct lambda_select2 : public lambda_base
{
  template <class T_arg1=void,class T_arg2=void,class T_arg3=void,class T_arg4=void,class T_arg5=void,class T_arg6=void,class T_arg7=void>
  struct deduce_result_type
    { typedef T_arg2 type; };
  typedef void result_type;
  void operator ()() const;
  template <class T_arg1,class T_arg2>
  T_arg2 operator ()(T_arg1, T_arg2 _A_2) const { return _A_2; }
  template <class T_arg1,class T_arg2,class T_arg3>
  T_arg2 operator ()(T_arg1, T_arg2 _A_2, T_arg3) const { return _A_2; }
  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4>
  T_arg2 operator ()(T_arg1, T_arg2 _A_2, T_arg3, T_arg4) const { return _A_2; }
  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
  T_arg2 operator ()(T_arg1, T_arg2 _A_2, T_arg3, T_arg4, T_arg5) const { return _A_2; }
  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
  T_arg2 operator ()(T_arg1, T_arg2 _A_2, T_arg3, T_arg4, T_arg5, T_arg6) const { return _A_2; }
  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
  T_arg2 operator ()(T_arg1, T_arg2 _A_2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7) const { return _A_2; }
};
struct lambda_select3 : public lambda_base
{
  template <class T_arg1=void,class T_arg2=void,class T_arg3=void,class T_arg4=void,class T_arg5=void,class T_arg6=void,class T_arg7=void>
  struct deduce_result_type
    { typedef T_arg3 type; };
  typedef void result_type;
  void operator ()() const;
  template <class T_arg1,class T_arg2,class T_arg3>
  T_arg3 operator ()(T_arg1, T_arg2, T_arg3 _A_3) const { return _A_3; }
  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4>
  T_arg3 operator ()(T_arg1, T_arg2, T_arg3 _A_3, T_arg4) const { return _A_3; }
  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
  T_arg3 operator ()(T_arg1, T_arg2, T_arg3 _A_3, T_arg4, T_arg5) const { return _A_3; }
  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
  T_arg3 operator ()(T_arg1, T_arg2, T_arg3 _A_3, T_arg4, T_arg5, T_arg6) const { return _A_3; }
  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
  T_arg3 operator ()(T_arg1, T_arg2, T_arg3 _A_3, T_arg4, T_arg5, T_arg6, T_arg7) const { return _A_3; }
};
struct lambda_select4 : public lambda_base
{
  template <class T_arg1=void,class T_arg2=void,class T_arg3=void,class T_arg4=void,class T_arg5=void,class T_arg6=void,class T_arg7=void>
  struct deduce_result_type
    { typedef T_arg4 type; };
  typedef void result_type;
  void operator ()() const;
  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4>
  T_arg4 operator ()(T_arg1, T_arg2, T_arg3, T_arg4 _A_4) const { return _A_4; }
  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
  T_arg4 operator ()(T_arg1, T_arg2, T_arg3, T_arg4 _A_4, T_arg5) const { return _A_4; }
  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
  T_arg4 operator ()(T_arg1, T_arg2, T_arg3, T_arg4 _A_4, T_arg5, T_arg6) const { return _A_4; }
  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
  T_arg4 operator ()(T_arg1, T_arg2, T_arg3, T_arg4 _A_4, T_arg5, T_arg6, T_arg7) const { return _A_4; }
};
struct lambda_select5 : public lambda_base
{
  template <class T_arg1=void,class T_arg2=void,class T_arg3=void,class T_arg4=void,class T_arg5=void,class T_arg6=void,class T_arg7=void>
  struct deduce_result_type
    { typedef T_arg5 type; };
  typedef void result_type;
  void operator ()() const;
  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
  T_arg5 operator ()(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 _A_5) const { return _A_5; }
  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
  T_arg5 operator ()(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 _A_5, T_arg6) const { return _A_5; }
  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
  T_arg5 operator ()(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 _A_5, T_arg6, T_arg7) const { return _A_5; }
};
struct lambda_select6 : public lambda_base
{
  template <class T_arg1=void,class T_arg2=void,class T_arg3=void,class T_arg4=void,class T_arg5=void,class T_arg6=void,class T_arg7=void>
  struct deduce_result_type
    { typedef T_arg6 type; };
  typedef void result_type;
  void operator ()() const;
  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
  T_arg6 operator ()(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 _A_6) const { return _A_6; }
  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
  T_arg6 operator ()(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 _A_6, T_arg7) const { return _A_6; }
};
struct lambda_select7 : public lambda_base
{
  template <class T_arg1=void,class T_arg2=void,class T_arg3=void,class T_arg4=void,class T_arg5=void,class T_arg6=void,class T_arg7=void>
  struct deduce_result_type
    { typedef T_arg7 type; };
  typedef void result_type;
  void operator ()() const;
  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
  T_arg7 operator ()(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 _A_7) const { return _A_7; }
};
}
extern const lambda<internal::lambda_select1> _1;
extern const lambda<internal::lambda_select2> _2;
extern const lambda<internal::lambda_select3> _3;
extern const lambda<internal::lambda_select4> _4;
extern const lambda<internal::lambda_select5> _5;
extern const lambda<internal::lambda_select6> _6;
extern const lambda<internal::lambda_select7> _7;
}
namespace sigc {
template <class T_type>
struct dereference_trait
  { typedef void type; };
template <class T_type>
struct dereference_trait<T_type*>
  { typedef T_type type; };
template <class T_type>
struct dereference_trait<const T_type*>
  { typedef const T_type type; };
template <class T_type>
struct dereference_trait<T_type*&>
  { typedef T_type type; };
template <class T_type>
struct dereference_trait<const T_type*&>
  { typedef const T_type type; };
template <class T_type>
struct dereference_trait<T_type* const&>
  { typedef T_type type; };
template <class T_type>
struct dereference_trait<const T_type* const&>
  { typedef const T_type type; };
template <class T_type>
struct arithmetic {};
template <class T_type>
struct bitwise {};
template <class T_type>
struct logical {};
template <class T_type>
struct relational {};
template <class T_type>
struct arithmetic_assign {};
template <class T_type>
struct bitwise_assign {};
template <class T_type>
struct other {};
template <class T_type>
struct unary_arithmetic {};
template <class T_type>
struct unary_bitwise {};
template <class T_type>
struct unary_logical {};
template <class T_type>
struct unary_other {};
template <class T_type>
struct cast_ {};
struct plus {};
struct minus {};
struct multiplies {};
struct divides {};
struct modulus {};
struct leftshift {};
struct rightshift {};
struct and_ {};
struct or_ {};
struct xor_ {};
struct less {};
struct greater {};
struct less_equal {};
struct greater_equal {};
struct equal_to {};
struct not_equal_to {};
struct subscript {};
struct assign {};
struct pre_increment {};
struct pre_decrement {};
struct negate {};
struct not_ {};
struct address {};
struct dereference {};
struct reinterpret_ {};
struct static_ {};
struct dynamic_ {};
template <class T_action, class T_test1, class T_test2>
struct lambda_action_deduce_result_type
  { typedef typename type_trait<T_test1>::type type; };
template <class T_action, class T_test1, class T_test2>
struct lambda_action_deduce_result_type<logical<T_action>, T_test1, T_test2>
  { typedef bool type; };
template <class T_action, class T_test1, class T_test2>
struct lambda_action_deduce_result_type<relational<T_action>, T_test1, T_test2>
  { typedef bool type; };
template <class T_action, class T_test1, class T_test2>
struct lambda_action_deduce_result_type<arithmetic_assign<T_action>, T_test1, T_test2>
  { typedef T_test1 type; };
template <class T_action, class T_test1, class T_test2>
struct lambda_action_deduce_result_type<bitwise_assign<T_action>, T_test1, T_test2>
  { typedef T_test1 type; };
template <class T_test1, class T_test2>
struct lambda_action_deduce_result_type<other<subscript>, T_test1, T_test2>
  { typedef typename type_trait<typename dereference_trait<T_test1>::type>::pass type; };
template <class T_action, class T_test>
struct lambda_action_unary_deduce_result_type
  { typedef typename type_trait<T_test>::type type; };
template <class T_action, class T_type, class T_test>
struct lambda_action_convert_deduce_result_type
  { typedef typename type_trait<T_type>::type type; };
template <class T_action, class T_test>
struct lambda_action_unary_deduce_result_type<unary_logical<T_action>, T_test>
  { typedef bool type; };
template <class T_test>
struct lambda_action_unary_deduce_result_type<unary_other<address>, T_test>
  { typedef typename type_trait<T_test>::pointer type; };
template <class T_test>
struct lambda_action_unary_deduce_result_type<unary_other<dereference>, T_test>
  { typedef typename type_trait<typename dereference_trait<T_test>::type>::pass type; };
template <class T_action>
struct lambda_action {};
template <class T_action>
struct lambda_action_unary {};
template <class T_action, class T_type>
struct lambda_action_convert {};
template <>
struct lambda_action<arithmetic<plus> >
{
  template <class T_arg1, class T_arg2>
  static typename lambda_action_deduce_result_type<arithmetic<plus>, T_arg1, T_arg2>::type
  do_action(T_arg1 _A_1, T_arg2 _A_2)
    { return _A_1 + _A_2; }
};
template <>
struct lambda_action<arithmetic<minus> >
{
  template <class T_arg1, class T_arg2>
  static typename lambda_action_deduce_result_type<arithmetic<minus>, T_arg1, T_arg2>::type
  do_action(T_arg1 _A_1, T_arg2 _A_2)
    { return _A_1 - _A_2; }
};
template <>
struct lambda_action<arithmetic<multiplies> >
{
  template <class T_arg1, class T_arg2>
  static typename lambda_action_deduce_result_type<arithmetic<multiplies>, T_arg1, T_arg2>::type
  do_action(T_arg1 _A_1, T_arg2 _A_2)
    { return _A_1 * _A_2; }
};
template <>
struct lambda_action<arithmetic<divides> >
{
  template <class T_arg1, class T_arg2>
  static typename lambda_action_deduce_result_type<arithmetic<divides>, T_arg1, T_arg2>::type
  do_action(T_arg1 _A_1, T_arg2 _A_2)
    { return _A_1 / _A_2; }
};
template <>
struct lambda_action<arithmetic<modulus> >
{
  template <class T_arg1, class T_arg2>
  static typename lambda_action_deduce_result_type<arithmetic<modulus>, T_arg1, T_arg2>::type
  do_action(T_arg1 _A_1, T_arg2 _A_2)
    { return _A_1 % _A_2; }
};
template <>
struct lambda_action<bitwise<leftshift> >
{
  template <class T_arg1, class T_arg2>
  static typename lambda_action_deduce_result_type<bitwise<leftshift>, T_arg1, T_arg2>::type
  do_action(T_arg1 _A_1, T_arg2 _A_2)
    { return _A_1 << _A_2; }
};
template <>
struct lambda_action<bitwise<rightshift> >
{
  template <class T_arg1, class T_arg2>
  static typename lambda_action_deduce_result_type<bitwise<rightshift>, T_arg1, T_arg2>::type
  do_action(T_arg1 _A_1, T_arg2 _A_2)
    { return _A_1 >> _A_2; }
};
template <>
struct lambda_action<bitwise<and_> >
{
  template <class T_arg1, class T_arg2>
  static typename lambda_action_deduce_result_type<bitwise<and_>, T_arg1, T_arg2>::type
  do_action(T_arg1 _A_1, T_arg2 _A_2)
    { return _A_1 & _A_2; }
};
template <>
struct lambda_action<bitwise<or_> >
{
  template <class T_arg1, class T_arg2>
  static typename lambda_action_deduce_result_type<bitwise<or_>, T_arg1, T_arg2>::type
  do_action(T_arg1 _A_1, T_arg2 _A_2)
    { return _A_1 | _A_2; }
};
template <>
struct lambda_action<bitwise<xor_> >
{
  template <class T_arg1, class T_arg2>
  static typename lambda_action_deduce_result_type<bitwise<xor_>, T_arg1, T_arg2>::type
  do_action(T_arg1 _A_1, T_arg2 _A_2)
    { return _A_1 ^ _A_2; }
};
template <>
struct lambda_action<logical<and_> >
{
  template <class T_arg1, class T_arg2>
  static typename lambda_action_deduce_result_type<logical<and_>, T_arg1, T_arg2>::type
  do_action(T_arg1 _A_1, T_arg2 _A_2)
    { return _A_1 && _A_2; }
};
template <>
struct lambda_action<logical<or_> >
{
  template <class T_arg1, class T_arg2>
  static typename lambda_action_deduce_result_type<logical<or_>, T_arg1, T_arg2>::type
  do_action(T_arg1 _A_1, T_arg2 _A_2)
    { return _A_1 || _A_2; }
};
template <>
struct lambda_action<relational<less> >
{
  template <class T_arg1, class T_arg2>
  static typename lambda_action_deduce_result_type<relational<less>, T_arg1, T_arg2>::type
  do_action(T_arg1 _A_1, T_arg2 _A_2)
    { return _A_1 < _A_2; }
};
template <>
struct lambda_action<relational<greater> >
{
  template <class T_arg1, class T_arg2>
  static typename lambda_action_deduce_result_type<relational<greater>, T_arg1, T_arg2>::type
  do_action(T_arg1 _A_1, T_arg2 _A_2)
    { return _A_1 > _A_2; }
};
template <>
struct lambda_action<relational<less_equal> >
{
  template <class T_arg1, class T_arg2>
  static typename lambda_action_deduce_result_type<relational<less_equal>, T_arg1, T_arg2>::type
  do_action(T_arg1 _A_1, T_arg2 _A_2)
    { return _A_1 <= _A_2; }
};
template <>
struct lambda_action<relational<greater_equal> >
{
  template <class T_arg1, class T_arg2>
  static typename lambda_action_deduce_result_type<relational<greater_equal>, T_arg1, T_arg2>::type
  do_action(T_arg1 _A_1, T_arg2 _A_2)
    { return _A_1 >= _A_2; }
};
template <>
struct lambda_action<relational<equal_to> >
{
  template <class T_arg1, class T_arg2>
  static typename lambda_action_deduce_result_type<relational<equal_to>, T_arg1, T_arg2>::type
  do_action(T_arg1 _A_1, T_arg2 _A_2)
    { return _A_1 == _A_2; }
};
template <>
struct lambda_action<relational<not_equal_to> >
{
  template <class T_arg1, class T_arg2>
  static typename lambda_action_deduce_result_type<relational<not_equal_to>, T_arg1, T_arg2>::type
  do_action(T_arg1 _A_1, T_arg2 _A_2)
    { return _A_1 != _A_2; }
};
template <>
struct lambda_action<arithmetic_assign<plus> >
{
  template <class T_arg1, class T_arg2>
  static typename lambda_action_deduce_result_type<arithmetic_assign<plus>, T_arg1, T_arg2>::type
  do_action(T_arg1 _A_1, T_arg2 _A_2)
    { return _A_1 += _A_2; }
};
template <>
struct lambda_action<arithmetic_assign<minus> >
{
  template <class T_arg1, class T_arg2>
  static typename lambda_action_deduce_result_type<arithmetic_assign<minus>, T_arg1, T_arg2>::type
  do_action(T_arg1 _A_1, T_arg2 _A_2)
    { return _A_1 -= _A_2; }
};
template <>
struct lambda_action<arithmetic_assign<multiplies> >
{
  template <class T_arg1, class T_arg2>
  static typename lambda_action_deduce_result_type<arithmetic_assign<multiplies>, T_arg1, T_arg2>::type
  do_action(T_arg1 _A_1, T_arg2 _A_2)
    { return _A_1 *= _A_2; }
};
template <>
struct lambda_action<arithmetic_assign<divides> >
{
  template <class T_arg1, class T_arg2>
  static typename lambda_action_deduce_result_type<arithmetic_assign<divides>, T_arg1, T_arg2>::type
  do_action(T_arg1 _A_1, T_arg2 _A_2)
    { return _A_1 /= _A_2; }
};
template <>
struct lambda_action<arithmetic_assign<modulus> >
{
  template <class T_arg1, class T_arg2>
  static typename lambda_action_deduce_result_type<arithmetic_assign<modulus>, T_arg1, T_arg2>::type
  do_action(T_arg1 _A_1, T_arg2 _A_2)
    { return _A_1 %= _A_2; }
};
template <>
struct lambda_action<bitwise_assign<leftshift> >
{
  template <class T_arg1, class T_arg2>
  static typename lambda_action_deduce_result_type<bitwise_assign<leftshift>, T_arg1, T_arg2>::type
  do_action(T_arg1 _A_1, T_arg2 _A_2)
    { return _A_1 <<= _A_2; }
};
template <>
struct lambda_action<bitwise_assign<rightshift> >
{
  template <class T_arg1, class T_arg2>
  static typename lambda_action_deduce_result_type<bitwise_assign<rightshift>, T_arg1, T_arg2>::type
  do_action(T_arg1 _A_1, T_arg2 _A_2)
    { return _A_1 >>= _A_2; }
};
template <>
struct lambda_action<bitwise_assign<and_> >
{
  template <class T_arg1, class T_arg2>
  static typename lambda_action_deduce_result_type<bitwise_assign<and_>, T_arg1, T_arg2>::type
  do_action(T_arg1 _A_1, T_arg2 _A_2)
    { return _A_1 &= _A_2; }
};
template <>
struct lambda_action<bitwise_assign<or_> >
{
  template <class T_arg1, class T_arg2>
  static typename lambda_action_deduce_result_type<bitwise_assign<or_>, T_arg1, T_arg2>::type
  do_action(T_arg1 _A_1, T_arg2 _A_2)
    { return _A_1 |= _A_2; }
};
template <>
struct lambda_action<bitwise_assign<xor_> >
{
  template <class T_arg1, class T_arg2>
  static typename lambda_action_deduce_result_type<bitwise_assign<xor_>, T_arg1, T_arg2>::type
  do_action(T_arg1 _A_1, T_arg2 _A_2)
    { return _A_1 ^= _A_2; }
};
template <>
struct lambda_action<other<subscript> >
{
  template <class T_arg1, class T_arg2>
  static typename lambda_action_deduce_result_type<other<subscript>, T_arg1, T_arg2>::type
  do_action(T_arg1 _A_1, T_arg2 _A_2)
    { return _A_1[_A_2]; }
};
template <>
struct lambda_action<other<assign> >
{
  template <class T_arg1, class T_arg2>
  static typename lambda_action_deduce_result_type<other<assign>, T_arg1, T_arg2>::type
  do_action(T_arg1 _A_1, T_arg2 _A_2)
    { return _A_1 = _A_2; }
};
template <>
struct lambda_action_unary<unary_arithmetic<pre_increment> >
{
  template <class T_arg>
  static typename lambda_action_unary_deduce_result_type<unary_arithmetic<pre_increment>, T_arg>::type
  do_action(T_arg _Aa)
    { return ++_Aa; }
};
template <>
struct lambda_action_unary<unary_arithmetic<pre_decrement> >
{
  template <class T_arg>
  static typename lambda_action_unary_deduce_result_type<unary_arithmetic<pre_decrement>, T_arg>::type
  do_action(T_arg _Aa)
    { return --_Aa; }
};
template <>
struct lambda_action_unary<unary_arithmetic<negate> >
{
  template <class T_arg>
  static typename lambda_action_unary_deduce_result_type<unary_arithmetic<negate>, T_arg>::type
  do_action(T_arg _Aa)
    { return -_Aa; }
};
template <>
struct lambda_action_unary<unary_bitwise<not_> >
{
  template <class T_arg>
  static typename lambda_action_unary_deduce_result_type<unary_bitwise<not_>, T_arg>::type
  do_action(T_arg _Aa)
    { return ~_Aa; }
};
template <>
struct lambda_action_unary<unary_logical<not_> >
{
  template <class T_arg>
  static typename lambda_action_unary_deduce_result_type<unary_logical<not_>, T_arg>::type
  do_action(T_arg _Aa)
    { return !_Aa; }
};
template <>
struct lambda_action_unary<unary_other<address> >
{
  template <class T_arg>
  static typename lambda_action_unary_deduce_result_type<unary_other<address>, T_arg>::type
  do_action(T_arg _Aa)
    { return &_Aa; }
};
template <>
struct lambda_action_unary<unary_other<dereference> >
{
  template <class T_arg>
  static typename lambda_action_unary_deduce_result_type<unary_other<dereference>, T_arg>::type
  do_action(T_arg _Aa)
    { return *_Aa; }
};
template <class T_type>
struct lambda_action_convert<cast_<reinterpret_>, T_type>
{
  template <class T_arg>
  static typename lambda_action_convert_deduce_result_type<cast_<reinterpret_>, T_type, T_arg>::type
  do_action(T_arg _Aa)
    { return reinterpret_cast<T_type>(_Aa); }
};
template <class T_type>
struct lambda_action_convert<cast_<static_>, T_type>
{
  template <class T_arg>
  static typename lambda_action_convert_deduce_result_type<cast_<static_>, T_type, T_arg>::type
  do_action(T_arg _Aa)
    { return static_cast<T_type>(_Aa); }
};
template <class T_type>
struct lambda_action_convert<cast_<dynamic_>, T_type>
{
  template <class T_arg>
  static typename lambda_action_convert_deduce_result_type<cast_<dynamic_>, T_type, T_arg>::type
  do_action(T_arg _Aa)
    { return dynamic_cast<T_type>(_Aa); }
};
template <class T_action, class T_type1, class T_type2>
struct lambda_operator : public lambda_base
{
  typedef typename lambda<T_type1>::lambda_type arg1_type;
  typedef typename lambda<T_type2>::lambda_type arg2_type;
  template <class T_arg1=void,class T_arg2=void,class T_arg3=void,class T_arg4=void,class T_arg5=void,class T_arg6=void,class T_arg7=void>
  struct deduce_result_type
    { typedef typename arg1_type::template deduce_result_type<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass,typename type_trait<T_arg6>::pass,typename type_trait<T_arg7>::pass>::type left_type;
      typedef typename arg2_type::template deduce_result_type<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass,typename type_trait<T_arg6>::pass,typename type_trait<T_arg7>::pass>::type right_type;
      typedef typename lambda_action_deduce_result_type<T_action, left_type, right_type>::type type;
    };
  typedef typename lambda_action_deduce_result_type<
      T_action,
      typename arg1_type::result_type,
      typename arg2_type::result_type
    >::type result_type;
  result_type
  operator ()() const;
  template <class T_arg1>
  typename deduce_result_type<T_arg1>::type
  operator ()(T_arg1 _A_1) const
    {
      return lambda_action<T_action>::template do_action<
            typename deduce_result_type<typename type_trait<T_arg1>::pass>::left_type,
            typename deduce_result_type<typename type_trait<T_arg1>::pass>::right_type>
        (arg1_.template operator()<typename type_trait<T_arg1>::pass>
            (_A_1),
         arg2_.template operator()<typename type_trait<T_arg1>::pass>
            (_A_1));
    }
  template <class T_arg1,class T_arg2>
  typename deduce_result_type<T_arg1,T_arg2>::type
  operator ()(T_arg1 _A_1,T_arg2 _A_2) const
    {
      return lambda_action<T_action>::template do_action<
            typename deduce_result_type<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass>::left_type,
            typename deduce_result_type<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass>::right_type>
        (arg1_.template operator()<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass>
            (_A_1,_A_2),
         arg2_.template operator()<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass>
            (_A_1,_A_2));
    }
  template <class T_arg1,class T_arg2,class T_arg3>
  typename deduce_result_type<T_arg1,T_arg2,T_arg3>::type
  operator ()(T_arg1 _A_1,T_arg2 _A_2,T_arg3 _A_3) const
    {
      return lambda_action<T_action>::template do_action<
            typename deduce_result_type<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass>::left_type,
            typename deduce_result_type<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass>::right_type>
        (arg1_.template operator()<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass>
            (_A_1,_A_2,_A_3),
         arg2_.template operator()<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass>
            (_A_1,_A_2,_A_3));
    }
  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4>
  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4>::type
  operator ()(T_arg1 _A_1,T_arg2 _A_2,T_arg3 _A_3,T_arg4 _A_4) const
    {
      return lambda_action<T_action>::template do_action<
            typename deduce_result_type<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass>::left_type,
            typename deduce_result_type<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass>::right_type>
        (arg1_.template operator()<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass>
            (_A_1,_A_2,_A_3,_A_4),
         arg2_.template operator()<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass>
            (_A_1,_A_2,_A_3,_A_4));
    }
  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>::type
  operator ()(T_arg1 _A_1,T_arg2 _A_2,T_arg3 _A_3,T_arg4 _A_4,T_arg5 _A_5) const
    {
      return lambda_action<T_action>::template do_action<
            typename deduce_result_type<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass>::left_type,
            typename deduce_result_type<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass>::right_type>
        (arg1_.template operator()<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass>
            (_A_1,_A_2,_A_3,_A_4,_A_5),
         arg2_.template operator()<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass>
            (_A_1,_A_2,_A_3,_A_4,_A_5));
    }
  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>::type
  operator ()(T_arg1 _A_1,T_arg2 _A_2,T_arg3 _A_3,T_arg4 _A_4,T_arg5 _A_5,T_arg6 _A_6) const
    {
      return lambda_action<T_action>::template do_action<
            typename deduce_result_type<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass,typename type_trait<T_arg6>::pass>::left_type,
            typename deduce_result_type<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass,typename type_trait<T_arg6>::pass>::right_type>
        (arg1_.template operator()<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass,typename type_trait<T_arg6>::pass>
            (_A_1,_A_2,_A_3,_A_4,_A_5,_A_6),
         arg2_.template operator()<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass,typename type_trait<T_arg6>::pass>
            (_A_1,_A_2,_A_3,_A_4,_A_5,_A_6));
    }
  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>::type
  operator ()(T_arg1 _A_1,T_arg2 _A_2,T_arg3 _A_3,T_arg4 _A_4,T_arg5 _A_5,T_arg6 _A_6,T_arg7 _A_7) const
    {
      return lambda_action<T_action>::template do_action<
            typename deduce_result_type<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass,typename type_trait<T_arg6>::pass,typename type_trait<T_arg7>::pass>::left_type,
            typename deduce_result_type<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass,typename type_trait<T_arg6>::pass,typename type_trait<T_arg7>::pass>::right_type>
        (arg1_.template operator()<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass,typename type_trait<T_arg6>::pass,typename type_trait<T_arg7>::pass>
            (_A_1,_A_2,_A_3,_A_4,_A_5,_A_6,_A_7),
         arg2_.template operator()<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass,typename type_trait<T_arg6>::pass,typename type_trait<T_arg7>::pass>
            (_A_1,_A_2,_A_3,_A_4,_A_5,_A_6,_A_7));
    }
  lambda_operator(typename type_trait<T_type1>::take a1, typename type_trait<T_type2>::take a2 )
    : arg1_(a1), arg2_(a2) {}
  arg1_type arg1_;
  arg2_type arg2_;
};
template <class T_action, class T_type1, class T_type2>
typename lambda_operator<T_action, T_type1, T_type2>::result_type
lambda_operator<T_action, T_type1, T_type2>::operator ()() const
  { return lambda_action<T_action>::template do_action<
      typename arg1_type::result_type,
      typename arg2_type::result_type>
      (arg1_(), arg2_()); }
template <class T_action, class T_lambda_action, class T_arg1, class T_arg2>
void visit_each(const T_action& _A_action,
                const lambda_operator<T_lambda_action, T_arg1, T_arg2>& _A_target)
{
  visit_each(_A_action, _A_target.arg1_);
  visit_each(_A_action, _A_target.arg2_);
}
template <class T_action, class T_type>
struct lambda_operator_unary : public lambda_base
{
  typedef typename lambda<T_type>::lambda_type arg_type;
  template <class T_arg1=void,class T_arg2=void,class T_arg3=void,class T_arg4=void,class T_arg5=void,class T_arg6=void,class T_arg7=void>
  struct deduce_result_type
    { typedef typename arg_type::template deduce_result_type<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass,typename type_trait<T_arg6>::pass,typename type_trait<T_arg7>::pass>::type operand_type;
      typedef typename lambda_action_unary_deduce_result_type<T_action, operand_type>::type type;
    };
  typedef typename lambda_action_unary_deduce_result_type<
      T_action,
      typename arg_type::result_type
    >::type result_type;
  result_type
  operator ()() const;
  template <class T_arg1>
  typename deduce_result_type<T_arg1>::type
  operator ()(T_arg1 _A_1) const
    {
      return lambda_action_unary<T_action>::template do_action<
            typename deduce_result_type<typename type_trait<T_arg1>::pass>::operand_type>
        (arg_.template operator()<typename type_trait<T_arg1>::pass>
            (_A_1));
    }
  template <class T_arg1,class T_arg2>
  typename deduce_result_type<T_arg1,T_arg2>::type
  operator ()(T_arg1 _A_1,T_arg2 _A_2) const
    {
      return lambda_action_unary<T_action>::template do_action<
            typename deduce_result_type<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass>::operand_type>
        (arg_.template operator()<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass>
            (_A_1,_A_2));
    }
  template <class T_arg1,class T_arg2,class T_arg3>
  typename deduce_result_type<T_arg1,T_arg2,T_arg3>::type
  operator ()(T_arg1 _A_1,T_arg2 _A_2,T_arg3 _A_3) const
    {
      return lambda_action_unary<T_action>::template do_action<
            typename deduce_result_type<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass>::operand_type>
        (arg_.template operator()<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass>
            (_A_1,_A_2,_A_3));
    }
  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4>
  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4>::type
  operator ()(T_arg1 _A_1,T_arg2 _A_2,T_arg3 _A_3,T_arg4 _A_4) const
    {
      return lambda_action_unary<T_action>::template do_action<
            typename deduce_result_type<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass>::operand_type>
        (arg_.template operator()<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass>
            (_A_1,_A_2,_A_3,_A_4));
    }
  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>::type
  operator ()(T_arg1 _A_1,T_arg2 _A_2,T_arg3 _A_3,T_arg4 _A_4,T_arg5 _A_5) const
    {
      return lambda_action_unary<T_action>::template do_action<
            typename deduce_result_type<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass>::operand_type>
        (arg_.template operator()<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass>
            (_A_1,_A_2,_A_3,_A_4,_A_5));
    }
  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>::type
  operator ()(T_arg1 _A_1,T_arg2 _A_2,T_arg3 _A_3,T_arg4 _A_4,T_arg5 _A_5,T_arg6 _A_6) const
    {
      return lambda_action_unary<T_action>::template do_action<
            typename deduce_result_type<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass,typename type_trait<T_arg6>::pass>::operand_type>
        (arg_.template operator()<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass,typename type_trait<T_arg6>::pass>
            (_A_1,_A_2,_A_3,_A_4,_A_5,_A_6));
    }
  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>::type
  operator ()(T_arg1 _A_1,T_arg2 _A_2,T_arg3 _A_3,T_arg4 _A_4,T_arg5 _A_5,T_arg6 _A_6,T_arg7 _A_7) const
    {
      return lambda_action_unary<T_action>::template do_action<
            typename deduce_result_type<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass,typename type_trait<T_arg6>::pass,typename type_trait<T_arg7>::pass>::operand_type>
        (arg_.template operator()<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass,typename type_trait<T_arg6>::pass,typename type_trait<T_arg7>::pass>
            (_A_1,_A_2,_A_3,_A_4,_A_5,_A_6,_A_7));
    }
  lambda_operator_unary(typename type_trait<T_type>::take a)
    : arg_(a) {}
  arg_type arg_;
};
template <class T_action, class T_type>
typename lambda_operator_unary<T_action, T_type>::result_type
lambda_operator_unary<T_action, T_type>::operator ()() const
  { return lambda_action_unary<T_action>::template do_action<
      typename arg_type::result_type>
      (arg_()); }
template <class T_action, class T_lambda_action, class T_arg>
void visit_each(const T_action& _A_action,
                const lambda_operator_unary<T_lambda_action, T_arg>& _A_target)
{
  visit_each(_A_action, _A_target.arg_);
}
template <class T_action, class T_type, class T_arg>
struct lambda_operator_convert : public lambda_base
{
  typedef typename lambda<T_arg>::lambda_type arg_type;
  template <class T_arg1=void,class T_arg2=void,class T_arg3=void,class T_arg4=void,class T_arg5=void,class T_arg6=void,class T_arg7=void>
  struct deduce_result_type
    { typedef typename arg_type::template deduce_result_type<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass,typename type_trait<T_arg6>::pass,typename type_trait<T_arg7>::pass>::type operand_type;
      typedef typename lambda_action_convert_deduce_result_type<T_action, T_type, operand_type>::type type;
    };
  typedef typename lambda_action_convert_deduce_result_type<
      T_action, T_type,
      typename arg_type::result_type
    >::type result_type;
  result_type
  operator ()() const;
  template <class T_arg1>
  typename deduce_result_type<T_arg1>::type
  operator ()(T_arg1 _A_1) const
    {
      return lambda_action_convert<T_action, T_type>::template do_action<
            typename deduce_result_type<typename type_trait<T_arg1>::pass>::operand_type>
        (arg_.template operator()<typename type_trait<T_arg1>::pass>
            (_A_1));
    }
  template <class T_arg1,class T_arg2>
  typename deduce_result_type<T_arg1,T_arg2>::type
  operator ()(T_arg1 _A_1,T_arg2 _A_2) const
    {
      return lambda_action_convert<T_action, T_type>::template do_action<
            typename deduce_result_type<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass>::operand_type>
        (arg_.template operator()<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass>
            (_A_1,_A_2));
    }
  template <class T_arg1,class T_arg2,class T_arg3>
  typename deduce_result_type<T_arg1,T_arg2,T_arg3>::type
  operator ()(T_arg1 _A_1,T_arg2 _A_2,T_arg3 _A_3) const
    {
      return lambda_action_convert<T_action, T_type>::template do_action<
            typename deduce_result_type<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass>::operand_type>
        (arg_.template operator()<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass>
            (_A_1,_A_2,_A_3));
    }
  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4>
  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4>::type
  operator ()(T_arg1 _A_1,T_arg2 _A_2,T_arg3 _A_3,T_arg4 _A_4) const
    {
      return lambda_action_convert<T_action, T_type>::template do_action<
            typename deduce_result_type<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass>::operand_type>
        (arg_.template operator()<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass>
            (_A_1,_A_2,_A_3,_A_4));
    }
  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>::type
  operator ()(T_arg1 _A_1,T_arg2 _A_2,T_arg3 _A_3,T_arg4 _A_4,T_arg5 _A_5) const
    {
      return lambda_action_convert<T_action, T_type>::template do_action<
            typename deduce_result_type<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass>::operand_type>
        (arg_.template operator()<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass>
            (_A_1,_A_2,_A_3,_A_4,_A_5));
    }
  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>::type
  operator ()(T_arg1 _A_1,T_arg2 _A_2,T_arg3 _A_3,T_arg4 _A_4,T_arg5 _A_5,T_arg6 _A_6) const
    {
      return lambda_action_convert<T_action, T_type>::template do_action<
            typename deduce_result_type<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass,typename type_trait<T_arg6>::pass>::operand_type>
        (arg_.template operator()<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass,typename type_trait<T_arg6>::pass>
            (_A_1,_A_2,_A_3,_A_4,_A_5,_A_6));
    }
  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>::type
  operator ()(T_arg1 _A_1,T_arg2 _A_2,T_arg3 _A_3,T_arg4 _A_4,T_arg5 _A_5,T_arg6 _A_6,T_arg7 _A_7) const
    {
      return lambda_action_convert<T_action, T_type>::template do_action<
            typename deduce_result_type<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass,typename type_trait<T_arg6>::pass,typename type_trait<T_arg7>::pass>::operand_type>
        (arg_.template operator()<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass,typename type_trait<T_arg6>::pass,typename type_trait<T_arg7>::pass>
            (_A_1,_A_2,_A_3,_A_4,_A_5,_A_6,_A_7));
    }
  lambda_operator_convert(typename type_trait<T_arg>::take a)
    : arg_(a) {}
  arg_type arg_;
};
template <class T_action, class T_type, class T_arg>
typename lambda_operator_convert<T_action, T_type, T_arg>::result_type
lambda_operator_convert<T_action, T_type, T_arg>::operator ()() const
  { return lambda_action_convert<T_action, T_type>::template do_action<
      typename arg_type::result_type>
      (arg_()); }
template <class T_action, class T_lambda_action, class T_type, class T_arg>
void visit_each(const T_action& _A_action,
                const lambda_operator_convert<T_lambda_action, T_type, T_arg>& _A_target)
{
  visit_each(_A_action, _A_target.arg_);
}
template <class T_arg1, class T_arg2>
lambda<lambda_operator<arithmetic<plus>, T_arg1, T_arg2> >
operator + (const lambda<T_arg1>& a1, const lambda<T_arg2>& a2)
{ typedef lambda_operator<arithmetic<plus>, T_arg1, T_arg2> operator_type;
  return lambda<operator_type>(operator_type(a1.value_,a2.value_)); }
template <class T_arg1, class T_arg2>
lambda<lambda_operator<arithmetic<plus>, T_arg1, typename unwrap_reference<T_arg2>::type> >
operator + (const lambda<T_arg1>& a1, const T_arg2& a2)
{ typedef lambda_operator<arithmetic<plus>, T_arg1, typename unwrap_reference<T_arg2>::type> operator_type;
  return lambda<operator_type>(operator_type(a1.value_,a2)); }
template <class T_arg1, class T_arg2>
lambda<lambda_operator<arithmetic<plus>, typename unwrap_reference<T_arg1>::type, T_arg2> >
operator + (const T_arg1& a1, const lambda<T_arg2>& a2)
{ typedef lambda_operator<arithmetic<plus>, typename unwrap_reference<T_arg1>::type, T_arg2> operator_type;
  return lambda<operator_type>(operator_type(a1,a2.value_)); }
template <class T_arg1, class T_arg2>
lambda<lambda_operator<arithmetic<minus>, T_arg1, T_arg2> >
operator - (const lambda<T_arg1>& a1, const lambda<T_arg2>& a2)
{ typedef lambda_operator<arithmetic<minus>, T_arg1, T_arg2> operator_type;
  return lambda<operator_type>(operator_type(a1.value_,a2.value_)); }
template <class T_arg1, class T_arg2>
lambda<lambda_operator<arithmetic<minus>, T_arg1, typename unwrap_reference<T_arg2>::type> >
operator - (const lambda<T_arg1>& a1, const T_arg2& a2)
{ typedef lambda_operator<arithmetic<minus>, T_arg1, typename unwrap_reference<T_arg2>::type> operator_type;
  return lambda<operator_type>(operator_type(a1.value_,a2)); }
template <class T_arg1, class T_arg2>
lambda<lambda_operator<arithmetic<minus>, typename unwrap_reference<T_arg1>::type, T_arg2> >
operator - (const T_arg1& a1, const lambda<T_arg2>& a2)
{ typedef lambda_operator<arithmetic<minus>, typename unwrap_reference<T_arg1>::type, T_arg2> operator_type;
  return lambda<operator_type>(operator_type(a1,a2.value_)); }
template <class T_arg1, class T_arg2>
lambda<lambda_operator<arithmetic<multiplies>, T_arg1, T_arg2> >
operator * (const lambda<T_arg1>& a1, const lambda<T_arg2>& a2)
{ typedef lambda_operator<arithmetic<multiplies>, T_arg1, T_arg2> operator_type;
  return lambda<operator_type>(operator_type(a1.value_,a2.value_)); }
template <class T_arg1, class T_arg2>
lambda<lambda_operator<arithmetic<multiplies>, T_arg1, typename unwrap_reference<T_arg2>::type> >
operator * (const lambda<T_arg1>& a1, const T_arg2& a2)
{ typedef lambda_operator<arithmetic<multiplies>, T_arg1, typename unwrap_reference<T_arg2>::type> operator_type;
  return lambda<operator_type>(operator_type(a1.value_,a2)); }
template <class T_arg1, class T_arg2>
lambda<lambda_operator<arithmetic<multiplies>, typename unwrap_reference<T_arg1>::type, T_arg2> >
operator * (const T_arg1& a1, const lambda<T_arg2>& a2)
{ typedef lambda_operator<arithmetic<multiplies>, typename unwrap_reference<T_arg1>::type, T_arg2> operator_type;
  return lambda<operator_type>(operator_type(a1,a2.value_)); }
template <class T_arg1, class T_arg2>
lambda<lambda_operator<arithmetic<divides>, T_arg1, T_arg2> >
operator / (const lambda<T_arg1>& a1, const lambda<T_arg2>& a2)
{ typedef lambda_operator<arithmetic<divides>, T_arg1, T_arg2> operator_type;
  return lambda<operator_type>(operator_type(a1.value_,a2.value_)); }
template <class T_arg1, class T_arg2>
lambda<lambda_operator<arithmetic<divides>, T_arg1, typename unwrap_reference<T_arg2>::type> >
operator / (const lambda<T_arg1>& a1, const T_arg2& a2)
{ typedef lambda_operator<arithmetic<divides>, T_arg1, typename unwrap_reference<T_arg2>::type> operator_type;
  return lambda<operator_type>(operator_type(a1.value_,a2)); }
template <class T_arg1, class T_arg2>
lambda<lambda_operator<arithmetic<divides>, typename unwrap_reference<T_arg1>::type, T_arg2> >
operator / (const T_arg1& a1, const lambda<T_arg2>& a2)
{ typedef lambda_operator<arithmetic<divides>, typename unwrap_reference<T_arg1>::type, T_arg2> operator_type;
  return lambda<operator_type>(operator_type(a1,a2.value_)); }
template <class T_arg1, class T_arg2>
lambda<lambda_operator<arithmetic<modulus>, T_arg1, T_arg2> >
operator % (const lambda<T_arg1>& a1, const lambda<T_arg2>& a2)
{ typedef lambda_operator<arithmetic<modulus>, T_arg1, T_arg2> operator_type;
  return lambda<operator_type>(operator_type(a1.value_,a2.value_)); }
template <class T_arg1, class T_arg2>
lambda<lambda_operator<arithmetic<modulus>, T_arg1, typename unwrap_reference<T_arg2>::type> >
operator % (const lambda<T_arg1>& a1, const T_arg2& a2)
{ typedef lambda_operator<arithmetic<modulus>, T_arg1, typename unwrap_reference<T_arg2>::type> operator_type;
  return lambda<operator_type>(operator_type(a1.value_,a2)); }
template <class T_arg1, class T_arg2>
lambda<lambda_operator<arithmetic<modulus>, typename unwrap_reference<T_arg1>::type, T_arg2> >
operator % (const T_arg1& a1, const lambda<T_arg2>& a2)
{ typedef lambda_operator<arithmetic<modulus>, typename unwrap_reference<T_arg1>::type, T_arg2> operator_type;
  return lambda<operator_type>(operator_type(a1,a2.value_)); }
template <class T_arg1, class T_arg2>
lambda<lambda_operator<bitwise<leftshift>, T_arg1, T_arg2> >
operator << (const lambda<T_arg1>& a1, const lambda<T_arg2>& a2)
{ typedef lambda_operator<bitwise<leftshift>, T_arg1, T_arg2> operator_type;
  return lambda<operator_type>(operator_type(a1.value_,a2.value_)); }
template <class T_arg1, class T_arg2>
lambda<lambda_operator<bitwise<leftshift>, T_arg1, typename unwrap_reference<T_arg2>::type> >
operator << (const lambda<T_arg1>& a1, const T_arg2& a2)
{ typedef lambda_operator<bitwise<leftshift>, T_arg1, typename unwrap_reference<T_arg2>::type> operator_type;
  return lambda<operator_type>(operator_type(a1.value_,a2)); }
template <class T_arg1, class T_arg2>
lambda<lambda_operator<bitwise<leftshift>, typename unwrap_reference<T_arg1>::type, T_arg2> >
operator << (const T_arg1& a1, const lambda<T_arg2>& a2)
{ typedef lambda_operator<bitwise<leftshift>, typename unwrap_reference<T_arg1>::type, T_arg2> operator_type;
  return lambda<operator_type>(operator_type(a1,a2.value_)); }
template <class T_arg1, class T_arg2>
lambda<lambda_operator<bitwise<rightshift>, T_arg1, T_arg2> >
operator >> (const lambda<T_arg1>& a1, const lambda<T_arg2>& a2)
{ typedef lambda_operator<bitwise<rightshift>, T_arg1, T_arg2> operator_type;
  return lambda<operator_type>(operator_type(a1.value_,a2.value_)); }
template <class T_arg1, class T_arg2>
lambda<lambda_operator<bitwise<rightshift>, T_arg1, typename unwrap_reference<T_arg2>::type> >
operator >> (const lambda<T_arg1>& a1, const T_arg2& a2)
{ typedef lambda_operator<bitwise<rightshift>, T_arg1, typename unwrap_reference<T_arg2>::type> operator_type;
  return lambda<operator_type>(operator_type(a1.value_,a2)); }
template <class T_arg1, class T_arg2>
lambda<lambda_operator<bitwise<rightshift>, typename unwrap_reference<T_arg1>::type, T_arg2> >
operator >> (const T_arg1& a1, const lambda<T_arg2>& a2)
{ typedef lambda_operator<bitwise<rightshift>, typename unwrap_reference<T_arg1>::type, T_arg2> operator_type;
  return lambda<operator_type>(operator_type(a1,a2.value_)); }
template <class T_arg1, class T_arg2>
lambda<lambda_operator<bitwise<and_>, T_arg1, T_arg2> >
operator & (const lambda<T_arg1>& a1, const lambda<T_arg2>& a2)
{ typedef lambda_operator<bitwise<and_>, T_arg1, T_arg2> operator_type;
  return lambda<operator_type>(operator_type(a1.value_,a2.value_)); }
template <class T_arg1, class T_arg2>
lambda<lambda_operator<bitwise<and_>, T_arg1, typename unwrap_reference<T_arg2>::type> >
operator & (const lambda<T_arg1>& a1, const T_arg2& a2)
{ typedef lambda_operator<bitwise<and_>, T_arg1, typename unwrap_reference<T_arg2>::type> operator_type;
  return lambda<operator_type>(operator_type(a1.value_,a2)); }
template <class T_arg1, class T_arg2>
lambda<lambda_operator<bitwise<and_>, typename unwrap_reference<T_arg1>::type, T_arg2> >
operator & (const T_arg1& a1, const lambda<T_arg2>& a2)
{ typedef lambda_operator<bitwise<and_>, typename unwrap_reference<T_arg1>::type, T_arg2> operator_type;
  return lambda<operator_type>(operator_type(a1,a2.value_)); }
template <class T_arg1, class T_arg2>
lambda<lambda_operator<bitwise<or_>, T_arg1, T_arg2> >
operator | (const lambda<T_arg1>& a1, const lambda<T_arg2>& a2)
{ typedef lambda_operator<bitwise<or_>, T_arg1, T_arg2> operator_type;
  return lambda<operator_type>(operator_type(a1.value_,a2.value_)); }
template <class T_arg1, class T_arg2>
lambda<lambda_operator<bitwise<or_>, T_arg1, typename unwrap_reference<T_arg2>::type> >
operator | (const lambda<T_arg1>& a1, const T_arg2& a2)
{ typedef lambda_operator<bitwise<or_>, T_arg1, typename unwrap_reference<T_arg2>::type> operator_type;
  return lambda<operator_type>(operator_type(a1.value_,a2)); }
template <class T_arg1, class T_arg2>
lambda<lambda_operator<bitwise<or_>, typename unwrap_reference<T_arg1>::type, T_arg2> >
operator | (const T_arg1& a1, const lambda<T_arg2>& a2)
{ typedef lambda_operator<bitwise<or_>, typename unwrap_reference<T_arg1>::type, T_arg2> operator_type;
  return lambda<operator_type>(operator_type(a1,a2.value_)); }
template <class T_arg1, class T_arg2>
lambda<lambda_operator<bitwise<xor_>, T_arg1, T_arg2> >
operator ^ (const lambda<T_arg1>& a1, const lambda<T_arg2>& a2)
{ typedef lambda_operator<bitwise<xor_>, T_arg1, T_arg2> operator_type;
  return lambda<operator_type>(operator_type(a1.value_,a2.value_)); }
template <class T_arg1, class T_arg2>
lambda<lambda_operator<bitwise<xor_>, T_arg1, typename unwrap_reference<T_arg2>::type> >
operator ^ (const lambda<T_arg1>& a1, const T_arg2& a2)
{ typedef lambda_operator<bitwise<xor_>, T_arg1, typename unwrap_reference<T_arg2>::type> operator_type;
  return lambda<operator_type>(operator_type(a1.value_,a2)); }
template <class T_arg1, class T_arg2>
lambda<lambda_operator<bitwise<xor_>, typename unwrap_reference<T_arg1>::type, T_arg2> >
operator ^ (const T_arg1& a1, const lambda<T_arg2>& a2)
{ typedef lambda_operator<bitwise<xor_>, typename unwrap_reference<T_arg1>::type, T_arg2> operator_type;
  return lambda<operator_type>(operator_type(a1,a2.value_)); }
template <class T_arg1, class T_arg2>
lambda<lambda_operator<logical<and_>, T_arg1, T_arg2> >
operator && (const lambda<T_arg1>& a1, const lambda<T_arg2>& a2)
{ typedef lambda_operator<logical<and_>, T_arg1, T_arg2> operator_type;
  return lambda<operator_type>(operator_type(a1.value_,a2.value_)); }
template <class T_arg1, class T_arg2>
lambda<lambda_operator<logical<and_>, T_arg1, typename unwrap_reference<T_arg2>::type> >
operator && (const lambda<T_arg1>& a1, const T_arg2& a2)
{ typedef lambda_operator<logical<and_>, T_arg1, typename unwrap_reference<T_arg2>::type> operator_type;
  return lambda<operator_type>(operator_type(a1.value_,a2)); }
template <class T_arg1, class T_arg2>
lambda<lambda_operator<logical<and_>, typename unwrap_reference<T_arg1>::type, T_arg2> >
operator && (const T_arg1& a1, const lambda<T_arg2>& a2)
{ typedef lambda_operator<logical<and_>, typename unwrap_reference<T_arg1>::type, T_arg2> operator_type;
  return lambda<operator_type>(operator_type(a1,a2.value_)); }
template <class T_arg1, class T_arg2>
lambda<lambda_operator<logical<or_>, T_arg1, T_arg2> >
operator || (const lambda<T_arg1>& a1, const lambda<T_arg2>& a2)
{ typedef lambda_operator<logical<or_>, T_arg1, T_arg2> operator_type;
  return lambda<operator_type>(operator_type(a1.value_,a2.value_)); }
template <class T_arg1, class T_arg2>
lambda<lambda_operator<logical<or_>, T_arg1, typename unwrap_reference<T_arg2>::type> >
operator || (const lambda<T_arg1>& a1, const T_arg2& a2)
{ typedef lambda_operator<logical<or_>, T_arg1, typename unwrap_reference<T_arg2>::type> operator_type;
  return lambda<operator_type>(operator_type(a1.value_,a2)); }
template <class T_arg1, class T_arg2>
lambda<lambda_operator<logical<or_>, typename unwrap_reference<T_arg1>::type, T_arg2> >
operator || (const T_arg1& a1, const lambda<T_arg2>& a2)
{ typedef lambda_operator<logical<or_>, typename unwrap_reference<T_arg1>::type, T_arg2> operator_type;
  return lambda<operator_type>(operator_type(a1,a2.value_)); }
template <class T_arg1, class T_arg2>
lambda<lambda_operator<relational<less>, T_arg1, T_arg2> >
operator < (const lambda<T_arg1>& a1, const lambda<T_arg2>& a2)
{ typedef lambda_operator<relational<less>, T_arg1, T_arg2> operator_type;
  return lambda<operator_type>(operator_type(a1.value_,a2.value_)); }
template <class T_arg1, class T_arg2>
lambda<lambda_operator<relational<less>, T_arg1, typename unwrap_reference<T_arg2>::type> >
operator < (const lambda<T_arg1>& a1, const T_arg2& a2)
{ typedef lambda_operator<relational<less>, T_arg1, typename unwrap_reference<T_arg2>::type> operator_type;
  return lambda<operator_type>(operator_type(a1.value_,a2)); }
template <class T_arg1, class T_arg2>
lambda<lambda_operator<relational<less>, typename unwrap_reference<T_arg1>::type, T_arg2> >
operator < (const T_arg1& a1, const lambda<T_arg2>& a2)
{ typedef lambda_operator<relational<less>, typename unwrap_reference<T_arg1>::type, T_arg2> operator_type;
  return lambda<operator_type>(operator_type(a1,a2.value_)); }
template <class T_arg1, class T_arg2>
lambda<lambda_operator<relational<greater>, T_arg1, T_arg2> >
operator > (const lambda<T_arg1>& a1, const lambda<T_arg2>& a2)
{ typedef lambda_operator<relational<greater>, T_arg1, T_arg2> operator_type;
  return lambda<operator_type>(operator_type(a1.value_,a2.value_)); }
template <class T_arg1, class T_arg2>
lambda<lambda_operator<relational<greater>, T_arg1, typename unwrap_reference<T_arg2>::type> >
operator > (const lambda<T_arg1>& a1, const T_arg2& a2)
{ typedef lambda_operator<relational<greater>, T_arg1, typename unwrap_reference<T_arg2>::type> operator_type;
  return lambda<operator_type>(operator_type(a1.value_,a2)); }
template <class T_arg1, class T_arg2>
lambda<lambda_operator<relational<greater>, typename unwrap_reference<T_arg1>::type, T_arg2> >
operator > (const T_arg1& a1, const lambda<T_arg2>& a2)
{ typedef lambda_operator<relational<greater>, typename unwrap_reference<T_arg1>::type, T_arg2> operator_type;
  return lambda<operator_type>(operator_type(a1,a2.value_)); }
template <class T_arg1, class T_arg2>
lambda<lambda_operator<relational<less_equal>, T_arg1, T_arg2> >
operator <= (const lambda<T_arg1>& a1, const lambda<T_arg2>& a2)
{ typedef lambda_operator<relational<less_equal>, T_arg1, T_arg2> operator_type;
  return lambda<operator_type>(operator_type(a1.value_,a2.value_)); }
template <class T_arg1, class T_arg2>
lambda<lambda_operator<relational<less_equal>, T_arg1, typename unwrap_reference<T_arg2>::type> >
operator <= (const lambda<T_arg1>& a1, const T_arg2& a2)
{ typedef lambda_operator<relational<less_equal>, T_arg1, typename unwrap_reference<T_arg2>::type> operator_type;
  return lambda<operator_type>(operator_type(a1.value_,a2)); }
template <class T_arg1, class T_arg2>
lambda<lambda_operator<relational<less_equal>, typename unwrap_reference<T_arg1>::type, T_arg2> >
operator <= (const T_arg1& a1, const lambda<T_arg2>& a2)
{ typedef lambda_operator<relational<less_equal>, typename unwrap_reference<T_arg1>::type, T_arg2> operator_type;
  return lambda<operator_type>(operator_type(a1,a2.value_)); }
template <class T_arg1, class T_arg2>
lambda<lambda_operator<relational<greater_equal>, T_arg1, T_arg2> >
operator >= (const lambda<T_arg1>& a1, const lambda<T_arg2>& a2)
{ typedef lambda_operator<relational<greater_equal>, T_arg1, T_arg2> operator_type;
  return lambda<operator_type>(operator_type(a1.value_,a2.value_)); }
template <class T_arg1, class T_arg2>
lambda<lambda_operator<relational<greater_equal>, T_arg1, typename unwrap_reference<T_arg2>::type> >
operator >= (const lambda<T_arg1>& a1, const T_arg2& a2)
{ typedef lambda_operator<relational<greater_equal>, T_arg1, typename unwrap_reference<T_arg2>::type> operator_type;
  return lambda<operator_type>(operator_type(a1.value_,a2)); }
template <class T_arg1, class T_arg2>
lambda<lambda_operator<relational<greater_equal>, typename unwrap_reference<T_arg1>::type, T_arg2> >
operator >= (const T_arg1& a1, const lambda<T_arg2>& a2)
{ typedef lambda_operator<relational<greater_equal>, typename unwrap_reference<T_arg1>::type, T_arg2> operator_type;
  return lambda<operator_type>(operator_type(a1,a2.value_)); }
template <class T_arg1, class T_arg2>
lambda<lambda_operator<relational<equal_to>, T_arg1, T_arg2> >
operator == (const lambda<T_arg1>& a1, const lambda<T_arg2>& a2)
{ typedef lambda_operator<relational<equal_to>, T_arg1, T_arg2> operator_type;
  return lambda<operator_type>(operator_type(a1.value_,a2.value_)); }
template <class T_arg1, class T_arg2>
lambda<lambda_operator<relational<equal_to>, T_arg1, typename unwrap_reference<T_arg2>::type> >
operator == (const lambda<T_arg1>& a1, const T_arg2& a2)
{ typedef lambda_operator<relational<equal_to>, T_arg1, typename unwrap_reference<T_arg2>::type> operator_type;
  return lambda<operator_type>(operator_type(a1.value_,a2)); }
template <class T_arg1, class T_arg2>
lambda<lambda_operator<relational<equal_to>, typename unwrap_reference<T_arg1>::type, T_arg2> >
operator == (const T_arg1& a1, const lambda<T_arg2>& a2)
{ typedef lambda_operator<relational<equal_to>, typename unwrap_reference<T_arg1>::type, T_arg2> operator_type;
  return lambda<operator_type>(operator_type(a1,a2.value_)); }
template <class T_arg1, class T_arg2>
lambda<lambda_operator<relational<not_equal_to>, T_arg1, T_arg2> >
operator != (const lambda<T_arg1>& a1, const lambda<T_arg2>& a2)
{ typedef lambda_operator<relational<not_equal_to>, T_arg1, T_arg2> operator_type;
  return lambda<operator_type>(operator_type(a1.value_,a2.value_)); }
template <class T_arg1, class T_arg2>
lambda<lambda_operator<relational<not_equal_to>, T_arg1, typename unwrap_reference<T_arg2>::type> >
operator != (const lambda<T_arg1>& a1, const T_arg2& a2)
{ typedef lambda_operator<relational<not_equal_to>, T_arg1, typename unwrap_reference<T_arg2>::type> operator_type;
  return lambda<operator_type>(operator_type(a1.value_,a2)); }
template <class T_arg1, class T_arg2>
lambda<lambda_operator<relational<not_equal_to>, typename unwrap_reference<T_arg1>::type, T_arg2> >
operator != (const T_arg1& a1, const lambda<T_arg2>& a2)
{ typedef lambda_operator<relational<not_equal_to>, typename unwrap_reference<T_arg1>::type, T_arg2> operator_type;
  return lambda<operator_type>(operator_type(a1,a2.value_)); }
template <class T_arg1, class T_arg2>
lambda<lambda_operator<arithmetic_assign<plus>, T_arg1, T_arg2> >
operator += (const lambda<T_arg1>& a1, const lambda<T_arg2>& a2)
{ typedef lambda_operator<arithmetic_assign<plus>, T_arg1, T_arg2> operator_type;
  return lambda<operator_type>(operator_type(a1.value_,a2.value_)); }
template <class T_arg1, class T_arg2>
lambda<lambda_operator<arithmetic_assign<plus>, T_arg1, typename unwrap_reference<T_arg2>::type> >
operator += (const lambda<T_arg1>& a1, const T_arg2& a2)
{ typedef lambda_operator<arithmetic_assign<plus>, T_arg1, typename unwrap_reference<T_arg2>::type> operator_type;
  return lambda<operator_type>(operator_type(a1.value_,a2)); }
template <class T_arg1, class T_arg2>
lambda<lambda_operator<arithmetic_assign<plus>, typename unwrap_reference<T_arg1>::type, T_arg2> >
operator += (const T_arg1& a1, const lambda<T_arg2>& a2)
{ typedef lambda_operator<arithmetic_assign<plus>, typename unwrap_reference<T_arg1>::type, T_arg2> operator_type;
  return lambda<operator_type>(operator_type(a1,a2.value_)); }
template <class T_arg1, class T_arg2>
lambda<lambda_operator<arithmetic_assign<minus>, T_arg1, T_arg2> >
operator -= (const lambda<T_arg1>& a1, const lambda<T_arg2>& a2)
{ typedef lambda_operator<arithmetic_assign<minus>, T_arg1, T_arg2> operator_type;
  return lambda<operator_type>(operator_type(a1.value_,a2.value_)); }
template <class T_arg1, class T_arg2>
lambda<lambda_operator<arithmetic_assign<minus>, T_arg1, typename unwrap_reference<T_arg2>::type> >
operator -= (const lambda<T_arg1>& a1, const T_arg2& a2)
{ typedef lambda_operator<arithmetic_assign<minus>, T_arg1, typename unwrap_reference<T_arg2>::type> operator_type;
  return lambda<operator_type>(operator_type(a1.value_,a2)); }
template <class T_arg1, class T_arg2>
lambda<lambda_operator<arithmetic_assign<minus>, typename unwrap_reference<T_arg1>::type, T_arg2> >
operator -= (const T_arg1& a1, const lambda<T_arg2>& a2)
{ typedef lambda_operator<arithmetic_assign<minus>, typename unwrap_reference<T_arg1>::type, T_arg2> operator_type;
  return lambda<operator_type>(operator_type(a1,a2.value_)); }
template <class T_arg1, class T_arg2>
lambda<lambda_operator<arithmetic_assign<multiplies>, T_arg1, T_arg2> >
operator *= (const lambda<T_arg1>& a1, const lambda<T_arg2>& a2)
{ typedef lambda_operator<arithmetic_assign<multiplies>, T_arg1, T_arg2> operator_type;
  return lambda<operator_type>(operator_type(a1.value_,a2.value_)); }
template <class T_arg1, class T_arg2>
lambda<lambda_operator<arithmetic_assign<multiplies>, T_arg1, typename unwrap_reference<T_arg2>::type> >
operator *= (const lambda<T_arg1>& a1, const T_arg2& a2)
{ typedef lambda_operator<arithmetic_assign<multiplies>, T_arg1, typename unwrap_reference<T_arg2>::type> operator_type;
  return lambda<operator_type>(operator_type(a1.value_,a2)); }
template <class T_arg1, class T_arg2>
lambda<lambda_operator<arithmetic_assign<multiplies>, typename unwrap_reference<T_arg1>::type, T_arg2> >
operator *= (const T_arg1& a1, const lambda<T_arg2>& a2)
{ typedef lambda_operator<arithmetic_assign<multiplies>, typename unwrap_reference<T_arg1>::type, T_arg2> operator_type;
  return lambda<operator_type>(operator_type(a1,a2.value_)); }
template <class T_arg1, class T_arg2>
lambda<lambda_operator<arithmetic_assign<divides>, T_arg1, T_arg2> >
operator /= (const lambda<T_arg1>& a1, const lambda<T_arg2>& a2)
{ typedef lambda_operator<arithmetic_assign<divides>, T_arg1, T_arg2> operator_type;
  return lambda<operator_type>(operator_type(a1.value_,a2.value_)); }
template <class T_arg1, class T_arg2>
lambda<lambda_operator<arithmetic_assign<divides>, T_arg1, typename unwrap_reference<T_arg2>::type> >
operator /= (const lambda<T_arg1>& a1, const T_arg2& a2)
{ typedef lambda_operator<arithmetic_assign<divides>, T_arg1, typename unwrap_reference<T_arg2>::type> operator_type;
  return lambda<operator_type>(operator_type(a1.value_,a2)); }
template <class T_arg1, class T_arg2>
lambda<lambda_operator<arithmetic_assign<divides>, typename unwrap_reference<T_arg1>::type, T_arg2> >
operator /= (const T_arg1& a1, const lambda<T_arg2>& a2)
{ typedef lambda_operator<arithmetic_assign<divides>, typename unwrap_reference<T_arg1>::type, T_arg2> operator_type;
  return lambda<operator_type>(operator_type(a1,a2.value_)); }
template <class T_arg1, class T_arg2>
lambda<lambda_operator<arithmetic_assign<modulus>, T_arg1, T_arg2> >
operator %= (const lambda<T_arg1>& a1, const lambda<T_arg2>& a2)
{ typedef lambda_operator<arithmetic_assign<modulus>, T_arg1, T_arg2> operator_type;
  return lambda<operator_type>(operator_type(a1.value_,a2.value_)); }
template <class T_arg1, class T_arg2>
lambda<lambda_operator<arithmetic_assign<modulus>, T_arg1, typename unwrap_reference<T_arg2>::type> >
operator %= (const lambda<T_arg1>& a1, const T_arg2& a2)
{ typedef lambda_operator<arithmetic_assign<modulus>, T_arg1, typename unwrap_reference<T_arg2>::type> operator_type;
  return lambda<operator_type>(operator_type(a1.value_,a2)); }
template <class T_arg1, class T_arg2>
lambda<lambda_operator<arithmetic_assign<modulus>, typename unwrap_reference<T_arg1>::type, T_arg2> >
operator %= (const T_arg1& a1, const lambda<T_arg2>& a2)
{ typedef lambda_operator<arithmetic_assign<modulus>, typename unwrap_reference<T_arg1>::type, T_arg2> operator_type;
  return lambda<operator_type>(operator_type(a1,a2.value_)); }
template <class T_arg1, class T_arg2>
lambda<lambda_operator<bitwise_assign<leftshift>, T_arg1, T_arg2> >
operator <<= (const lambda<T_arg1>& a1, const lambda<T_arg2>& a2)
{ typedef lambda_operator<bitwise_assign<leftshift>, T_arg1, T_arg2> operator_type;
  return lambda<operator_type>(operator_type(a1.value_,a2.value_)); }
template <class T_arg1, class T_arg2>
lambda<lambda_operator<bitwise_assign<leftshift>, T_arg1, typename unwrap_reference<T_arg2>::type> >
operator <<= (const lambda<T_arg1>& a1, const T_arg2& a2)
{ typedef lambda_operator<bitwise_assign<leftshift>, T_arg1, typename unwrap_reference<T_arg2>::type> operator_type;
  return lambda<operator_type>(operator_type(a1.value_,a2)); }
template <class T_arg1, class T_arg2>
lambda<lambda_operator<bitwise_assign<leftshift>, typename unwrap_reference<T_arg1>::type, T_arg2> >
operator <<= (const T_arg1& a1, const lambda<T_arg2>& a2)
{ typedef lambda_operator<bitwise_assign<leftshift>, typename unwrap_reference<T_arg1>::type, T_arg2> operator_type;
  return lambda<operator_type>(operator_type(a1,a2.value_)); }
template <class T_arg1, class T_arg2>
lambda<lambda_operator<bitwise_assign<rightshift>, T_arg1, T_arg2> >
operator >>= (const lambda<T_arg1>& a1, const lambda<T_arg2>& a2)
{ typedef lambda_operator<bitwise_assign<rightshift>, T_arg1, T_arg2> operator_type;
  return lambda<operator_type>(operator_type(a1.value_,a2.value_)); }
template <class T_arg1, class T_arg2>
lambda<lambda_operator<bitwise_assign<rightshift>, T_arg1, typename unwrap_reference<T_arg2>::type> >
operator >>= (const lambda<T_arg1>& a1, const T_arg2& a2)
{ typedef lambda_operator<bitwise_assign<rightshift>, T_arg1, typename unwrap_reference<T_arg2>::type> operator_type;
  return lambda<operator_type>(operator_type(a1.value_,a2)); }
template <class T_arg1, class T_arg2>
lambda<lambda_operator<bitwise_assign<rightshift>, typename unwrap_reference<T_arg1>::type, T_arg2> >
operator >>= (const T_arg1& a1, const lambda<T_arg2>& a2)
{ typedef lambda_operator<bitwise_assign<rightshift>, typename unwrap_reference<T_arg1>::type, T_arg2> operator_type;
  return lambda<operator_type>(operator_type(a1,a2.value_)); }
template <class T_arg1, class T_arg2>
lambda<lambda_operator<bitwise_assign<and_>, T_arg1, T_arg2> >
operator &= (const lambda<T_arg1>& a1, const lambda<T_arg2>& a2)
{ typedef lambda_operator<bitwise_assign<and_>, T_arg1, T_arg2> operator_type;
  return lambda<operator_type>(operator_type(a1.value_,a2.value_)); }
template <class T_arg1, class T_arg2>
lambda<lambda_operator<bitwise_assign<and_>, T_arg1, typename unwrap_reference<T_arg2>::type> >
operator &= (const lambda<T_arg1>& a1, const T_arg2& a2)
{ typedef lambda_operator<bitwise_assign<and_>, T_arg1, typename unwrap_reference<T_arg2>::type> operator_type;
  return lambda<operator_type>(operator_type(a1.value_,a2)); }
template <class T_arg1, class T_arg2>
lambda<lambda_operator<bitwise_assign<and_>, typename unwrap_reference<T_arg1>::type, T_arg2> >
operator &= (const T_arg1& a1, const lambda<T_arg2>& a2)
{ typedef lambda_operator<bitwise_assign<and_>, typename unwrap_reference<T_arg1>::type, T_arg2> operator_type;
  return lambda<operator_type>(operator_type(a1,a2.value_)); }
template <class T_arg1, class T_arg2>
lambda<lambda_operator<bitwise_assign<or_>, T_arg1, T_arg2> >
operator |= (const lambda<T_arg1>& a1, const lambda<T_arg2>& a2)
{ typedef lambda_operator<bitwise_assign<or_>, T_arg1, T_arg2> operator_type;
  return lambda<operator_type>(operator_type(a1.value_,a2.value_)); }
template <class T_arg1, class T_arg2>
lambda<lambda_operator<bitwise_assign<or_>, T_arg1, typename unwrap_reference<T_arg2>::type> >
operator |= (const lambda<T_arg1>& a1, const T_arg2& a2)
{ typedef lambda_operator<bitwise_assign<or_>, T_arg1, typename unwrap_reference<T_arg2>::type> operator_type;
  return lambda<operator_type>(operator_type(a1.value_,a2)); }
template <class T_arg1, class T_arg2>
lambda<lambda_operator<bitwise_assign<or_>, typename unwrap_reference<T_arg1>::type, T_arg2> >
operator |= (const T_arg1& a1, const lambda<T_arg2>& a2)
{ typedef lambda_operator<bitwise_assign<or_>, typename unwrap_reference<T_arg1>::type, T_arg2> operator_type;
  return lambda<operator_type>(operator_type(a1,a2.value_)); }
template <class T_arg1, class T_arg2>
lambda<lambda_operator<bitwise_assign<xor_>, T_arg1, T_arg2> >
operator ^= (const lambda<T_arg1>& a1, const lambda<T_arg2>& a2)
{ typedef lambda_operator<bitwise_assign<xor_>, T_arg1, T_arg2> operator_type;
  return lambda<operator_type>(operator_type(a1.value_,a2.value_)); }
template <class T_arg1, class T_arg2>
lambda<lambda_operator<bitwise_assign<xor_>, T_arg1, typename unwrap_reference<T_arg2>::type> >
operator ^= (const lambda<T_arg1>& a1, const T_arg2& a2)
{ typedef lambda_operator<bitwise_assign<xor_>, T_arg1, typename unwrap_reference<T_arg2>::type> operator_type;
  return lambda<operator_type>(operator_type(a1.value_,a2)); }
template <class T_arg1, class T_arg2>
lambda<lambda_operator<bitwise_assign<xor_>, typename unwrap_reference<T_arg1>::type, T_arg2> >
operator ^= (const T_arg1& a1, const lambda<T_arg2>& a2)
{ typedef lambda_operator<bitwise_assign<xor_>, typename unwrap_reference<T_arg1>::type, T_arg2> operator_type;
  return lambda<operator_type>(operator_type(a1,a2.value_)); }
template <class T_arg>
lambda<lambda_operator_unary<unary_arithmetic<pre_increment>, T_arg> >
operator ++ (const lambda<T_arg>& a)
{ typedef lambda_operator_unary<unary_arithmetic<pre_increment>, T_arg> operator_type;
  return lambda<operator_type>(operator_type(a.value_)); }
template <class T_arg>
lambda<lambda_operator_unary<unary_arithmetic<pre_decrement>, T_arg> >
operator -- (const lambda<T_arg>& a)
{ typedef lambda_operator_unary<unary_arithmetic<pre_decrement>, T_arg> operator_type;
  return lambda<operator_type>(operator_type(a.value_)); }
template <class T_arg>
lambda<lambda_operator_unary<unary_arithmetic<negate>, T_arg> >
operator - (const lambda<T_arg>& a)
{ typedef lambda_operator_unary<unary_arithmetic<negate>, T_arg> operator_type;
  return lambda<operator_type>(operator_type(a.value_)); }
template <class T_arg>
lambda<lambda_operator_unary<unary_bitwise<not_>, T_arg> >
operator ~ (const lambda<T_arg>& a)
{ typedef lambda_operator_unary<unary_bitwise<not_>, T_arg> operator_type;
  return lambda<operator_type>(operator_type(a.value_)); }
template <class T_arg>
lambda<lambda_operator_unary<unary_logical<not_>, T_arg> >
operator ! (const lambda<T_arg>& a)
{ typedef lambda_operator_unary<unary_logical<not_>, T_arg> operator_type;
  return lambda<operator_type>(operator_type(a.value_)); }
template <class T_arg>
lambda<lambda_operator_unary<unary_other<address>, T_arg> >
operator & (const lambda<T_arg>& a)
{ typedef lambda_operator_unary<unary_other<address>, T_arg> operator_type;
  return lambda<operator_type>(operator_type(a.value_)); }
template <class T_arg>
lambda<lambda_operator_unary<unary_other<dereference>, T_arg> >
operator * (const lambda<T_arg>& a)
{ typedef lambda_operator_unary<unary_other<dereference>, T_arg> operator_type;
  return lambda<operator_type>(operator_type(a.value_)); }
template <class T_type, class T_arg>
lambda<lambda_operator_convert<cast_<reinterpret_>, T_type, typename unwrap_lambda_type<T_arg>::type> >
reinterpret_cast_(const T_arg& a)
{ typedef lambda_operator_convert<cast_<reinterpret_>, T_type, typename unwrap_lambda_type<T_arg>::type> operator_type;
  return lambda<operator_type>(operator_type(unwrap_lambda_value(a))); }
template <class T_type, class T_arg>
lambda<lambda_operator_convert<cast_<static_>, T_type, typename unwrap_lambda_type<T_arg>::type> >
static_cast_(const T_arg& a)
{ typedef lambda_operator_convert<cast_<static_>, T_type, typename unwrap_lambda_type<T_arg>::type> operator_type;
  return lambda<operator_type>(operator_type(unwrap_lambda_value(a))); }
template <class T_type, class T_arg>
lambda<lambda_operator_convert<cast_<dynamic_>, T_type, typename unwrap_lambda_type<T_arg>::type> >
dynamic_cast_(const T_arg& a)
{ typedef lambda_operator_convert<cast_<dynamic_>, T_type, typename unwrap_lambda_type<T_arg>::type> operator_type;
  return lambda<operator_type>(operator_type(unwrap_lambda_value(a))); }
}
namespace sigc {
template <class T_functor, class T_type1>
struct lambda_group1 : public lambda_base
{
  typedef typename functor_trait<T_functor>::result_type result_type;
  typedef typename lambda<T_type1>::lambda_type value1_type;
  typedef typename adaptor_trait<T_functor>::adaptor_type functor_type;
  template <class T_arg1=void,class T_arg2=void,class T_arg3=void,class T_arg4=void,class T_arg5=void,class T_arg6=void,class T_arg7=void>
  struct deduce_result_type
    { typedef typename functor_type::template deduce_result_type<
          typename value1_type::template deduce_result_type<
            typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass,typename type_trait<T_arg6>::pass,typename type_trait<T_arg7>::pass>::type
        >::type type; };
  result_type
  operator ()() const;
  template <class T_arg1>
  typename deduce_result_type<T_arg1>::type
  operator() (T_arg1 _A_1) const
    { return this->func_.template operator()<
          typename value1_type::template deduce_result_type<T_arg1>::type>(
        this->value1_.template operator()<
          typename type_trait<T_arg1>::pass>(_A_1)); }
  template <class T_arg1,class T_arg2>
  typename deduce_result_type<T_arg1,T_arg2>::type
  operator() (T_arg1 _A_1,T_arg2 _A_2) const
    { return this->func_.template operator()<
          typename value1_type::template deduce_result_type<T_arg1,T_arg2>::type>(
        this->value1_.template operator()<
          typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass>(_A_1,_A_2)); }
  template <class T_arg1,class T_arg2,class T_arg3>
  typename deduce_result_type<T_arg1,T_arg2,T_arg3>::type
  operator() (T_arg1 _A_1,T_arg2 _A_2,T_arg3 _A_3) const
    { return this->func_.template operator()<
          typename value1_type::template deduce_result_type<T_arg1,T_arg2,T_arg3>::type>(
        this->value1_.template operator()<
          typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass>(_A_1,_A_2,_A_3)); }
  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4>
  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4>::type
  operator() (T_arg1 _A_1,T_arg2 _A_2,T_arg3 _A_3,T_arg4 _A_4) const
    { return this->func_.template operator()<
          typename value1_type::template deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4>::type>(
        this->value1_.template operator()<
          typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass>(_A_1,_A_2,_A_3,_A_4)); }
  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>::type
  operator() (T_arg1 _A_1,T_arg2 _A_2,T_arg3 _A_3,T_arg4 _A_4,T_arg5 _A_5) const
    { return this->func_.template operator()<
          typename value1_type::template deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>::type>(
        this->value1_.template operator()<
          typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass>(_A_1,_A_2,_A_3,_A_4,_A_5)); }
  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>::type
  operator() (T_arg1 _A_1,T_arg2 _A_2,T_arg3 _A_3,T_arg4 _A_4,T_arg5 _A_5,T_arg6 _A_6) const
    { return this->func_.template operator()<
          typename value1_type::template deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>::type>(
        this->value1_.template operator()<
          typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass,typename type_trait<T_arg6>::pass>(_A_1,_A_2,_A_3,_A_4,_A_5,_A_6)); }
  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>::type
  operator() (T_arg1 _A_1,T_arg2 _A_2,T_arg3 _A_3,T_arg4 _A_4,T_arg5 _A_5,T_arg6 _A_6,T_arg7 _A_7) const
    { return this->func_.template operator()<
          typename value1_type::template deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>::type>(
        this->value1_.template operator()<
          typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass,typename type_trait<T_arg6>::pass,typename type_trait<T_arg7>::pass>(_A_1,_A_2,_A_3,_A_4,_A_5,_A_6,_A_7)); }
  lambda_group1(typename type_trait<T_functor>::take _A_func, typename type_trait<T_type1>::take _A_1)
    : value1_(_A_1), func_(_A_func) {}
  value1_type value1_;
  mutable functor_type func_;
};
template <class T_functor, class T_type1>
typename lambda_group1<T_functor, T_type1>::result_type
lambda_group1<T_functor, T_type1>::operator ()() const
  { return func_(value1_()); }
template <class T_action, class T_functor, class T_type1>
void visit_each(const T_action& _A_action,
                const lambda_group1<T_functor, T_type1>& _A_target)
{
  visit_each(_A_action, _A_target.value1_);
  visit_each(_A_action, _A_target.func_);
}
template <class T_functor, class T_type1,class T_type2>
struct lambda_group2 : public lambda_base
{
  typedef typename functor_trait<T_functor>::result_type result_type;
  typedef typename lambda<T_type1>::lambda_type value1_type;
  typedef typename lambda<T_type2>::lambda_type value2_type;
  typedef typename adaptor_trait<T_functor>::adaptor_type functor_type;
  template <class T_arg1=void,class T_arg2=void,class T_arg3=void,class T_arg4=void,class T_arg5=void,class T_arg6=void,class T_arg7=void>
  struct deduce_result_type
    { typedef typename functor_type::template deduce_result_type<
          typename value1_type::template deduce_result_type<
            typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass,typename type_trait<T_arg6>::pass,typename type_trait<T_arg7>::pass>::type,
          typename value2_type::template deduce_result_type<
            typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass,typename type_trait<T_arg6>::pass,typename type_trait<T_arg7>::pass>::type
        >::type type; };
  result_type
  operator ()() const;
  template <class T_arg1>
  typename deduce_result_type<T_arg1>::type
  operator() (T_arg1 _A_1) const
    { return this->func_.template operator()<
          typename value1_type::template deduce_result_type<T_arg1>::type,
          typename value2_type::template deduce_result_type<T_arg1>::type>(
        this->value1_.template operator()<
          typename type_trait<T_arg1>::pass>(_A_1),
        this->value2_.template operator()<
          typename type_trait<T_arg1>::pass>(_A_1)); }
  template <class T_arg1,class T_arg2>
  typename deduce_result_type<T_arg1,T_arg2>::type
  operator() (T_arg1 _A_1,T_arg2 _A_2) const
    { return this->func_.template operator()<
          typename value1_type::template deduce_result_type<T_arg1,T_arg2>::type,
          typename value2_type::template deduce_result_type<T_arg1,T_arg2>::type>(
        this->value1_.template operator()<
          typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass>(_A_1,_A_2),
        this->value2_.template operator()<
          typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass>(_A_1,_A_2)); }
  template <class T_arg1,class T_arg2,class T_arg3>
  typename deduce_result_type<T_arg1,T_arg2,T_arg3>::type
  operator() (T_arg1 _A_1,T_arg2 _A_2,T_arg3 _A_3) const
    { return this->func_.template operator()<
          typename value1_type::template deduce_result_type<T_arg1,T_arg2,T_arg3>::type,
          typename value2_type::template deduce_result_type<T_arg1,T_arg2,T_arg3>::type>(
        this->value1_.template operator()<
          typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass>(_A_1,_A_2,_A_3),
        this->value2_.template operator()<
          typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass>(_A_1,_A_2,_A_3)); }
  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4>
  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4>::type
  operator() (T_arg1 _A_1,T_arg2 _A_2,T_arg3 _A_3,T_arg4 _A_4) const
    { return this->func_.template operator()<
          typename value1_type::template deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4>::type,
          typename value2_type::template deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4>::type>(
        this->value1_.template operator()<
          typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass>(_A_1,_A_2,_A_3,_A_4),
        this->value2_.template operator()<
          typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass>(_A_1,_A_2,_A_3,_A_4)); }
  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>::type
  operator() (T_arg1 _A_1,T_arg2 _A_2,T_arg3 _A_3,T_arg4 _A_4,T_arg5 _A_5) const
    { return this->func_.template operator()<
          typename value1_type::template deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>::type,
          typename value2_type::template deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>::type>(
        this->value1_.template operator()<
          typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass>(_A_1,_A_2,_A_3,_A_4,_A_5),
        this->value2_.template operator()<
          typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass>(_A_1,_A_2,_A_3,_A_4,_A_5)); }
  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>::type
  operator() (T_arg1 _A_1,T_arg2 _A_2,T_arg3 _A_3,T_arg4 _A_4,T_arg5 _A_5,T_arg6 _A_6) const
    { return this->func_.template operator()<
          typename value1_type::template deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>::type,
          typename value2_type::template deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>::type>(
        this->value1_.template operator()<
          typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass,typename type_trait<T_arg6>::pass>(_A_1,_A_2,_A_3,_A_4,_A_5,_A_6),
        this->value2_.template operator()<
          typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass,typename type_trait<T_arg6>::pass>(_A_1,_A_2,_A_3,_A_4,_A_5,_A_6)); }
  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>::type
  operator() (T_arg1 _A_1,T_arg2 _A_2,T_arg3 _A_3,T_arg4 _A_4,T_arg5 _A_5,T_arg6 _A_6,T_arg7 _A_7) const
    { return this->func_.template operator()<
          typename value1_type::template deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>::type,
          typename value2_type::template deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>::type>(
        this->value1_.template operator()<
          typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass,typename type_trait<T_arg6>::pass,typename type_trait<T_arg7>::pass>(_A_1,_A_2,_A_3,_A_4,_A_5,_A_6,_A_7),
        this->value2_.template operator()<
          typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass,typename type_trait<T_arg6>::pass,typename type_trait<T_arg7>::pass>(_A_1,_A_2,_A_3,_A_4,_A_5,_A_6,_A_7)); }
  lambda_group2(typename type_trait<T_functor>::take _A_func, typename type_trait<T_type1>::take _A_1,typename type_trait<T_type2>::take _A_2)
    : value1_(_A_1),value2_(_A_2), func_(_A_func) {}
  value1_type value1_;
  value2_type value2_;
  mutable functor_type func_;
};
template <class T_functor, class T_type1,class T_type2>
typename lambda_group2<T_functor, T_type1,T_type2>::result_type
lambda_group2<T_functor, T_type1,T_type2>::operator ()() const
  { return func_(value1_(),value2_()); }
template <class T_action, class T_functor, class T_type1,class T_type2>
void visit_each(const T_action& _A_action,
                const lambda_group2<T_functor, T_type1,T_type2>& _A_target)
{
  visit_each(_A_action, _A_target.value1_);
  visit_each(_A_action, _A_target.value2_);
  visit_each(_A_action, _A_target.func_);
}
template <class T_functor, class T_type1,class T_type2,class T_type3>
struct lambda_group3 : public lambda_base
{
  typedef typename functor_trait<T_functor>::result_type result_type;
  typedef typename lambda<T_type1>::lambda_type value1_type;
  typedef typename lambda<T_type2>::lambda_type value2_type;
  typedef typename lambda<T_type3>::lambda_type value3_type;
  typedef typename adaptor_trait<T_functor>::adaptor_type functor_type;
  template <class T_arg1=void,class T_arg2=void,class T_arg3=void,class T_arg4=void,class T_arg5=void,class T_arg6=void,class T_arg7=void>
  struct deduce_result_type
    { typedef typename functor_type::template deduce_result_type<
          typename value1_type::template deduce_result_type<
            typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass,typename type_trait<T_arg6>::pass,typename type_trait<T_arg7>::pass>::type,
          typename value2_type::template deduce_result_type<
            typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass,typename type_trait<T_arg6>::pass,typename type_trait<T_arg7>::pass>::type,
          typename value3_type::template deduce_result_type<
            typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass,typename type_trait<T_arg6>::pass,typename type_trait<T_arg7>::pass>::type
        >::type type; };
  result_type
  operator ()() const;
  template <class T_arg1>
  typename deduce_result_type<T_arg1>::type
  operator() (T_arg1 _A_1) const
    { return this->func_.template operator()<
          typename value1_type::template deduce_result_type<T_arg1>::type,
          typename value2_type::template deduce_result_type<T_arg1>::type,
          typename value3_type::template deduce_result_type<T_arg1>::type>(
        this->value1_.template operator()<
          typename type_trait<T_arg1>::pass>(_A_1),
        this->value2_.template operator()<
          typename type_trait<T_arg1>::pass>(_A_1),
        this->value3_.template operator()<
          typename type_trait<T_arg1>::pass>(_A_1)); }
  template <class T_arg1,class T_arg2>
  typename deduce_result_type<T_arg1,T_arg2>::type
  operator() (T_arg1 _A_1,T_arg2 _A_2) const
    { return this->func_.template operator()<
          typename value1_type::template deduce_result_type<T_arg1,T_arg2>::type,
          typename value2_type::template deduce_result_type<T_arg1,T_arg2>::type,
          typename value3_type::template deduce_result_type<T_arg1,T_arg2>::type>(
        this->value1_.template operator()<
          typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass>(_A_1,_A_2),
        this->value2_.template operator()<
          typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass>(_A_1,_A_2),
        this->value3_.template operator()<
          typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass>(_A_1,_A_2)); }
  template <class T_arg1,class T_arg2,class T_arg3>
  typename deduce_result_type<T_arg1,T_arg2,T_arg3>::type
  operator() (T_arg1 _A_1,T_arg2 _A_2,T_arg3 _A_3) const
    { return this->func_.template operator()<
          typename value1_type::template deduce_result_type<T_arg1,T_arg2,T_arg3>::type,
          typename value2_type::template deduce_result_type<T_arg1,T_arg2,T_arg3>::type,
          typename value3_type::template deduce_result_type<T_arg1,T_arg2,T_arg3>::type>(
        this->value1_.template operator()<
          typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass>(_A_1,_A_2,_A_3),
        this->value2_.template operator()<
          typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass>(_A_1,_A_2,_A_3),
        this->value3_.template operator()<
          typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass>(_A_1,_A_2,_A_3)); }
  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4>
  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4>::type
  operator() (T_arg1 _A_1,T_arg2 _A_2,T_arg3 _A_3,T_arg4 _A_4) const
    { return this->func_.template operator()<
          typename value1_type::template deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4>::type,
          typename value2_type::template deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4>::type,
          typename value3_type::template deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4>::type>(
        this->value1_.template operator()<
          typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass>(_A_1,_A_2,_A_3,_A_4),
        this->value2_.template operator()<
          typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass>(_A_1,_A_2,_A_3,_A_4),
        this->value3_.template operator()<
          typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass>(_A_1,_A_2,_A_3,_A_4)); }
  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>::type
  operator() (T_arg1 _A_1,T_arg2 _A_2,T_arg3 _A_3,T_arg4 _A_4,T_arg5 _A_5) const
    { return this->func_.template operator()<
          typename value1_type::template deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>::type,
          typename value2_type::template deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>::type,
          typename value3_type::template deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>::type>(
        this->value1_.template operator()<
          typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass>(_A_1,_A_2,_A_3,_A_4,_A_5),
        this->value2_.template operator()<
          typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass>(_A_1,_A_2,_A_3,_A_4,_A_5),
        this->value3_.template operator()<
          typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass>(_A_1,_A_2,_A_3,_A_4,_A_5)); }
  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>::type
  operator() (T_arg1 _A_1,T_arg2 _A_2,T_arg3 _A_3,T_arg4 _A_4,T_arg5 _A_5,T_arg6 _A_6) const
    { return this->func_.template operator()<
          typename value1_type::template deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>::type,
          typename value2_type::template deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>::type,
          typename value3_type::template deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>::type>(
        this->value1_.template operator()<
          typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass,typename type_trait<T_arg6>::pass>(_A_1,_A_2,_A_3,_A_4,_A_5,_A_6),
        this->value2_.template operator()<
          typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass,typename type_trait<T_arg6>::pass>(_A_1,_A_2,_A_3,_A_4,_A_5,_A_6),
        this->value3_.template operator()<
          typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass,typename type_trait<T_arg6>::pass>(_A_1,_A_2,_A_3,_A_4,_A_5,_A_6)); }
  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>::type
  operator() (T_arg1 _A_1,T_arg2 _A_2,T_arg3 _A_3,T_arg4 _A_4,T_arg5 _A_5,T_arg6 _A_6,T_arg7 _A_7) const
    { return this->func_.template operator()<
          typename value1_type::template deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>::type,
          typename value2_type::template deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>::type,
          typename value3_type::template deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>::type>(
        this->value1_.template operator()<
          typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass,typename type_trait<T_arg6>::pass,typename type_trait<T_arg7>::pass>(_A_1,_A_2,_A_3,_A_4,_A_5,_A_6,_A_7),
        this->value2_.template operator()<
          typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass,typename type_trait<T_arg6>::pass,typename type_trait<T_arg7>::pass>(_A_1,_A_2,_A_3,_A_4,_A_5,_A_6,_A_7),
        this->value3_.template operator()<
          typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass,typename type_trait<T_arg6>::pass,typename type_trait<T_arg7>::pass>(_A_1,_A_2,_A_3,_A_4,_A_5,_A_6,_A_7)); }
  lambda_group3(typename type_trait<T_functor>::take _A_func, typename type_trait<T_type1>::take _A_1,typename type_trait<T_type2>::take _A_2,typename type_trait<T_type3>::take _A_3)
    : value1_(_A_1),value2_(_A_2),value3_(_A_3), func_(_A_func) {}
  value1_type value1_;
  value2_type value2_;
  value3_type value3_;
  mutable functor_type func_;
};
template <class T_functor, class T_type1,class T_type2,class T_type3>
typename lambda_group3<T_functor, T_type1,T_type2,T_type3>::result_type
lambda_group3<T_functor, T_type1,T_type2,T_type3>::operator ()() const
  { return func_(value1_(),value2_(),value3_()); }
template <class T_action, class T_functor, class T_type1,class T_type2,class T_type3>
void visit_each(const T_action& _A_action,
                const lambda_group3<T_functor, T_type1,T_type2,T_type3>& _A_target)
{
  visit_each(_A_action, _A_target.value1_);
  visit_each(_A_action, _A_target.value2_);
  visit_each(_A_action, _A_target.value3_);
  visit_each(_A_action, _A_target.func_);
}
template <class T_functor, class T_type1>
lambda<lambda_group1<T_functor, typename unwrap_reference<T_type1>::type> >
group(const T_functor& _A_func, T_type1 _A_1)
{
  typedef lambda_group1<T_functor, typename unwrap_reference<T_type1>::type> T_lambda;
  return lambda<T_lambda>(T_lambda(_A_func, _A_1));
}
template <class T_functor, class T_type1,class T_type2>
lambda<lambda_group2<T_functor, typename unwrap_reference<T_type1>::type,typename unwrap_reference<T_type2>::type> >
group(const T_functor& _A_func, T_type1 _A_1,T_type2 _A_2)
{
  typedef lambda_group2<T_functor, typename unwrap_reference<T_type1>::type,typename unwrap_reference<T_type2>::type> T_lambda;
  return lambda<T_lambda>(T_lambda(_A_func, _A_1,_A_2));
}
template <class T_functor, class T_type1,class T_type2,class T_type3>
lambda<lambda_group3<T_functor, typename unwrap_reference<T_type1>::type,typename unwrap_reference<T_type2>::type,typename unwrap_reference<T_type3>::type> >
group(const T_functor& _A_func, T_type1 _A_1,T_type2 _A_2,T_type3 _A_3)
{
  typedef lambda_group3<T_functor, typename unwrap_reference<T_type1>::type,typename unwrap_reference<T_type2>::type,typename unwrap_reference<T_type3>::type> T_lambda;
  return lambda<T_lambda>(T_lambda(_A_func, _A_1,_A_2,_A_3));
}
}
typedef struct _GObject GObject;
typedef struct _GClosure GClosure;
namespace Glib
{
class SignalProxyConnectionNode
{
public:
  SignalProxyConnectionNode(const sigc::slot_base& slot, GObject* gobject);
  static void* notify(void* data);
  static void destroy_notify_handler(gpointer data, GClosure* closure);
  gulong connection_id_;
  sigc::slot_base slot_;
protected:
  GObject* object_;
};
}
namespace Glib
{
class ObjectBase;
struct SignalProxyInfo
{
  const char* signal_name;
  GCallback callback;
  GCallback notify_callback;
};
class SignalProxyBase
{
public:
  SignalProxyBase(Glib::ObjectBase* obj);
  static inline sigc::slot_base* data_to_slot(void* data)
  {
    SignalProxyConnectionNode *const pConnectionNode = static_cast<SignalProxyConnectionNode*>(data);
    return (!pConnectionNode->slot_.blocked()) ? &pConnectionNode->slot_ : 0;
  }
protected:
  ObjectBase* obj_;
private:
  SignalProxyBase& operator=(const SignalProxyBase&);
};
class SignalProxyNormal : public SignalProxyBase
{
public:
  ~SignalProxyNormal();
  void emission_stop();
  static void slot0_void_callback(GObject*, void* data);
protected:
  SignalProxyNormal(Glib::ObjectBase* obj, const SignalProxyInfo* info);
  sigc::slot_base& connect_(const sigc::slot_base& slot, bool after);
  sigc::slot_base& connect_notify_(const sigc::slot_base& slot, bool after);
private:
  const SignalProxyInfo* info_;
  sigc::slot_base& connect_impl_(GCallback callback, const sigc::slot_base& slot, bool after);
  SignalProxyNormal& operator=(const SignalProxyNormal&);
};
template <class R>
class SignalProxy0 : public SignalProxyNormal
{
public:
  typedef sigc::slot<R> SlotType;
  typedef sigc::slot<void> VoidSlotType;
  SignalProxy0(ObjectBase* obj, const SignalProxyInfo* info)
    : SignalProxyNormal(obj, info) {}
  sigc::connection connect(const SlotType& slot, bool after = true)
    { return sigc::connection(connect_(slot, after)); }
  sigc::connection connect_notify(const VoidSlotType& slot, bool after = false)
    { return sigc::connection(connect_notify_(slot, after)); }
};
template <class R,class P1>
class SignalProxy1 : public SignalProxyNormal
{
public:
  typedef sigc::slot<R,P1> SlotType;
  typedef sigc::slot<void,P1> VoidSlotType;
  SignalProxy1(ObjectBase* obj, const SignalProxyInfo* info)
    : SignalProxyNormal(obj, info) {}
  sigc::connection connect(const SlotType& slot, bool after = true)
    { return sigc::connection(connect_(slot, after)); }
  sigc::connection connect_notify(const VoidSlotType& slot, bool after = false)
    { return sigc::connection(connect_notify_(slot, after)); }
};
template <class R,class P1,class P2>
class SignalProxy2 : public SignalProxyNormal
{
public:
  typedef sigc::slot<R,P1,P2> SlotType;
  typedef sigc::slot<void,P1,P2> VoidSlotType;
  SignalProxy2(ObjectBase* obj, const SignalProxyInfo* info)
    : SignalProxyNormal(obj, info) {}
  sigc::connection connect(const SlotType& slot, bool after = true)
    { return sigc::connection(connect_(slot, after)); }
  sigc::connection connect_notify(const VoidSlotType& slot, bool after = false)
    { return sigc::connection(connect_notify_(slot, after)); }
};
template <class R,class P1,class P2,class P3>
class SignalProxy3 : public SignalProxyNormal
{
public:
  typedef sigc::slot<R,P1,P2,P3> SlotType;
  typedef sigc::slot<void,P1,P2,P3> VoidSlotType;
  SignalProxy3(ObjectBase* obj, const SignalProxyInfo* info)
    : SignalProxyNormal(obj, info) {}
  sigc::connection connect(const SlotType& slot, bool after = true)
    { return sigc::connection(connect_(slot, after)); }
  sigc::connection connect_notify(const VoidSlotType& slot, bool after = false)
    { return sigc::connection(connect_notify_(slot, after)); }
};
template <class R,class P1,class P2,class P3,class P4>
class SignalProxy4 : public SignalProxyNormal
{
public:
  typedef sigc::slot<R,P1,P2,P3,P4> SlotType;
  typedef sigc::slot<void,P1,P2,P3,P4> VoidSlotType;
  SignalProxy4(ObjectBase* obj, const SignalProxyInfo* info)
    : SignalProxyNormal(obj, info) {}
  sigc::connection connect(const SlotType& slot, bool after = true)
    { return sigc::connection(connect_(slot, after)); }
  sigc::connection connect_notify(const VoidSlotType& slot, bool after = false)
    { return sigc::connection(connect_notify_(slot, after)); }
};
template <class R,class P1,class P2,class P3,class P4,class P5>
class SignalProxy5 : public SignalProxyNormal
{
public:
  typedef sigc::slot<R,P1,P2,P3,P4,P5> SlotType;
  typedef sigc::slot<void,P1,P2,P3,P4,P5> VoidSlotType;
  SignalProxy5(ObjectBase* obj, const SignalProxyInfo* info)
    : SignalProxyNormal(obj, info) {}
  sigc::connection connect(const SlotType& slot, bool after = true)
    { return sigc::connection(connect_(slot, after)); }
  sigc::connection connect_notify(const VoidSlotType& slot, bool after = false)
    { return sigc::connection(connect_notify_(slot, after)); }
};
template <class R,class P1,class P2,class P3,class P4,class P5,class P6>
class SignalProxy6 : public SignalProxyNormal
{
public:
  typedef sigc::slot<R,P1,P2,P3,P4,P5,P6> SlotType;
  typedef sigc::slot<void,P1,P2,P3,P4,P5,P6> VoidSlotType;
  SignalProxy6(ObjectBase* obj, const SignalProxyInfo* info)
    : SignalProxyNormal(obj, info) {}
  sigc::connection connect(const SlotType& slot, bool after = true)
    { return sigc::connection(connect_(slot, after)); }
  sigc::connection connect_notify(const VoidSlotType& slot, bool after = false)
    { return sigc::connection(connect_notify_(slot, after)); }
};
}
namespace Glib
{
class ObjectBase;
class Object;
class ValueBase
{
public:
  ValueBase();
  ValueBase(const ValueBase& other);
  ValueBase& operator=(const ValueBase& other);
  ~ValueBase();
  void init(GType type);
  void init(const GValue* value);
  void reset();
  GValue* gobj() { return &gobject_; }
  const GValue* gobj() const { return &gobject_; }
protected:
  GValue gobject_;
};
class ValueBase_Boxed : public ValueBase
{
public:
  static GType value_type() __attribute__((__const__));
  GParamSpec* create_param_spec(const Glib::ustring& name) const;
protected:
  void set_boxed(const void* data);
  void* get_boxed() const;
};
class ValueBase_Object : public ValueBase
{
public:
  static GType value_type() __attribute__((__const__));
  GParamSpec* create_param_spec(const Glib::ustring& name) const;
protected:
  void set_object(Glib::ObjectBase* data);
  Glib::ObjectBase* get_object() const;
  Glib::RefPtr<Glib::ObjectBase> get_object_copy() const;
};
class ValueBase_Enum : public ValueBase
{
public:
  typedef gint CType;
  static GType value_type() __attribute__((__const__));
  GParamSpec* create_param_spec(const Glib::ustring& name) const;
protected:
  void set_enum(int data);
  int get_enum() const;
};
class ValueBase_Flags : public ValueBase
{
public:
  typedef guint CType;
  static GType value_type() __attribute__((__const__));
  GParamSpec* create_param_spec(const Glib::ustring& name) const;
protected:
  void set_flags(unsigned int data);
  unsigned int get_flags() const;
};
class ValueBase_String : public ValueBase
{
public:
  typedef const gchar* CType;
  static GType value_type() __attribute__((__const__));
  GParamSpec* create_param_spec(const Glib::ustring& name) const;
protected:
  void set_cstring(const char* data);
  const char* get_cstring() const;
};
}
namespace Glib
{
extern "C"
{
  typedef void (* ValueInitFunc) (GValue*);
  typedef void (* ValueFreeFunc) (GValue*);
  typedef void (* ValueCopyFunc) (const GValue*, GValue*);
}
GType custom_boxed_type_register(const char* type_name,
                                 ValueInitFunc init_func,
                                 ValueFreeFunc free_func,
                                 ValueCopyFunc copy_func);
GType custom_pointer_type_register(const char* type_name);
template <class T, class PtrT>
class Value_Pointer : public ValueBase_Object
{
public:
  typedef PtrT CppType;
  typedef void* CType;
  static inline GType value_type() __attribute__((__const__));
  inline void set(CppType data);
  inline CppType get() const;
private:
  inline
  static GType value_type_(Glib::Object*);
  static GType value_type_(void*);
  inline void set_(CppType data, Glib::Object*);
  inline void set_(CppType data, void*);
  inline CppType get_(Glib::Object*) const;
  inline CppType get_(void*) const;
};
template <class T>
class Value : public ValueBase_Boxed
{
public:
  typedef T CppType;
  typedef T* CType;
  static GType value_type() __attribute__((__const__));
  inline void set(const CppType& data);
  inline CppType get() const;
private:
  static GType custom_type_;
  static void value_init_func(GValue* value);
  static void value_free_func(GValue* value);
  static void value_copy_func(const GValue* src_value, GValue* dest_value);
};
template <class T>
class Value<T*> : public Value_Pointer<T,T*>
{};
template <class T>
class Value<const T*> : public Value_Pointer<T,const T*>
{};
template <class T, class PtrT> inline
GType Value_Pointer<T,PtrT>::value_type_(Glib::Object*)
{
  return T::get_base_type();
}
template <class T, class PtrT> inline
void Value_Pointer<T,PtrT>::set_(PtrT data, Glib::Object*)
{
  set_object(const_cast<T*>(data));
}
template <class T, class PtrT> inline
PtrT Value_Pointer<T,PtrT>::get_(Glib::Object*) const
{
  return dynamic_cast<T*>(get_object());
}
template <class T, class PtrT>
GType Value_Pointer<T,PtrT>::value_type_(void*)
{
  static GType custom_type = 0;
  if(!custom_type)
    custom_type = Glib::custom_pointer_type_register(typeid(PtrT).name());
  return custom_type;
}
template <class T, class PtrT> inline
void Value_Pointer<T,PtrT>::set_(PtrT data, void*)
{
  gobject_.data[0].v_pointer = const_cast<T*>(data);
}
template <class T, class PtrT> inline
PtrT Value_Pointer<T,PtrT>::get_(void*) const
{
  return static_cast<T*>(gobject_.data[0].v_pointer);
}
template <class T, class PtrT> inline
GType Value_Pointer<T,PtrT>::value_type()
{
  return Value_Pointer<T,PtrT>::value_type_(static_cast<T*>(0));
}
template <class T, class PtrT> inline
void Value_Pointer<T,PtrT>::set(PtrT data)
{
  this->set_(data, static_cast<T*>(0));
}
template <class T, class PtrT> inline
PtrT Value_Pointer<T,PtrT>::get() const
{
  return this->get_(static_cast<T*>(0));
}
template <class T>
GType Value<T>::custom_type_ = 0;
template <class T> inline
void Value<T>::set(const typename Value<T>::CppType& data)
{
  *static_cast<T*>(gobject_.data[0].v_pointer) = data;
}
template <class T> inline
typename Value<T>::CppType Value<T>::get() const
{
  return *static_cast<T*>(gobject_.data[0].v_pointer);
}
template <class T>
GType Value<T>::value_type()
{
  if(!custom_type_)
  {
    custom_type_ = Glib::custom_boxed_type_register(
        typeid(CppType).name(),
        &Value<T>::value_init_func,
        &Value<T>::value_free_func,
        &Value<T>::value_copy_func);
  }
  return custom_type_;
}
template <class T>
void Value<T>::value_init_func(GValue* value)
{
  value->data[0].v_pointer = new(std::nothrow) T();
}
template <class T>
void Value<T>::value_free_func(GValue* value)
{
  delete static_cast<T*>(value->data[0].v_pointer);
}
template <class T>
void Value<T>::value_copy_func(const GValue* src_value, GValue* dest_value)
{
  const T& source = *static_cast<T*>(src_value->data[0].v_pointer);
  dest_value->data[0].v_pointer = new(std::nothrow) T(source);
}
}
namespace Glib
{
template <class T>
class Value_Boxed : public ValueBase_Boxed
{
public:
  typedef T CppType;
  typedef typename T::BaseObjectType* CType;
  static GType value_type() { return T::get_type(); }
  void set(const CppType& data) { set_boxed(data.gobj()); }
  CppType get() const { return CppType(static_cast<CType>(get_boxed())); }
};
template <class T>
class Value< Glib::RefPtr<T> > : public ValueBase_Object
{
public:
  typedef Glib::RefPtr<T> CppType;
  typedef typename T::BaseObjectType* CType;
  static GType value_type() { return T::get_base_type(); }
  void set(const CppType& data) { set_object(data.operator->()); }
  CppType get() const { return Glib::RefPtr<T>::cast_dynamic(get_object_copy()); }
};
template <class T>
class Value< Glib::RefPtr<const T> > : public ValueBase_Object
{
public:
  typedef Glib::RefPtr<const T> CppType;
  typedef typename T::BaseObjectType* CType;
  static GType value_type() { return T::get_base_type(); }
  void set(const CppType& data) { set_object(const_cast<T*>(data.operator->())); }
  CppType get() const { return Glib::RefPtr<T>::cast_dynamic(get_object_copy()); }
};
}
namespace Glib
{
template <>
class Value<bool> : public ValueBase
{
public:
  typedef bool CppType;
  typedef gboolean CType;
  static GType value_type() __attribute__((__const__));
  void set(bool data);
  bool get() const;
  GParamSpec* create_param_spec(const Glib::ustring& name) const;
};
template <>
class Value<char> : public ValueBase
{
public:
  typedef char CppType;
  typedef gchar CType;
  static GType value_type() __attribute__((__const__));
  void set(char data);
  char get() const;
  GParamSpec* create_param_spec(const Glib::ustring& name) const;
};
template <>
class Value<unsigned char> : public ValueBase
{
public:
  typedef unsigned char CppType;
  typedef guchar CType;
  static GType value_type() __attribute__((__const__));
  void set(unsigned char data);
  unsigned char get() const;
  GParamSpec* create_param_spec(const Glib::ustring& name) const;
};
template <>
class Value<int> : public ValueBase
{
public:
  typedef int CppType;
  typedef gint CType;
  static GType value_type() __attribute__((__const__));
  void set(int data);
  int get() const;
  GParamSpec* create_param_spec(const Glib::ustring& name) const;
};
template <>
class Value<unsigned int> : public ValueBase
{
public:
  typedef unsigned int CppType;
  typedef guint CType;
  static GType value_type() __attribute__((__const__));
  void set(unsigned int data);
  unsigned int get() const;
  GParamSpec* create_param_spec(const Glib::ustring& name) const;
};
template <>
class Value<long> : public ValueBase
{
public:
  typedef long CppType;
  typedef glong CType;
  static GType value_type() __attribute__((__const__));
  void set(long data);
  long get() const;
  GParamSpec* create_param_spec(const Glib::ustring& name) const;
};
template <>
class Value<unsigned long> : public ValueBase
{
public:
  typedef unsigned long CppType;
  typedef gulong CType;
  static GType value_type() __attribute__((__const__));
  void set(unsigned long data);
  unsigned long get() const;
  GParamSpec* create_param_spec(const Glib::ustring& name) const;
};
template <>
class Value<long long> : public ValueBase
{
public:
  typedef long long CppType;
  typedef gint64 CType;
  static GType value_type() __attribute__((__const__));
  void set(long long data);
  long long get() const;
  GParamSpec* create_param_spec(const Glib::ustring& name) const;
};
template <>
class Value<unsigned long long> : public ValueBase
{
public:
  typedef unsigned long long CppType;
  typedef guint64 CType;
  static GType value_type() __attribute__((__const__));
  void set(unsigned long long data);
  unsigned long long get() const;
  GParamSpec* create_param_spec(const Glib::ustring& name) const;
};
template <>
class Value<float> : public ValueBase
{
public:
  typedef float CppType;
  typedef gfloat CType;
  static GType value_type() __attribute__((__const__));
  void set(float data);
  float get() const;
  GParamSpec* create_param_spec(const Glib::ustring& name) const;
};
template <>
class Value<double> : public ValueBase
{
public:
  typedef double CppType;
  typedef gdouble CType;
  static GType value_type() __attribute__((__const__));
  void set(double data);
  double get() const;
  GParamSpec* create_param_spec(const Glib::ustring& name) const;
};
template <>
class Value<void*> : public ValueBase
{
public:
  typedef void* CppType;
  typedef gpointer CType;
  static GType value_type() __attribute__((__const__));
  void set(void* data);
  void* get() const;
  GParamSpec* create_param_spec(const Glib::ustring& name) const;
};
}
namespace Glib
{
template <>
class Value<std::string> : public ValueBase_String
{
public:
  typedef std::string CppType;
  void set(const std::string& data);
  std::string get() const { return get_cstring(); }
};
template <>
class Value<Glib::ustring> : public ValueBase_String
{
public:
  typedef Glib::ustring CppType;
  void set(const Glib::ustring& data);
  Glib::ustring get() const { return get_cstring(); }
};
template <class T>
class Value_Enum : public ValueBase_Enum
{
public:
  typedef T CppType;
  void set(CppType data) { set_enum(data); }
  CppType get() const { return CppType(get_enum()); }
};
template <class T>
class Value_Flags : public ValueBase_Flags
{
public:
  typedef T CppType;
  void set(CppType data) { set_flags(data); }
  CppType get() const { return CppType(get_flags()); }
};
}
namespace Glib
{
class ObjectBase;
class SignalProxyProperty : public SignalProxyBase
{
public:
  friend class PropertyProxy_Base;
  SignalProxyProperty(Glib::ObjectBase* obj, const gchar* property_name);
  ~SignalProxyProperty();
  typedef sigc::slot<void> SlotType;
  sigc::connection connect(const SlotType& sl);
protected:
  const char* property_name_;
private:
  SignalProxyProperty& operator=(const SignalProxyProperty&);
};
class PropertyProxy_Base
{
public:
  PropertyProxy_Base(ObjectBase* obj, const char* property_name);
  PropertyProxy_Base(const PropertyProxy_Base& other);
  SignalProxyProperty signal_changed();
  ObjectBase* get_object() const { return obj_; }
  const char* get_name() const { return property_name_; }
protected:
  void set_property_(const Glib::ValueBase& value);
  void get_property_(Glib::ValueBase& value) const;
  void reset_property_();
  ObjectBase* obj_;
  const char* property_name_;
private:
  PropertyProxy_Base& operator=(const PropertyProxy_Base&);
};
class SignalProxyProperty;
class PropertyProxyConnectionNode : public SignalProxyConnectionNode
{
public:
  friend class SignalProxyProperty;
  PropertyProxyConnectionNode(const sigc::slot_base& slot, GObject* gobject);
  static void callback(GObject* object, GParamSpec* pspec, gpointer data);
};
}
namespace Glib
{
template <class T>
class PropertyProxy : public PropertyProxy_Base
{
public:
  typedef T PropertyType;
  PropertyProxy(ObjectBase* obj, const char* name)
    : PropertyProxy_Base(obj, name) {}
  void set_value(const PropertyType& data);
  PropertyType get_value() const;
  void reset_value()
    { reset_property_(); }
  PropertyProxy<T>& operator=(const PropertyType& data)
    { this->set_value(data); return *this; }
  operator PropertyType() const
    { return this->get_value(); }
};
template <class T>
class PropertyProxy_WriteOnly : public PropertyProxy_Base
{
public:
  typedef T PropertyType;
  PropertyProxy_WriteOnly(ObjectBase* obj, const char* name)
    : PropertyProxy_Base(obj, name) {}
  void set_value(const PropertyType& data);
  void reset_value()
    { reset_property_(); }
  PropertyProxy_WriteOnly<T>& operator=(const PropertyType& data)
    { this->set_value(data); return *this; }
};
template <class T>
class PropertyProxy_ReadOnly : public PropertyProxy_Base
{
public:
  typedef T PropertyType;
  PropertyProxy_ReadOnly(const ObjectBase* obj, const char* name)
    : PropertyProxy_Base(const_cast<ObjectBase*>(obj), name) {}
  PropertyType get_value() const;
  operator PropertyType() const
    { return this->get_value(); }
};
template <class T>
void PropertyProxy<T>::set_value(const T& data)
{
  Glib::Value<T> value;
  value.init(Glib::Value<T>::value_type());
  value.set(data);
  set_property_(value);
}
template <class T>
T PropertyProxy<T>::get_value() const
{
  Glib::Value<T> value;
  value.init(Glib::Value<T>::value_type());
  get_property_(value);
  return value.get();
}
template <class T>
void PropertyProxy_WriteOnly<T>::set_value(const T& data)
{
  Glib::Value<T> value;
  value.init(Glib::Value<T>::value_type());
  value.set(data);
  set_property_(value);
}
template <class T>
T PropertyProxy_ReadOnly<T>::get_value() const
{
  Glib::Value<T> value;
  value.init(Glib::Value<T>::value_type());
  get_property_(value);
  return value.get();
}
}
namespace Glib
{
class QueryQuark
{
  public:
    QueryQuark(const GQuark& q);
    QueryQuark(const ustring& s);
    QueryQuark(const char*s);
    ~QueryQuark() {}
    QueryQuark& operator=(const QueryQuark& q);
    operator ustring() const;
    operator GQuark() const {return quark_;}
    GQuark id() const {return quark_;}
  private:
    GQuark quark_;
};
class Quark: public QueryQuark
{
  public:
    Quark(const ustring& s);
    Quark(const char* s);
    ~Quark();
};
inline bool operator==(const QueryQuark& a, const QueryQuark& b)
  { return a.id() == b.id(); }
inline bool operator!=(const QueryQuark& a, const QueryQuark& b)
  { return a.id() != b.id(); }
extern GQuark quark_;
extern GQuark quark_cpp_wrapper_deleted_;
}
extern "C" { typedef struct _GObject GObject; }
namespace Glib
{
class GSigConnectionNode;
class ObjectBase : virtual public sigc::trackable
{
protected:
  ObjectBase();
  explicit ObjectBase(const char* custom_type_name);
  explicit ObjectBase(const std::type_info& custom_type_info);
  virtual ~ObjectBase() = 0;
  void initialize(GObject* castitem);
public:
  void set_property_value(const Glib::ustring& property_name, const Glib::ValueBase& value);
  void get_property_value(const Glib::ustring& property_name, Glib::ValueBase& value) const;
  template <class PropertyType>
  void set_property(const Glib::ustring& property_name, const PropertyType& value);
  template <class PropertyType>
  void get_property(const Glib::ustring& property_name, PropertyType& value) const;
  void connect_property_changed(const Glib::ustring& property_name, const sigc::slot<void>& slot);
  virtual void reference() const;
  virtual void unreference() const;
  inline GObject* gobj() { return gobject_; }
  inline const GObject* gobj() const { return gobject_; }
  GObject* gobj_copy() const;
  static ObjectBase* _get_current_wrapper(GObject* object);
  bool _cpp_destruction_is_in_progress() const;
protected:
  GObject* gobject_;
  const char* custom_type_name_;
  bool cpp_destruction_in_progress_;
  bool is_anonymous_custom_() const;
public:
  bool is_derived_() const;
protected:
  static void destroy_notify_callback_(void* data);
  virtual void destroy_notify_();
  void _set_current_wrapper(GObject* object);
private:
  ObjectBase(const ObjectBase&);
  ObjectBase& operator=(const ObjectBase&);
  virtual void set_manage();
  friend class Glib::GSigConnectionNode;
};
template <class PropertyType> inline
void ObjectBase::set_property(const Glib::ustring& property_name, const PropertyType& value)
{
  Glib::Value<PropertyType> property_value;
  property_value.init(Glib::Value<PropertyType>::value_type());
  property_value.set(value);
  this->set_property_value(property_name, property_value);
}
template <class PropertyType> inline
void ObjectBase::get_property(const Glib::ustring& property_name, PropertyType& value) const
{
  Glib::Value<PropertyType> property_value;
  property_value.init(Glib::Value<PropertyType>::value_type());
  this->get_property_value(property_name, property_value);
  value = property_value.get();
}
bool _gobject_cppinstance_already_deleted(GObject* gobject);
}
namespace Glib
{
class ObjectBase;
class Object;
typedef Glib::ObjectBase* (*WrapNewFunction) (GObject*);
void wrap_register_init();
void wrap_register_cleanup();
void wrap_register(GType type, WrapNewFunction func);
Glib::ObjectBase* wrap_auto(GObject* object, bool take_copy = false);
Glib::ObjectBase* wrap_create_new_wrapper_for_interface(GObject* object, GType interface_gtype);
template<class TInterface>
TInterface* wrap_auto_interface(GObject* object, bool take_copy = false)
{
  if(!object)
    return 0;
  ObjectBase* pCppObject = ObjectBase::_get_current_wrapper(object);
  if(!pCppObject)
  {
    pCppObject = wrap_create_new_wrapper_for_interface(object, TInterface::get_base_type());
  }
  TInterface* result = 0;
  if(pCppObject)
     result = dynamic_cast<TInterface*>(pCppObject);
  else
     result = new TInterface((typename TInterface::BaseObjectType*)object);
  if(take_copy && result)
    result->reference();
  return result;
}
Glib::RefPtr<Glib::Object> wrap(GObject* object, bool take_copy = false);
template <class T> inline
typename T::BaseObjectType* unwrap(T* ptr)
{
  return (ptr) ? ptr->gobj() : 0;
}
template <class T> inline
const typename T::BaseObjectType* unwrap(const T* ptr)
{
  return (ptr) ? ptr->gobj() : 0;
}
template <class T> inline
typename T::BaseObjectType* unwrap(const Glib::RefPtr<T>& ptr)
{
  return (ptr) ? ptr->gobj() : 0;
}
template <class T> inline
const typename T::BaseObjectType* unwrap(const Glib::RefPtr<const T>& ptr)
{
  return (ptr) ? ptr->gobj() : 0;
}
template <class T> inline
typename T::BaseObjectType* unwrap_copy(const Glib::RefPtr<T>& ptr)
{
  return (ptr) ? ptr->gobj_copy() : 0;
}
template <class T> inline
const typename T::BaseObjectType* unwrap_copy(const Glib::RefPtr<const T>& ptr)
{
  return (ptr) ? ptr->gobj_copy() : 0;
}
}
namespace Glib
{
enum OwnershipType
{
  OWNERSHIP_NONE = 0,
  OWNERSHIP_SHALLOW,
  OWNERSHIP_DEEP
};
template <class Iterator>
class Sequence
{
private:
  Iterator pbegin_;
  Iterator pend_;
public:
  Sequence(Iterator pbegin, Iterator pend)
    : pbegin_(pbegin), pend_(pend) {}
  Iterator begin() const { return pbegin_; }
  Iterator end() const { return pend_; }
  size_t size() const { return std::distance(pbegin_, pend_); }
};
template <class Iterator> inline
Sequence<Iterator> sequence(Iterator pbegin, Iterator pend)
{
  return Sequence<Iterator>(pbegin, pend);
}
namespace Container_Helpers
{
template <class T>
struct TypeTraits
{
  typedef T CppType;
  typedef T CType;
  typedef T CTypeNonConst;
  static CType to_c_type (const CppType& item) { return item; }
  static CppType to_cpp_type (const CType& item) { return item; }
  static void release_c_type (const CType&) {}
};
template <class T>
struct TypeTraits<T*>
{
  typedef T * CppType;
  typedef typename T::BaseObjectType * CType;
  typedef typename T::BaseObjectType * CTypeNonConst;
  static CType to_c_type (CppType ptr) { return Glib::unwrap(ptr); }
  static CType to_c_type (CType ptr) { return ptr; }
  static CppType to_cpp_type (CType ptr)
  {
    GObject* cobj = (GObject*)ptr;
    return dynamic_cast<CppType>(Glib::wrap_auto(cobj, false ));
  }
  static void release_c_type (CType ptr)
  {
    if (1){ (void)0; }else (void) 0;
    g_object_unref(ptr);
  }
};
template <class T>
struct TypeTraits<const T*>
{
  typedef const T * CppType;
  typedef const typename T::BaseObjectType * CType;
  typedef typename T::BaseObjectType * CTypeNonConst;
  static CType to_c_type (CppType ptr) { return Glib::unwrap(ptr); }
  static CType to_c_type (CType ptr) { return ptr; }
  static CppType to_cpp_type (CType ptr)
  {
     GObject* cobj = (GObject*)const_cast<CTypeNonConst>(ptr);
     return dynamic_cast<CppType>(Glib::wrap_auto(cobj, false ));
  }
  static void release_c_type (CType ptr)
  {
    if (1){ (void)0; }else (void) 0;
    g_object_unref(const_cast<CTypeNonConst>(ptr));
  }
};
template <class T>
struct TypeTraits< Glib::RefPtr<T> >
{
  typedef Glib::RefPtr<T> CppType;
  typedef typename T::BaseObjectType * CType;
  typedef typename T::BaseObjectType * CTypeNonConst;
  static CType to_c_type (const CppType& ptr) { return Glib::unwrap(ptr); }
  static CType to_c_type (CType ptr) { return ptr; }
  static CppType to_cpp_type (CType ptr)
  {
    GObject* cobj = (GObject*)const_cast<CTypeNonConst>(ptr);
    return Glib::RefPtr<T>( dynamic_cast<T*>(Glib::wrap_auto(cobj, true )) );
  }
  static void release_c_type (CType ptr)
  {
    if (1){ (void)0; }else (void) 0;
    g_object_unref(ptr);
  }
};
template <class T>
struct TypeTraits< Glib::RefPtr<const T> >
{
  typedef Glib::RefPtr<const T> CppType;
  typedef const typename T::BaseObjectType * CType;
  typedef typename T::BaseObjectType * CTypeNonConst;
  static CType to_c_type (const CppType& ptr) { return Glib::unwrap(ptr); }
  static CType to_c_type (CType ptr) { return ptr; }
  static CppType to_cpp_type (CType ptr)
  {
    GObject* cobj = (GObject*)(ptr);
    return Glib::RefPtr<const T>( dynamic_cast<const T*>(Glib::wrap_auto(cobj, true )) );
  }
  static void release_c_type (CType ptr)
  {
    if (1){ (void)0; }else (void) 0;
    g_object_unref(const_cast<CTypeNonConst>(ptr));
  }
};
template <>
struct TypeTraits<Glib::ustring>
{
  typedef Glib::ustring CppType;
  typedef const char * CType;
  typedef char * CTypeNonConst;
  static CType to_c_type (const Glib::ustring& str) { return str.c_str(); }
  static CType to_c_type (const std::string& str) { return str.c_str(); }
  static CType to_c_type (CType str) { return str; }
  static CppType to_cpp_type(CType str)
    { return (str) ? Glib::ustring(str) : Glib::ustring(); }
  static void release_c_type(CType str)
    { g_free(const_cast<CTypeNonConst>(str)); }
};
template <>
struct TypeTraits<std::string>
{
  typedef std::string CppType;
  typedef const char * CType;
  typedef char * CTypeNonConst;
  static CType to_c_type (const std::string& str) { return str.c_str(); }
  static CType to_c_type (const Glib::ustring& str) { return str.c_str(); }
  static CType to_c_type (CType str) { return str; }
  static CppType to_cpp_type(CType str)
    { return (str) ? std::string(str) : std::string(); }
  static void release_c_type(CType str)
    { g_free(const_cast<CTypeNonConst>(str)); }
};
template <>
struct TypeTraits<bool>
{
  typedef bool CppType;
  typedef gboolean* CType;
  typedef gboolean* CTypeNonConst;
  static CType to_c_type (CppType val) { return (int*)((gpointer) (val)); }
  static CType to_c_type (CType ptr) { return ptr; }
  static CppType to_cpp_type(CType ptr)
  {
    if(ptr)
    {
   return ((gint) (ptr));
 }
 else
   return CppType();
  }
  static void release_c_type(CType )
  {
  }
};
}
}
namespace Glib
{
namespace Container_Helpers
{
template <class T> inline
size_t compute_array_size(const T* array)
{
  const T* pend = array;
  while(*pend)
    ++pend;
  return (pend - array);
}
template <class For, class Tr>
typename Tr::CType* create_array(For pbegin, size_t size, Tr)
{
  typedef typename Tr::CType CType;
  CType *const array = static_cast<CType*>(g_malloc((size + 1) * sizeof(CType)));
  CType *const array_end = array + size;
  for(CType* pdest = array; pdest != array_end; ++pdest)
  {
    *pdest = Tr::to_c_type(*&*pbegin);
    ++pbegin;
  }
  *array_end = CType();
  return array;
}
template <class Tr, class Cont>
struct ArraySourceTraits
{
  typedef typename Tr::CType CType;
  static size_t get_size(const Cont& cont)
    { return cont.size(); }
  static const CType* get_data(const Cont& cont, size_t size)
    { return Glib::Container_Helpers::create_array(cont.begin(), size, Tr()); }
  static const Glib::OwnershipType initial_ownership = Glib::OWNERSHIP_SHALLOW;
};
template <class Tr, class Cont>
struct ArraySourceTraits<Tr,Cont*>
{
  typedef typename Tr::CType CType;
  static size_t get_size(const CType* array)
    { return (array) ? Glib::Container_Helpers::compute_array_size(array) : 0; }
  static const CType* get_data(const CType* array, size_t)
    { return array; }
  static const Glib::OwnershipType initial_ownership = Glib::OWNERSHIP_NONE;
};
template <class Tr, class Cont>
struct ArraySourceTraits<Tr,const Cont*> : ArraySourceTraits<Tr,Cont*>
{};
template <class Tr, class Cont, size_t N>
struct ArraySourceTraits<Tr,Cont[N]>
{
  typedef typename Tr::CType CType;
  static size_t get_size(const CType*)
    { return (N - 1); }
  static const CType* get_data(const CType* array, size_t)
    { return array; }
  static const Glib::OwnershipType initial_ownership = Glib::OWNERSHIP_NONE;
};
template <class Tr, class Cont, size_t N>
struct ArraySourceTraits<Tr,const Cont[N]> : ArraySourceTraits<Tr,Cont[N]>
{};
template <class Tr>
class ArrayHandleIterator
{
public:
  typedef typename Tr::CppType CppType;
  typedef typename Tr::CType CType;
  typedef std::random_access_iterator_tag iterator_category;
  typedef CppType value_type;
  typedef ptrdiff_t difference_type;
  typedef value_type reference;
  typedef void pointer;
  explicit inline ArrayHandleIterator(const CType* pos);
  inline value_type operator*() const;
  inline value_type operator[](difference_type offset) const;
  inline ArrayHandleIterator<Tr> & operator++();
  inline const ArrayHandleIterator<Tr> operator++(int);
  inline ArrayHandleIterator<Tr> & operator+=(difference_type rhs);
  inline ArrayHandleIterator<Tr> & operator-=(difference_type rhs);
  inline const ArrayHandleIterator<Tr> operator+ (difference_type rhs) const;
  inline const ArrayHandleIterator<Tr> operator- (difference_type rhs) const;
  inline difference_type operator-(const ArrayHandleIterator<Tr>& rhs) const;
  inline bool operator==(const ArrayHandleIterator<Tr>& rhs) const;
  inline bool operator!=(const ArrayHandleIterator<Tr>& rhs) const;
  inline bool operator< (const ArrayHandleIterator<Tr>& rhs) const;
  inline bool operator> (const ArrayHandleIterator<Tr>& rhs) const;
  inline bool operator<=(const ArrayHandleIterator<Tr>& rhs) const;
  inline bool operator>=(const ArrayHandleIterator<Tr>& rhs) const;
private:
  const CType* pos_;
};
}
template < class T, class Tr = Glib::Container_Helpers::TypeTraits<T> >
class ArrayHandle
{
public:
  typedef typename Tr::CppType CppType;
  typedef typename Tr::CType CType;
  typedef CppType value_type;
  typedef size_t size_type;
  typedef ptrdiff_t difference_type;
  typedef Glib::Container_Helpers::ArrayHandleIterator<Tr> const_iterator;
  typedef Glib::Container_Helpers::ArrayHandleIterator<Tr> iterator;
  template <class Cont> inline
    ArrayHandle(const Cont& container);
  inline ArrayHandle(const CType* array, size_t array_size, Glib::OwnershipType ownership);
  inline ArrayHandle(const CType* array, Glib::OwnershipType ownership);
  inline ArrayHandle(const ArrayHandle<T,Tr>& other);
  ~ArrayHandle();
  inline const_iterator begin() const;
  inline const_iterator end() const;
  template <class U> inline operator std::vector<U>() const;
  template <class U> inline operator std::deque<U>() const;
  template <class U> inline operator std::list<U>() const;
  template <class Cont> inline
    void assign_to(Cont& container) const;
  template <class Out> inline
    void copy(Out pdest) const;
  inline const CType* data() const;
  inline size_t size() const;
  inline bool empty() const;
private:
  size_t size_;
  const CType* parray_;
  mutable Glib::OwnershipType ownership_;
  ArrayHandle<T, Tr>& operator=(const ArrayHandle<T,Tr>&);
};
typedef ArrayHandle<Glib::ustring> StringArrayHandle;
namespace Container_Helpers
{
template <class Tr> inline
ArrayHandleIterator<Tr>::ArrayHandleIterator(const CType* pos)
:
  pos_ (pos)
{}
template <class Tr> inline
typename ArrayHandleIterator<Tr>::value_type ArrayHandleIterator<Tr>::operator*() const
{
  return Tr::to_cpp_type(*pos_);
}
template <class Tr> inline
typename ArrayHandleIterator<Tr>::value_type
ArrayHandleIterator<Tr>::operator[](difference_type offset) const
{
  return Tr::to_cpp_type(pos_[offset]);
}
template <class Tr> inline
ArrayHandleIterator<Tr>& ArrayHandleIterator<Tr>::operator++()
{
  ++pos_;
  return *this;
}
template <class Tr> inline
const ArrayHandleIterator<Tr> ArrayHandleIterator<Tr>::operator++(int)
{
  return ArrayHandleIterator<Tr>(pos_++);
}
template <class Tr> inline
ArrayHandleIterator<Tr>&
ArrayHandleIterator<Tr>::operator+=(typename ArrayHandleIterator<Tr>::difference_type rhs)
{
  pos_ += rhs;
  return *this;
}
template <class Tr> inline
ArrayHandleIterator<Tr>&
ArrayHandleIterator<Tr>::operator-=(typename ArrayHandleIterator<Tr>::difference_type rhs)
{
  pos_ -= rhs;
  return *this;
}
template <class Tr> inline
const ArrayHandleIterator<Tr>
ArrayHandleIterator<Tr>::operator+(typename ArrayHandleIterator<Tr>::difference_type rhs) const
{
  return ArrayHandleIterator<Tr>(pos_ + rhs);
}
template <class Tr> inline
const ArrayHandleIterator<Tr>
ArrayHandleIterator<Tr>::operator-(typename ArrayHandleIterator<Tr>::difference_type rhs) const
{
  return ArrayHandleIterator<Tr>(pos_ - rhs);
}
template <class Tr> inline
typename ArrayHandleIterator<Tr>::difference_type
ArrayHandleIterator<Tr>::operator-(const ArrayHandleIterator<Tr>& rhs) const
{
  return (pos_ - rhs.pos_);
}
template <class Tr> inline
bool ArrayHandleIterator<Tr>::operator==(const ArrayHandleIterator<Tr>& rhs) const
{
  return (pos_ == rhs.pos_);
}
template <class Tr> inline
bool ArrayHandleIterator<Tr>::operator!=(const ArrayHandleIterator<Tr>& rhs) const
{
  return (pos_ != rhs.pos_);
}
template <class Tr> inline
bool ArrayHandleIterator<Tr>::operator<(const ArrayHandleIterator<Tr>& rhs) const
{
  return (pos_ < rhs.pos_);
}
template <class Tr> inline
bool ArrayHandleIterator<Tr>::operator>(const ArrayHandleIterator<Tr>& rhs) const
{
  return (pos_ > rhs.pos_);
}
template <class Tr> inline
bool ArrayHandleIterator<Tr>::operator<=(const ArrayHandleIterator<Tr>& rhs) const
{
  return (pos_ <= rhs.pos_);
}
template <class Tr> inline
bool ArrayHandleIterator<Tr>::operator>=(const ArrayHandleIterator<Tr>& rhs) const
{
  return (pos_ >= rhs.pos_);
}
}
template <class T, class Tr>
  template <class Cont>
inline
ArrayHandle<T,Tr>::ArrayHandle(const Cont& container)
:
  size_ (Glib::Container_Helpers::ArraySourceTraits<Tr,Cont>::get_size(container)),
  parray_ (Glib::Container_Helpers::ArraySourceTraits<Tr,Cont>::get_data(container, size_)),
  ownership_ (Glib::Container_Helpers::ArraySourceTraits<Tr,Cont>::initial_ownership)
{}
template <class T, class Tr> inline
ArrayHandle<T,Tr>::ArrayHandle(const typename ArrayHandle<T,Tr>::CType* array, size_t array_size,
                               Glib::OwnershipType ownership)
:
  size_ (array_size),
  parray_ (array),
  ownership_ (ownership)
{}
template <class T, class Tr> inline
ArrayHandle<T,Tr>::ArrayHandle(const typename ArrayHandle<T,Tr>::CType* array,
                               Glib::OwnershipType ownership)
:
  size_ ((array) ? Glib::Container_Helpers::compute_array_size(array) : 0),
  parray_ (array),
  ownership_ (ownership)
{}
template <class T, class Tr> inline
ArrayHandle<T,Tr>::ArrayHandle(const ArrayHandle<T,Tr>& other)
:
  size_ (other.size_),
  parray_ (other.parray_),
  ownership_ (other.ownership_)
{
  other.ownership_ = Glib::OWNERSHIP_NONE;
}
template <class T, class Tr>
ArrayHandle<T,Tr>::~ArrayHandle()
{
  if(ownership_ != Glib::OWNERSHIP_NONE)
  {
    if(ownership_ != Glib::OWNERSHIP_SHALLOW)
    {
      const CType *const pend = parray_ + size_;
      for(const CType* p = parray_; p != pend; ++p)
        Tr::release_c_type(*p);
    }
    g_free(const_cast<CType*>(parray_));
  }
}
template <class T, class Tr> inline
typename ArrayHandle<T,Tr>::const_iterator ArrayHandle<T,Tr>::begin() const
{
  return Glib::Container_Helpers::ArrayHandleIterator<Tr>(parray_);
}
template <class T, class Tr> inline
typename ArrayHandle<T,Tr>::const_iterator ArrayHandle<T,Tr>::end() const
{
  return Glib::Container_Helpers::ArrayHandleIterator<Tr>(parray_ + size_);
}
template <class T, class Tr>
  template <class U>
inline
ArrayHandle<T,Tr>::operator std::vector<U>() const
{
  return std::vector<U>(this->begin(), this->end());
}
template <class T, class Tr>
  template <class U>
inline
ArrayHandle<T,Tr>::operator std::deque<U>() const
{
  return std::deque<U>(this->begin(), this->end());
}
template <class T, class Tr>
  template <class U>
inline
ArrayHandle<T,Tr>::operator std::list<U>() const
{
  return std::list<U>(this->begin(), this->end());
}
template <class T, class Tr>
  template <class Cont>
inline
void ArrayHandle<T,Tr>::assign_to(Cont& container) const
{
  container.assign(this->begin(), this->end());
}
template <class T, class Tr>
  template <class Out>
inline
void ArrayHandle<T,Tr>::copy(Out pdest) const
{
  std::copy(this->begin(), this->end(), pdest);
}
template <class T, class Tr> inline
const typename ArrayHandle<T,Tr>::CType* ArrayHandle<T,Tr>::data() const
{
  return parray_;
}
template <class T, class Tr> inline
size_t ArrayHandle<T,Tr>::size() const
{
  return size_;
}
template <class T, class Tr> inline
bool ArrayHandle<T,Tr>::empty() const
{
  return (size_ == 0);
}
}
namespace Glib
{
class Class
{
public:
  inline GType get_type() const;
  GType clone_custom_type(const char* custom_type_name) const;
protected:
  GType gtype_;
  GClassInitFunc class_init_func_;
  void register_derived_type(GType base_type);
private:
  static void custom_class_init_function(void* g_class, void* class_data);
};
inline
GType Class::get_type() const
{
  return gtype_;
}
}
extern "C" { typedef struct _GError GError; }
namespace Glib
{
class Exception
{
public:
  virtual ~Exception() throw() = 0;
  virtual Glib::ustring what() const = 0;
};
}
namespace Glib
{
class Error : public Glib::Exception
{
public:
  Error();
  Error(GQuark domain, int code, const Glib::ustring& message);
  explicit Error(GError* gobject, bool take_copy = false);
  Error(const Error& other);
  Error& operator=(const Error& other);
  virtual ~Error() throw();
  GQuark domain() const;
  int code() const;
  virtual Glib::ustring what() const;
  bool matches(GQuark domain, int code) const;
  GError* gobj();
  const GError* gobj() const;
  void propagate(GError** dest);
  typedef void (* ThrowFunc) (GError*);
  static void register_init();
  static void register_cleanup();
  static void register_domain(GQuark domain, ThrowFunc throw_func);
  static void throw_exception(GError* gobject) __attribute__((__noreturn__));
protected:
  GError* gobject_;
};
}
extern "C" { typedef struct _GIConv* GIConv; }
namespace Glib
{
class ConvertError : public Glib::Error
{
public:
  enum Code
  {
    NO_CONVERSION,
    ILLEGAL_SEQUENCE,
    FAILED,
    PARTIAL_INPUT,
    BAD_URI,
    NOT_ABSOLUTE_PATH
  };
  ConvertError(Code error_code, const Glib::ustring& error_message);
  explicit ConvertError(GError* gobject);
  Code code() const;
private:
  static void throw_func(GError* gobject);
  friend void wrap_init();
};
class IConv
{
public:
  IConv(const std::string& to_codeset, const std::string& from_codeset);
  explicit IConv(GIConv gobject);
  ~IConv();
  size_t iconv(char** inbuf, gsize* inbytes_left, char** outbuf, gsize* outbytes_left);
  void reset();
  std::string convert(const std::string& str);
  GIConv gobj() { return gobject_; }
private:
  GIConv gobject_;
  IConv(const IConv&);
  IConv& operator=(const IConv&);
};
bool get_charset();
bool get_charset(std::string& charset);
std::string convert(const std::string& str,
                    const std::string& to_codeset,
                    const std::string& from_codeset);
std::string convert_with_fallback(const std::string& str,
                                  const std::string& to_codeset,
                                  const std::string& from_codeset);
std::string convert_with_fallback(const std::string& str,
                                  const std::string& to_codeset,
                                  const std::string& from_codeset,
                                  const Glib::ustring& fallback);
Glib::ustring locale_to_utf8(const std::string& opsys_string);
std::string locale_from_utf8(const Glib::ustring& utf8_string);
Glib::ustring filename_to_utf8(const std::string& opsys_string);
std::string filename_from_utf8(const Glib::ustring& utf8_string);
std::string filename_from_uri(const Glib::ustring& uri, Glib::ustring& hostname);
std::string filename_from_uri(const Glib::ustring& uri);
Glib::ustring filename_to_uri(const std::string& filename, const Glib::ustring& hostname);
Glib::ustring filename_to_uri(const std::string& filename);
Glib::ustring filename_display_basename(const std::string& filename);
Glib::ustring filename_display_name(const std::string& filename);
}
extern "C" { struct tm; }
namespace Glib
{
class Date
{
public:
  typedef guint8 Day;
  typedef guint16 Year;
enum Month
{
  BAD_MONTH,
  JANUARY,
  FEBRUARY,
  MARCH,
  APRIL,
  MAY,
  JUNE,
  JULY,
  AUGUST,
  SEPTEMBER,
  OCTOBER,
  NOVEMBER,
  DECEMBER
};
enum Weekday
{
  BAD_WEEKDAY,
  MONDAY,
  TUESDAY,
  WEDNESDAY,
  THURSDAY,
  FRIDAY,
  SATURDAY,
  SUNDAY
};
enum DMY
{
  DAY,
  MONTH,
  YEAR
};
  static const Day BAD_DAY = 0;
  static const Year BAD_YEAR = 0;
  static const guint32 BAD_JULIAN = 0;
  Date();
  Date(Day day, Month month, Year year);
  explicit Date(guint32 julian_day);
  explicit Date(const GDate& castitem);
  void clear();
  void set_parse (const Glib::ustring& str);
  void set_time(GTime time);
  void set_time(time_t timet);
  void set_time(const GTimeVal& timeval);
  void set_time_current();
  void set_month(Month month);
  void set_day(Day day);
  void set_year(Year year);
  void set_dmy(Day day, Month month, Year year);
   void set_julian(guint32 julian_day);
  Date& add_days(int n_days);
  Date& subtract_days(int n_days);
  Date& add_months(int n_months);
  Date& subtract_months(int n_months);
  Date& add_years(int n_years);
  Date& subtract_years(int n_years);
  int days_between(const Date& rhs) const;
  int compare(const Date& rhs) const;
  Date& clamp(const Date& min_date, const Date& max_date);
  Date& clamp_min(const Date& min_date);
  Date& clamp_max(const Date& max_date);
  void order(Date& other);
  Weekday get_weekday() const;
  Month get_month() const;
  Year get_year() const;
  Day get_day() const;
  guint32 get_julian() const;
  unsigned int get_day_of_year() const;
  unsigned int get_monday_week_of_year() const;
  unsigned int get_sunday_week_of_year() const;
  bool is_first_of_month() const;
  bool is_last_of_month() const;
  static guint8 get_days_in_month(Month month, Year year);
  static guint8 get_monday_weeks_in_year(Year year);
  static guint8 get_sunday_weeks_in_year(Year year);
  static bool is_leap_year(Year year);
  Glib::ustring format_string(const Glib::ustring& format) const;
  void to_struct_tm(struct tm& dest) const;
  bool valid() const;
  static bool valid_day(Day day);
  static bool valid_month(Month month);
  static bool valid_year(Year year);
  static bool valid_weekday(Weekday weekday);
  static bool valid_julian(guint32 julian_day);
  static bool valid_dmy(Day day, Month month, Year year);
  GDate* gobj() { return &gobject_; }
  const GDate* gobj() const { return &gobject_; }
private:
  GDate gobject_;
};
inline bool operator==(const Date& lhs, const Date& rhs)
  { return (lhs.compare(rhs) == 0); }
inline bool operator!=(const Date& lhs, const Date& rhs)
  { return (lhs.compare(rhs) != 0); }
inline bool operator<(const Date& lhs, const Date& rhs)
  { return (lhs.compare(rhs) < 0); }
inline bool operator>(const Date& lhs, const Date& rhs)
  { return (lhs.compare(rhs) > 0); }
inline bool operator<=(const Date& lhs, const Date& rhs)
  { return (lhs.compare(rhs) <= 0); }
inline bool operator>=(const Date& lhs, const Date& rhs)
  { return (lhs.compare(rhs) >= 0); }
}
namespace Glib
{
struct TimeVal : public GTimeVal
{
  inline TimeVal();
  inline TimeVal(long seconds, long microseconds);
  inline TimeVal(const GTimeVal& gtimeval);
  inline TimeVal& operator=(const GTimeVal& gtimeval);
  void assign_current_time();
  void add(const TimeVal& rhs);
  void subtract(const TimeVal& rhs);
  void add_seconds(long seconds);
  void subtract_seconds(long seconds);
  void add_milliseconds(long milliseconds);
  void subtract_milliseconds(long milliseconds);
  void add_microseconds(long microseconds);
  void subtract_microseconds(long microseconds);
  inline TimeVal& operator+=(const TimeVal& gtimeval);
  inline TimeVal& operator-=(const TimeVal& gtimeval);
  inline TimeVal& operator+=(long seconds);
  inline TimeVal& operator-=(long seconds);
  inline double as_double() const;
  inline bool negative() const;
  inline bool valid() const;
};
inline
TimeVal::TimeVal()
{
  tv_sec = 0;
  tv_usec = 0;
}
inline
TimeVal::TimeVal(long seconds, long microseconds)
{
  tv_sec = seconds;
  tv_usec = microseconds;
}
inline
TimeVal::TimeVal(const GTimeVal& gtimeval)
{
  tv_sec = gtimeval.tv_sec;
  tv_usec = gtimeval.tv_usec;
}
inline
TimeVal& TimeVal::operator=(const GTimeVal& gtimeval)
{
  tv_sec = gtimeval.tv_sec;
  tv_usec = gtimeval.tv_usec;
  return *this;
}
inline
TimeVal& TimeVal::operator+=(const TimeVal& gtimeval)
{
  add(gtimeval);
  return *this;
}
inline
TimeVal& TimeVal::operator-=(const TimeVal& gtimeval)
{
  subtract(gtimeval);
  return *this;
}
inline
TimeVal& TimeVal::operator+=(long seconds)
{
  add_seconds(seconds);
  return *this;
}
inline
TimeVal& TimeVal::operator-=(long seconds)
{
  subtract_seconds(seconds);
  return *this;
}
inline
double TimeVal::as_double() const
{
  return tv_sec + ((double) tv_usec / (double) 1000000);
}
inline
bool TimeVal::negative() const
{
  return (tv_sec < 0);
}
inline
bool TimeVal::valid() const
{
  return (tv_usec >= 0 && tv_usec < 1000000);
}
inline
TimeVal operator+(const TimeVal& lhs, const TimeVal& rhs)
{ return TimeVal(lhs) += rhs; }
inline
TimeVal operator+(const TimeVal& lhs, long seconds)
{ return TimeVal(lhs) += seconds; }
inline
TimeVal operator-(const TimeVal& lhs, const TimeVal& rhs)
{ return TimeVal(lhs) -= rhs; }
inline
TimeVal operator-(const TimeVal& lhs, long seconds)
{ return TimeVal(lhs) -= seconds; }
inline
bool operator==(const TimeVal& lhs, const TimeVal& rhs)
{
  return (lhs.tv_sec == rhs.tv_sec && lhs.tv_usec == rhs.tv_usec);
}
inline
bool operator!=(const TimeVal& lhs, const TimeVal& rhs)
{
  return (lhs.tv_sec != rhs.tv_sec || lhs.tv_usec != rhs.tv_usec);
}
inline
bool operator<(const TimeVal& lhs, const TimeVal& rhs)
{
  return ((lhs.tv_sec < rhs.tv_sec) ||
          (lhs.tv_sec == rhs.tv_sec && lhs.tv_usec < rhs.tv_usec));
}
inline
bool operator>(const TimeVal& lhs, const TimeVal& rhs)
{
  return ((lhs.tv_sec > rhs.tv_sec) ||
          (lhs.tv_sec == rhs.tv_sec && lhs.tv_usec > rhs.tv_usec));
}
inline
bool operator<=(const TimeVal& lhs, const TimeVal& rhs)
{
  return ((lhs.tv_sec < rhs.tv_sec) ||
          (lhs.tv_sec == rhs.tv_sec && lhs.tv_usec <= rhs.tv_usec));
}
inline
bool operator>=(const TimeVal& lhs, const TimeVal& rhs)
{
  return ((lhs.tv_sec > rhs.tv_sec) ||
          (lhs.tv_sec == rhs.tv_sec && lhs.tv_usec >= rhs.tv_usec));
}
}
namespace Glib
{
class Cond;
class Mutex;
class IOChannel;
enum
{
  PRIORITY_HIGH = -100,
  PRIORITY_DEFAULT = 0,
  PRIORITY_HIGH_IDLE = 100,
  PRIORITY_DEFAULT_IDLE = 200,
  PRIORITY_LOW = 300
};
enum IOCondition
{
  IO_IN = G_IO_IN,
  IO_OUT = G_IO_OUT,
  IO_PRI = G_IO_PRI,
  IO_ERR = G_IO_ERR,
  IO_HUP = G_IO_HUP,
  IO_NVAL = G_IO_NVAL
};
inline IOCondition operator|(IOCondition lhs, IOCondition rhs)
  { return static_cast<IOCondition>(static_cast<unsigned>(lhs) | static_cast<unsigned>(rhs)); }
inline IOCondition operator&(IOCondition lhs, IOCondition rhs)
  { return static_cast<IOCondition>(static_cast<unsigned>(lhs) & static_cast<unsigned>(rhs)); }
inline IOCondition operator^(IOCondition lhs, IOCondition rhs)
  { return static_cast<IOCondition>(static_cast<unsigned>(lhs) ^ static_cast<unsigned>(rhs)); }
inline IOCondition operator~(IOCondition flags)
  { return static_cast<IOCondition>(~static_cast<unsigned>(flags)); }
inline IOCondition& operator|=(IOCondition& lhs, IOCondition rhs)
  { return (lhs = static_cast<IOCondition>(static_cast<unsigned>(lhs) | static_cast<unsigned>(rhs))); }
inline IOCondition& operator&=(IOCondition& lhs, IOCondition rhs)
  { return (lhs = static_cast<IOCondition>(static_cast<unsigned>(lhs) & static_cast<unsigned>(rhs))); }
inline IOCondition& operator^=(IOCondition& lhs, IOCondition rhs)
  { return (lhs = static_cast<IOCondition>(static_cast<unsigned>(lhs) ^ static_cast<unsigned>(rhs))); }
class PollFD
{
public:
  PollFD();
  explicit PollFD(int fd);
  PollFD(int fd, IOCondition events);
  void set_fd(int fd) { gobject_.fd = fd; }
  int get_fd() const { return gobject_.fd; }
  void set_events(IOCondition events) { gobject_.events = events; }
  IOCondition get_events() const { return static_cast<IOCondition>(gobject_.events); }
  void set_revents(IOCondition revents) { gobject_.revents = revents; }
  IOCondition get_revents() const { return static_cast<IOCondition>(gobject_.revents); }
  GPollFD* gobj() { return &gobject_; }
  const GPollFD* gobj() const { return &gobject_; }
private:
  GPollFD gobject_;
};
class SignalTimeout
{
public:
  explicit inline SignalTimeout(GMainContext* context);
  sigc::connection connect(const sigc::slot<bool>& slot, unsigned int interval,
                           int priority = PRIORITY_DEFAULT);
  sigc::connection connect_seconds(const sigc::slot<bool>& slot, unsigned int interval,
                           int priority = PRIORITY_DEFAULT);
private:
  GMainContext* context_;
  SignalTimeout& operator=(const SignalTimeout&);
};
class SignalIdle
{
public:
  explicit inline SignalIdle(GMainContext* context);
  sigc::connection connect(const sigc::slot<bool>& slot, int priority = PRIORITY_DEFAULT_IDLE);
private:
  GMainContext* context_;
  SignalIdle& operator=(const SignalIdle&);
};
class SignalIO
{
public:
  explicit inline SignalIO(GMainContext* context);
  sigc::connection connect(const sigc::slot<bool,IOCondition>& slot, int fd,
                           IOCondition condition, int priority = PRIORITY_DEFAULT);
  sigc::connection connect(const sigc::slot<bool,IOCondition>& slot, const Glib::RefPtr<IOChannel>& channel,
                           IOCondition condition, int priority = PRIORITY_DEFAULT);
private:
  GMainContext* context_;
  SignalIO& operator=(const SignalIO&);
};
class SignalChildWatch
{
public:
  explicit inline SignalChildWatch(GMainContext* context);
  sigc::connection connect(const sigc::slot<void,GPid, int>& slot, GPid pid,
int priority = PRIORITY_DEFAULT);
private:
  GMainContext* context_;
  SignalChildWatch& operator=(const SignalChildWatch&);
};
SignalTimeout signal_timeout();
SignalIdle signal_idle();
SignalIO signal_io();
SignalChildWatch signal_child_watch();
class MainContext
{
public:
  typedef Glib::MainContext CppObjectType;
  typedef GMainContext BaseObjectType;
  static Glib::RefPtr<MainContext> create();
  static Glib::RefPtr<MainContext> get_default();
  bool iteration(bool may_block);
  bool pending();
  void wakeup();
  bool acquire();
  bool wait(Glib::Cond& cond, Glib::Mutex& mutex);
  void release();
  bool prepare(int& priority);
  bool prepare();
  void query(int max_priority, int& timeout, std::vector<PollFD>& fds);
  bool check(int max_priority, std::vector<PollFD>& fds);
  void dispatch();
  void set_poll_func(GPollFunc poll_func);
  GPollFunc get_poll_func();
  void add_poll(PollFD& fd, int priority);
  void remove_poll(PollFD& fd);
  SignalTimeout signal_timeout();
  SignalIdle signal_idle();
  SignalIO signal_io();
  SignalChildWatch signal_child_watch();
  void reference() const;
  void unreference() const;
  GMainContext* gobj();
  const GMainContext* gobj() const;
  GMainContext* gobj_copy() const;
private:
  MainContext();
  void operator delete(void*, size_t);
  MainContext(const MainContext& other);
  MainContext& operator=(const MainContext& other);
};
Glib::RefPtr<MainContext> wrap(GMainContext* gobject, bool take_copy = false);
class MainLoop
{
public:
  typedef Glib::MainLoop CppObjectType;
  typedef GMainLoop BaseObjectType;
  static Glib::RefPtr<MainLoop> create(bool is_running = false);
  static Glib::RefPtr<MainLoop> create(const Glib::RefPtr<MainContext>& context,
                                       bool is_running = false);
  void run();
  void quit();
  bool is_running();
  Glib::RefPtr<MainContext> get_context();
  static int depth();
  void reference() const;
  void unreference() const;
  GMainLoop* gobj();
  const GMainLoop* gobj() const;
  GMainLoop* gobj_copy() const;
private:
  MainLoop();
  void operator delete(void*, size_t);
  MainLoop(const MainLoop&);
  MainLoop& operator=(const MainLoop&);
};
Glib::RefPtr<MainLoop> wrap(GMainLoop* gobject, bool take_copy = false);
class Source
{
public:
  typedef Glib::Source CppObjectType;
  typedef GSource BaseObjectType;
  static Glib::RefPtr<Source> create() ;
  unsigned int attach(const Glib::RefPtr<MainContext>& context);
  unsigned int attach();
  void destroy();
  void set_priority(int priority);
  int get_priority() const;
  void set_can_recurse(bool can_recurse);
  bool get_can_recurse() const;
  unsigned int get_id() const;
  Glib::RefPtr<MainContext> get_context();
  GSource* gobj() { return gobject_; }
  const GSource* gobj() const { return gobject_; }
  GSource* gobj_copy() const;
  void reference() const;
  void unreference() const;
protected:
  Source();
  Source(GSource* cast_item, GSourceFunc callback_func);
  virtual ~Source();
  sigc::connection connect_generic(const sigc::slot_base& slot);
  void add_poll(PollFD& poll_fd);
  void remove_poll(PollFD& poll_fd);
  void get_current_time(Glib::TimeVal& current_time);
  virtual bool prepare(int& timeout) = 0;
  virtual bool check() = 0;
  virtual bool dispatch(sigc::slot_base* slot) = 0;
private:
  GSource* gobject_;
  static inline Source* get_wrapper(GSource* source);
  static const GSourceFuncs vfunc_table_;
  static gboolean prepare_vfunc(GSource* source, int* timeout);
  static gboolean check_vfunc(GSource* source);
  static gboolean dispatch_vfunc(GSource* source, GSourceFunc callback, void* user_data);
public:
  static void destroy_notify_callback(void* data);
private:
  Source(const Source&);
  Source& operator=(const Source&);
};
class TimeoutSource : public Glib::Source
{
public:
  typedef Glib::TimeoutSource CppObjectType;
  static Glib::RefPtr<TimeoutSource> create(unsigned int interval);
  sigc::connection connect(const sigc::slot<bool>& slot);
protected:
  explicit TimeoutSource(unsigned int interval);
  virtual ~TimeoutSource();
  virtual bool prepare(int& timeout);
  virtual bool check();
  virtual bool dispatch(sigc::slot_base* slot);
private:
  Glib::TimeVal expiration_;
  unsigned int interval_;
};
class IdleSource : public Glib::Source
{
public:
  typedef Glib::IdleSource CppObjectType;
  static Glib::RefPtr<IdleSource> create();
  sigc::connection connect(const sigc::slot<bool>& slot);
protected:
  IdleSource();
  virtual ~IdleSource();
  virtual bool prepare(int& timeout);
  virtual bool check();
  virtual bool dispatch(sigc::slot_base* slot_data);
};
class IOSource : public Glib::Source
{
public:
  typedef Glib::IOSource CppObjectType;
  static Glib::RefPtr<IOSource> create(int fd, IOCondition condition);
  static Glib::RefPtr<IOSource> create(const Glib::RefPtr<IOChannel>& channel, IOCondition condition);
  sigc::connection connect(const sigc::slot<bool,IOCondition>& slot);
protected:
  IOSource(int fd, IOCondition condition);
  IOSource(const Glib::RefPtr<IOChannel>& channel, IOCondition condition);
  virtual ~IOSource();
  virtual bool prepare(int& timeout);
  virtual bool check();
  virtual bool dispatch(sigc::slot_base* slot);
private:
  PollFD poll_fd_;
};
}
namespace Glib
{
class DispatchNotifier;
class Dispatcher
{
public:
  Dispatcher();
  explicit Dispatcher(const Glib::RefPtr<MainContext>& context);
  ~Dispatcher();
  void emit();
  void operator()();
  sigc::connection connect(const sigc::slot<void>& slot);
private:
  sigc::signal<void> signal_;
  DispatchNotifier* notifier_;
  Dispatcher(const Dispatcher&);
  Dispatcher& operator=(const Dispatcher&);
  friend class Glib::DispatchNotifier;
};
}
namespace Glib
{
sigc::connection add_exception_handler(const sigc::slot<void>& slot);
void exception_handlers_invoke() throw();
}
extern "C" { typedef struct _GDir GDir; }
namespace Glib
{
enum FileTest
{
  FILE_TEST_IS_REGULAR = 1 << 0,
  FILE_TEST_IS_SYMLINK = 1 << 1,
  FILE_TEST_IS_DIR = 1 << 2,
  FILE_TEST_IS_EXECUTABLE = 1 << 3,
  FILE_TEST_EXISTS = 1 << 4
};
inline FileTest operator|(FileTest lhs, FileTest rhs)
  { return static_cast<FileTest>(static_cast<unsigned>(lhs) | static_cast<unsigned>(rhs)); }
inline FileTest operator&(FileTest lhs, FileTest rhs)
  { return static_cast<FileTest>(static_cast<unsigned>(lhs) & static_cast<unsigned>(rhs)); }
inline FileTest operator^(FileTest lhs, FileTest rhs)
  { return static_cast<FileTest>(static_cast<unsigned>(lhs) ^ static_cast<unsigned>(rhs)); }
inline FileTest operator~(FileTest flags)
  { return static_cast<FileTest>(~static_cast<unsigned>(flags)); }
inline FileTest& operator|=(FileTest& lhs, FileTest rhs)
  { return (lhs = static_cast<FileTest>(static_cast<unsigned>(lhs) | static_cast<unsigned>(rhs))); }
inline FileTest& operator&=(FileTest& lhs, FileTest rhs)
  { return (lhs = static_cast<FileTest>(static_cast<unsigned>(lhs) & static_cast<unsigned>(rhs))); }
inline FileTest& operator^=(FileTest& lhs, FileTest rhs)
  { return (lhs = static_cast<FileTest>(static_cast<unsigned>(lhs) ^ static_cast<unsigned>(rhs))); }
class FileError : public Glib::Error
{
public:
  enum Code
  {
    EXISTS,
    IS_DIRECTORY,
    ACCESS_DENIED,
    NAME_TOO_LONG,
    NO_SUCH_ENTITY,
    NOT_DIRECTORY,
    NO_SUCH_DEVICE,
    NOT_DEVICE,
    READONLY_FILESYSTEM,
    TEXT_FILE_BUSY,
    FAULTY_ADDRESS,
    SYMLINK_LOOP,
    NO_SPACE_LEFT,
    NOT_ENOUGH_MEMORY,
    TOO_MANY_OPEN_FILES,
    FILE_TABLE_OVERFLOW,
    BAD_FILE_DESCRIPTOR,
    INVALID_ARGUMENT,
    BROKEN_PIPE,
    TRYAGAIN,
    INTERRUPTED,
    IO_ERROR,
    NOT_OWNER,
    NOSYS,
    FAILED
  };
  FileError(Code error_code, const Glib::ustring& error_message);
  explicit FileError(GError* gobject);
  Code code() const;
private:
  static void throw_func(GError* gobject);
  friend void wrap_init();
};
class Dir;
class DirIterator
{
public:
  typedef std::input_iterator_tag iterator_category;
  typedef std::string value_type;
  typedef int difference_type;
  typedef value_type reference;
  typedef void pointer;
  DirIterator();
  DirIterator(GDir* gobject, const char* current);
  std::string operator*() const;
  DirIterator& operator++();
  void operator++(int);
  bool operator==(const DirIterator& rhs) const;
  bool operator!=(const DirIterator& rhs) const;
private:
  GDir* gobject_;
  const char* current_;
};
class Dir
{
public:
  typedef DirIterator iterator;
  typedef DirIterator const_iterator;
  explicit Dir(const std::string& path);
  explicit Dir(GDir* gobject);
  ~Dir();
  std::string read_name();
  void rewind();
  void close();
  DirIterator begin();
  DirIterator end();
private:
  GDir* gobject_;
  Dir(const Dir&);
  Dir& operator=(const Dir&);
};
bool file_test(const std::string& filename, FileTest test);
int mkstemp(std::string& filename_template);
int file_open_tmp(std::string& name_used, const std::string& prefix);
int file_open_tmp(std::string& name_used);
std::string file_get_contents(const std::string& filename);
}
namespace Glib { typedef Glib::ArrayHandle<Glib::ustring> SArray; }
namespace Glib
{
template <class T> class List_Iterator;
template <class T> class List_ConstIterator;
template <class T> class List_ReverseIterator;
extern gpointer glibmm_null_pointer;
template <class T>
class List_Iterator_Base
{
public:
  typedef T value_type;
  typedef T* pointer;
  typedef T& reference;
} ;
template <class T>
class List_Iterator : public List_Iterator_Base<T>
{
public:
  typedef std::bidirectional_iterator_tag iterator_category;
  typedef size_t size_type;
  typedef ptrdiff_t difference_type;
  typedef typename List_Iterator_Base<T>::pointer pointer;
  typedef typename List_Iterator_Base<T>::reference reference;
  GList* const* head_;
  GList* node_;
  typedef List_Iterator<T> Self;
  List_Iterator(GList* const& head, GList* node)
  : head_(&head), node_(node)
  {}
  List_Iterator()
   : head_(0), node_(0)
  {}
  List_Iterator(const Self& src)
  : head_(src.head_), node_(src.node_)
  {}
  bool operator==(const Self& src) const { return node_ == src.node_; }
  bool operator!=(const Self& src) const { return node_ != src.node_; }
  Self& operator++()
  {
    if (!node_)
      node_ = g_list_first(*head_);
    else
      node_ = (GList*)((node_) ? (((GList *)(node_))->next) : __null);
    return *this;
  }
  Self operator++(int)
  {
    Self tmp = *this;
    ++*this;
    return tmp;
  }
  Self& operator--()
  {
    if (!node_)
      node_ = g_list_last(*head_);
    else
      node_ = (GList*)((node_) ? (((GList *)(node_))->prev) : __null);
    return *this;
  }
  Self operator--(int)
  {
    Self tmp = *this;
    --*this;
    return tmp;
  }
  reference operator*() const
  {
    return *(pointer)( node_ ? node_->data : glibmm_null_pointer );
  }
  pointer operator -> () const { return &operator*(); }
};
template <class T>
class SList_Iterator : public List_Iterator_Base<T>
{
public:
  typedef std::forward_iterator_tag iterator_category;
  typedef size_t size_type;
  typedef ptrdiff_t difference_type;
  typedef typename List_Iterator_Base<T>::pointer pointer;
  typedef typename List_Iterator_Base<T>::reference reference;
  GSList* node_;
  typedef SList_Iterator<T> Self;
  SList_Iterator(GSList* node)
   : node_(node)
   {}
  SList_Iterator()
   : node_(0)
   {}
  SList_Iterator(const Self& src)
  : node_(src.node_)
  {}
  bool operator==(const Self& src) const { return node_ == src.node_; }
  bool operator!=(const Self& src) const { return node_ != src.node_; }
  Self& operator++()
  {
    node_ = ((node_) ? (((GSList *)(node_))->next) : __null);
    return *this;
  }
  Self operator++(int)
  {
    Self tmp = *this;
    ++*this;
    return tmp;
  }
  reference operator*() const
  {
    return reinterpret_cast<T&>( node_ ? node_->data : glibmm_null_pointer );
  }
  pointer operator -> () const { return &operator*(); }
};
template<class T_Impl, class T_IFace>
class List_Cpp_Iterator : public List_Iterator_Base<T_IFace>
{
public:
  typedef std::bidirectional_iterator_tag iterator_category;
  typedef size_t size_type;
  typedef ptrdiff_t difference_type;
  typedef typename List_Iterator_Base<T_IFace>::pointer pointer;
  typedef typename List_Iterator_Base<T_IFace>::reference reference;
  typedef List_Cpp_Iterator<T_Impl, T_IFace> Self;
  GList** head_;
  GList* node_;
  bool operator==(const Self& src) const { return node_ == src.node_; }
  bool operator!=(const Self& src) const { return node_ != src.node_; }
  List_Cpp_Iterator(GList*& head, GList* node )
  : head_(&head), node_(node )
  {}
  List_Cpp_Iterator()
  : head_(0), node_(0)
  {}
  List_Cpp_Iterator(const Self& src)
  : head_(src.head_), node_(src.node_)
  {}
  reference operator*() const
  {
    if (node_ && node_->data)
    {
      GObject* cobj = static_cast<GObject*>( (*node_).data );
      return *(dynamic_cast<pointer>(Glib::wrap_auto(cobj, false )));
    }
    return *(pointer)glibmm_null_pointer;
  }
  pointer operator->() const { return &operator*(); }
  Self& operator++()
  {
    if (!node_)
      node_ = g_list_first(*head_);
    else
      node_ = (GList *)((node_) ? (((GList *)(node_))->next) : __null);
    return *this;
  }
  Self operator++(int)
  {
    Self tmp = *this;
    ++*this;
    return tmp;
  }
  Self& operator--()
  {
    if (!node_)
      node_ = g_list_last(*head_);
    else
      node_ = (GList *)((node_) ? (((GList *)(node_))->prev) : __null);
    return *this;
  }
  Self operator--(int)
  {
    Self tmp = *this;
    --*this;
    return tmp;
  }
};
template <class T_Base>
class List_ReverseIterator: private T_Base
{
public:
  typedef typename T_Base::iterator_category iterator_category;
  typedef typename T_Base::size_type size_type;
  typedef typename T_Base::difference_type difference_type;
  typedef typename T_Base::value_type value_type;
  typedef typename T_Base::pointer pointer;
  typedef typename T_Base::reference reference;
  typedef List_ReverseIterator<T_Base> Self;
  bool operator==(const Self& src) const { return T_Base::operator==(src); }
  bool operator!=(const Self& src) const { return T_Base::operator!=(src); }
  List_ReverseIterator(GList* const& head, GList* node)
   : T_Base(head, node)
  {}
  List_ReverseIterator()
   : T_Base()
  {}
  List_ReverseIterator(const Self& src)
  : T_Base(src)
  {}
  List_ReverseIterator(const T_Base& src)
  : T_Base(src)
  { ++(*this); }
  Self& operator++() {T_Base::operator--(); return *this;}
  Self& operator--() {T_Base::operator++(); return *this;}
  Self operator++(int) {Self src = *this; T_Base::operator--(); return src;}
  Self operator--(int) {Self src = *this; T_Base::operator++(); return src;}
  reference operator*() const { return T_Base::operator*(); }
  pointer operator->() const { return T_Base::operator->(); }
};
template <class T_Base>
class List_ConstIterator: public T_Base
{
public:
  typedef typename T_Base::iterator_category iterator_category;
  typedef typename T_Base::size_type size_type;
  typedef typename T_Base::difference_type difference_type;
  typedef const typename T_Base::value_type value_type;
  typedef const typename T_Base::pointer pointer;
  typedef const typename T_Base::reference reference;
  typedef List_ConstIterator<T_Base> Self;
  bool operator==(const Self& src) const { return T_Base::operator==(src); }
  bool operator!=(const Self& src) const { return T_Base::operator!=(src); }
  List_ConstIterator(GList* const& head, GList* node)
  : T_Base(head, node)
  {}
  List_ConstIterator()
  : T_Base()
  {}
  List_ConstIterator(const Self& src)
  : T_Base(src)
  {}
  List_ConstIterator(const T_Base& src)
  : T_Base(src)
  {}
  Self& operator++() {T_Base::operator++(); return *this;}
  Self& operator--() {T_Base::operator--(); return *this;}
  Self operator++(int) {Self src = *this; T_Base::operator++(); return src;}
  Self operator--(int) {Self src = *this; T_Base::operator--(); return src;}
  reference operator*() const { return T_Base::operator*(); }
  pointer operator->() const { return T_Base::operator->(); }
};
}
namespace Glib
{
template< typename T_Child, typename T_CppElement, typename T_Iterator >
class HelperList
{
public:
  HelperList()
  : gparent_(0)
  {}
  HelperList(GObject* gp)
  : gparent_(gp)
  {}
  virtual ~HelperList()
  {}
  typedef T_Child value_type;
  typedef value_type& reference;
  typedef const value_type& const_reference;
  typedef T_Iterator iterator;
  typedef List_ConstIterator<iterator> const_iterator;
  typedef List_ReverseIterator<iterator> reverse_iterator;
  typedef List_ConstIterator<reverse_iterator> const_reverse_iterator;
  typedef T_CppElement element_type;
  typedef size_t difference_type;
  typedef size_t size_type;
  virtual iterator erase(iterator) = 0;
  virtual void erase(iterator start, iterator stop)
  {
    while(start != stop)
      start = erase(start);
  }
  virtual void remove(const_reference) = 0;
  size_type size() const
  {
    return g_list_length(glist());
  }
  inline size_type max_size() { return size_type(-1); }
  inline bool empty() { return glist() == 0; }
  inline iterator begin()
    {return begin_();}
  inline iterator end()
    {return end_();}
  inline const_iterator begin() const
    { return const_iterator(begin_()); }
  inline const_iterator end() const
    { return const_iterator(end_()); }
  inline reverse_iterator rbegin()
    { return reverse_iterator(end_()); }
  inline reverse_iterator rend()
    { return reverse_iterator(begin_()); }
  inline const_reverse_iterator rbegin() const
    { return const_reverse_iterator(reverse_iterator(end_())); }
  inline const_reverse_iterator rend() const
    { return const_reverse_iterator(reverse_iterator(begin_())); }
  reference front() const
  {
    return *begin();
  }
  reference back() const
  {
    return *(--end());
  }
  reference operator[](size_type l) const
  {
    size_type j = 0;
    iterator i;
    for(i = begin(), j = 0; i != end(), j < l; ++i, ++j);
    return (*i);
  }
  inline void pop_front()
    { erase(begin()); }
  inline void pop_back()
    { erase(--end()); }
  void clear()
    { erase(begin(), end()); }
  GObject* gparent()
    { return gparent_; };
  const GObject* gparent() const
    { return gparent_; };
protected:
  virtual GList*& glist() const = 0;
  iterator begin_() const
  {
    return iterator(glist(), glist());
  }
  iterator end_() const
  {
    return iterator(glist(), (GList*)0);
  }
  GObject* gparent_;
};
}
namespace Glib
{
template <typename T>
class ScopedPtr
{
private:
  T* ptr_;
  ScopedPtr(const ScopedPtr<T>&);
  ScopedPtr<T>& operator=(const ScopedPtr<T>&);
public:
  ScopedPtr() : ptr_ (0) {}
  explicit ScopedPtr(T* ptr) : ptr_ (ptr) {}
  ~ScopedPtr() { g_free(ptr_); }
  T* get() const { return ptr_; }
  T** addr() { return &ptr_; }
};
template <class T>
inline T* unconst(const T* t)
  { return const_cast<T*>(t); }
inline
Glib::ustring convert_const_gchar_ptr_to_ustring(const char* str)
{
  return (str) ? Glib::ustring(str) : Glib::ustring();
}
inline
std::string convert_const_gchar_ptr_to_stdstring(const char* str)
{
  return (str) ? std::string(str) : std::string();
}
inline
Glib::ustring convert_return_gchar_ptr_to_ustring(char* str)
{
  return (str) ? Glib::ustring(Glib::ScopedPtr<char>(str).get())
               : Glib::ustring();
}
inline
std::string convert_return_gchar_ptr_to_stdstring(char* str)
{
  return (str) ? std::string(Glib::ScopedPtr<char>(str).get())
               : std::string();
}
void append_canonical_typename(std::string& dest, const char* type_name);
}
extern "C"
{
typedef struct _GObject GObject;
typedef struct _GObjectClass GObjectClass;
}
namespace Glib
{
class Class;
class Object_Class;
class GSigConnectionNode;
class ConstructParams
{
public:
  const Glib::Class& glibmm_class;
  unsigned int n_parameters;
  GParameter* parameters;
  explicit ConstructParams(const Glib::Class& glibmm_class_);
  ConstructParams(const Glib::Class& glibmm_class_, const char* first_property_name, ...)
    __attribute__((__sentinel__));
  ~ConstructParams();
  ConstructParams(const ConstructParams& other);
private:
  ConstructParams& operator=(const ConstructParams&);
};
class Object : virtual public ObjectBase
{
public:
  typedef Object CppObjectType;
  typedef Object_Class CppClassType;
  typedef GObject BaseObjectType;
  typedef GObjectClass BaseClassType;
protected:
  Object();
  explicit Object(const Glib::ConstructParams& construct_params);
  explicit Object(GObject* castitem);
  virtual ~Object();
public:
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  void* get_data(const QueryQuark &key);
  void set_data(const Quark &key, void* data);
  typedef void (*DestroyNotify) (gpointer data);
  void set_data(const Quark &key, void* data, DestroyNotify notify);
  void remove_data(const QueryQuark& quark);
  void* steal_data(const QueryQuark& quark);
private:
  friend class Glib::Object_Class;
  static CppClassType object_class_;
  Object(const Object&);
  Object& operator=(const Object&);
};
}
namespace Glib
{
class Interface_Class;
class Interface : virtual public Glib::ObjectBase
{
public:
  typedef Interface CppObjectType;
  typedef Interface_Class CppClassType;
  typedef GTypeInterface BaseClassType;
  explicit Interface(const Glib::Interface_Class& interface_class);
  explicit Interface(GObject* castitem);
  virtual ~Interface();
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  inline GObject* gobj() { return gobject_; }
  inline const GObject* gobj() const { return gobject_; }
private:
  Interface(const Interface&);
  Interface& operator=(const Interface&);
};
RefPtr<ObjectBase> wrap_interface(GObject* object, bool take_copy = false);
}
extern "C" { typedef struct _GIOChannel GIOChannel; }
namespace Glib
{
class Source;
class IOSource;
enum SeekType
{
  SEEK_TYPE_CUR,
  SEEK_TYPE_SET,
  SEEK_TYPE_END
};
enum IOStatus
{
  IO_STATUS_ERROR,
  IO_STATUS_NORMAL,
  IO_STATUS_EOF,
  IO_STATUS_AGAIN
};
enum IOFlags
{
  IO_FLAG_APPEND = 1 << 0,
  IO_FLAG_NONBLOCK = 1 << 1,
  IO_FLAG_IS_READABLE = 1 << 2,
  IO_FLAG_IS_WRITEABLE = 1 << 3,
  IO_FLAG_IS_SEEKABLE = 1 << 4,
  IO_FLAG_GET_MASK = 0x0,
  IO_FLAG_SET_MASK = 0x1
};
inline IOFlags operator|(IOFlags lhs, IOFlags rhs)
  { return static_cast<IOFlags>(static_cast<unsigned>(lhs) | static_cast<unsigned>(rhs)); }
inline IOFlags operator&(IOFlags lhs, IOFlags rhs)
  { return static_cast<IOFlags>(static_cast<unsigned>(lhs) & static_cast<unsigned>(rhs)); }
inline IOFlags operator^(IOFlags lhs, IOFlags rhs)
  { return static_cast<IOFlags>(static_cast<unsigned>(lhs) ^ static_cast<unsigned>(rhs)); }
inline IOFlags operator~(IOFlags flags)
  { return static_cast<IOFlags>(~static_cast<unsigned>(flags)); }
inline IOFlags& operator|=(IOFlags& lhs, IOFlags rhs)
  { return (lhs = static_cast<IOFlags>(static_cast<unsigned>(lhs) | static_cast<unsigned>(rhs))); }
inline IOFlags& operator&=(IOFlags& lhs, IOFlags rhs)
  { return (lhs = static_cast<IOFlags>(static_cast<unsigned>(lhs) & static_cast<unsigned>(rhs))); }
inline IOFlags& operator^=(IOFlags& lhs, IOFlags rhs)
  { return (lhs = static_cast<IOFlags>(static_cast<unsigned>(lhs) ^ static_cast<unsigned>(rhs))); }
class IOChannelError : public Glib::Error
{
public:
  enum Code
  {
    FILE_TOO_BIG,
    INVALID_ARGUMENT,
    IO_ERROR,
    IS_DIRECTORY,
    NO_SPACE_LEFT,
    NO_SUCH_DEVICE,
    OVERFLOWN,
    BROKEN_PIPE,
    FAILED
  };
  IOChannelError(Code error_code, const Glib::ustring& error_message);
  explicit IOChannelError(GError* gobject);
  Code code() const;
private:
  static void throw_func(GError* gobject);
  friend void wrap_init();
};
class GlibmmIOChannel;
class IOChannel : public sigc::trackable
{
  public:
  typedef IOChannel CppObjectType;
  typedef GIOChannel BaseObjectType;
private:
public:
  virtual ~IOChannel();
  static Glib::RefPtr<IOChannel> create_from_file(const std::string& filename, const std::string& mode);
  static Glib::RefPtr<IOChannel> create_from_fd(int fd);
  IOStatus read(gunichar& thechar);
  IOStatus read(char* buf, gsize count, gsize& bytes_read);
  IOStatus read(Glib::ustring& str, gsize count);
  IOStatus read_line(Glib::ustring& line);
  IOStatus read_to_end(Glib::ustring& str);
  IOStatus write(const Glib::ustring& str);
  IOStatus write(const char* buf, gssize count, gsize& bytes_written);
  IOStatus write(gunichar unichar);
  IOStatus seek(gint64 offset, SeekType type = SEEK_TYPE_SET);
  IOStatus flush();
  IOStatus close(bool flush = true);
  gsize get_buffer_size() const;
  void set_buffer_size(gsize size);
  IOFlags get_flags() const;
  IOStatus set_flags(IOFlags flags);
  void set_buffered(bool buffered);
  bool get_buffered() const;
  IOCondition get_buffer_condition() const;
  bool get_close_on_unref() const;
  void set_close_on_unref(bool do_close);
  IOStatus set_encoding(const std::string& encoding = std::string());
  std::string get_encoding() const;
  void set_line_term(const std::string& term = std::string());
  std::string get_line_term() const;
  Glib::RefPtr<IOSource> create_watch(IOCondition condition);
  virtual void reference() const;
  virtual void unreference() const;
  GIOChannel* gobj() { return gobject_; }
  const GIOChannel* gobj() const { return gobject_; }
protected:
  GIOChannel* gobject_;
  IOChannel();
  IOChannel(GIOChannel* gobject, bool take_copy);
  virtual IOStatus read_vfunc(char* buf, gsize count, gsize& bytes_read);
  virtual IOStatus write_vfunc(const char* buf, gsize count, gsize& bytes_written);
  virtual IOStatus seek_vfunc(gint64 offset, SeekType type);
  virtual IOStatus close_vfunc();
  virtual IOStatus set_flags_vfunc(IOFlags flags);
  virtual IOFlags get_flags_vfunc();
  virtual Glib::RefPtr<Glib::Source> create_watch_vfunc(IOCondition cond);
  friend class Glib::GlibmmIOChannel;
};
Glib::RefPtr<IOChannel> wrap(GIOChannel* gobject, bool take_copy = false);
}
namespace Glib
{
void init();
}
extern "C" { typedef struct _GKeyFile GKeyFile; }
namespace Glib
{
enum KeyFileFlags
{
  KEY_FILE_NONE = 0,
  KEY_FILE_KEEP_COMMENTS = 1 << 0,
  KEY_FILE_KEEP_TRANSLATIONS = 1 << 1
};
inline KeyFileFlags operator|(KeyFileFlags lhs, KeyFileFlags rhs)
  { return static_cast<KeyFileFlags>(static_cast<unsigned>(lhs) | static_cast<unsigned>(rhs)); }
inline KeyFileFlags operator&(KeyFileFlags lhs, KeyFileFlags rhs)
  { return static_cast<KeyFileFlags>(static_cast<unsigned>(lhs) & static_cast<unsigned>(rhs)); }
inline KeyFileFlags operator^(KeyFileFlags lhs, KeyFileFlags rhs)
  { return static_cast<KeyFileFlags>(static_cast<unsigned>(lhs) ^ static_cast<unsigned>(rhs)); }
inline KeyFileFlags operator~(KeyFileFlags flags)
  { return static_cast<KeyFileFlags>(~static_cast<unsigned>(flags)); }
inline KeyFileFlags& operator|=(KeyFileFlags& lhs, KeyFileFlags rhs)
  { return (lhs = static_cast<KeyFileFlags>(static_cast<unsigned>(lhs) | static_cast<unsigned>(rhs))); }
inline KeyFileFlags& operator&=(KeyFileFlags& lhs, KeyFileFlags rhs)
  { return (lhs = static_cast<KeyFileFlags>(static_cast<unsigned>(lhs) & static_cast<unsigned>(rhs))); }
inline KeyFileFlags& operator^=(KeyFileFlags& lhs, KeyFileFlags rhs)
  { return (lhs = static_cast<KeyFileFlags>(static_cast<unsigned>(lhs) ^ static_cast<unsigned>(rhs))); }
class KeyFileError : public Glib::Error
{
public:
  enum Code
  {
    UNKNOWN_ENCODING,
    PARSE,
    NOT_FOUND,
    KEY_NOT_FOUND,
    GROUP_NOT_FOUND,
    INVALID_VALUE
  };
  KeyFileError(Code error_code, const Glib::ustring& error_message);
  explicit KeyFileError(GError* gobject);
  Code code() const;
private:
  static void throw_func(GError* gobject);
  friend void wrap_init();
};
class KeyFile
{
  public:
  typedef KeyFile CppObjectType;
  typedef GKeyFile BaseObjectType;
private:
public:
  KeyFile();
  ~KeyFile();
  KeyFile(GKeyFile* castitem, bool takes_ownership = false);
public:
  bool load_from_file(const std::string& filename, KeyFileFlags flags = Glib::KEY_FILE_NONE);
  bool load_from_data(const Glib::ustring& data, KeyFileFlags flags = Glib::KEY_FILE_NONE);
  bool load_from_data_dirs(const std::string& file, std::string& full_path, KeyFileFlags flags = Glib::KEY_FILE_NONE);
  Glib::ustring to_data();
  Glib::ustring get_start_group() const;
  Glib::ArrayHandle<Glib::ustring> get_groups() const;
  Glib::ArrayHandle<Glib::ustring> get_keys(const Glib::ustring& group_name) const;
  bool has_group(const Glib::ustring& group_name) const;
  bool has_key(const Glib::ustring& group_name, const Glib::ustring& key) const;
  Glib::ustring get_value(const Glib::ustring& group_name, const Glib::ustring& key) const;
  Glib::ustring get_string(const Glib::ustring& group_name, const Glib::ustring& key) const;
  Glib::ustring get_locale_string(const Glib::ustring& group_name, const Glib::ustring& key) const;
  Glib::ustring get_locale_string(const Glib::ustring& group_name, const Glib::ustring& key, const Glib::ustring& locale) const;
  bool get_boolean(const Glib::ustring& group_name, const Glib::ustring& key) const;
  int get_integer(const Glib::ustring& key) const;
  int get_integer(const Glib::ustring& group_name, const Glib::ustring& key) const;
   double get_double(const Glib::ustring& key) const;
  double get_double(const Glib::ustring& group_name, const Glib::ustring& key) const;
  void set_double(const Glib::ustring& group_name, const Glib::ustring& key, double value);
  void set_double(const Glib::ustring& key, double value);
  Glib::ArrayHandle<Glib::ustring> get_string_list(const Glib::ustring& group_name, const Glib::ustring& key) const;
  Glib::ArrayHandle<Glib::ustring> get_locale_string_list(const Glib::ustring& group_name, const Glib::ustring& key) const;
  Glib::ArrayHandle<Glib::ustring> get_locale_string_list(const Glib::ustring& group_name, const Glib::ustring& key, const Glib::ustring& locale) const;
  Glib::ArrayHandle<bool> get_boolean_list(const Glib::ustring& group_name, const Glib::ustring& key) const;
  Glib::ArrayHandle<int> get_integer_list(const Glib::ustring& group_name, const Glib::ustring& key) const;
  Glib::ArrayHandle<double> get_double_list(const Glib::ustring& group_name, const Glib::ustring& key) const;
  Glib::ustring get_comment() const;
  Glib::ustring get_comment(const Glib::ustring& group_name) const;
  Glib::ustring get_comment(const Glib::ustring& group_name, const Glib::ustring& key) const;
  void set_list_separator(gchar separator);
  void set_value(const Glib::ustring& group_name, const Glib::ustring& key, const Glib::ustring& value);
  void set_string(const Glib::ustring& group_name, const Glib::ustring& key, const Glib::ustring& string);
  void set_locale_string(const Glib::ustring& group_name, const Glib::ustring& key, const Glib::ustring& locale, const Glib::ustring& string);
  void set_boolean(const Glib::ustring& group_name, const Glib::ustring& key, bool value);
  void set_integer(const Glib::ustring& group_name, const Glib::ustring& key, int value);
  void set_string_list(const Glib::ustring& group_name, const Glib::ustring& key, const Glib::ArrayHandle<Glib::ustring>& list);
  void set_locale_string_list(const Glib::ustring& group_name, const Glib::ustring& key, const Glib::ustring& locale, const Glib::ArrayHandle<Glib::ustring>& list);
  void set_boolean_list(const Glib::ustring& group_name, const Glib::ustring& key, Glib::ArrayHandle<bool>& list);
  void set_integer_list(const Glib::ustring& group_name, const Glib::ustring& key, Glib::ArrayHandle<int>& list);
  void set_double_list(const Glib::ustring& group_name, const Glib::ustring& key, Glib::ArrayHandle<double>& list);
  void set_comment(const Glib::ustring& comment);
  void set_comment(const Glib::ustring& group_name, const Glib::ustring& comment);
  void set_comment(const Glib::ustring& group_name, const Glib::ustring& key, const Glib::ustring& comment);
  void remove_comment(const Glib::ustring& group_name, const Glib::ustring& key);
  void remove_key(const Glib::ustring& group_name, const Glib::ustring& key);
  void remove_group(const Glib::ustring& group_name);
  GKeyFile* gobj() { return gobject_; }
  const GKeyFile* gobj() const { return gobject_; }
protected:
  GKeyFile* gobject_;
  bool owns_gobject_;
private:
  KeyFile(const KeyFile&);
  KeyFile& operator=(const KeyFile&);
};
}
namespace Glib
{
class StreamIOChannel : public Glib::IOChannel
{
public:
  virtual ~StreamIOChannel();
  static Glib::RefPtr<StreamIOChannel> create(std::istream& stream);
  static Glib::RefPtr<StreamIOChannel> create(std::ostream& stream);
  static Glib::RefPtr<StreamIOChannel> create(std::iostream& stream);
protected:
  std::istream* stream_in_;
  std::ostream* stream_out_;
  StreamIOChannel(std::istream* stream_in, std::ostream* stream_out);
  virtual IOStatus read_vfunc(char* buf, gsize count, gsize& bytes_read);
  virtual IOStatus write_vfunc(const char* buf, gsize count, gsize& bytes_written);
  virtual IOStatus seek_vfunc(gint64 offset, SeekType type);
  virtual IOStatus close_vfunc();
  virtual IOStatus set_flags_vfunc(IOFlags flags);
  virtual IOFlags get_flags_vfunc();
  virtual Glib::RefPtr<Glib::Source> create_watch_vfunc(IOCondition cond);
};
}
namespace Glib
{
namespace Container_Helpers
{
template <class Bi, class Tr>
GList* create_list(Bi pbegin, Bi pend, Tr)
{
  GList* head = 0;
  while(pend != pbegin)
  {
    const void *const item = Tr::to_c_type(*&*--pend);
    head = g_list_prepend(head, const_cast<void*>(item));
  }
  return head;
}
template <class For, class Tr>
GList* create_list(For pbegin, Tr)
{
  GList* head = 0;
  while(*pbegin)
  {
    const void *const item = Tr::to_c_type(*&*pbegin);
    head = g_list_prepend(head, const_cast<void*>(item));
    ++pbegin;
  }
  return g_list_reverse(head);
}
template <class Tr, class Cont>
struct ListSourceTraits
{
  static GList* get_data(const Cont& cont)
    { return Glib::Container_Helpers::create_list(cont.begin(), cont.end(), Tr()); }
  static const Glib::OwnershipType initial_ownership = Glib::OWNERSHIP_SHALLOW;
};
template <class Tr, class Cont>
struct ListSourceTraits<Tr,Cont*>
{
  static GList* get_data(const Cont* array)
    { return (array) ? Glib::Container_Helpers::create_list(array, Tr()) : 0; }
  static const Glib::OwnershipType initial_ownership = Glib::OWNERSHIP_SHALLOW;
};
template <class Tr, class Cont>
struct ListSourceTraits<Tr,const Cont*> : ListSourceTraits<Tr,Cont*>
{};
template <class Tr, class Cont, size_t N>
struct ListSourceTraits<Tr,Cont[N]>
{
  static GList* get_data(const Cont* array)
    { return Glib::Container_Helpers::create_list(array, array + (N - 1), Tr()); }
  static const Glib::OwnershipType initial_ownership = Glib::OWNERSHIP_SHALLOW;
};
template <class Tr, class Cont, size_t N>
struct ListSourceTraits<Tr,const Cont[N]> : ListSourceTraits<Tr,Cont[N]>
{};
template <class Tr>
class ListHandleIterator
{
public:
  typedef typename Tr::CppType CppType;
  typedef typename Tr::CType CType;
  typedef std::forward_iterator_tag iterator_category;
  typedef CppType value_type;
  typedef ptrdiff_t difference_type;
  typedef value_type reference;
  typedef void pointer;
  explicit inline ListHandleIterator(const GList* node);
  inline value_type operator*() const;
  inline ListHandleIterator<Tr> & operator++();
  inline const ListHandleIterator<Tr> operator++(int);
  inline bool operator==(const ListHandleIterator<Tr>& rhs) const;
  inline bool operator!=(const ListHandleIterator<Tr>& rhs) const;
private:
  const GList* node_;
};
}
template < class T, class Tr = Glib::Container_Helpers::TypeTraits<T> >
class ListHandle
{
public:
  typedef typename Tr::CppType CppType;
  typedef typename Tr::CType CType;
  typedef CppType value_type;
  typedef size_t size_type;
  typedef ptrdiff_t difference_type;
  typedef Glib::Container_Helpers::ListHandleIterator<Tr> const_iterator;
  typedef Glib::Container_Helpers::ListHandleIterator<Tr> iterator;
  template <class Cont> inline
    ListHandle(const Cont& container);
  inline ListHandle(GList* glist, Glib::OwnershipType ownership);
  inline ListHandle(const ListHandle<T,Tr>& other);
  ~ListHandle();
  inline const_iterator begin() const;
  inline const_iterator end() const;
  template <class U> inline operator std::vector<U>() const;
  template <class U> inline operator std::deque<U>() const;
  template <class U> inline operator std::list<U>() const;
  template <class Cont> inline
    void assign_to(Cont& container) const;
  template <class Out> inline
    void copy(Out pdest) const;
  inline GList* data() const;
  inline size_t size() const;
  inline bool empty() const;
private:
  GList * plist_;
  mutable Glib::OwnershipType ownership_;
  ListHandle<T,Tr>& operator=(const ListHandle<T,Tr>&);
};
namespace Container_Helpers
{
template <class Tr> inline
ListHandleIterator<Tr>::ListHandleIterator(const GList* node)
:
  node_ (node)
{}
template <class Tr> inline
typename ListHandleIterator<Tr>::value_type ListHandleIterator<Tr>::operator*() const
{
  return Tr::to_cpp_type(static_cast<typename Tr::CTypeNonConst>(node_->data));
}
template <class Tr> inline
ListHandleIterator<Tr>& ListHandleIterator<Tr>::operator++()
{
  node_ = node_->next;
  return *this;
}
template <class Tr> inline
const ListHandleIterator<Tr> ListHandleIterator<Tr>::operator++(int)
{
  const ListHandleIterator<Tr> tmp (*this);
  node_ = node_->next;
  return tmp;
}
template <class Tr> inline
bool ListHandleIterator<Tr>::operator==(const ListHandleIterator<Tr>& rhs) const
{
  return (node_ == rhs.node_);
}
template <class Tr> inline
bool ListHandleIterator<Tr>::operator!=(const ListHandleIterator<Tr>& rhs) const
{
  return (node_ != rhs.node_);
}
}
template <class T, class Tr>
  template <class Cont>
inline
ListHandle<T,Tr>::ListHandle(const Cont& container)
:
  plist_ (Glib::Container_Helpers::ListSourceTraits<Tr,Cont>::get_data(container)),
  ownership_ (Glib::Container_Helpers::ListSourceTraits<Tr,Cont>::initial_ownership)
{}
template <class T, class Tr> inline
ListHandle<T,Tr>::ListHandle(GList* glist, Glib::OwnershipType ownership)
:
  plist_ (glist),
  ownership_ (ownership)
{}
template <class T, class Tr> inline
ListHandle<T,Tr>::ListHandle(const ListHandle<T,Tr>& other)
:
  plist_ (other.plist_),
  ownership_ (other.ownership_)
{
  other.ownership_ = Glib::OWNERSHIP_NONE;
}
template <class T, class Tr>
ListHandle<T,Tr>::~ListHandle()
{
  if(ownership_ != Glib::OWNERSHIP_NONE)
  {
    if(ownership_ != Glib::OWNERSHIP_SHALLOW)
    {
      for(GList* node = plist_; node != 0; node = node->next)
        Tr::release_c_type(static_cast<typename Tr::CTypeNonConst>(node->data));
    }
    g_list_free(plist_);
  }
}
template <class T, class Tr> inline
typename ListHandle<T,Tr>::const_iterator ListHandle<T,Tr>::begin() const
{
  return Glib::Container_Helpers::ListHandleIterator<Tr>(plist_);
}
template <class T, class Tr> inline
typename ListHandle<T,Tr>::const_iterator ListHandle<T,Tr>::end() const
{
  return Glib::Container_Helpers::ListHandleIterator<Tr>(0);
}
template <class T, class Tr>
  template <class U>
inline
ListHandle<T,Tr>::operator std::vector<U>() const
{
  return std::vector<U>(this->begin(), this->end());
}
template <class T, class Tr>
  template <class U>
inline
ListHandle<T,Tr>::operator std::deque<U>() const
{
  return std::deque<U>(this->begin(), this->end());
}
template <class T, class Tr>
  template <class U>
inline
ListHandle<T,Tr>::operator std::list<U>() const
{
  return std::list<U>(this->begin(), this->end());
}
template <class T, class Tr>
  template <class Cont>
inline
void ListHandle<T,Tr>::assign_to(Cont& container) const
{
  container.assign(this->begin(), this->end());
}
template <class T, class Tr>
  template <class Out>
inline
void ListHandle<T,Tr>::copy(Out pdest) const
{
  std::copy(this->begin(), this->end(), pdest);
}
template <class T, class Tr> inline
GList* ListHandle<T,Tr>::data() const
{
  return plist_;
}
template <class T, class Tr> inline
size_t ListHandle<T,Tr>::size() const
{
  return g_list_length(plist_);
}
template <class T, class Tr> inline
bool ListHandle<T,Tr>::empty() const
{
  return (plist_ == 0);
}
}
namespace std
{
  enum _Rb_tree_color { _S_red = false, _S_black = true };
  struct _Rb_tree_node_base
  {
    typedef _Rb_tree_node_base* _Base_ptr;
    typedef const _Rb_tree_node_base* _Const_Base_ptr;
    _Rb_tree_color _M_color;
    _Base_ptr _M_parent;
    _Base_ptr _M_left;
    _Base_ptr _M_right;
    static _Base_ptr
    _S_minimum(_Base_ptr __x)
    {
      while (__x->_M_left != 0) __x = __x->_M_left;
      return __x;
    }
    static _Const_Base_ptr
    _S_minimum(_Const_Base_ptr __x)
    {
      while (__x->_M_left != 0) __x = __x->_M_left;
      return __x;
    }
    static _Base_ptr
    _S_maximum(_Base_ptr __x)
    {
      while (__x->_M_right != 0) __x = __x->_M_right;
      return __x;
    }
    static _Const_Base_ptr
    _S_maximum(_Const_Base_ptr __x)
    {
      while (__x->_M_right != 0) __x = __x->_M_right;
      return __x;
    }
  };
  template<typename _Val>
    struct _Rb_tree_node : public _Rb_tree_node_base
    {
      typedef _Rb_tree_node<_Val>* _Link_type;
      _Val _M_value_field;
    };
  _Rb_tree_node_base*
  _Rb_tree_increment(_Rb_tree_node_base* __x);
  const _Rb_tree_node_base*
  _Rb_tree_increment(const _Rb_tree_node_base* __x);
  _Rb_tree_node_base*
  _Rb_tree_decrement(_Rb_tree_node_base* __x);
  const _Rb_tree_node_base*
  _Rb_tree_decrement(const _Rb_tree_node_base* __x);
  template<typename _Tp>
    struct _Rb_tree_iterator
    {
      typedef _Tp value_type;
      typedef _Tp& reference;
      typedef _Tp* pointer;
      typedef bidirectional_iterator_tag iterator_category;
      typedef ptrdiff_t difference_type;
      typedef _Rb_tree_iterator<_Tp> _Self;
      typedef _Rb_tree_node_base::_Base_ptr _Base_ptr;
      typedef _Rb_tree_node<_Tp>* _Link_type;
      _Rb_tree_iterator()
      : _M_node() { }
      explicit
      _Rb_tree_iterator(_Link_type __x)
      : _M_node(__x) { }
      reference
      operator*() const
      { return static_cast<_Link_type>(_M_node)->_M_value_field; }
      pointer
      operator->() const
      { return &static_cast<_Link_type>(_M_node)->_M_value_field; }
      _Self&
      operator++()
      {
 _M_node = _Rb_tree_increment(_M_node);
 return *this;
      }
      _Self
      operator++(int)
      {
 _Self __tmp = *this;
 _M_node = _Rb_tree_increment(_M_node);
 return __tmp;
      }
      _Self&
      operator--()
      {
 _M_node = _Rb_tree_decrement(_M_node);
 return *this;
      }
      _Self
      operator--(int)
      {
 _Self __tmp = *this;
 _M_node = _Rb_tree_decrement(_M_node);
 return __tmp;
      }
      bool
      operator==(const _Self& __x) const
      { return _M_node == __x._M_node; }
      bool
      operator!=(const _Self& __x) const
      { return _M_node != __x._M_node; }
      _Base_ptr _M_node;
  };
  template<typename _Tp>
    struct _Rb_tree_const_iterator
    {
      typedef _Tp value_type;
      typedef const _Tp& reference;
      typedef const _Tp* pointer;
      typedef _Rb_tree_iterator<_Tp> iterator;
      typedef bidirectional_iterator_tag iterator_category;
      typedef ptrdiff_t difference_type;
      typedef _Rb_tree_const_iterator<_Tp> _Self;
      typedef _Rb_tree_node_base::_Const_Base_ptr _Base_ptr;
      typedef const _Rb_tree_node<_Tp>* _Link_type;
      _Rb_tree_const_iterator()
      : _M_node() { }
      explicit
      _Rb_tree_const_iterator(_Link_type __x)
      : _M_node(__x) { }
      _Rb_tree_const_iterator(const iterator& __it)
      : _M_node(__it._M_node) { }
      reference
      operator*() const
      { return static_cast<_Link_type>(_M_node)->_M_value_field; }
      pointer
      operator->() const
      { return &static_cast<_Link_type>(_M_node)->_M_value_field; }
      _Self&
      operator++()
      {
 _M_node = _Rb_tree_increment(_M_node);
 return *this;
      }
      _Self
      operator++(int)
      {
 _Self __tmp = *this;
 _M_node = _Rb_tree_increment(_M_node);
 return __tmp;
      }
      _Self&
      operator--()
      {
 _M_node = _Rb_tree_decrement(_M_node);
 return *this;
      }
      _Self
      operator--(int)
      {
 _Self __tmp = *this;
 _M_node = _Rb_tree_decrement(_M_node);
 return __tmp;
      }
      bool
      operator==(const _Self& __x) const
      { return _M_node == __x._M_node; }
      bool
      operator!=(const _Self& __x) const
      { return _M_node != __x._M_node; }
      _Base_ptr _M_node;
    };
  template<typename _Val>
    inline bool
    operator==(const _Rb_tree_iterator<_Val>& __x,
               const _Rb_tree_const_iterator<_Val>& __y)
    { return __x._M_node == __y._M_node; }
  template<typename _Val>
    inline bool
    operator!=(const _Rb_tree_iterator<_Val>& __x,
               const _Rb_tree_const_iterator<_Val>& __y)
    { return __x._M_node != __y._M_node; }
  void
  _Rb_tree_rotate_left(_Rb_tree_node_base* const __x,
                       _Rb_tree_node_base*& __root);
  void
  _Rb_tree_rotate_right(_Rb_tree_node_base* const __x,
                        _Rb_tree_node_base*& __root);
  void
  _Rb_tree_insert_and_rebalance(const bool __insert_left,
                                _Rb_tree_node_base* __x,
                                _Rb_tree_node_base* __p,
                                _Rb_tree_node_base& __header);
  _Rb_tree_node_base*
  _Rb_tree_rebalance_for_erase(_Rb_tree_node_base* const __z,
          _Rb_tree_node_base& __header);
  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc = allocator<_Val> >
    class _Rb_tree
    {
      typedef typename _Alloc::template rebind<_Rb_tree_node<_Val> >::other
              _Node_allocator;
    protected:
      typedef _Rb_tree_node_base* _Base_ptr;
      typedef const _Rb_tree_node_base* _Const_Base_ptr;
      typedef _Rb_tree_node<_Val> _Rb_tree_node;
    public:
      typedef _Key key_type;
      typedef _Val value_type;
      typedef value_type* pointer;
      typedef const value_type* const_pointer;
      typedef value_type& reference;
      typedef const value_type& const_reference;
      typedef _Rb_tree_node* _Link_type;
      typedef const _Rb_tree_node* _Const_Link_type;
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Alloc allocator_type;
      allocator_type
      get_allocator() const
      { return *static_cast<const _Node_allocator*>(&this->_M_impl); }
    protected:
      _Rb_tree_node*
      _M_get_node()
      { return _M_impl._Node_allocator::allocate(1); }
      void
      _M_put_node(_Rb_tree_node* __p)
      { _M_impl._Node_allocator::deallocate(__p, 1); }
      _Link_type
      _M_create_node(const value_type& __x)
      {
 _Link_type __tmp = _M_get_node();
 try
   { get_allocator().construct(&__tmp->_M_value_field, __x); }
 catch(...)
   {
     _M_put_node(__tmp);
     throw;
   }
 return __tmp;
      }
      _Link_type
      _M_clone_node(_Const_Link_type __x)
      {
 _Link_type __tmp = _M_create_node(__x->_M_value_field);
 __tmp->_M_color = __x->_M_color;
 __tmp->_M_left = 0;
 __tmp->_M_right = 0;
 return __tmp;
      }
      void
      destroy_node(_Link_type __p)
      {
 get_allocator().destroy(&__p->_M_value_field);
 _M_put_node(__p);
      }
    protected:
      template<typename _Key_compare,
        bool _Is_pod_comparator = std::__is_pod<_Key_compare>::__value>
        struct _Rb_tree_impl : public _Node_allocator
        {
   _Key_compare _M_key_compare;
   _Rb_tree_node_base _M_header;
   size_type _M_node_count;
   _Rb_tree_impl(const _Node_allocator& __a = _Node_allocator(),
   const _Key_compare& __comp = _Key_compare())
   : _Node_allocator(__a), _M_key_compare(__comp), _M_header(),
     _M_node_count(0)
   {
     this->_M_header._M_color = _S_red;
     this->_M_header._M_parent = 0;
     this->_M_header._M_left = &this->_M_header;
     this->_M_header._M_right = &this->_M_header;
   }
 };
      template<typename _Key_compare>
        struct _Rb_tree_impl<_Key_compare, true> : public _Node_allocator
 {
   _Key_compare _M_key_compare;
   _Rb_tree_node_base _M_header;
   size_type _M_node_count;
   _Rb_tree_impl(const _Node_allocator& __a = _Node_allocator(),
   const _Key_compare& __comp = _Key_compare())
   : _Node_allocator(__a), _M_key_compare(__comp), _M_header(),
     _M_node_count(0)
   {
     this->_M_header._M_color = _S_red;
     this->_M_header._M_parent = 0;
     this->_M_header._M_left = &this->_M_header;
     this->_M_header._M_right = &this->_M_header;
   }
 };
      _Rb_tree_impl<_Compare> _M_impl;
    protected:
      _Base_ptr&
      _M_root()
      { return this->_M_impl._M_header._M_parent; }
      _Const_Base_ptr
      _M_root() const
      { return this->_M_impl._M_header._M_parent; }
      _Base_ptr&
      _M_leftmost()
      { return this->_M_impl._M_header._M_left; }
      _Const_Base_ptr
      _M_leftmost() const
      { return this->_M_impl._M_header._M_left; }
      _Base_ptr&
      _M_rightmost()
      { return this->_M_impl._M_header._M_right; }
      _Const_Base_ptr
      _M_rightmost() const
      { return this->_M_impl._M_header._M_right; }
      _Link_type
      _M_begin()
      { return static_cast<_Link_type>(this->_M_impl._M_header._M_parent); }
      _Const_Link_type
      _M_begin() const
      {
 return static_cast<_Const_Link_type>
   (this->_M_impl._M_header._M_parent);
      }
      _Link_type
      _M_end()
      { return static_cast<_Link_type>(&this->_M_impl._M_header); }
      _Const_Link_type
      _M_end() const
      { return static_cast<_Const_Link_type>(&this->_M_impl._M_header); }
      static const_reference
      _S_value(_Const_Link_type __x)
      { return __x->_M_value_field; }
      static const _Key&
      _S_key(_Const_Link_type __x)
      { return _KeyOfValue()(_S_value(__x)); }
      static _Link_type
      _S_left(_Base_ptr __x)
      { return static_cast<_Link_type>(__x->_M_left); }
      static _Const_Link_type
      _S_left(_Const_Base_ptr __x)
      { return static_cast<_Const_Link_type>(__x->_M_left); }
      static _Link_type
      _S_right(_Base_ptr __x)
      { return static_cast<_Link_type>(__x->_M_right); }
      static _Const_Link_type
      _S_right(_Const_Base_ptr __x)
      { return static_cast<_Const_Link_type>(__x->_M_right); }
      static const_reference
      _S_value(_Const_Base_ptr __x)
      { return static_cast<_Const_Link_type>(__x)->_M_value_field; }
      static const _Key&
      _S_key(_Const_Base_ptr __x)
      { return _KeyOfValue()(_S_value(__x)); }
      static _Base_ptr
      _S_minimum(_Base_ptr __x)
      { return _Rb_tree_node_base::_S_minimum(__x); }
      static _Const_Base_ptr
      _S_minimum(_Const_Base_ptr __x)
      { return _Rb_tree_node_base::_S_minimum(__x); }
      static _Base_ptr
      _S_maximum(_Base_ptr __x)
      { return _Rb_tree_node_base::_S_maximum(__x); }
      static _Const_Base_ptr
      _S_maximum(_Const_Base_ptr __x)
      { return _Rb_tree_node_base::_S_maximum(__x); }
    public:
      typedef _Rb_tree_iterator<value_type> iterator;
      typedef _Rb_tree_const_iterator<value_type> const_iterator;
      typedef std::reverse_iterator<iterator> reverse_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
    private:
      iterator
      _M_insert(_Base_ptr __x, _Base_ptr __y, const value_type& __v);
      const_iterator
      _M_insert(_Const_Base_ptr __x, _Const_Base_ptr __y,
  const value_type& __v);
      _Link_type
      _M_copy(_Const_Link_type __x, _Link_type __p);
      void
      _M_erase(_Link_type __x);
    public:
      _Rb_tree()
      { }
      _Rb_tree(const _Compare& __comp)
      : _M_impl(allocator_type(), __comp)
      { }
      _Rb_tree(const _Compare& __comp, const allocator_type& __a)
      : _M_impl(__a, __comp)
      { }
      _Rb_tree(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x)
      : _M_impl(__x.get_allocator(), __x._M_impl._M_key_compare)
      {
 if (__x._M_root() != 0)
   {
     _M_root() = _M_copy(__x._M_begin(), _M_end());
     _M_leftmost() = _S_minimum(_M_root());
     _M_rightmost() = _S_maximum(_M_root());
     _M_impl._M_node_count = __x._M_impl._M_node_count;
   }
      }
      ~_Rb_tree()
      { _M_erase(_M_begin()); }
      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>&
      operator=(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x);
      _Compare
      key_comp() const
      { return _M_impl._M_key_compare; }
      iterator
      begin()
      {
 return iterator(static_cast<_Link_type>
   (this->_M_impl._M_header._M_left));
      }
      const_iterator
      begin() const
      {
 return const_iterator(static_cast<_Const_Link_type>
         (this->_M_impl._M_header._M_left));
      }
      iterator
      end()
      { return iterator(static_cast<_Link_type>(&this->_M_impl._M_header)); }
      const_iterator
      end() const
      {
 return const_iterator(static_cast<_Const_Link_type>
         (&this->_M_impl._M_header));
      }
      reverse_iterator
      rbegin()
      { return reverse_iterator(end()); }
      const_reverse_iterator
      rbegin() const
      { return const_reverse_iterator(end()); }
      reverse_iterator
      rend()
      { return reverse_iterator(begin()); }
      const_reverse_iterator
      rend() const
      { return const_reverse_iterator(begin()); }
      bool
      empty() const
      { return _M_impl._M_node_count == 0; }
      size_type
      size() const
      { return _M_impl._M_node_count; }
      size_type
      max_size() const
      { return size_type(-1); }
      void
      swap(_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __t);
      pair<iterator,bool>
      insert_unique(const value_type& __x);
      iterator
      insert_equal(const value_type& __x);
      iterator
      insert_unique(iterator __position, const value_type& __x);
      const_iterator
      insert_unique(const_iterator __position, const value_type& __x);
      iterator
      insert_equal(iterator __position, const value_type& __x);
      const_iterator
      insert_equal(const_iterator __position, const value_type& __x);
      template<typename _InputIterator>
        void
        insert_unique(_InputIterator __first, _InputIterator __last);
      template<typename _InputIterator>
        void
        insert_equal(_InputIterator __first, _InputIterator __last);
      void
      erase(iterator __position);
      void
      erase(const_iterator __position);
      size_type
      erase(const key_type& __x);
      void
      erase(iterator __first, iterator __last);
      void
      erase(const_iterator __first, const_iterator __last);
      void
      erase(const key_type* __first, const key_type* __last);
      void
      clear()
      {
        _M_erase(_M_begin());
        _M_leftmost() = _M_end();
        _M_root() = 0;
        _M_rightmost() = _M_end();
        _M_impl._M_node_count = 0;
      }
      iterator
      find(const key_type& __x);
      const_iterator
      find(const key_type& __x) const;
      size_type
      count(const key_type& __x) const;
      iterator
      lower_bound(const key_type& __x);
      const_iterator
      lower_bound(const key_type& __x) const;
      iterator
      upper_bound(const key_type& __x);
      const_iterator
      upper_bound(const key_type& __x) const;
      pair<iterator,iterator>
      equal_range(const key_type& __x);
      pair<const_iterator, const_iterator>
      equal_range(const key_type& __x) const;
      bool
      __rb_verify() const;
    };
  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline bool
    operator==(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
        const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
    {
      return __x.size() == __y.size()
      && std::equal(__x.begin(), __x.end(), __y.begin());
    }
  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline bool
    operator<(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
       const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
    {
      return std::lexicographical_compare(__x.begin(), __x.end(),
       __y.begin(), __y.end());
    }
  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline bool
    operator!=(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
        const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
    { return !(__x == __y); }
  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline bool
    operator>(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
       const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
    { return __y < __x; }
  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline bool
    operator<=(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
        const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
    { return !(__y < __x); }
  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline bool
    operator>=(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
        const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
    { return !(__x < __y); }
  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline void
    swap(_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
  _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
    { __x.swap(__y); }
  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>&
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    operator=(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x)
    {
      if (this != &__x)
 {
   clear();
   _M_impl._M_key_compare = __x._M_impl._M_key_compare;
   if (__x._M_root() != 0)
     {
       _M_root() = _M_copy(__x._M_begin(), _M_end());
       _M_leftmost() = _S_minimum(_M_root());
       _M_rightmost() = _S_maximum(_M_root());
       _M_impl._M_node_count = __x._M_impl._M_node_count;
     }
 }
      return *this;
    }
  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_insert(_Base_ptr __x, _Base_ptr __p, const _Val& __v)
    {
      bool __insert_left = (__x != 0 || __p == _M_end()
       || _M_impl._M_key_compare(_KeyOfValue()(__v),
            _S_key(__p)));
      _Link_type __z = _M_create_node(__v);
      _Rb_tree_insert_and_rebalance(__insert_left, __z, __p,
        this->_M_impl._M_header);
      ++_M_impl._M_node_count;
      return iterator(__z);
    }
  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_insert(_Const_Base_ptr __x, _Const_Base_ptr __p, const _Val& __v)
    {
      bool __insert_left = (__x != 0 || __p == _M_end()
       || _M_impl._M_key_compare(_KeyOfValue()(__v),
            _S_key(__p)));
      _Link_type __z = _M_create_node(__v);
      _Rb_tree_insert_and_rebalance(__insert_left, __z,
        const_cast<_Base_ptr>(__p),
        this->_M_impl._M_header);
      ++_M_impl._M_node_count;
      return const_iterator(__z);
    }
  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    insert_equal(const _Val& __v)
    {
      _Link_type __x = _M_begin();
      _Link_type __y = _M_end();
      while (__x != 0)
 {
   __y = __x;
   __x = _M_impl._M_key_compare(_KeyOfValue()(__v), _S_key(__x)) ?
         _S_left(__x) : _S_right(__x);
 }
      return _M_insert(__x, __y, __v);
    }
  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    void
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    swap(_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __t)
    {
      if (_M_root() == 0)
      {
 if (__t._M_root() != 0)
 {
   _M_root() = __t._M_root();
   _M_leftmost() = __t._M_leftmost();
   _M_rightmost() = __t._M_rightmost();
          _M_root()->_M_parent = _M_end();
   __t._M_root() = 0;
   __t._M_leftmost() = __t._M_end();
   __t._M_rightmost() = __t._M_end();
 }
      }
      else if (__t._M_root() == 0)
      {
 __t._M_root() = _M_root();
 __t._M_leftmost() = _M_leftmost();
 __t._M_rightmost() = _M_rightmost();
        __t._M_root()->_M_parent = __t._M_end();
 _M_root() = 0;
 _M_leftmost() = _M_end();
 _M_rightmost() = _M_end();
      }
      else
      {
 std::swap(_M_root(),__t._M_root());
 std::swap(_M_leftmost(),__t._M_leftmost());
 std::swap(_M_rightmost(),__t._M_rightmost());
 _M_root()->_M_parent = _M_end();
 __t._M_root()->_M_parent = __t._M_end();
      }
      std::swap(this->_M_impl._M_node_count, __t._M_impl._M_node_count);
      std::swap(this->_M_impl._M_key_compare, __t._M_impl._M_key_compare);
    }
  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::iterator, bool>
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    insert_unique(const _Val& __v)
    {
      _Link_type __x = _M_begin();
      _Link_type __y = _M_end();
      bool __comp = true;
      while (__x != 0)
 {
   __y = __x;
   __comp = _M_impl._M_key_compare(_KeyOfValue()(__v), _S_key(__x));
   __x = __comp ? _S_left(__x) : _S_right(__x);
 }
      iterator __j = iterator(__y);
      if (__comp)
 if (__j == begin())
   return pair<iterator,bool>(_M_insert(__x, __y, __v), true);
 else
   --__j;
      if (_M_impl._M_key_compare(_S_key(__j._M_node), _KeyOfValue()(__v)))
 return pair<iterator, bool>(_M_insert(__x, __y, __v), true);
      return pair<iterator, bool>(__j, false);
    }
  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    insert_unique(iterator __position, const _Val& __v)
    {
      if (__position._M_node == _M_end())
 {
   if (size() > 0
       && _M_impl._M_key_compare(_S_key(_M_rightmost()),
     _KeyOfValue()(__v)))
     return _M_insert(0, _M_rightmost(), __v);
   else
     return insert_unique(__v).first;
 }
      else if (_M_impl._M_key_compare(_KeyOfValue()(__v),
          _S_key(__position._M_node)))
 {
   iterator __before = __position;
   if (__position._M_node == _M_leftmost())
     return _M_insert(_M_leftmost(), _M_leftmost(), __v);
   else if (_M_impl._M_key_compare(_S_key((--__before)._M_node),
       _KeyOfValue()(__v)))
     {
       if (_S_right(__before._M_node) == 0)
  return _M_insert(0, __before._M_node, __v);
       else
  return _M_insert(__position._M_node,
     __position._M_node, __v);
     }
   else
     return insert_unique(__v).first;
 }
      else if (_M_impl._M_key_compare(_S_key(__position._M_node),
          _KeyOfValue()(__v)))
 {
   iterator __after = __position;
   if (__position._M_node == _M_rightmost())
     return _M_insert(0, _M_rightmost(), __v);
   else if (_M_impl._M_key_compare(_KeyOfValue()(__v),
       _S_key((++__after)._M_node)))
     {
       if (_S_right(__position._M_node) == 0)
  return _M_insert(0, __position._M_node, __v);
       else
  return _M_insert(__after._M_node, __after._M_node, __v);
     }
   else
     return insert_unique(__v).first;
 }
      else
 return __position;
    }
  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    insert_unique(const_iterator __position, const _Val& __v)
    {
      if (__position._M_node == _M_end())
 {
   if (size() > 0
       && _M_impl._M_key_compare(_S_key(_M_rightmost()),
     _KeyOfValue()(__v)))
     return _M_insert(0, _M_rightmost(), __v);
   else
     return const_iterator(insert_unique(__v).first);
 }
      else if (_M_impl._M_key_compare(_KeyOfValue()(__v),
          _S_key(__position._M_node)))
 {
   const_iterator __before = __position;
   if (__position._M_node == _M_leftmost())
     return _M_insert(_M_leftmost(), _M_leftmost(), __v);
   else if (_M_impl._M_key_compare(_S_key((--__before)._M_node),
       _KeyOfValue()(__v)))
     {
       if (_S_right(__before._M_node) == 0)
  return _M_insert(0, __before._M_node, __v);
       else
  return _M_insert(__position._M_node,
     __position._M_node, __v);
     }
   else
     return const_iterator(insert_unique(__v).first);
 }
      else if (_M_impl._M_key_compare(_S_key(__position._M_node),
          _KeyOfValue()(__v)))
 {
   const_iterator __after = __position;
   if (__position._M_node == _M_rightmost())
     return _M_insert(0, _M_rightmost(), __v);
   else if (_M_impl._M_key_compare(_KeyOfValue()(__v),
       _S_key((++__after)._M_node)))
     {
       if (_S_right(__position._M_node) == 0)
  return _M_insert(0, __position._M_node, __v);
       else
  return _M_insert(__after._M_node, __after._M_node, __v);
     }
   else
     return const_iterator(insert_unique(__v).first);
 }
      else
 return __position;
    }
  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    insert_equal(iterator __position, const _Val& __v)
    {
      if (__position._M_node == _M_end())
 {
   if (size() > 0
       && !_M_impl._M_key_compare(_KeyOfValue()(__v),
      _S_key(_M_rightmost())))
     return _M_insert(0, _M_rightmost(), __v);
   else
     return insert_equal(__v);
 }
      else if (!_M_impl._M_key_compare(_S_key(__position._M_node),
           _KeyOfValue()(__v)))
 {
   iterator __before = __position;
   if (__position._M_node == _M_leftmost())
     return _M_insert(_M_leftmost(), _M_leftmost(), __v);
   else if (!_M_impl._M_key_compare(_KeyOfValue()(__v),
        _S_key((--__before)._M_node)))
     {
       if (_S_right(__before._M_node) == 0)
  return _M_insert(0, __before._M_node, __v);
       else
  return _M_insert(__position._M_node,
     __position._M_node, __v);
     }
   else
     return insert_equal(__v);
 }
      else
 {
   iterator __after = __position;
   if (__position._M_node == _M_rightmost())
     return _M_insert(0, _M_rightmost(), __v);
   else if (!_M_impl._M_key_compare(_S_key((++__after)._M_node),
        _KeyOfValue()(__v)))
     {
       if (_S_right(__position._M_node) == 0)
  return _M_insert(0, __position._M_node, __v);
       else
  return _M_insert(__after._M_node, __after._M_node, __v);
     }
   else
     return insert_equal(__v);
 }
    }
  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    insert_equal(const_iterator __position, const _Val& __v)
    {
      if (__position._M_node == _M_end())
 {
   if (size() > 0
       && !_M_impl._M_key_compare(_KeyOfValue()(__v),
      _S_key(_M_rightmost())))
     return _M_insert(0, _M_rightmost(), __v);
   else
     return const_iterator(insert_equal(__v));
 }
      else if (!_M_impl._M_key_compare(_S_key(__position._M_node),
           _KeyOfValue()(__v)))
 {
   const_iterator __before = __position;
   if (__position._M_node == _M_leftmost())
     return _M_insert(_M_leftmost(), _M_leftmost(), __v);
   else if (!_M_impl._M_key_compare(_KeyOfValue()(__v),
        _S_key((--__before)._M_node)))
     {
       if (_S_right(__before._M_node) == 0)
  return _M_insert(0, __before._M_node, __v);
       else
  return _M_insert(__position._M_node,
     __position._M_node, __v);
     }
   else
     return const_iterator(insert_equal(__v));
 }
      else
 {
   const_iterator __after = __position;
   if (__position._M_node == _M_rightmost())
     return _M_insert(0, _M_rightmost(), __v);
   else if (!_M_impl._M_key_compare(_S_key((++__after)._M_node),
        _KeyOfValue()(__v)))
     {
       if (_S_right(__position._M_node) == 0)
  return _M_insert(0, __position._M_node, __v);
       else
  return _M_insert(__after._M_node, __after._M_node, __v);
     }
   else
     return const_iterator(insert_equal(__v));
 }
    }
  template<typename _Key, typename _Val, typename _KoV,
           typename _Cmp, typename _Alloc>
    template<class _II>
      void
      _Rb_tree<_Key, _Val, _KoV, _Cmp, _Alloc>::
      insert_equal(_II __first, _II __last)
      {
 for (; __first != __last; ++__first)
   insert_equal(end(), *__first);
      }
  template<typename _Key, typename _Val, typename _KoV,
           typename _Cmp, typename _Alloc>
    template<class _II>
      void
      _Rb_tree<_Key, _Val, _KoV, _Cmp, _Alloc>::
      insert_unique(_II __first, _II __last)
      {
 for (; __first != __last; ++__first)
   insert_unique(end(), *__first);
      }
  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline void
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    erase(iterator __position)
    {
      _Link_type __y =
 static_cast<_Link_type>(_Rb_tree_rebalance_for_erase
    (__position._M_node,
     this->_M_impl._M_header));
      destroy_node(__y);
      --_M_impl._M_node_count;
    }
  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline void
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    erase(const_iterator __position)
    {
      _Link_type __y =
 static_cast<_Link_type>(_Rb_tree_rebalance_for_erase
    (const_cast<_Base_ptr>(__position._M_node),
     this->_M_impl._M_header));
      destroy_node(__y);
      --_M_impl._M_node_count;
    }
  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::size_type
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    erase(const _Key& __x)
    {
      pair<iterator,iterator> __p = equal_range(__x);
      size_type __n = std::distance(__p.first, __p.second);
      erase(__p.first, __p.second);
      return __n;
    }
  template<typename _Key, typename _Val, typename _KoV,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KoV, _Compare, _Alloc>::_Link_type
    _Rb_tree<_Key, _Val, _KoV, _Compare, _Alloc>::
    _M_copy(_Const_Link_type __x, _Link_type __p)
    {
      _Link_type __top = _M_clone_node(__x);
      __top->_M_parent = __p;
      try
 {
   if (__x->_M_right)
     __top->_M_right = _M_copy(_S_right(__x), __top);
   __p = __top;
   __x = _S_left(__x);
   while (__x != 0)
     {
       _Link_type __y = _M_clone_node(__x);
       __p->_M_left = __y;
       __y->_M_parent = __p;
       if (__x->_M_right)
  __y->_M_right = _M_copy(_S_right(__x), __y);
       __p = __y;
       __x = _S_left(__x);
     }
 }
      catch(...)
 {
   _M_erase(__top);
   throw;
 }
      return __top;
    }
  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    void
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_erase(_Link_type __x)
    {
      while (__x != 0)
 {
   _M_erase(_S_right(__x));
   _Link_type __y = _S_left(__x);
   destroy_node(__x);
   __x = __y;
 }
    }
  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    void
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    erase(iterator __first, iterator __last)
    {
      if (__first == begin() && __last == end())
 clear();
      else
 while (__first != __last)
   erase(__first++);
    }
  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    void
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    erase(const_iterator __first, const_iterator __last)
    {
      if (__first == begin() && __last == end())
 clear();
      else
 while (__first != __last)
   erase(__first++);
    }
  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    void
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    erase(const _Key* __first, const _Key* __last)
    {
      while (__first != __last)
 erase(*__first++);
    }
  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    find(const _Key& __k)
    {
      _Link_type __x = _M_begin();
      _Link_type __y = _M_end();
      while (__x != 0)
 if (!_M_impl._M_key_compare(_S_key(__x), __k))
   __y = __x, __x = _S_left(__x);
 else
   __x = _S_right(__x);
      iterator __j = iterator(__y);
      return (__j == end()
       || _M_impl._M_key_compare(__k,
     _S_key(__j._M_node))) ? end() : __j;
    }
  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    find(const _Key& __k) const
    {
      _Const_Link_type __x = _M_begin();
      _Const_Link_type __y = _M_end();
     while (__x != 0)
       {
  if (!_M_impl._M_key_compare(_S_key(__x), __k))
    __y = __x, __x = _S_left(__x);
  else
    __x = _S_right(__x);
       }
     const_iterator __j = const_iterator(__y);
     return (__j == end()
      || _M_impl._M_key_compare(__k,
           _S_key(__j._M_node))) ? end() : __j;
    }
  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::size_type
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    count(const _Key& __k) const
    {
      pair<const_iterator, const_iterator> __p = equal_range(__k);
      const size_type __n = std::distance(__p.first, __p.second);
      return __n;
    }
  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    lower_bound(const _Key& __k)
    {
      _Link_type __x = _M_begin();
      _Link_type __y = _M_end();
      while (__x != 0)
 if (!_M_impl._M_key_compare(_S_key(__x), __k))
   __y = __x, __x = _S_left(__x);
 else
   __x = _S_right(__x);
      return iterator(__y);
    }
  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    lower_bound(const _Key& __k) const
    {
      _Const_Link_type __x = _M_begin();
      _Const_Link_type __y = _M_end();
      while (__x != 0)
 if (!_M_impl._M_key_compare(_S_key(__x), __k))
   __y = __x, __x = _S_left(__x);
 else
   __x = _S_right(__x);
      return const_iterator(__y);
    }
  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    upper_bound(const _Key& __k)
    {
      _Link_type __x = _M_begin();
      _Link_type __y = _M_end();
      while (__x != 0)
 if (_M_impl._M_key_compare(__k, _S_key(__x)))
   __y = __x, __x = _S_left(__x);
 else
   __x = _S_right(__x);
      return iterator(__y);
    }
  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    upper_bound(const _Key& __k) const
    {
      _Const_Link_type __x = _M_begin();
      _Const_Link_type __y = _M_end();
      while (__x != 0)
 if (_M_impl._M_key_compare(__k, _S_key(__x)))
   __y = __x, __x = _S_left(__x);
 else
   __x = _S_right(__x);
      return const_iterator(__y);
    }
  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline
    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::iterator,
  typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator>
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    equal_range(const _Key& __k)
    { return pair<iterator, iterator>(lower_bound(__k), upper_bound(__k)); }
  template<typename _Key, typename _Val, typename _KoV,
           typename _Compare, typename _Alloc>
    inline
    pair<typename _Rb_tree<_Key, _Val, _KoV,
      _Compare, _Alloc>::const_iterator,
  typename _Rb_tree<_Key, _Val, _KoV, _Compare, _Alloc>::const_iterator>
    _Rb_tree<_Key, _Val, _KoV, _Compare, _Alloc>::
    equal_range(const _Key& __k) const
    { return pair<const_iterator, const_iterator>(lower_bound(__k),
        upper_bound(__k)); }
  unsigned int
  _Rb_tree_black_count(const _Rb_tree_node_base* __node,
                       const _Rb_tree_node_base* __root);
  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    bool
    _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::__rb_verify() const
    {
      if (_M_impl._M_node_count == 0 || begin() == end())
 return _M_impl._M_node_count == 0 && begin() == end()
        && this->_M_impl._M_header._M_left == _M_end()
        && this->_M_impl._M_header._M_right == _M_end();
      unsigned int __len = _Rb_tree_black_count(_M_leftmost(), _M_root());
      for (const_iterator __it = begin(); __it != end(); ++__it)
 {
   _Const_Link_type __x = static_cast<_Const_Link_type>(__it._M_node);
   _Const_Link_type __L = _S_left(__x);
   _Const_Link_type __R = _S_right(__x);
   if (__x->_M_color == _S_red)
     if ((__L && __L->_M_color == _S_red)
  || (__R && __R->_M_color == _S_red))
       return false;
   if (__L && _M_impl._M_key_compare(_S_key(__x), _S_key(__L)))
     return false;
   if (__R && _M_impl._M_key_compare(_S_key(__R), _S_key(__x)))
     return false;
   if (!__L && !__R && _Rb_tree_black_count(__x, _M_root()) != __len)
     return false;
 }
      if (_M_leftmost() != _Rb_tree_node_base::_S_minimum(_M_root()))
 return false;
      if (_M_rightmost() != _Rb_tree_node_base::_S_maximum(_M_root()))
 return false;
      return true;
    }
}
namespace std
{
  template <typename _Key, typename _Tp, typename _Compare = std::less<_Key>,
            typename _Alloc = std::allocator<std::pair<const _Key, _Tp> > >
    class map
    {
    public:
      typedef _Key key_type;
      typedef _Tp mapped_type;
      typedef std::pair<const _Key, _Tp> value_type;
      typedef _Compare key_compare;
      typedef _Alloc allocator_type;
    private:
      typedef typename _Alloc::value_type _Alloc_value_type;
    public:
      class value_compare
      : public std::binary_function<value_type, value_type, bool>
      {
 friend class map<_Key, _Tp, _Compare, _Alloc>;
      protected:
 _Compare comp;
 value_compare(_Compare __c)
 : comp(__c) { }
      public:
 bool operator()(const value_type& __x, const value_type& __y) const
 { return comp(__x.first, __y.first); }
      };
    private:
      typedef typename _Alloc::template rebind<value_type>::other
        _Pair_alloc_type;
      typedef _Rb_tree<key_type, value_type, _Select1st<value_type>,
         key_compare, _Pair_alloc_type> _Rep_type;
      _Rep_type _M_t;
    public:
      typedef typename _Pair_alloc_type::pointer pointer;
      typedef typename _Pair_alloc_type::const_pointer const_pointer;
      typedef typename _Pair_alloc_type::reference reference;
      typedef typename _Pair_alloc_type::const_reference const_reference;
      typedef typename _Rep_type::iterator iterator;
      typedef typename _Rep_type::const_iterator const_iterator;
      typedef typename _Rep_type::size_type size_type;
      typedef typename _Rep_type::difference_type difference_type;
      typedef typename _Rep_type::reverse_iterator reverse_iterator;
      typedef typename _Rep_type::const_reverse_iterator const_reverse_iterator;
      map()
      : _M_t(_Compare(), allocator_type()) { }
      explicit
      map(const _Compare& __comp, const allocator_type& __a = allocator_type())
      : _M_t(__comp, __a) { }
      map(const map& __x)
      : _M_t(__x._M_t) { }
      template <typename _InputIterator>
        map(_InputIterator __first, _InputIterator __last)
 : _M_t(_Compare(), allocator_type())
        { _M_t.insert_unique(__first, __last); }
      template <typename _InputIterator>
        map(_InputIterator __first, _InputIterator __last,
     const _Compare& __comp, const allocator_type& __a = allocator_type())
 : _M_t(__comp, __a)
        { _M_t.insert_unique(__first, __last); }
      map&
      operator=(const map& __x)
      {
 _M_t = __x._M_t;
 return *this;
      }
      allocator_type
      get_allocator() const
      { return _M_t.get_allocator(); }
      iterator
      begin()
      { return _M_t.begin(); }
      const_iterator
      begin() const
      { return _M_t.begin(); }
      iterator
      end()
      { return _M_t.end(); }
      const_iterator
      end() const
      { return _M_t.end(); }
      reverse_iterator
      rbegin()
      { return _M_t.rbegin(); }
      const_reverse_iterator
      rbegin() const
      { return _M_t.rbegin(); }
      reverse_iterator
      rend()
      { return _M_t.rend(); }
      const_reverse_iterator
      rend() const
      { return _M_t.rend(); }
      bool
      empty() const
      { return _M_t.empty(); }
      size_type
      size() const
      { return _M_t.size(); }
      size_type
      max_size() const
      { return _M_t.max_size(); }
      mapped_type&
      operator[](const key_type& __k)
      {
 iterator __i = lower_bound(__k);
 if (__i == end() || key_comp()(__k, (*__i).first))
          __i = insert(__i, value_type(__k, mapped_type()));
 return (*__i).second;
      }
      mapped_type&
      at(const key_type& __k)
      {
 iterator __i = lower_bound(__k);
 if (__i == end() || key_comp()(__k, (*__i).first))
   __throw_out_of_range(("map::at"));
 return (*__i).second;
      }
      const mapped_type&
      at(const key_type& __k) const
      {
 const_iterator __i = lower_bound(__k);
 if (__i == end() || key_comp()(__k, (*__i).first))
   __throw_out_of_range(("map::at"));
 return (*__i).second;
      }
      std::pair<iterator,bool>
      insert(const value_type& __x)
      { return _M_t.insert_unique(__x); }
      iterator
      insert(iterator position, const value_type& __x)
      { return _M_t.insert_unique(position, __x); }
      template <typename _InputIterator>
        void
        insert(_InputIterator __first, _InputIterator __last)
        { _M_t.insert_unique(__first, __last); }
      void
      erase(iterator __position)
      { _M_t.erase(__position); }
      size_type
      erase(const key_type& __x)
      { return _M_t.erase(__x); }
      void
      erase(iterator __first, iterator __last)
      { _M_t.erase(__first, __last); }
      void
      swap(map& __x)
      { _M_t.swap(__x._M_t); }
      void
      clear()
      { _M_t.clear(); }
      key_compare
      key_comp() const
      { return _M_t.key_comp(); }
      value_compare
      value_comp() const
      { return value_compare(_M_t.key_comp()); }
      iterator
      find(const key_type& __x)
      { return _M_t.find(__x); }
      const_iterator
      find(const key_type& __x) const
      { return _M_t.find(__x); }
      size_type
      count(const key_type& __x) const
      { return _M_t.find(__x) == _M_t.end() ? 0 : 1; }
      iterator
      lower_bound(const key_type& __x)
      { return _M_t.lower_bound(__x); }
      const_iterator
      lower_bound(const key_type& __x) const
      { return _M_t.lower_bound(__x); }
      iterator
      upper_bound(const key_type& __x)
      { return _M_t.upper_bound(__x); }
      const_iterator
      upper_bound(const key_type& __x) const
      { return _M_t.upper_bound(__x); }
      std::pair<iterator, iterator>
      equal_range(const key_type& __x)
      { return _M_t.equal_range(__x); }
      std::pair<const_iterator, const_iterator>
      equal_range(const key_type& __x) const
      { return _M_t.equal_range(__x); }
      template <typename _K1, typename _T1, typename _C1, typename _A1>
        friend bool
        operator== (const map<_K1, _T1, _C1, _A1>&,
      const map<_K1, _T1, _C1, _A1>&);
      template <typename _K1, typename _T1, typename _C1, typename _A1>
        friend bool
        operator< (const map<_K1, _T1, _C1, _A1>&,
     const map<_K1, _T1, _C1, _A1>&);
    };
  template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator==(const map<_Key, _Tp, _Compare, _Alloc>& __x,
               const map<_Key, _Tp, _Compare, _Alloc>& __y)
    { return __x._M_t == __y._M_t; }
  template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator<(const map<_Key, _Tp, _Compare, _Alloc>& __x,
              const map<_Key, _Tp, _Compare, _Alloc>& __y)
    { return __x._M_t < __y._M_t; }
  template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator!=(const map<_Key, _Tp, _Compare, _Alloc>& __x,
               const map<_Key, _Tp, _Compare, _Alloc>& __y)
    { return !(__x == __y); }
  template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator>(const map<_Key, _Tp, _Compare, _Alloc>& __x,
              const map<_Key, _Tp, _Compare, _Alloc>& __y)
    { return __y < __x; }
  template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator<=(const map<_Key, _Tp, _Compare, _Alloc>& __x,
               const map<_Key, _Tp, _Compare, _Alloc>& __y)
    { return !(__y < __x); }
  template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator>=(const map<_Key, _Tp, _Compare, _Alloc>& __x,
               const map<_Key, _Tp, _Compare, _Alloc>& __y)
    { return !(__x < __y); }
  template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline void
    swap(map<_Key, _Tp, _Compare, _Alloc>& __x,
  map<_Key, _Tp, _Compare, _Alloc>& __y)
    { __x.swap(__y); }
}
namespace std
{
  template <typename _Key, typename _Tp,
            typename _Compare = std::less<_Key>,
            typename _Alloc = std::allocator<std::pair<const _Key, _Tp> > >
    class multimap;
  template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator==(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,
        const multimap<_Key, _Tp, _Compare, _Alloc>& __y);
  template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator<(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,
       const multimap<_Key, _Tp, _Compare, _Alloc>& __y);
  template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    class multimap
    {
    public:
      typedef _Key key_type;
      typedef _Tp mapped_type;
      typedef std::pair<const _Key, _Tp> value_type;
      typedef _Compare key_compare;
      typedef _Alloc allocator_type;
    private:
      typedef typename _Alloc::value_type _Alloc_value_type;
    public:
      class value_compare
      : public std::binary_function<value_type, value_type, bool>
      {
 friend class multimap<_Key, _Tp, _Compare, _Alloc>;
      protected:
 _Compare comp;
 value_compare(_Compare __c)
 : comp(__c) { }
      public:
 bool operator()(const value_type& __x, const value_type& __y) const
 { return comp(__x.first, __y.first); }
      };
    private:
      typedef typename _Alloc::template rebind<value_type>::other
        _Pair_alloc_type;
      typedef _Rb_tree<key_type, value_type, _Select1st<value_type>,
         key_compare, _Pair_alloc_type> _Rep_type;
      _Rep_type _M_t;
    public:
      typedef typename _Pair_alloc_type::pointer pointer;
      typedef typename _Pair_alloc_type::const_pointer const_pointer;
      typedef typename _Pair_alloc_type::reference reference;
      typedef typename _Pair_alloc_type::const_reference const_reference;
      typedef typename _Rep_type::iterator iterator;
      typedef typename _Rep_type::const_iterator const_iterator;
      typedef typename _Rep_type::size_type size_type;
      typedef typename _Rep_type::difference_type difference_type;
      typedef typename _Rep_type::reverse_iterator reverse_iterator;
      typedef typename _Rep_type::const_reverse_iterator const_reverse_iterator;
      multimap()
      : _M_t(_Compare(), allocator_type()) { }
      explicit
      multimap(const _Compare& __comp,
        const allocator_type& __a = allocator_type())
      : _M_t(__comp, __a) { }
      multimap(const multimap& __x)
      : _M_t(__x._M_t) { }
      template <typename _InputIterator>
        multimap(_InputIterator __first, _InputIterator __last)
 : _M_t(_Compare(), allocator_type())
        { _M_t.insert_equal(__first, __last); }
      template <typename _InputIterator>
        multimap(_InputIterator __first, _InputIterator __last,
   const _Compare& __comp,
   const allocator_type& __a = allocator_type())
        : _M_t(__comp, __a)
        { _M_t.insert_equal(__first, __last); }
      multimap&
      operator=(const multimap& __x)
      {
 _M_t = __x._M_t;
 return *this;
      }
      allocator_type
      get_allocator() const
      { return _M_t.get_allocator(); }
      iterator
      begin()
      { return _M_t.begin(); }
      const_iterator
      begin() const
      { return _M_t.begin(); }
      iterator
      end()
      { return _M_t.end(); }
      const_iterator
      end() const
      { return _M_t.end(); }
      reverse_iterator
      rbegin()
      { return _M_t.rbegin(); }
      const_reverse_iterator
      rbegin() const
      { return _M_t.rbegin(); }
      reverse_iterator
      rend()
      { return _M_t.rend(); }
      const_reverse_iterator
      rend() const
      { return _M_t.rend(); }
      bool
      empty() const
      { return _M_t.empty(); }
      size_type
      size() const
      { return _M_t.size(); }
      size_type
      max_size() const
      { return _M_t.max_size(); }
      iterator
      insert(const value_type& __x)
      { return _M_t.insert_equal(__x); }
      iterator
      insert(iterator __position, const value_type& __x)
      { return _M_t.insert_equal(__position, __x); }
      template <typename _InputIterator>
        void
        insert(_InputIterator __first, _InputIterator __last)
        { _M_t.insert_equal(__first, __last); }
      void
      erase(iterator __position)
      { _M_t.erase(__position); }
      size_type
      erase(const key_type& __x)
      { return _M_t.erase(__x); }
      void
      erase(iterator __first, iterator __last)
      { _M_t.erase(__first, __last); }
      void
      swap(multimap& __x)
      { _M_t.swap(__x._M_t); }
      void
      clear()
      { _M_t.clear(); }
      key_compare
      key_comp() const
      { return _M_t.key_comp(); }
      value_compare
      value_comp() const
      { return value_compare(_M_t.key_comp()); }
      iterator
      find(const key_type& __x)
      { return _M_t.find(__x); }
      const_iterator
      find(const key_type& __x) const
      { return _M_t.find(__x); }
      size_type
      count(const key_type& __x) const
      { return _M_t.count(__x); }
      iterator
      lower_bound(const key_type& __x)
      { return _M_t.lower_bound(__x); }
      const_iterator
      lower_bound(const key_type& __x) const
      { return _M_t.lower_bound(__x); }
      iterator
      upper_bound(const key_type& __x)
      { return _M_t.upper_bound(__x); }
      const_iterator
      upper_bound(const key_type& __x) const
      { return _M_t.upper_bound(__x); }
      std::pair<iterator, iterator>
      equal_range(const key_type& __x)
      { return _M_t.equal_range(__x); }
      std::pair<const_iterator, const_iterator>
      equal_range(const key_type& __x) const
      { return _M_t.equal_range(__x); }
      template <typename _K1, typename _T1, typename _C1, typename _A1>
        friend bool
        operator== (const multimap<_K1, _T1, _C1, _A1>&,
      const multimap<_K1, _T1, _C1, _A1>&);
      template <typename _K1, typename _T1, typename _C1, typename _A1>
        friend bool
        operator< (const multimap<_K1, _T1, _C1, _A1>&,
     const multimap<_K1, _T1, _C1, _A1>&);
  };
  template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator==(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,
               const multimap<_Key, _Tp, _Compare, _Alloc>& __y)
    { return __x._M_t == __y._M_t; }
  template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator<(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,
              const multimap<_Key, _Tp, _Compare, _Alloc>& __y)
    { return __x._M_t < __y._M_t; }
  template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator!=(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,
               const multimap<_Key, _Tp, _Compare, _Alloc>& __y)
    { return !(__x == __y); }
  template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator>(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,
              const multimap<_Key, _Tp, _Compare, _Alloc>& __y)
    { return __y < __x; }
  template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator<=(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,
               const multimap<_Key, _Tp, _Compare, _Alloc>& __y)
    { return !(__y < __x); }
  template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator>=(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,
               const multimap<_Key, _Tp, _Compare, _Alloc>& __y)
    { return !(__x < __y); }
  template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline void
    swap(multimap<_Key, _Tp, _Compare, _Alloc>& __x,
         multimap<_Key, _Tp, _Compare, _Alloc>& __y)
    { __x.swap(__y); }
}
extern "C" { typedef struct _GMarkupParseContext GMarkupParseContext; }
namespace Glib
{
class MarkupError : public Glib::Error
{
public:
  enum Code
  {
    BAD_UTF8,
    EMPTY,
    PARSE,
    UNKNOWN_ELEMENT,
    UNKNOWN_ATTRIBUTE,
    INVALID_CONTENT
  };
  MarkupError(Code error_code, const Glib::ustring& error_message);
  explicit MarkupError(GError* gobject);
  Code code() const;
private:
  static void throw_func(GError* gobject);
  friend void wrap_init();
};
namespace Markup
{
class ParseContext;
typedef Glib::MarkupError Error;
Glib::ustring escape_text(const Glib::ustring& text);
enum ParseFlags
{
  DO_NOT_USE_THIS_UNSUPPORTED_FLAG = 1 << 0,
  TREAT_CDATA_AS_TEXT = 1 << 1
};
inline ParseFlags operator|(ParseFlags lhs, ParseFlags rhs)
  { return static_cast<ParseFlags>(static_cast<unsigned>(lhs) | static_cast<unsigned>(rhs)); }
inline ParseFlags operator&(ParseFlags lhs, ParseFlags rhs)
  { return static_cast<ParseFlags>(static_cast<unsigned>(lhs) & static_cast<unsigned>(rhs)); }
inline ParseFlags operator^(ParseFlags lhs, ParseFlags rhs)
  { return static_cast<ParseFlags>(static_cast<unsigned>(lhs) ^ static_cast<unsigned>(rhs)); }
inline ParseFlags operator~(ParseFlags flags)
  { return static_cast<ParseFlags>(~static_cast<unsigned>(flags)); }
inline ParseFlags& operator|=(ParseFlags& lhs, ParseFlags rhs)
  { return (lhs = static_cast<ParseFlags>(static_cast<unsigned>(lhs) | static_cast<unsigned>(rhs))); }
inline ParseFlags& operator&=(ParseFlags& lhs, ParseFlags rhs)
  { return (lhs = static_cast<ParseFlags>(static_cast<unsigned>(lhs) & static_cast<unsigned>(rhs))); }
inline ParseFlags& operator^=(ParseFlags& lhs, ParseFlags rhs)
  { return (lhs = static_cast<ParseFlags>(static_cast<unsigned>(lhs) ^ static_cast<unsigned>(rhs))); }
class AttributeKeyLess
{
public:
  typedef Glib::ustring first_argument_type;
  typedef Glib::ustring second_argument_type;
  typedef bool result_type;
  bool operator()(const Glib::ustring& lhs, const Glib::ustring& rhs) const;
};
class ParserCallbacks;
class Parser : public sigc::trackable
{
public:
  typedef std::map<Glib::ustring, Glib::ustring, Glib::Markup::AttributeKeyLess> AttributeMap;
  virtual ~Parser() = 0;
protected:
  Parser();
  virtual void on_start_element(ParseContext& context,
                                const Glib::ustring& element_name,
                                const AttributeMap& attributes);
  virtual void on_end_element(ParseContext& context, const Glib::ustring& element_name);
  virtual void on_text(ParseContext& context, const Glib::ustring& text);
  virtual void on_passthrough(ParseContext& context, const Glib::ustring& passthrough_text);
  virtual void on_error(ParseContext& context, const MarkupError& error);
private:
  Parser(const Parser&);
  Parser& operator=(const Parser&);
  friend class Glib::Markup::ParserCallbacks;
};
class ParseContext : public sigc::trackable
{
public:
  explicit ParseContext(Parser& parser, ParseFlags flags = ParseFlags(0));
  virtual ~ParseContext();
  void parse(const Glib::ustring& text);
  void parse(const char* text_begin, const char* text_end);
  void end_parse();
  Glib::ustring get_element() const;
  int get_line_number() const;
  int get_char_number() const;
  Parser* get_parser() { return parser_; }
  const Parser* get_parser() const { return parser_; }
  GMarkupParseContext* gobj() { return gobject_; }
  const GMarkupParseContext* gobj() const { return gobject_; }
private:
  Markup::Parser* parser_;
  GMarkupParseContext* gobject_;
  ParseContext(const ParseContext&);
  ParseContext& operator=(const ParseContext&);
  static void destroy_notify_callback(void* data);
};
}
}
namespace Glib
{
Glib::ustring get_application_name();
void set_application_name(const Glib::ustring& application_name);
std::string get_prgname();
void set_prgname(const std::string& prgname);
std::string getenv(const std::string& variable, bool& found);
std::string getenv(const std::string& variable);
bool setenv(const std::string& variable, const std::string& value, bool overwrite = true);
void unsetenv(const std::string& variable);
std::string get_user_name();
std::string get_real_name();
std::string get_home_dir();
std::string get_tmp_dir();
std::string get_current_dir();
std::string get_user_special_dir(GUserDirectory directory);
std::string get_user_data_dir();
std::string get_user_config_dir();
std::string get_user_cache_dir();
bool path_is_absolute(const std::string& filename);
std::string path_skip_root(const std::string& filename);
std::string path_get_basename(const std::string& filename);
std::string path_get_dirname(const std::string& filename);
std::string build_filename(const Glib::ArrayHandle<std::string>& elements);
std::string build_filename(const std::string& elem1, const std::string& elem2);
std::string build_path(const std::string& separator,
                       const Glib::ArrayHandle<std::string>& elements);
std::string find_program_in_path(const std::string& program);
}
extern "C" { typedef struct _GModule GModule; }
namespace Glib
{
enum ModuleFlags
{
  MODULE_BIND_LAZY = 1 << 0,
  MODULE_BIND_LOCAL = 1 << 1,
  MODULE_BIND_MASK = 0x03
};
inline ModuleFlags operator|(ModuleFlags lhs, ModuleFlags rhs)
  { return static_cast<ModuleFlags>(static_cast<unsigned>(lhs) | static_cast<unsigned>(rhs)); }
inline ModuleFlags operator&(ModuleFlags lhs, ModuleFlags rhs)
  { return static_cast<ModuleFlags>(static_cast<unsigned>(lhs) & static_cast<unsigned>(rhs)); }
inline ModuleFlags operator^(ModuleFlags lhs, ModuleFlags rhs)
  { return static_cast<ModuleFlags>(static_cast<unsigned>(lhs) ^ static_cast<unsigned>(rhs)); }
inline ModuleFlags operator~(ModuleFlags flags)
  { return static_cast<ModuleFlags>(~static_cast<unsigned>(flags)); }
inline ModuleFlags& operator|=(ModuleFlags& lhs, ModuleFlags rhs)
  { return (lhs = static_cast<ModuleFlags>(static_cast<unsigned>(lhs) | static_cast<unsigned>(rhs))); }
inline ModuleFlags& operator&=(ModuleFlags& lhs, ModuleFlags rhs)
  { return (lhs = static_cast<ModuleFlags>(static_cast<unsigned>(lhs) & static_cast<unsigned>(rhs))); }
inline ModuleFlags& operator^=(ModuleFlags& lhs, ModuleFlags rhs)
  { return (lhs = static_cast<ModuleFlags>(static_cast<unsigned>(lhs) ^ static_cast<unsigned>(rhs))); }
class Module
{
  public:
  typedef Module CppObjectType;
  typedef GModule BaseObjectType;
private:
public:
  explicit Module(const std::string& file_name, ModuleFlags flags = ModuleFlags(0));
  virtual ~Module();
  operator bool() const;
  static bool get_supported();
  void make_resident();
  static std::string get_last_error();
  bool get_symbol(const std::string& symbol_name, void*& symbol) const;
  std::string get_name() const;
  static std::string build_path(const std::string& directory, const std::string& module_name);
  GModule* gobj() { return gobject_; }
  const GModule* gobj() const { return gobject_; }
protected:
  GModule* gobject_;
private:
  Module(const Module&);
  Module& operator=(const Module&);
};
}
extern "C" { typedef struct _GOptionEntry GOptionEntry; }
namespace Glib
{
class OptionEntry
{
  public:
  typedef OptionEntry CppObjectType;
  typedef GOptionEntry BaseObjectType;
private:
public:
  enum Flags
  {
    FLAG_HIDDEN = 1 << 0,
    FLAG_IN_MAIN = 1 << 1,
    FLAG_REVERSE = 1 << 2,
    FLAG_NO_ARG = 1 << 3,
    FLAG_FILENAME = 1 << 4,
    FLAG_OPTIONAL_ARG = 1 << 5,
    FLAG_NOALIAS = 1 << 6
  } GOptionFlags;
  OptionEntry();
  OptionEntry(const OptionEntry& src);
  virtual ~OptionEntry();
  OptionEntry& operator=(const OptionEntry& src);
   Glib::ustring get_long_name() const;
    void set_long_name(const Glib::ustring& value);
   gchar get_short_name() const;
    void set_short_name(const gchar& value);
   int get_flags() const;
    void set_flags(const int& value);
   Glib::ustring get_description() const;
    void set_description(const Glib::ustring& value);
   Glib::ustring get_arg_description() const;
    void set_arg_description(const Glib::ustring& value);
  GOptionEntry* gobj() { return gobject_; }
  const GOptionEntry* gobj() const { return gobject_; }
protected:
  GOptionEntry* gobject_;
};
}
extern "C" { typedef struct _GOptionGroup GOptionGroup; }
namespace Glib
{
class OptionEntry;
class OptionContext;
class OptionGroup
{
  public:
  typedef OptionGroup CppObjectType;
  typedef GOptionGroup BaseObjectType;
private:
public:
  OptionGroup(const Glib::ustring& name, const Glib::ustring& description, const Glib::ustring& help_description = Glib::ustring());
  explicit OptionGroup(GOptionGroup* castitem);
  virtual ~OptionGroup();
  virtual bool on_pre_parse(OptionContext& context, OptionGroup& group);
  virtual bool on_post_parse(OptionContext& context, OptionGroup& group);
  virtual void on_error(OptionContext& context, OptionGroup& group);
  void add_entry(const OptionEntry& entry);
  typedef std::vector<Glib::ustring> vecustrings;
  typedef std::vector<std::string> vecstrings;
  void add_entry(const OptionEntry& entry, bool& arg);
  void add_entry(const OptionEntry& entry, int& arg);
  void add_entry(const OptionEntry& entry, Glib::ustring& arg);
  void add_entry_filename(const OptionEntry& entry, std::string& arg);
  void add_entry(const OptionEntry& entry, vecustrings& arg);
  void add_entry_filename(const OptionEntry& entry, vecstrings& arg);
  void set_translation_domain(const Glib::ustring& domain);
  GOptionGroup* gobj() { return gobject_; }
  const GOptionGroup* gobj() const { return gobject_; }
  GOptionGroup* gobj_give_ownership();
protected:
  class CppOptionEntry
  {
  public:
    CppOptionEntry();
    void allocate_c_arg();
    void set_c_arg_default(void* cpp_arg);
    void convert_c_to_cpp();
    void release_c_arg();
    GOptionArg carg_type_;
    void* carg_;
    void* cpparg_;
    OptionEntry* entry_;
  };
  void add_entry_with_wrapper(const OptionEntry& entry, GOptionArg arg_type, void* cpp_arg);
  typedef std::map<Glib::ustring, CppOptionEntry> type_map_entries;
  type_map_entries map_entries_;
  GOptionGroup* gobject_;
  bool has_ownership_;
};
}
extern "C" { typedef struct _GOptionContext GOptionContext; }
namespace Glib
{
class OptionError : public Glib::Error
{
public:
  enum Code
  {
    UNKNOWN_OPTION,
    BAD_VALUE,
    FAILED
  };
  OptionError(Code error_code, const Glib::ustring& error_message);
  explicit OptionError(GError* gobject);
  Code code() const;
private:
  static void throw_func(GError* gobject);
  friend void wrap_init();
};
class OptionContext
{
  public:
  typedef OptionContext CppObjectType;
  typedef GOptionContext BaseObjectType;
private:
public:
  explicit OptionContext(const Glib::ustring& parameter_string = Glib::ustring());
  explicit OptionContext(GOptionContext* castitem, bool take_ownership = false);
  virtual ~OptionContext();
  void set_help_enabled(bool help_enabled = true);
  bool get_help_enabled() const;
  void set_ignore_unknown_options(bool ignore_unknown = true);
  bool get_ignore_unknown_options() const;
  bool parse(int& argc, char**& argv);
  void add_group(OptionGroup& group);
  void set_main_group(OptionGroup& group);
  GOptionContext* gobj() { return gobject_; }
  const GOptionContext* gobj() const { return gobject_; }
  void set_summary(const Glib::ustring& summary);
  Glib::ustring get_summary() const;
  void set_description(const Glib::ustring& description);
  Glib::ustring get_description() const;
  void set_translation_domain(const Glib::ustring& domain);
  typedef sigc::slot<Glib::ustring, const Glib::ustring&> SlotTranslate;
  void set_translate_func (const SlotTranslate& slot);
protected:
  GOptionContext* gobject_;
  bool has_ownership_;
};
}
extern "C" { typedef struct _GPatternSpec GPatternSpec; }
namespace Glib
{
class PatternSpec
{
public:
  explicit PatternSpec(const Glib::ustring& pattern);
  explicit PatternSpec(GPatternSpec* gobject);
  ~PatternSpec();
  bool match(const Glib::ustring& str) const;
  bool match(const Glib::ustring& str, const Glib::ustring& str_reversed) const;
  bool operator==(const PatternSpec& rhs) const;
  bool operator!=(const PatternSpec& rhs) const;
  GPatternSpec* gobj() { return gobject_; }
  const GPatternSpec* gobj() const { return gobject_; }
private:
  GPatternSpec* gobject_;
  PatternSpec(const PatternSpec&);
  PatternSpec& operator=(const PatternSpec&);
};
}
namespace Glib
{
void custom_get_property_callback(GObject* object, unsigned int property_id,
                                  GValue* value, GParamSpec* param_spec);
void custom_set_property_callback(GObject* object, unsigned int property_id,
                                  const GValue* value, GParamSpec* param_spec);
class PropertyBase
{
public:
  Glib::ustring get_name() const;
  void notify();
protected:
  Glib::Object* object_;
  Glib::ValueBase value_;
  GParamSpec* param_spec_;
  PropertyBase(Glib::Object& object, GType value_type);
  ~PropertyBase();
  bool lookup_property(const Glib::ustring& name);
  void install_property(GParamSpec* param_spec);
  const char* get_name_internal() const;
private:
  PropertyBase(const PropertyBase&);
  PropertyBase& operator=(const PropertyBase&);
  friend void Glib::custom_get_property_callback(GObject* object, unsigned int property_id,
                                                 GValue* value, GParamSpec* param_spec);
  friend void Glib::custom_set_property_callback(GObject* object, unsigned int property_id,
                                                 const GValue* value, GParamSpec* param_spec);
};
template <class T>
class Property : public PropertyBase
{
public:
  typedef T PropertyType;
  typedef Glib::Value<T> ValueType;
  Property(Glib::Object& object, const Glib::ustring& name);
  Property(Glib::Object& object, const Glib::ustring& name, const PropertyType& default_value);
  inline void set_value(const PropertyType& data);
  inline PropertyType get_value() const;
  inline Property<T>& operator=(const PropertyType& data);
  inline operator PropertyType() const;
  inline Glib::PropertyProxy<T> get_proxy();
};
template <class T>
Property<T>::Property(Glib::Object& object, const Glib::ustring& name)
:
  PropertyBase(object, ValueType::value_type())
{
  if(!lookup_property(name))
    install_property(static_cast<ValueType&>(value_).create_param_spec(name));
}
template <class T>
Property<T>::Property(Glib::Object& object, const Glib::ustring& name,
                      const typename Property<T>::PropertyType& default_value)
:
  PropertyBase(object, ValueType::value_type())
{
  static_cast<ValueType&>(value_).set(default_value);
  if(!lookup_property(name))
    install_property(static_cast<ValueType&>(value_).create_param_spec(name));
}
template <class T> inline
void Property<T>::set_value(const typename Property<T>::PropertyType& data)
{
  static_cast<ValueType&>(value_).set(data);
  this->notify();
}
template <class T> inline
typename Property<T>::PropertyType Property<T>::get_value() const
{
  return static_cast<const ValueType&>(value_).get();
}
template <class T> inline
Property<T>& Property<T>::operator=(const typename Property<T>::PropertyType& data)
{
  static_cast<ValueType&>(value_).set(data);
  this->notify();
  return *this;
}
template <class T> inline
Property<T>::operator T() const
{
  return static_cast<const ValueType&>(value_).get();
}
template <class T> inline
Glib::PropertyProxy<T> Property<T>::get_proxy()
{
  return Glib::PropertyProxy<T>(object_, get_name_internal());
}
}
extern "C" { typedef struct _GRand GRand; }
namespace Glib
{
class Rand
{
public:
  Rand();
  explicit Rand(guint32 seed);
  ~Rand();
  void set_seed(guint32 seed);
  bool get_bool();
  guint32 get_int();
  gint32 get_int_range(gint32 begin, gint32 end);
  double get_double();
  double get_double_range(double begin, double end);
  GRand* gobj() { return gobject_; }
  const GRand* gobj() const { return gobject_; }
private:
  GRand* gobject_;
  Rand(const Rand&);
  Rand& operator=(const Rand&);
};
}
typedef struct _GRegex GRegex;
namespace Glib
{
enum RegexCompileFlags
{
  REGEX_CASELESS = 1 << 0,
  REGEX_MULTILINE = 1 << 1,
  REGEX_DOTALL = 1 << 2,
  REGEX_EXTENDED = 1 << 3,
  REGEX_ANCHORED = 1 << 4,
  REGEX_DOLLAR_ENDONLY = 1 << 5,
  REGEX_UNGREEDY = 1 << 9,
  REGEX_RAW = 1 << 11,
  REGEX_NO_AUTO_CAPTURE = 1 << 12,
  REGEX_OPTIMIZE = 1 << 13,
  REGEX_DUPNAMES = 1 << 19,
  REGEX_NEWLINE_CR = 1 << 20,
  REGEX_NEWLINE_LF = 1 << 21,
  REGEX_NEWLINE_CRLF = 0x100000
};
inline RegexCompileFlags operator|(RegexCompileFlags lhs, RegexCompileFlags rhs)
  { return static_cast<RegexCompileFlags>(static_cast<unsigned>(lhs) | static_cast<unsigned>(rhs)); }
inline RegexCompileFlags operator&(RegexCompileFlags lhs, RegexCompileFlags rhs)
  { return static_cast<RegexCompileFlags>(static_cast<unsigned>(lhs) & static_cast<unsigned>(rhs)); }
inline RegexCompileFlags operator^(RegexCompileFlags lhs, RegexCompileFlags rhs)
  { return static_cast<RegexCompileFlags>(static_cast<unsigned>(lhs) ^ static_cast<unsigned>(rhs)); }
inline RegexCompileFlags operator~(RegexCompileFlags flags)
  { return static_cast<RegexCompileFlags>(~static_cast<unsigned>(flags)); }
inline RegexCompileFlags& operator|=(RegexCompileFlags& lhs, RegexCompileFlags rhs)
  { return (lhs = static_cast<RegexCompileFlags>(static_cast<unsigned>(lhs) | static_cast<unsigned>(rhs))); }
inline RegexCompileFlags& operator&=(RegexCompileFlags& lhs, RegexCompileFlags rhs)
  { return (lhs = static_cast<RegexCompileFlags>(static_cast<unsigned>(lhs) & static_cast<unsigned>(rhs))); }
inline RegexCompileFlags& operator^=(RegexCompileFlags& lhs, RegexCompileFlags rhs)
  { return (lhs = static_cast<RegexCompileFlags>(static_cast<unsigned>(lhs) ^ static_cast<unsigned>(rhs))); }
enum RegexMatchFlags
{
  REGEX_MATCH_ANCHORED = 1 << 4,
  REGEX_MATCH_NOTBOL = 1 << 7,
  REGEX_MATCH_NOTEOL = 1 << 8,
  REGEX_MATCH_NOTEMPTY = 1 << 10,
  REGEX_MATCH_PARTIAL = 1 << 15,
  REGEX_MATCH_NEWLINE_CR = 1 << 20,
  REGEX_MATCH_NEWLINE_LF = 1 << 21,
  REGEX_MATCH_NEWLINE_CRLF = 0x100000,
  REGEX_MATCH_NEWLINE_ANY = 1 << 22
};
inline RegexMatchFlags operator|(RegexMatchFlags lhs, RegexMatchFlags rhs)
  { return static_cast<RegexMatchFlags>(static_cast<unsigned>(lhs) | static_cast<unsigned>(rhs)); }
inline RegexMatchFlags operator&(RegexMatchFlags lhs, RegexMatchFlags rhs)
  { return static_cast<RegexMatchFlags>(static_cast<unsigned>(lhs) & static_cast<unsigned>(rhs)); }
inline RegexMatchFlags operator^(RegexMatchFlags lhs, RegexMatchFlags rhs)
  { return static_cast<RegexMatchFlags>(static_cast<unsigned>(lhs) ^ static_cast<unsigned>(rhs)); }
inline RegexMatchFlags operator~(RegexMatchFlags flags)
  { return static_cast<RegexMatchFlags>(~static_cast<unsigned>(flags)); }
inline RegexMatchFlags& operator|=(RegexMatchFlags& lhs, RegexMatchFlags rhs)
  { return (lhs = static_cast<RegexMatchFlags>(static_cast<unsigned>(lhs) | static_cast<unsigned>(rhs))); }
inline RegexMatchFlags& operator&=(RegexMatchFlags& lhs, RegexMatchFlags rhs)
  { return (lhs = static_cast<RegexMatchFlags>(static_cast<unsigned>(lhs) & static_cast<unsigned>(rhs))); }
inline RegexMatchFlags& operator^=(RegexMatchFlags& lhs, RegexMatchFlags rhs)
  { return (lhs = static_cast<RegexMatchFlags>(static_cast<unsigned>(lhs) ^ static_cast<unsigned>(rhs))); }
class RegexError : public Glib::Error
{
public:
  enum Code
  {
    COMPILE,
    OPTIMIZE,
    REPLACE,
    MATCH
  };
  RegexError(Code error_code, const Glib::ustring& error_message);
  explicit RegexError(GError* gobject);
  Code code() const;
private:
  static void throw_func(GError* gobject);
  friend void wrap_init();
};
class Regex
{
  public:
  typedef Regex CppObjectType;
  typedef GRegex BaseObjectType;
  void reference() const;
  void unreference() const;
  GRegex* gobj();
  const GRegex* gobj() const;
  GRegex* gobj_copy() const;
protected:
  Regex();
  void operator delete(void*, size_t);
private:
  Regex(const Regex&);
  Regex& operator=(const Regex&);
public:
  static Glib::RefPtr<Glib::Regex> create(const Glib::ustring& pattern, RegexCompileFlags compile_options = static_cast<RegexCompileFlags>(0), RegexMatchFlags match_options = static_cast<RegexMatchFlags>(0));
  Glib::ustring get_pattern() const;
  int get_max_backref() const;
  int get_capture_count() const;
  int get_string_number(const Glib::ustring& name) const;
  static Glib::ustring escape_string(const Glib::ustring& string);
  static bool match_simple(const Glib::ustring& pattern, const Glib::ustring& string, RegexCompileFlags compile_options = static_cast<RegexCompileFlags>(0), RegexMatchFlags match_options = static_cast<RegexMatchFlags>(0));
  bool match(const Glib::ustring& string, RegexMatchFlags match_options = static_cast<RegexMatchFlags>(0));
  bool match(const Glib::ustring& string, int start_position, RegexMatchFlags match_options);
  bool match(const Glib::ustring& string, gssize string_len, int start_position, RegexMatchFlags match_options);
  bool match_all(const Glib::ustring& string, RegexMatchFlags match_options = static_cast<RegexMatchFlags>(0));
  bool match_all(const Glib::ustring& string, int start_position, RegexMatchFlags match_options);
  bool match_all(const Glib::ustring& string, gssize string_len, int start_position, RegexMatchFlags match_options);
  static Glib::StringArrayHandle split_simple(const Glib::ustring& pattern, const Glib::ustring& string, RegexCompileFlags compile_options = static_cast<RegexCompileFlags>(0), RegexMatchFlags match_options = static_cast<RegexMatchFlags>(0));
  Glib::StringArrayHandle split(const Glib::ustring& string, RegexMatchFlags match_options = static_cast<RegexMatchFlags>(0));
  Glib::StringArrayHandle split(const gchar* string, gssize string_len, int start_position, RegexMatchFlags match_options = static_cast<RegexMatchFlags>(0), int max_tokens = 0) const;
  Glib::StringArrayHandle split(const Glib::ustring& string, int start_position, RegexMatchFlags match_options, int max_tokens) const;
  Glib::ustring replace(const gchar* string, gssize string_len, int start_position, const Glib::ustring& replacement, RegexMatchFlags match_options = static_cast<RegexMatchFlags>(0));
  Glib::ustring replace(const Glib::ustring& string, int start_position, const Glib::ustring& replacement, RegexMatchFlags match_options);
  Glib::ustring replace_literal(const gchar *string, gssize string_len, int start_position, const Glib::ustring& replacement, RegexMatchFlags match_options = static_cast<RegexMatchFlags>(0));
  Glib::ustring replace_literal(const Glib::ustring& string, int start_position, const Glib::ustring& replacement, RegexMatchFlags match_options);
  Glib::ustring replace_eval(const Glib::ustring& string, gssize string_len, int start_position, RegexMatchFlags match_options, GRegexEvalCallback eval, gpointer user_data);
  static bool check_replacement(const Glib::ustring& replacement, gboolean* has_references);
};
}
namespace Glib
{
  Glib::RefPtr<Glib::Regex> wrap(GRegex* object, bool take_copy = false);
}
namespace Glib
{
class ShellError : public Glib::Error
{
public:
  enum Code
  {
    BAD_QUOTING,
    EMPTY_STRING,
    FAILED
  };
  ShellError(Code error_code, const Glib::ustring& error_message);
  explicit ShellError(GError* gobject);
  Code code() const;
private:
  static void throw_func(GError* gobject);
  friend void wrap_init();
};
Glib::ArrayHandle<std::string> shell_parse_argv(const std::string& command_line);
std::string shell_quote(const std::string& unquoted_string);
std::string shell_unquote(const std::string& quoted_string);
}
namespace Glib
{
namespace Container_Helpers
{
template <class Bi, class Tr>
GSList* create_slist(Bi pbegin, Bi pend, Tr)
{
  GSList* head = 0;
  while(pend != pbegin)
  {
    const void *const item = Tr::to_c_type(*&*--pend);
    head = g_slist_prepend(head, const_cast<void*>(item));
  }
  return head;
}
template <class For, class Tr>
GSList* create_slist(For pbegin, Tr)
{
  GSList* head = 0;
  while(*pbegin)
  {
    const void *const item = Tr::to_c_type(*&*pbegin);
    head = g_slist_prepend(head, const_cast<void*>(item));
    ++pbegin;
  }
  return g_slist_reverse(head);
}
template <class Tr, class Cont>
struct SListSourceTraits
{
  static GSList* get_data(const Cont& cont)
    { return Glib::Container_Helpers::create_slist(cont.begin(), cont.end(), Tr()); }
  static const Glib::OwnershipType initial_ownership = Glib::OWNERSHIP_SHALLOW;
};
template <class Tr, class Cont>
struct SListSourceTraits<Tr,Cont*>
{
  static GSList* get_data(const Cont* array)
    { return (array) ? Glib::Container_Helpers::create_slist(array, Tr()) : 0; }
  static const Glib::OwnershipType initial_ownership = Glib::OWNERSHIP_SHALLOW;
};
template <class Tr, class Cont>
struct SListSourceTraits<Tr,const Cont*> : SListSourceTraits<Tr,Cont*>
{};
template <class Tr, class Cont, size_t N>
struct SListSourceTraits<Tr,Cont[N]>
{
  static GSList* get_data(const Cont* array)
    { return Glib::Container_Helpers::create_slist(array, array + (N - 1), Tr()); }
  static const Glib::OwnershipType initial_ownership = Glib::OWNERSHIP_SHALLOW;
};
template <class Tr, class Cont, size_t N>
struct SListSourceTraits<Tr,const Cont[N]> : SListSourceTraits<Tr,Cont[N]>
{};
template <class Tr>
class SListHandleIterator
{
public:
  typedef typename Tr::CppType CppType;
  typedef typename Tr::CType CType;
  typedef std::forward_iterator_tag iterator_category;
  typedef CppType value_type;
  typedef ptrdiff_t difference_type;
  typedef value_type reference;
  typedef void pointer;
  explicit inline SListHandleIterator(const GSList* node);
  inline value_type operator*() const;
  inline SListHandleIterator<Tr> & operator++();
  inline const SListHandleIterator<Tr> operator++(int);
  inline bool operator==(const SListHandleIterator<Tr>& rhs) const;
  inline bool operator!=(const SListHandleIterator<Tr>& rhs) const;
private:
  const GSList* node_;
};
}
template < class T, class Tr = Glib::Container_Helpers::TypeTraits<T> >
class SListHandle
{
public:
  typedef typename Tr::CppType CppType;
  typedef typename Tr::CType CType;
  typedef CppType value_type;
  typedef size_t size_type;
  typedef ptrdiff_t difference_type;
  typedef Glib::Container_Helpers::SListHandleIterator<Tr> const_iterator;
  typedef Glib::Container_Helpers::SListHandleIterator<Tr> iterator;
  template <class Cont> inline
    SListHandle(const Cont& container);
  inline SListHandle(GSList* glist, Glib::OwnershipType ownership);
  inline SListHandle(const SListHandle<T,Tr>& other);
  ~SListHandle();
  inline const_iterator begin() const;
  inline const_iterator end() const;
  template <class U> inline operator std::vector<U>() const;
  template <class U> inline operator std::deque<U>() const;
  template <class U> inline operator std::list<U>() const;
  template <class Cont> inline
    void assign_to(Cont& container) const;
  template <class Out> inline
    void copy(Out pdest) const;
  inline GSList* data() const;
  inline size_t size() const;
  inline bool empty() const;
private:
  GSList * pslist_;
  mutable Glib::OwnershipType ownership_;
  SListHandle<T,Tr>& operator=(const SListHandle<T,Tr>&);
};
namespace Container_Helpers
{
template <class Tr> inline
SListHandleIterator<Tr>::SListHandleIterator(const GSList* node)
:
  node_ (node)
{}
template <class Tr> inline
typename SListHandleIterator<Tr>::value_type SListHandleIterator<Tr>::operator*() const
{
  return Tr::to_cpp_type(static_cast<typename Tr::CTypeNonConst>(node_->data));
}
template <class Tr> inline
SListHandleIterator<Tr>& SListHandleIterator<Tr>::operator++()
{
  node_ = node_->next;
  return *this;
}
template <class Tr> inline
const SListHandleIterator<Tr> SListHandleIterator<Tr>::operator++(int)
{
  const SListHandleIterator<Tr> tmp (*this);
  node_ = node_->next;
  return tmp;
}
template <class Tr> inline
bool SListHandleIterator<Tr>::operator==(const SListHandleIterator<Tr>& rhs) const
{
  return (node_ == rhs.node_);
}
template <class Tr> inline
bool SListHandleIterator<Tr>::operator!=(const SListHandleIterator<Tr>& rhs) const
{
  return (node_ != rhs.node_);
}
}
template <class T, class Tr>
  template <class Cont>
inline
SListHandle<T,Tr>::SListHandle(const Cont& container)
:
  pslist_ (Glib::Container_Helpers::SListSourceTraits<Tr,Cont>::get_data(container)),
  ownership_ (Glib::Container_Helpers::SListSourceTraits<Tr,Cont>::initial_ownership)
{}
template <class T, class Tr> inline
SListHandle<T,Tr>::SListHandle(GSList* gslist, Glib::OwnershipType ownership)
:
  pslist_ (gslist),
  ownership_ (ownership)
{}
template <class T, class Tr> inline
SListHandle<T,Tr>::SListHandle(const SListHandle<T,Tr>& other)
:
  pslist_ (other.pslist_),
  ownership_ (other.ownership_)
{
  other.ownership_ = Glib::OWNERSHIP_NONE;
}
template <class T, class Tr>
SListHandle<T,Tr>::~SListHandle()
{
  if(ownership_ != Glib::OWNERSHIP_NONE)
  {
    if(ownership_ != Glib::OWNERSHIP_SHALLOW)
    {
      for(GSList* node = pslist_; node != 0; node = node->next)
        Tr::release_c_type(static_cast<typename Tr::CTypeNonConst>(node->data));
    }
    g_slist_free(pslist_);
  }
}
template <class T, class Tr> inline
typename SListHandle<T,Tr>::const_iterator SListHandle<T,Tr>::begin() const
{
  return Glib::Container_Helpers::SListHandleIterator<Tr>(pslist_);
}
template <class T, class Tr> inline
typename SListHandle<T,Tr>::const_iterator SListHandle<T,Tr>::end() const
{
  return Glib::Container_Helpers::SListHandleIterator<Tr>(0);
}
template <class T, class Tr>
  template <class U>
inline
SListHandle<T,Tr>::operator std::vector<U>() const
{
  return std::vector<U>(this->begin(), this->end());
}
template <class T, class Tr>
  template <class U>
inline
SListHandle<T,Tr>::operator std::deque<U>() const
{
  return std::deque<U>(this->begin(), this->end());
}
template <class T, class Tr>
  template <class U>
inline
SListHandle<T,Tr>::operator std::list<U>() const
{
  return std::list<U>(this->begin(), this->end());
}
template <class T, class Tr>
  template <class Cont>
inline
void SListHandle<T,Tr>::assign_to(Cont& container) const
{
  container.assign(this->begin(), this->end());
}
template <class T, class Tr>
  template <class Out>
inline
void SListHandle<T,Tr>::copy(Out pdest) const
{
  std::copy(this->begin(), this->end(), pdest);
}
template <class T, class Tr> inline
GSList* SListHandle<T,Tr>::data() const
{
  return pslist_;
}
template <class T, class Tr> inline
size_t SListHandle<T,Tr>::size() const
{
  return g_slist_length(pslist_);
}
template <class T, class Tr> inline
bool SListHandle<T,Tr>::empty() const
{
  return (pslist_ == 0);
}
}
namespace Glib
{
typedef GPid Pid;
enum SpawnFlags
{
  SPAWN_LEAVE_DESCRIPTORS_OPEN = 1 << 0,
  SPAWN_DO_NOT_REAP_CHILD = 1 << 1,
  SPAWN_SEARCH_PATH = 1 << 2,
  SPAWN_STDOUT_TO_DEV_NULL = 1 << 3,
  SPAWN_STDERR_TO_DEV_NULL = 1 << 4,
  SPAWN_CHILD_INHERITS_STDIN = 1 << 5,
  SPAWN_FILE_AND_ARGV_ZERO = 1 << 6
};
inline SpawnFlags operator|(SpawnFlags lhs, SpawnFlags rhs)
  { return static_cast<SpawnFlags>(static_cast<unsigned>(lhs) | static_cast<unsigned>(rhs)); }
inline SpawnFlags operator&(SpawnFlags lhs, SpawnFlags rhs)
  { return static_cast<SpawnFlags>(static_cast<unsigned>(lhs) & static_cast<unsigned>(rhs)); }
inline SpawnFlags operator^(SpawnFlags lhs, SpawnFlags rhs)
  { return static_cast<SpawnFlags>(static_cast<unsigned>(lhs) ^ static_cast<unsigned>(rhs)); }
inline SpawnFlags operator~(SpawnFlags flags)
  { return static_cast<SpawnFlags>(~static_cast<unsigned>(flags)); }
inline SpawnFlags& operator|=(SpawnFlags& lhs, SpawnFlags rhs)
  { return (lhs = static_cast<SpawnFlags>(static_cast<unsigned>(lhs) | static_cast<unsigned>(rhs))); }
inline SpawnFlags& operator&=(SpawnFlags& lhs, SpawnFlags rhs)
  { return (lhs = static_cast<SpawnFlags>(static_cast<unsigned>(lhs) & static_cast<unsigned>(rhs))); }
inline SpawnFlags& operator^=(SpawnFlags& lhs, SpawnFlags rhs)
  { return (lhs = static_cast<SpawnFlags>(static_cast<unsigned>(lhs) ^ static_cast<unsigned>(rhs))); }
class SpawnError : public Glib::Error
{
public:
  enum Code
  {
    FORK,
    READ,
    CHDIR,
    ACCES,
    PERM,
    TOOBIG,
    NOEXEC,
    NAMETOOLONG,
    NOENT,
    NOMEM,
    NOTDIR,
    LOOP,
    TXTBUSY,
    IO,
    NFILE,
    MFILE,
    INVAL,
    ISDIR,
    LIBBAD
  };
  SpawnError(Code error_code, const Glib::ustring& error_message);
  explicit SpawnError(GError* gobject);
  Code code() const;
private:
  static void throw_func(GError* gobject);
  friend void wrap_init();
};
void spawn_async_with_pipes(const std::string& working_directory,
                            const Glib::ArrayHandle<std::string>& argv,
                            const Glib::ArrayHandle<std::string>& envp,
                            SpawnFlags flags = SpawnFlags(0),
                            const sigc::slot<void>& child_setup = sigc::slot<void>(),
                            Pid* child_pid = 0,
                            int* standard_input = 0,
                            int* standard_output = 0,
                            int* standard_error = 0);
void spawn_async_with_pipes(const std::string& working_directory,
                            const Glib::ArrayHandle<std::string>& argv,
                            SpawnFlags flags = SpawnFlags(0),
                            const sigc::slot<void>& child_setup = sigc::slot<void>(),
                            Pid* child_pid = 0,
                            int* standard_input = 0,
                            int* standard_output = 0,
                            int* standard_error = 0);
void spawn_async(const std::string& working_directory,
                 const Glib::ArrayHandle<std::string>& argv,
                 const Glib::ArrayHandle<std::string>& envp,
                 SpawnFlags flags = SpawnFlags(0),
                 const sigc::slot<void>& child_setup = sigc::slot<void>(),
                 Pid* child_pid = 0);
void spawn_async(const std::string& working_directory,
                 const Glib::ArrayHandle<std::string>& argv,
                 SpawnFlags flags = SpawnFlags(0),
                 const sigc::slot<void>& child_setup = sigc::slot<void>(),
                 Pid* child_pid = 0);
void spawn_sync(const std::string& working_directory,
                const Glib::ArrayHandle<std::string>& argv,
                const Glib::ArrayHandle<std::string>& envp,
                SpawnFlags flags = SpawnFlags(0),
                const sigc::slot<void>& child_setup = sigc::slot<void>(),
                std::string* standard_output = 0,
                std::string* standard_error = 0,
                int* exit_status = 0);
void spawn_sync(const std::string& working_directory,
                const Glib::ArrayHandle<std::string>& argv,
                SpawnFlags flags = SpawnFlags(0),
                const sigc::slot<void>& child_setup = sigc::slot<void>(),
                std::string* standard_output = 0,
                std::string* standard_error = 0,
                int* exit_status = 0);
void spawn_command_line_async(const std::string& command_line);
void spawn_command_line_sync(const std::string& command_line,
                             std::string* standard_output = 0,
                             std::string* standard_error = 0,
                             int* exit_status = 0);
void spawn_close_pid(Pid pid);
}
namespace Glib
{
bool str_has_prefix(const std::string& str, const std::string& prefix);
bool str_has_suffix(const std::string& str, const std::string& suffix);
namespace Ascii
{
double strtod(const std::string& str);
double strtod(const std::string& str,
              std::string::size_type& end_index,
              std::string::size_type start_index = 0);
std::string dtostr(double d);
}
std::string strescape(const std::string& source);
std::string strescape(const std::string& source, const std::string& exceptions);
std::string strcompress(const std::string& source);
Glib::ustring strerror(int errnum);
Glib::ustring strsignal(int signum);
}
namespace Glib
{
enum ThreadPriority
{
  THREAD_PRIORITY_LOW,
  THREAD_PRIORITY_NORMAL,
  THREAD_PRIORITY_HIGH,
  THREAD_PRIORITY_URGENT
};
enum NotLock { NOT_LOCK };
enum TryLock { TRY_LOCK };
inline void thread_init(GThreadFunctions* vtable = 0);
inline bool thread_supported();
class Mutex;
class RecMutex;
class RWLock;
struct StaticMutex;
struct StaticRecMutex;
struct StaticRWLock;
class ThreadError : public Glib::Error
{
public:
  enum Code
  {
    AGAIN
  };
  ThreadError(Code error_code, const Glib::ustring& error_message);
  explicit ThreadError(GError* gobject);
  Code code() const;
private:
  static void throw_func(GError* gobject);
  friend void wrap_init();
};
class Thread
{
public:
  class Exit;
  static Thread* create(const sigc::slot<void>& slot, bool joinable);
  static Thread* create(const sigc::slot<void>& slot, unsigned long stack_size,
                        bool joinable, bool bound, ThreadPriority priority);
  static Thread* self();
  bool joinable() const;
  void join();
  void set_priority(ThreadPriority priority);
  ThreadPriority get_priority() const;
  static void yield();
  GThread* gobj() { return &gobject_; }
  const GThread* gobj() const { return &gobject_; }
private:
  GThread gobject_;
  Thread();
  void operator delete(void*, size_t);
  Thread(const Thread&);
  Thread& operator=(const Thread&);
};
class Thread::Exit
{};
Thread* wrap(GThread* gobject);
struct StaticMutex
{
  void lock();
  bool trylock();
  void unlock();
  operator Mutex&();
  GStaticMutex* gobj() { return &gobject_; }
  GStaticMutex gobject_;
};
class Mutex
{
public:
  class Lock;
  Mutex();
  ~Mutex();
  void lock();
  bool trylock();
  void unlock();
  GMutex* gobj() { return gobject_; }
private:
  GMutex* gobject_;
  Mutex(const Mutex&);
  Mutex& operator=(const Mutex&);
};
class Mutex::Lock
{
public:
  explicit inline Lock(Mutex& mutex);
  inline Lock(Mutex& mutex, NotLock);
  inline Lock(Mutex& mutex, TryLock);
  inline ~Lock();
  inline void acquire();
  inline bool try_acquire();
  inline void release();
  inline bool locked() const;
private:
  Mutex& mutex_;
  bool locked_;
  Lock(const Mutex::Lock&);
  Mutex::Lock& operator=(const Mutex::Lock&);
};
struct StaticRecMutex
{
  void lock();
  bool trylock();
  void unlock();
  void lock_full(unsigned int depth);
  unsigned int unlock_full();
  operator RecMutex&();
  GStaticRecMutex* gobj() { return &gobject_; }
  GStaticRecMutex gobject_;
};
class RecMutex : public StaticRecMutex
{
public:
  class Lock;
  RecMutex();
  ~RecMutex();
private:
  RecMutex(const RecMutex&);
  RecMutex& operator=(const RecMutex&);
};
class RecMutex::Lock
{
public:
  explicit inline Lock(RecMutex& mutex);
  inline Lock(RecMutex& mutex, NotLock);
  inline Lock(RecMutex& mutex, TryLock);
  inline ~Lock();
  inline void acquire();
  inline bool try_acquire();
  inline void release();
  inline bool locked() const;
private:
  RecMutex& mutex_;
  bool locked_;
  Lock(const RecMutex::Lock&);
  RecMutex::Lock& operator=(const RecMutex::Lock&);
};
struct StaticRWLock
{
  void reader_lock();
  bool reader_trylock();
  void reader_unlock();
  void writer_lock();
  bool writer_trylock();
  void writer_unlock();
  operator RWLock&();
  GStaticRWLock* gobj() { return &gobject_; }
  GStaticRWLock gobject_;
};
class RWLock : public StaticRWLock
{
public:
  class ReaderLock;
  class WriterLock;
  RWLock();
  ~RWLock();
private:
  RWLock(const RWLock&);
  RWLock& operator=(const RWLock&);
};
class RWLock::ReaderLock
{
public:
  explicit inline ReaderLock(RWLock& rwlock);
  inline ReaderLock(RWLock& rwlock, NotLock);
  inline ReaderLock(RWLock& rwlock, TryLock);
  inline ~ReaderLock();
  inline void acquire();
  inline bool try_acquire();
  inline void release();
  inline bool locked() const;
private:
  RWLock& rwlock_;
  bool locked_;
  ReaderLock(const RWLock::ReaderLock&);
  RWLock::ReaderLock& operator=(const RWLock::ReaderLock&);
};
class RWLock::WriterLock
{
public:
  explicit inline WriterLock(RWLock& rwlock);
  inline WriterLock(RWLock& rwlock, NotLock);
  inline WriterLock(RWLock& rwlock, TryLock);
  inline ~WriterLock();
  inline void acquire();
  inline bool try_acquire();
  inline void release();
  inline bool locked() const;
private:
  RWLock& rwlock_;
  bool locked_;
  WriterLock(const RWLock::WriterLock&);
  RWLock::WriterLock& operator=(const RWLock::WriterLock&);
};
class Cond
{
public:
  Cond();
  ~Cond();
  void signal();
  void broadcast();
  void wait(Mutex& mutex);
  bool timed_wait(Mutex& mutex, const Glib::TimeVal& abs_time);
  GCond* gobj() { return gobject_; }
private:
  GCond* gobject_;
  Cond(const Cond&);
  Cond& operator=(const Cond&);
};
template <class T>
struct StaticPrivate
{
  typedef void (*DestroyNotifyFunc) (void*);
  static void delete_ptr(void* data);
  inline T* get();
  inline void set(T* data, DestroyNotifyFunc notify_func = &StaticPrivate<T>::delete_ptr);
  GStaticPrivate* gobj() { return &gobject_; }
  GStaticPrivate gobject_;
};
template <class T>
class Private
{
public:
  typedef void (*DestructorFunc) (void*);
  static void delete_ptr(void* data);
  explicit inline Private(DestructorFunc destructor_func = &Private<T>::delete_ptr);
  inline T* get();
  inline void set(T* data);
  GPrivate* gobj() { return gobject_; }
private:
  GPrivate* gobject_;
  Private(const Private<T>&);
  Private<T>& operator=(const Private<T>&);
};
void thread_init_impl();
inline
void thread_init(GThreadFunctions* vtable)
{
  g_thread_init(vtable);
  Glib::thread_init_impl();
}
inline
bool thread_supported()
{
  return ((g_threads_got_initialized) != 0);
}
inline
Mutex::Lock::Lock(Mutex& mutex)
:
  mutex_ (mutex),
  locked_ (true)
{
  mutex_.lock();
}
inline
Mutex::Lock::Lock(Mutex& mutex, NotLock)
:
  mutex_ (mutex),
  locked_ (false)
{}
inline
Mutex::Lock::Lock(Mutex& mutex, TryLock)
:
  mutex_ (mutex),
  locked_ (mutex.trylock())
{}
inline
Mutex::Lock::~Lock()
{
  if(locked_)
    mutex_.unlock();
}
inline
void Mutex::Lock::acquire()
{
  mutex_.lock();
  locked_ = true;
}
inline
bool Mutex::Lock::try_acquire()
{
  locked_ = mutex_.trylock();
  return locked_;
}
inline
void Mutex::Lock::release()
{
  mutex_.unlock();
  locked_ = false;
}
inline
bool Mutex::Lock::locked() const
{
  return locked_;
}
inline
RecMutex::Lock::Lock(RecMutex& mutex)
:
  mutex_ (mutex),
  locked_ (true)
{
  mutex_.lock();
}
inline
RecMutex::Lock::Lock(RecMutex& mutex, NotLock)
:
  mutex_ (mutex),
  locked_ (false)
{}
inline
RecMutex::Lock::Lock(RecMutex& mutex, TryLock)
:
  mutex_ (mutex),
  locked_ (mutex.trylock())
{}
inline
RecMutex::Lock::~Lock()
{
  if(locked_)
    mutex_.unlock();
}
inline
void RecMutex::Lock::acquire()
{
  mutex_.lock();
  locked_ = true;
}
inline
bool RecMutex::Lock::try_acquire()
{
  locked_ = mutex_.trylock();
  return locked_;
}
inline
void RecMutex::Lock::release()
{
  mutex_.unlock();
  locked_ = false;
}
inline
bool RecMutex::Lock::locked() const
{
  return locked_;
}
inline
RWLock::ReaderLock::ReaderLock(RWLock& rwlock)
:
  rwlock_ (rwlock),
  locked_ (true)
{
  rwlock_.reader_lock();
}
inline
RWLock::ReaderLock::ReaderLock(RWLock& rwlock, NotLock)
:
  rwlock_ (rwlock),
  locked_ (false)
{}
inline
RWLock::ReaderLock::ReaderLock(RWLock& rwlock, TryLock)
:
  rwlock_ (rwlock),
  locked_ (rwlock.reader_trylock())
{}
inline
RWLock::ReaderLock::~ReaderLock()
{
  if(locked_)
    rwlock_.reader_unlock();
}
inline
void RWLock::ReaderLock::acquire()
{
  rwlock_.reader_lock();
  locked_ = true;
}
inline
bool RWLock::ReaderLock::try_acquire()
{
  locked_ = rwlock_.reader_trylock();
  return locked_;
}
inline
void RWLock::ReaderLock::release()
{
  rwlock_.reader_unlock();
  locked_ = false;
}
inline
bool RWLock::ReaderLock::locked() const
{
  return locked_;
}
inline
RWLock::WriterLock::WriterLock(RWLock& rwlock)
:
  rwlock_ (rwlock),
  locked_ (true)
{
  rwlock_.writer_lock();
}
inline
RWLock::WriterLock::WriterLock(RWLock& rwlock, NotLock)
:
  rwlock_ (rwlock),
  locked_ (false)
{}
inline
RWLock::WriterLock::WriterLock(RWLock& rwlock, TryLock)
:
  rwlock_ (rwlock),
  locked_ (rwlock.writer_trylock())
{}
inline
RWLock::WriterLock::~WriterLock()
{
  if(locked_)
    rwlock_.writer_unlock();
}
inline
void RWLock::WriterLock::acquire()
{
  rwlock_.writer_lock();
  locked_ = true;
}
inline
bool RWLock::WriterLock::try_acquire()
{
  locked_ = rwlock_.writer_trylock();
  return locked_;
}
inline
void RWLock::WriterLock::release()
{
  rwlock_.writer_unlock();
  locked_ = false;
}
inline
bool RWLock::WriterLock::locked() const
{
  return locked_;
}
template <class T>
void StaticPrivate<T>::delete_ptr(void* data)
{
  delete static_cast<T*>(data);
}
template <class T> inline
T* StaticPrivate<T>::get()
{
  return static_cast<T*>(g_static_private_get(&gobject_));
}
template <class T> inline
void StaticPrivate<T>::set(T* data, typename StaticPrivate<T>::DestroyNotifyFunc notify_func)
{
  g_static_private_set(&gobject_, data, notify_func);
}
template <class T>
void Private<T>::delete_ptr(void* data)
{
  delete static_cast<T*>(data);
}
template <class T> inline
Private<T>::Private(typename Private<T>::DestructorFunc destructor_func)
:
  gobject_ ((*g_thread_functions_for_glib_use . private_new) (destructor_func))
{}
template <class T> inline
T* Private<T>::get()
{
  return static_cast<T*>(((g_threads_got_initialized) ? (*g_thread_functions_for_glib_use . private_get) (gobject_) : (((gpointer)gobject_))));
}
template <class T> inline
void Private<T>::set(T* data)
{
  ((g_threads_got_initialized) ? (*g_thread_functions_for_glib_use . private_set) (gobject_, data) : ((void) (gobject_ = (GPrivate*) (data))));
}
}
extern "C" { typedef struct _GThreadPool GThreadPool; }
namespace Glib
{
class ThreadPool
{
public:
  explicit ThreadPool(int max_threads = -1, bool exclusive = false);
  virtual ~ThreadPool();
  void push(const sigc::slot<void>& slot);
  void set_max_threads(int max_threads);
  int get_max_threads() const;
  unsigned int get_num_threads() const;
  unsigned int unprocessed() const;
  bool get_exclusive() const;
  void shutdown(bool immediately = false);
  static void set_max_unused_threads(int max_threads);
  static int get_max_unused_threads();
  static unsigned int get_num_unused_threads();
  static void stop_unused_threads();
  GThreadPool* gobj() { return gobject_; }
  const GThreadPool* gobj() const { return gobject_; }
  class SlotList;
private:
  GThreadPool* gobject_;
  SlotList* slot_list_;
  ThreadPool(const ThreadPool&);
  ThreadPool& operator=(const ThreadPool&);
};
}
extern "C" { typedef struct _GTimer GTimer; }
namespace Glib
{
class Timer
{
public:
  Timer();
  ~Timer();
  void start();
  void stop();
  void reset();
  double elapsed() const;
  double elapsed(unsigned long& microseconds) const;
  GTimer* gobj() { return gobject_; }
  const GTimer* gobj() const { return gobject_; }
private:
  GTimer* gobject_;
  Timer(const Timer&);
  Timer& operator=(const Timer&);
};
void usleep(unsigned long microseconds);
}
extern "C" {
 int
cairo_version (void);
 const char*
cairo_version_string (void);
typedef int cairo_bool_t;
typedef struct _cairo cairo_t;
typedef struct _cairo_surface cairo_surface_t;
typedef struct _cairo_matrix {
    double xx; double yx;
    double xy; double yy;
    double x0; double y0;
} cairo_matrix_t;
typedef struct _cairo_pattern cairo_pattern_t;
typedef void (*cairo_destroy_func_t) (void *data);
typedef struct _cairo_user_data_key {
    int unused;
} cairo_user_data_key_t;
typedef enum _cairo_status {
    CAIRO_STATUS_SUCCESS = 0,
    CAIRO_STATUS_NO_MEMORY,
    CAIRO_STATUS_INVALID_RESTORE,
    CAIRO_STATUS_INVALID_POP_GROUP,
    CAIRO_STATUS_NO_CURRENT_POINT,
    CAIRO_STATUS_INVALID_MATRIX,
    CAIRO_STATUS_INVALID_STATUS,
    CAIRO_STATUS_NULL_POINTER,
    CAIRO_STATUS_INVALID_STRING,
    CAIRO_STATUS_INVALID_PATH_DATA,
    CAIRO_STATUS_READ_ERROR,
    CAIRO_STATUS_WRITE_ERROR,
    CAIRO_STATUS_SURFACE_FINISHED,
    CAIRO_STATUS_SURFACE_TYPE_MISMATCH,
    CAIRO_STATUS_PATTERN_TYPE_MISMATCH,
    CAIRO_STATUS_INVALID_CONTENT,
    CAIRO_STATUS_INVALID_FORMAT,
    CAIRO_STATUS_INVALID_VISUAL,
    CAIRO_STATUS_FILE_NOT_FOUND,
    CAIRO_STATUS_INVALID_DASH,
    CAIRO_STATUS_INVALID_DSC_COMMENT,
    CAIRO_STATUS_INVALID_INDEX,
    CAIRO_STATUS_CLIP_NOT_REPRESENTABLE
} cairo_status_t;
typedef enum _cairo_content {
    CAIRO_CONTENT_COLOR = 0x1000,
    CAIRO_CONTENT_ALPHA = 0x2000,
    CAIRO_CONTENT_COLOR_ALPHA = 0x3000
} cairo_content_t;
typedef cairo_status_t (*cairo_write_func_t) (void *closure,
           const unsigned char *data,
           unsigned int length);
typedef cairo_status_t (*cairo_read_func_t) (void *closure,
          unsigned char *data,
          unsigned int length);
 cairo_t *
cairo_create (cairo_surface_t *target);
 cairo_t *
cairo_reference (cairo_t *cr);
 void
cairo_destroy (cairo_t *cr);
 unsigned int
cairo_get_reference_count (cairo_t *cr);
 void *
cairo_get_user_data (cairo_t *cr,
       const cairo_user_data_key_t *key);
 cairo_status_t
cairo_set_user_data (cairo_t *cr,
       const cairo_user_data_key_t *key,
       void *user_data,
       cairo_destroy_func_t destroy);
 void
cairo_save (cairo_t *cr);
 void
cairo_restore (cairo_t *cr);
 void
cairo_push_group (cairo_t *cr);
 void
cairo_push_group_with_content (cairo_t *cr, cairo_content_t content);
 cairo_pattern_t *
cairo_pop_group (cairo_t *cr);
 void
cairo_pop_group_to_source (cairo_t *cr);
typedef enum _cairo_operator {
    CAIRO_OPERATOR_CLEAR,
    CAIRO_OPERATOR_SOURCE,
    CAIRO_OPERATOR_OVER,
    CAIRO_OPERATOR_IN,
    CAIRO_OPERATOR_OUT,
    CAIRO_OPERATOR_ATOP,
    CAIRO_OPERATOR_DEST,
    CAIRO_OPERATOR_DEST_OVER,
    CAIRO_OPERATOR_DEST_IN,
    CAIRO_OPERATOR_DEST_OUT,
    CAIRO_OPERATOR_DEST_ATOP,
    CAIRO_OPERATOR_XOR,
    CAIRO_OPERATOR_ADD,
    CAIRO_OPERATOR_SATURATE
} cairo_operator_t;
 void
cairo_set_operator (cairo_t *cr, cairo_operator_t op);
 void
cairo_set_source (cairo_t *cr, cairo_pattern_t *source);
 void
cairo_set_source_rgb (cairo_t *cr, double red, double green, double blue);
 void
cairo_set_source_rgba (cairo_t *cr,
         double red, double green, double blue,
         double alpha);
 void
cairo_set_source_surface (cairo_t *cr,
     cairo_surface_t *surface,
     double x,
     double y);
 void
cairo_set_tolerance (cairo_t *cr, double tolerance);
typedef enum _cairo_antialias {
    CAIRO_ANTIALIAS_DEFAULT,
    CAIRO_ANTIALIAS_NONE,
    CAIRO_ANTIALIAS_GRAY,
    CAIRO_ANTIALIAS_SUBPIXEL
} cairo_antialias_t;
 void
cairo_set_antialias (cairo_t *cr, cairo_antialias_t antialias);
typedef enum _cairo_fill_rule {
    CAIRO_FILL_RULE_WINDING,
    CAIRO_FILL_RULE_EVEN_ODD
} cairo_fill_rule_t;
 void
cairo_set_fill_rule (cairo_t *cr, cairo_fill_rule_t fill_rule);
 void
cairo_set_line_width (cairo_t *cr, double width);
typedef enum _cairo_line_cap {
    CAIRO_LINE_CAP_BUTT,
    CAIRO_LINE_CAP_ROUND,
    CAIRO_LINE_CAP_SQUARE
} cairo_line_cap_t;
 void
cairo_set_line_cap (cairo_t *cr, cairo_line_cap_t line_cap);
typedef enum _cairo_line_join {
    CAIRO_LINE_JOIN_MITER,
    CAIRO_LINE_JOIN_ROUND,
    CAIRO_LINE_JOIN_BEVEL
} cairo_line_join_t;
 void
cairo_set_line_join (cairo_t *cr, cairo_line_join_t line_join);
 void
cairo_set_dash (cairo_t *cr,
  const double *dashes,
  int num_dashes,
  double offset);
 void
cairo_set_miter_limit (cairo_t *cr, double limit);
 void
cairo_translate (cairo_t *cr, double tx, double ty);
 void
cairo_scale (cairo_t *cr, double sx, double sy);
 void
cairo_rotate (cairo_t *cr, double angle);
 void
cairo_transform (cairo_t *cr,
   const cairo_matrix_t *matrix);
 void
cairo_set_matrix (cairo_t *cr,
    const cairo_matrix_t *matrix);
 void
cairo_identity_matrix (cairo_t *cr);
 void
cairo_user_to_device (cairo_t *cr, double *x, double *y);
 void
cairo_user_to_device_distance (cairo_t *cr, double *dx, double *dy);
 void
cairo_device_to_user (cairo_t *cr, double *x, double *y);
 void
cairo_device_to_user_distance (cairo_t *cr, double *dx, double *dy);
 void
cairo_new_path (cairo_t *cr);
 void
cairo_move_to (cairo_t *cr, double x, double y);
 void
cairo_new_sub_path (cairo_t *cr);
 void
cairo_line_to (cairo_t *cr, double x, double y);
 void
cairo_curve_to (cairo_t *cr,
  double x1, double y1,
  double x2, double y2,
  double x3, double y3);
 void
cairo_arc (cairo_t *cr,
    double xc, double yc,
    double radius,
    double angle1, double angle2);
 void
cairo_arc_negative (cairo_t *cr,
      double xc, double yc,
      double radius,
      double angle1, double angle2);
 void
cairo_rel_move_to (cairo_t *cr, double dx, double dy);
 void
cairo_rel_line_to (cairo_t *cr, double dx, double dy);
 void
cairo_rel_curve_to (cairo_t *cr,
      double dx1, double dy1,
      double dx2, double dy2,
      double dx3, double dy3);
 void
cairo_rectangle (cairo_t *cr,
   double x, double y,
   double width, double height);
 void
cairo_close_path (cairo_t *cr);
 void
cairo_paint (cairo_t *cr);
 void
cairo_paint_with_alpha (cairo_t *cr,
   double alpha);
 void
cairo_mask (cairo_t *cr,
     cairo_pattern_t *pattern);
 void
cairo_mask_surface (cairo_t *cr,
      cairo_surface_t *surface,
      double surface_x,
      double surface_y);
 void
cairo_stroke (cairo_t *cr);
 void
cairo_stroke_preserve (cairo_t *cr);
 void
cairo_fill (cairo_t *cr);
 void
cairo_fill_preserve (cairo_t *cr);
 void
cairo_copy_page (cairo_t *cr);
 void
cairo_show_page (cairo_t *cr);
 cairo_bool_t
cairo_in_stroke (cairo_t *cr, double x, double y);
 cairo_bool_t
cairo_in_fill (cairo_t *cr, double x, double y);
 void
cairo_stroke_extents (cairo_t *cr,
        double *x1, double *y1,
        double *x2, double *y2);
 void
cairo_fill_extents (cairo_t *cr,
      double *x1, double *y1,
      double *x2, double *y2);
 void
cairo_reset_clip (cairo_t *cr);
 void
cairo_clip (cairo_t *cr);
 void
cairo_clip_preserve (cairo_t *cr);
 void
cairo_clip_extents (cairo_t *cr,
      double *x1, double *y1,
      double *x2, double *y2);
typedef struct _cairo_rectangle {
    double x, y, width, height;
} cairo_rectangle_t;
typedef struct _cairo_rectangle_list {
    cairo_status_t status;
    cairo_rectangle_t *rectangles;
    int num_rectangles;
} cairo_rectangle_list_t;
 cairo_rectangle_list_t *
cairo_copy_clip_rectangle_list (cairo_t *cr);
 void
cairo_rectangle_list_destroy (cairo_rectangle_list_t *rectangle_list);
typedef struct _cairo_scaled_font cairo_scaled_font_t;
typedef struct _cairo_font_face cairo_font_face_t;
typedef struct {
  unsigned long index;
  double x;
  double y;
} cairo_glyph_t;
typedef struct {
    double x_bearing;
    double y_bearing;
    double width;
    double height;
    double x_advance;
    double y_advance;
} cairo_text_extents_t;
typedef struct {
    double ascent;
    double descent;
    double height;
    double max_x_advance;
    double max_y_advance;
} cairo_font_extents_t;
typedef enum _cairo_font_slant {
  CAIRO_FONT_SLANT_NORMAL,
  CAIRO_FONT_SLANT_ITALIC,
  CAIRO_FONT_SLANT_OBLIQUE
} cairo_font_slant_t;
typedef enum _cairo_font_weight {
  CAIRO_FONT_WEIGHT_NORMAL,
  CAIRO_FONT_WEIGHT_BOLD
} cairo_font_weight_t;
typedef enum _cairo_subpixel_order {
    CAIRO_SUBPIXEL_ORDER_DEFAULT,
    CAIRO_SUBPIXEL_ORDER_RGB,
    CAIRO_SUBPIXEL_ORDER_BGR,
    CAIRO_SUBPIXEL_ORDER_VRGB,
    CAIRO_SUBPIXEL_ORDER_VBGR
} cairo_subpixel_order_t;
typedef enum _cairo_hint_style {
    CAIRO_HINT_STYLE_DEFAULT,
    CAIRO_HINT_STYLE_NONE,
    CAIRO_HINT_STYLE_SLIGHT,
    CAIRO_HINT_STYLE_MEDIUM,
    CAIRO_HINT_STYLE_FULL
} cairo_hint_style_t;
typedef enum _cairo_hint_metrics {
    CAIRO_HINT_METRICS_DEFAULT,
    CAIRO_HINT_METRICS_OFF,
    CAIRO_HINT_METRICS_ON
} cairo_hint_metrics_t;
typedef struct _cairo_font_options cairo_font_options_t;
 cairo_font_options_t *
cairo_font_options_create (void);
 cairo_font_options_t *
cairo_font_options_copy (const cairo_font_options_t *original);
 void
cairo_font_options_destroy (cairo_font_options_t *options);
 cairo_status_t
cairo_font_options_status (cairo_font_options_t *options);
 void
cairo_font_options_merge (cairo_font_options_t *options,
     const cairo_font_options_t *other);
 cairo_bool_t
cairo_font_options_equal (const cairo_font_options_t *options,
     const cairo_font_options_t *other);
 unsigned long
cairo_font_options_hash (const cairo_font_options_t *options);
 void
cairo_font_options_set_antialias (cairo_font_options_t *options,
      cairo_antialias_t antialias);
 cairo_antialias_t
cairo_font_options_get_antialias (const cairo_font_options_t *options);
 void
cairo_font_options_set_subpixel_order (cairo_font_options_t *options,
           cairo_subpixel_order_t subpixel_order);
 cairo_subpixel_order_t
cairo_font_options_get_subpixel_order (const cairo_font_options_t *options);
 void
cairo_font_options_set_hint_style (cairo_font_options_t *options,
       cairo_hint_style_t hint_style);
 cairo_hint_style_t
cairo_font_options_get_hint_style (const cairo_font_options_t *options);
 void
cairo_font_options_set_hint_metrics (cairo_font_options_t *options,
         cairo_hint_metrics_t hint_metrics);
 cairo_hint_metrics_t
cairo_font_options_get_hint_metrics (const cairo_font_options_t *options);
 void
cairo_select_font_face (cairo_t *cr,
   const char *family,
   cairo_font_slant_t slant,
   cairo_font_weight_t weight);
 void
cairo_set_font_size (cairo_t *cr, double size);
 void
cairo_set_font_matrix (cairo_t *cr,
         const cairo_matrix_t *matrix);
 void
cairo_get_font_matrix (cairo_t *cr,
         cairo_matrix_t *matrix);
 void
cairo_set_font_options (cairo_t *cr,
   const cairo_font_options_t *options);
 void
cairo_get_font_options (cairo_t *cr,
   cairo_font_options_t *options);
 void
cairo_set_font_face (cairo_t *cr, cairo_font_face_t *font_face);
 cairo_font_face_t *
cairo_get_font_face (cairo_t *cr);
 void
cairo_set_scaled_font (cairo_t *cr,
         const cairo_scaled_font_t *scaled_font);
 cairo_scaled_font_t *
cairo_get_scaled_font (cairo_t *cr);
 void
cairo_show_text (cairo_t *cr, const char *utf8);
 void
cairo_show_glyphs (cairo_t *cr, const cairo_glyph_t *glyphs, int num_glyphs);
 void
cairo_text_path (cairo_t *cr, const char *utf8);
 void
cairo_glyph_path (cairo_t *cr, const cairo_glyph_t *glyphs, int num_glyphs);
 void
cairo_text_extents (cairo_t *cr,
      const char *utf8,
      cairo_text_extents_t *extents);
 void
cairo_glyph_extents (cairo_t *cr,
       const cairo_glyph_t *glyphs,
       int num_glyphs,
       cairo_text_extents_t *extents);
 void
cairo_font_extents (cairo_t *cr,
      cairo_font_extents_t *extents);
 cairo_font_face_t *
cairo_font_face_reference (cairo_font_face_t *font_face);
 void
cairo_font_face_destroy (cairo_font_face_t *font_face);
 unsigned int
cairo_font_face_get_reference_count (cairo_font_face_t *font_face);
 cairo_status_t
cairo_font_face_status (cairo_font_face_t *font_face);
typedef enum _cairo_font_type {
    CAIRO_FONT_TYPE_TOY,
    CAIRO_FONT_TYPE_FT,
    CAIRO_FONT_TYPE_WIN32,
    CAIRO_FONT_TYPE_ATSUI
} cairo_font_type_t;
 cairo_font_type_t
cairo_font_face_get_type (cairo_font_face_t *font_face);
 void *
cairo_font_face_get_user_data (cairo_font_face_t *font_face,
          const cairo_user_data_key_t *key);
 cairo_status_t
cairo_font_face_set_user_data (cairo_font_face_t *font_face,
          const cairo_user_data_key_t *key,
          void *user_data,
          cairo_destroy_func_t destroy);
 cairo_scaled_font_t *
cairo_scaled_font_create (cairo_font_face_t *font_face,
     const cairo_matrix_t *font_matrix,
     const cairo_matrix_t *ctm,
     const cairo_font_options_t *options);
 cairo_scaled_font_t *
cairo_scaled_font_reference (cairo_scaled_font_t *scaled_font);
 void
cairo_scaled_font_destroy (cairo_scaled_font_t *scaled_font);
 unsigned int
cairo_scaled_font_get_reference_count (cairo_scaled_font_t *scaled_font);
 cairo_status_t
cairo_scaled_font_status (cairo_scaled_font_t *scaled_font);
 cairo_font_type_t
cairo_scaled_font_get_type (cairo_scaled_font_t *scaled_font);
 void *
cairo_scaled_font_get_user_data (cairo_scaled_font_t *scaled_font,
     const cairo_user_data_key_t *key);
 cairo_status_t
cairo_scaled_font_set_user_data (cairo_scaled_font_t *scaled_font,
     const cairo_user_data_key_t *key,
     void *user_data,
     cairo_destroy_func_t destroy);
 void
cairo_scaled_font_extents (cairo_scaled_font_t *scaled_font,
      cairo_font_extents_t *extents);
 void
cairo_scaled_font_text_extents (cairo_scaled_font_t *scaled_font,
    const char *utf8,
    cairo_text_extents_t *extents);
 void
cairo_scaled_font_glyph_extents (cairo_scaled_font_t *scaled_font,
     const cairo_glyph_t *glyphs,
     int num_glyphs,
     cairo_text_extents_t *extents);
 cairo_font_face_t *
cairo_scaled_font_get_font_face (cairo_scaled_font_t *scaled_font);
 void
cairo_scaled_font_get_font_matrix (cairo_scaled_font_t *scaled_font,
       cairo_matrix_t *font_matrix);
 void
cairo_scaled_font_get_ctm (cairo_scaled_font_t *scaled_font,
      cairo_matrix_t *ctm);
 void
cairo_scaled_font_get_font_options (cairo_scaled_font_t *scaled_font,
        cairo_font_options_t *options);
 cairo_operator_t
cairo_get_operator (cairo_t *cr);
 cairo_pattern_t *
cairo_get_source (cairo_t *cr);
 double
cairo_get_tolerance (cairo_t *cr);
 cairo_antialias_t
cairo_get_antialias (cairo_t *cr);
 void
cairo_get_current_point (cairo_t *cr, double *x, double *y);
 cairo_fill_rule_t
cairo_get_fill_rule (cairo_t *cr);
 double
cairo_get_line_width (cairo_t *cr);
 cairo_line_cap_t
cairo_get_line_cap (cairo_t *cr);
 cairo_line_join_t
cairo_get_line_join (cairo_t *cr);
 double
cairo_get_miter_limit (cairo_t *cr);
 int
cairo_get_dash_count (cairo_t *cr);
 void
cairo_get_dash (cairo_t *cr, double *dashes, double *offset);
 void
cairo_get_matrix (cairo_t *cr, cairo_matrix_t *matrix);
 cairo_surface_t *
cairo_get_target (cairo_t *cr);
 cairo_surface_t *
cairo_get_group_target (cairo_t *cr);
typedef enum _cairo_path_data_type {
    CAIRO_PATH_MOVE_TO,
    CAIRO_PATH_LINE_TO,
    CAIRO_PATH_CURVE_TO,
    CAIRO_PATH_CLOSE_PATH
} cairo_path_data_type_t;
typedef union _cairo_path_data_t cairo_path_data_t;
union _cairo_path_data_t {
    struct {
 cairo_path_data_type_t type;
 int length;
    } header;
    struct {
 double x, y;
    } point;
};
typedef struct cairo_path {
    cairo_status_t status;
    cairo_path_data_t *data;
    int num_data;
} cairo_path_t;
 cairo_path_t *
cairo_copy_path (cairo_t *cr);
 cairo_path_t *
cairo_copy_path_flat (cairo_t *cr);
 void
cairo_append_path (cairo_t *cr,
     const cairo_path_t *path);
 void
cairo_path_destroy (cairo_path_t *path);
 cairo_status_t
cairo_status (cairo_t *cr);
 const char *
cairo_status_to_string (cairo_status_t status);
 cairo_surface_t *
cairo_surface_create_similar (cairo_surface_t *other,
         cairo_content_t content,
         int width,
         int height);
 cairo_surface_t *
cairo_surface_reference (cairo_surface_t *surface);
 void
cairo_surface_finish (cairo_surface_t *surface);
 void
cairo_surface_destroy (cairo_surface_t *surface);
 unsigned int
cairo_surface_get_reference_count (cairo_surface_t *surface);
 cairo_status_t
cairo_surface_status (cairo_surface_t *surface);
typedef enum _cairo_surface_type {
    CAIRO_SURFACE_TYPE_IMAGE,
    CAIRO_SURFACE_TYPE_PDF,
    CAIRO_SURFACE_TYPE_PS,
    CAIRO_SURFACE_TYPE_XLIB,
    CAIRO_SURFACE_TYPE_XCB,
    CAIRO_SURFACE_TYPE_GLITZ,
    CAIRO_SURFACE_TYPE_QUARTZ,
    CAIRO_SURFACE_TYPE_WIN32,
    CAIRO_SURFACE_TYPE_BEOS,
    CAIRO_SURFACE_TYPE_DIRECTFB,
    CAIRO_SURFACE_TYPE_SVG,
    CAIRO_SURFACE_TYPE_OS2
} cairo_surface_type_t;
 cairo_surface_type_t
cairo_surface_get_type (cairo_surface_t *surface);
 cairo_content_t
cairo_surface_get_content (cairo_surface_t *surface);
 cairo_status_t
cairo_surface_write_to_png (cairo_surface_t *surface,
       const char *filename);
 cairo_status_t
cairo_surface_write_to_png_stream (cairo_surface_t *surface,
       cairo_write_func_t write_func,
       void *closure);
 void *
cairo_surface_get_user_data (cairo_surface_t *surface,
        const cairo_user_data_key_t *key);
 cairo_status_t
cairo_surface_set_user_data (cairo_surface_t *surface,
        const cairo_user_data_key_t *key,
        void *user_data,
        cairo_destroy_func_t destroy);
 void
cairo_surface_get_font_options (cairo_surface_t *surface,
    cairo_font_options_t *options);
 void
cairo_surface_flush (cairo_surface_t *surface);
 void
cairo_surface_mark_dirty (cairo_surface_t *surface);
 void
cairo_surface_mark_dirty_rectangle (cairo_surface_t *surface,
        int x,
        int y,
        int width,
        int height);
 void
cairo_surface_set_device_offset (cairo_surface_t *surface,
     double x_offset,
     double y_offset);
 void
cairo_surface_get_device_offset (cairo_surface_t *surface,
     double *x_offset,
     double *y_offset);
 void
cairo_surface_set_fallback_resolution (cairo_surface_t *surface,
           double x_pixels_per_inch,
           double y_pixels_per_inch);
typedef enum _cairo_format {
    CAIRO_FORMAT_ARGB32,
    CAIRO_FORMAT_RGB24,
    CAIRO_FORMAT_A8,
    CAIRO_FORMAT_A1
} cairo_format_t;
 cairo_surface_t *
cairo_image_surface_create (cairo_format_t format,
       int width,
       int height);
 cairo_surface_t *
cairo_image_surface_create_for_data (unsigned char *data,
         cairo_format_t format,
         int width,
         int height,
         int stride);
 unsigned char *
cairo_image_surface_get_data (cairo_surface_t *surface);
 cairo_format_t
cairo_image_surface_get_format (cairo_surface_t *surface);
 int
cairo_image_surface_get_width (cairo_surface_t *surface);
 int
cairo_image_surface_get_height (cairo_surface_t *surface);
 int
cairo_image_surface_get_stride (cairo_surface_t *surface);
 cairo_surface_t *
cairo_image_surface_create_from_png (const char *filename);
 cairo_surface_t *
cairo_image_surface_create_from_png_stream (cairo_read_func_t read_func,
         void *closure);
 cairo_pattern_t *
cairo_pattern_create_rgb (double red, double green, double blue);
 cairo_pattern_t *
cairo_pattern_create_rgba (double red, double green, double blue,
      double alpha);
 cairo_pattern_t *
cairo_pattern_create_for_surface (cairo_surface_t *surface);
 cairo_pattern_t *
cairo_pattern_create_linear (double x0, double y0,
        double x1, double y1);
 cairo_pattern_t *
cairo_pattern_create_radial (double cx0, double cy0, double radius0,
        double cx1, double cy1, double radius1);
 cairo_pattern_t *
cairo_pattern_reference (cairo_pattern_t *pattern);
 void
cairo_pattern_destroy (cairo_pattern_t *pattern);
 unsigned int
cairo_pattern_get_reference_count (cairo_pattern_t *pattern);
 cairo_status_t
cairo_pattern_status (cairo_pattern_t *pattern);
 void *
cairo_pattern_get_user_data (cairo_pattern_t *pattern,
        const cairo_user_data_key_t *key);
 cairo_status_t
cairo_pattern_set_user_data (cairo_pattern_t *pattern,
        const cairo_user_data_key_t *key,
        void *user_data,
        cairo_destroy_func_t destroy);
typedef enum _cairo_pattern_type {
    CAIRO_PATTERN_TYPE_SOLID,
    CAIRO_PATTERN_TYPE_SURFACE,
    CAIRO_PATTERN_TYPE_LINEAR,
    CAIRO_PATTERN_TYPE_RADIAL
} cairo_pattern_type_t;
 cairo_pattern_type_t
cairo_pattern_get_type (cairo_pattern_t *pattern);
 void
cairo_pattern_add_color_stop_rgb (cairo_pattern_t *pattern,
      double offset,
      double red, double green, double blue);
 void
cairo_pattern_add_color_stop_rgba (cairo_pattern_t *pattern,
       double offset,
       double red, double green, double blue,
       double alpha);
 void
cairo_pattern_set_matrix (cairo_pattern_t *pattern,
     const cairo_matrix_t *matrix);
 void
cairo_pattern_get_matrix (cairo_pattern_t *pattern,
     cairo_matrix_t *matrix);
typedef enum _cairo_extend {
    CAIRO_EXTEND_NONE,
    CAIRO_EXTEND_REPEAT,
    CAIRO_EXTEND_REFLECT,
    CAIRO_EXTEND_PAD
} cairo_extend_t;
 void
cairo_pattern_set_extend (cairo_pattern_t *pattern, cairo_extend_t extend);
 cairo_extend_t
cairo_pattern_get_extend (cairo_pattern_t *pattern);
typedef enum _cairo_filter {
    CAIRO_FILTER_FAST,
    CAIRO_FILTER_GOOD,
    CAIRO_FILTER_BEST,
    CAIRO_FILTER_NEAREST,
    CAIRO_FILTER_BILINEAR,
    CAIRO_FILTER_GAUSSIAN
} cairo_filter_t;
 void
cairo_pattern_set_filter (cairo_pattern_t *pattern, cairo_filter_t filter);
 cairo_filter_t
cairo_pattern_get_filter (cairo_pattern_t *pattern);
 cairo_status_t
cairo_pattern_get_rgba (cairo_pattern_t *pattern,
   double *red, double *green,
   double *blue, double *alpha);
 cairo_status_t
cairo_pattern_get_surface (cairo_pattern_t *pattern,
      cairo_surface_t **surface);
 cairo_status_t
cairo_pattern_get_color_stop_rgba (cairo_pattern_t *pattern,
       int index, double *offset,
       double *red, double *green,
       double *blue, double *alpha);
 cairo_status_t
cairo_pattern_get_color_stop_count (cairo_pattern_t *pattern,
        int *count);
 cairo_status_t
cairo_pattern_get_linear_points (cairo_pattern_t *pattern,
     double *x0, double *y0,
     double *x1, double *y1);
 cairo_status_t
cairo_pattern_get_radial_circles (cairo_pattern_t *pattern,
      double *x0, double *y0, double *r0,
      double *x1, double *y1, double *r1);
 void
cairo_matrix_init (cairo_matrix_t *matrix,
     double xx, double yx,
     double xy, double yy,
     double x0, double y0);
 void
cairo_matrix_init_identity (cairo_matrix_t *matrix);
 void
cairo_matrix_init_translate (cairo_matrix_t *matrix,
        double tx, double ty);
 void
cairo_matrix_init_scale (cairo_matrix_t *matrix,
    double sx, double sy);
 void
cairo_matrix_init_rotate (cairo_matrix_t *matrix,
     double radians);
 void
cairo_matrix_translate (cairo_matrix_t *matrix, double tx, double ty);
 void
cairo_matrix_scale (cairo_matrix_t *matrix, double sx, double sy);
 void
cairo_matrix_rotate (cairo_matrix_t *matrix, double radians);
 cairo_status_t
cairo_matrix_invert (cairo_matrix_t *matrix);
 void
cairo_matrix_multiply (cairo_matrix_t *result,
         const cairo_matrix_t *a,
         const cairo_matrix_t *b);
 void
cairo_matrix_transform_distance (const cairo_matrix_t *matrix,
     double *dx, double *dy);
 void
cairo_matrix_transform_point (const cairo_matrix_t *matrix,
         double *x, double *y);
 void
cairo_debug_reset_static_data (void);
}
extern "C" {
typedef struct _PangoCoverage PangoCoverage;
typedef enum {
  PANGO_COVERAGE_NONE,
  PANGO_COVERAGE_FALLBACK,
  PANGO_COVERAGE_APPROXIMATE,
  PANGO_COVERAGE_EXACT
} PangoCoverageLevel;
PangoCoverage * pango_coverage_new (void);
PangoCoverage * pango_coverage_ref (PangoCoverage *coverage);
void pango_coverage_unref (PangoCoverage *coverage);
PangoCoverage * pango_coverage_copy (PangoCoverage *coverage);
PangoCoverageLevel pango_coverage_get (PangoCoverage *coverage,
        int index_);
void pango_coverage_set (PangoCoverage *coverage,
        int index_,
        PangoCoverageLevel level);
void pango_coverage_max (PangoCoverage *coverage,
        PangoCoverage *other);
void pango_coverage_to_bytes (PangoCoverage *coverage,
       guchar **bytes,
       int *n_bytes);
PangoCoverage *pango_coverage_from_bytes (guchar *bytes,
       int n_bytes);
}
extern "C" {
typedef struct _PangoLogAttr PangoLogAttr;
typedef struct _PangoEngineLang PangoEngineLang;
typedef struct _PangoEngineShape PangoEngineShape;
typedef struct _PangoFont PangoFont;
typedef struct _PangoFontMap PangoFontMap;
typedef struct _PangoRectangle PangoRectangle;
typedef guint32 PangoGlyph;
int pango_units_from_double (double d) __attribute__((__const__));
double pango_units_to_double (int i) __attribute__((__const__));
struct _PangoRectangle
{
  int x;
  int y;
  int width;
  int height;
};
void pango_extents_to_pixels (PangoRectangle *ink_rect,
         PangoRectangle *logical_rect);
typedef enum {
  PANGO_DIRECTION_LTR,
  PANGO_DIRECTION_RTL,
  PANGO_DIRECTION_TTB_LTR,
  PANGO_DIRECTION_TTB_RTL,
  PANGO_DIRECTION_WEAK_LTR,
  PANGO_DIRECTION_WEAK_RTL,
  PANGO_DIRECTION_NEUTRAL
} PangoDirection;
PangoDirection pango_unichar_direction (gunichar ch) __attribute__((__const__));
PangoDirection pango_find_base_dir (const gchar *text,
          gint length);
gboolean pango_get_mirror_char (gunichar ch,
          gunichar *mirrored_ch);
extern "C" {
typedef enum {
  PANGO_GRAVITY_SOUTH,
  PANGO_GRAVITY_EAST,
  PANGO_GRAVITY_NORTH,
  PANGO_GRAVITY_WEST,
  PANGO_GRAVITY_AUTO
} PangoGravity;
typedef enum {
  PANGO_GRAVITY_HINT_NATURAL,
  PANGO_GRAVITY_HINT_STRONG,
  PANGO_GRAVITY_HINT_LINE
} PangoGravityHint;
extern "C" {
typedef struct _PangoMatrix PangoMatrix;
struct _PangoMatrix
{
  double xx;
  double xy;
  double yx;
  double yy;
  double x0;
  double y0;
};
GType pango_matrix_get_type (void) __attribute__((__const__));
PangoMatrix *pango_matrix_copy (const PangoMatrix *matrix);
void pango_matrix_free (PangoMatrix *matrix);
void pango_matrix_translate (PangoMatrix *matrix,
        double tx,
        double ty);
void pango_matrix_scale (PangoMatrix *matrix,
        double scale_x,
        double scale_y);
void pango_matrix_rotate (PangoMatrix *matrix,
        double degrees);
void pango_matrix_concat (PangoMatrix *matrix,
        const PangoMatrix *new_matrix);
void pango_matrix_transform_point (const PangoMatrix *matrix,
          double *x,
          double *y);
void pango_matrix_transform_distance (const PangoMatrix *matrix,
          double *dx,
          double *dy);
void pango_matrix_transform_rectangle (const PangoMatrix *matrix,
           PangoRectangle *rect);
void pango_matrix_transform_pixel_rectangle (const PangoMatrix *matrix,
          PangoRectangle *rect);
double pango_matrix_get_font_scale_factor (const PangoMatrix *matrix) __attribute__((__pure__));
}
extern "C" {
typedef struct _PangoLanguage PangoLanguage;
GType pango_language_get_type (void) __attribute__((__const__));
PangoLanguage *pango_language_from_string (const char *language);
const char *pango_language_get_sample_string (PangoLanguage *language) __attribute__((__const__));
PangoLanguage *pango_language_get_default (void) __attribute__((__const__));
gboolean pango_language_matches (PangoLanguage *language,
           const char *range_list) __attribute__((__pure__));
}
extern "C" {
typedef struct _PangoScriptIter PangoScriptIter;
typedef enum {
      PANGO_SCRIPT_INVALID_CODE = -1,
      PANGO_SCRIPT_COMMON = 0,
      PANGO_SCRIPT_INHERITED,
      PANGO_SCRIPT_ARABIC,
      PANGO_SCRIPT_ARMENIAN,
      PANGO_SCRIPT_BENGALI,
      PANGO_SCRIPT_BOPOMOFO,
      PANGO_SCRIPT_CHEROKEE,
      PANGO_SCRIPT_COPTIC,
      PANGO_SCRIPT_CYRILLIC,
      PANGO_SCRIPT_DESERET,
      PANGO_SCRIPT_DEVANAGARI,
      PANGO_SCRIPT_ETHIOPIC,
      PANGO_SCRIPT_GEORGIAN,
      PANGO_SCRIPT_GOTHIC,
      PANGO_SCRIPT_GREEK,
      PANGO_SCRIPT_GUJARATI,
      PANGO_SCRIPT_GURMUKHI,
      PANGO_SCRIPT_HAN,
      PANGO_SCRIPT_HANGUL,
      PANGO_SCRIPT_HEBREW,
      PANGO_SCRIPT_HIRAGANA,
      PANGO_SCRIPT_KANNADA,
      PANGO_SCRIPT_KATAKANA,
      PANGO_SCRIPT_KHMER,
      PANGO_SCRIPT_LAO,
      PANGO_SCRIPT_LATIN,
      PANGO_SCRIPT_MALAYALAM,
      PANGO_SCRIPT_MONGOLIAN,
      PANGO_SCRIPT_MYANMAR,
      PANGO_SCRIPT_OGHAM,
      PANGO_SCRIPT_OLD_ITALIC,
      PANGO_SCRIPT_ORIYA,
      PANGO_SCRIPT_RUNIC,
      PANGO_SCRIPT_SINHALA,
      PANGO_SCRIPT_SYRIAC,
      PANGO_SCRIPT_TAMIL,
      PANGO_SCRIPT_TELUGU,
      PANGO_SCRIPT_THAANA,
      PANGO_SCRIPT_THAI,
      PANGO_SCRIPT_TIBETAN,
      PANGO_SCRIPT_CANADIAN_ABORIGINAL,
      PANGO_SCRIPT_YI,
      PANGO_SCRIPT_TAGALOG,
      PANGO_SCRIPT_HANUNOO,
      PANGO_SCRIPT_BUHID,
      PANGO_SCRIPT_TAGBANWA,
      PANGO_SCRIPT_BRAILLE,
      PANGO_SCRIPT_CYPRIOT,
      PANGO_SCRIPT_LIMBU,
      PANGO_SCRIPT_OSMANYA,
      PANGO_SCRIPT_SHAVIAN,
      PANGO_SCRIPT_LINEAR_B,
      PANGO_SCRIPT_TAI_LE,
      PANGO_SCRIPT_UGARITIC,
      PANGO_SCRIPT_NEW_TAI_LUE,
      PANGO_SCRIPT_BUGINESE,
      PANGO_SCRIPT_GLAGOLITIC,
      PANGO_SCRIPT_TIFINAGH,
      PANGO_SCRIPT_SYLOTI_NAGRI,
      PANGO_SCRIPT_OLD_PERSIAN,
      PANGO_SCRIPT_KHAROSHTHI,
      PANGO_SCRIPT_UNKNOWN,
      PANGO_SCRIPT_BALINESE,
      PANGO_SCRIPT_CUNEIFORM,
      PANGO_SCRIPT_PHOENICIAN,
      PANGO_SCRIPT_PHAGS_PA,
      PANGO_SCRIPT_NKO
} PangoScript;
PangoScript pango_script_for_unichar (gunichar ch) __attribute__((__const__));
PangoScriptIter *pango_script_iter_new (const char *text,
           int length);
void pango_script_iter_get_range (PangoScriptIter *iter,
           const char **start,
           const char **end,
           PangoScript *script);
gboolean pango_script_iter_next (PangoScriptIter *iter);
void pango_script_iter_free (PangoScriptIter *iter);
PangoLanguage *pango_script_get_sample_language (PangoScript script) __attribute__((__pure__));
gboolean pango_language_includes_script (PangoLanguage *language,
       PangoScript script) __attribute__((__pure__));
}
double pango_gravity_to_rotation (PangoGravity gravity) __attribute__((__const__));
PangoGravity pango_gravity_get_for_matrix (const PangoMatrix *matrix) __attribute__((__pure__));
PangoGravity pango_gravity_get_for_script (PangoScript script,
        PangoGravity base_gravity,
        PangoGravityHint hint) __attribute__((__const__));
}
}
extern "C" {
typedef struct _PangoFontDescription PangoFontDescription;
typedef struct _PangoFontMetrics PangoFontMetrics;
typedef enum {
  PANGO_STYLE_NORMAL,
  PANGO_STYLE_OBLIQUE,
  PANGO_STYLE_ITALIC
} PangoStyle;
typedef enum {
  PANGO_VARIANT_NORMAL,
  PANGO_VARIANT_SMALL_CAPS
} PangoVariant;
typedef enum {
  PANGO_WEIGHT_ULTRALIGHT = 200,
  PANGO_WEIGHT_LIGHT = 300,
  PANGO_WEIGHT_NORMAL = 400,
  PANGO_WEIGHT_SEMIBOLD = 600,
  PANGO_WEIGHT_BOLD = 700,
  PANGO_WEIGHT_ULTRABOLD = 800,
  PANGO_WEIGHT_HEAVY = 900
} PangoWeight;
typedef enum {
  PANGO_STRETCH_ULTRA_CONDENSED,
  PANGO_STRETCH_EXTRA_CONDENSED,
  PANGO_STRETCH_CONDENSED,
  PANGO_STRETCH_SEMI_CONDENSED,
  PANGO_STRETCH_NORMAL,
  PANGO_STRETCH_SEMI_EXPANDED,
  PANGO_STRETCH_EXPANDED,
  PANGO_STRETCH_EXTRA_EXPANDED,
  PANGO_STRETCH_ULTRA_EXPANDED
} PangoStretch;
typedef enum {
  PANGO_FONT_MASK_FAMILY = 1 << 0,
  PANGO_FONT_MASK_STYLE = 1 << 1,
  PANGO_FONT_MASK_VARIANT = 1 << 2,
  PANGO_FONT_MASK_WEIGHT = 1 << 3,
  PANGO_FONT_MASK_STRETCH = 1 << 4,
  PANGO_FONT_MASK_SIZE = 1 << 5,
  PANGO_FONT_MASK_GRAVITY = 1 << 6
} PangoFontMask;
GType pango_font_description_get_type (void) __attribute__((__const__));
PangoFontDescription *pango_font_description_new (void);
PangoFontDescription *pango_font_description_copy (const PangoFontDescription *desc);
PangoFontDescription *pango_font_description_copy_static (const PangoFontDescription *desc);
guint pango_font_description_hash (const PangoFontDescription *desc) __attribute__((__pure__));
gboolean pango_font_description_equal (const PangoFontDescription *desc1,
         const PangoFontDescription *desc2) __attribute__((__pure__));
void pango_font_description_free (PangoFontDescription *desc);
void pango_font_descriptions_free (PangoFontDescription **descs,
         int n_descs);
void pango_font_description_set_family (PangoFontDescription *desc,
              const char *family);
void pango_font_description_set_family_static (PangoFontDescription *desc,
              const char *family);
const char *pango_font_description_get_family (const PangoFontDescription *desc) __attribute__((__pure__));
void pango_font_description_set_style (PangoFontDescription *desc,
              PangoStyle style);
PangoStyle pango_font_description_get_style (const PangoFontDescription *desc) __attribute__((__pure__));
void pango_font_description_set_variant (PangoFontDescription *desc,
              PangoVariant variant);
PangoVariant pango_font_description_get_variant (const PangoFontDescription *desc) __attribute__((__pure__));
void pango_font_description_set_weight (PangoFontDescription *desc,
              PangoWeight weight);
PangoWeight pango_font_description_get_weight (const PangoFontDescription *desc) __attribute__((__pure__));
void pango_font_description_set_stretch (PangoFontDescription *desc,
              PangoStretch stretch);
PangoStretch pango_font_description_get_stretch (const PangoFontDescription *desc) __attribute__((__pure__));
void pango_font_description_set_size (PangoFontDescription *desc,
              gint size);
gint pango_font_description_get_size (const PangoFontDescription *desc) __attribute__((__pure__));
void pango_font_description_set_absolute_size (PangoFontDescription *desc,
              double size);
gboolean pango_font_description_get_size_is_absolute (const PangoFontDescription *desc) __attribute__((__pure__));
void pango_font_description_set_gravity (PangoFontDescription *desc,
              PangoGravity gravity);
PangoGravity pango_font_description_get_gravity (const PangoFontDescription *desc) __attribute__((__pure__));
PangoFontMask pango_font_description_get_set_fields (const PangoFontDescription *desc) __attribute__((__pure__));
void pango_font_description_unset_fields (PangoFontDescription *desc,
           PangoFontMask to_unset);
void pango_font_description_merge (PangoFontDescription *desc,
       const PangoFontDescription *desc_to_merge,
       gboolean replace_existing);
void pango_font_description_merge_static (PangoFontDescription *desc,
       const PangoFontDescription *desc_to_merge,
       gboolean replace_existing);
gboolean pango_font_description_better_match (const PangoFontDescription *desc,
           const PangoFontDescription *old_match,
           const PangoFontDescription *new_match) __attribute__((__pure__));
PangoFontDescription *pango_font_description_from_string (const char *str);
char * pango_font_description_to_string (const PangoFontDescription *desc);
char * pango_font_description_to_filename (const PangoFontDescription *desc);
GType pango_font_metrics_get_type (void) __attribute__((__const__));
PangoFontMetrics *pango_font_metrics_ref (PangoFontMetrics *metrics);
void pango_font_metrics_unref (PangoFontMetrics *metrics);
int pango_font_metrics_get_ascent (PangoFontMetrics *metrics) __attribute__((__pure__));
int pango_font_metrics_get_descent (PangoFontMetrics *metrics) __attribute__((__pure__));
int pango_font_metrics_get_approximate_char_width (PangoFontMetrics *metrics) __attribute__((__pure__));
int pango_font_metrics_get_approximate_digit_width (PangoFontMetrics *metrics) __attribute__((__pure__));
int pango_font_metrics_get_underline_position (PangoFontMetrics *metrics) __attribute__((__pure__));
int pango_font_metrics_get_underline_thickness (PangoFontMetrics *metrics) __attribute__((__pure__));
int pango_font_metrics_get_strikethrough_position (PangoFontMetrics *metrics) __attribute__((__pure__));
int pango_font_metrics_get_strikethrough_thickness (PangoFontMetrics *metrics) __attribute__((__pure__));
typedef struct _PangoFontFamily PangoFontFamily;
typedef struct _PangoFontFace PangoFontFace;
GType pango_font_family_get_type (void) __attribute__((__const__));
void pango_font_family_list_faces (PangoFontFamily *family,
         PangoFontFace ***faces,
         int *n_faces);
const char *pango_font_family_get_name (PangoFontFamily *family) __attribute__((__pure__));
gboolean pango_font_family_is_monospace (PangoFontFamily *family) __attribute__((__pure__));
GType pango_font_face_get_type (void) __attribute__((__const__));
PangoFontDescription *pango_font_face_describe (PangoFontFace *face);
const char *pango_font_face_get_face_name (PangoFontFace *face) __attribute__((__pure__));
void pango_font_face_list_sizes (PangoFontFace *face,
            int **sizes,
            int *n_sizes);
gboolean pango_font_face_is_synthesized (PangoFontFace *face) __attribute__((__pure__));
GType pango_font_get_type (void) __attribute__((__const__));
PangoFontDescription *pango_font_describe (PangoFont *font);
PangoFontDescription *pango_font_describe_with_absolute_size (PangoFont *font);
PangoCoverage * pango_font_get_coverage (PangoFont *font,
          PangoLanguage *language);
PangoEngineShape * pango_font_find_shaper (PangoFont *font,
          PangoLanguage *language,
          guint32 ch);
PangoFontMetrics * pango_font_get_metrics (PangoFont *font,
          PangoLanguage *language);
void pango_font_get_glyph_extents (PangoFont *font,
          PangoGlyph glyph,
          PangoRectangle *ink_rect,
          PangoRectangle *logical_rect);
PangoFontMap *pango_font_get_font_map (PangoFont *font);
}
extern "C" {
typedef struct _PangoColor PangoColor;
struct _PangoColor
{
  guint16 red;
  guint16 green;
  guint16 blue;
};
GType pango_color_get_type (void) __attribute__((__const__));
PangoColor *pango_color_copy (const PangoColor *src);
void pango_color_free (PangoColor *color);
gboolean pango_color_parse (PangoColor *color,
      const char *spec);
gchar *pango_color_to_string(const PangoColor *color);
typedef struct _PangoAttribute PangoAttribute;
typedef struct _PangoAttrClass PangoAttrClass;
typedef struct _PangoAttrString PangoAttrString;
typedef struct _PangoAttrLanguage PangoAttrLanguage;
typedef struct _PangoAttrInt PangoAttrInt;
typedef struct _PangoAttrSize PangoAttrSize;
typedef struct _PangoAttrFloat PangoAttrFloat;
typedef struct _PangoAttrColor PangoAttrColor;
typedef struct _PangoAttrFontDesc PangoAttrFontDesc;
typedef struct _PangoAttrShape PangoAttrShape;
typedef struct _PangoAttrList PangoAttrList;
typedef struct _PangoAttrIterator PangoAttrIterator;
typedef enum
{
  PANGO_ATTR_INVALID,
  PANGO_ATTR_LANGUAGE,
  PANGO_ATTR_FAMILY,
  PANGO_ATTR_STYLE,
  PANGO_ATTR_WEIGHT,
  PANGO_ATTR_VARIANT,
  PANGO_ATTR_STRETCH,
  PANGO_ATTR_SIZE,
  PANGO_ATTR_FONT_DESC,
  PANGO_ATTR_FOREGROUND,
  PANGO_ATTR_BACKGROUND,
  PANGO_ATTR_UNDERLINE,
  PANGO_ATTR_STRIKETHROUGH,
  PANGO_ATTR_RISE,
  PANGO_ATTR_SHAPE,
  PANGO_ATTR_SCALE,
  PANGO_ATTR_FALLBACK,
  PANGO_ATTR_LETTER_SPACING,
  PANGO_ATTR_UNDERLINE_COLOR,
  PANGO_ATTR_STRIKETHROUGH_COLOR,
  PANGO_ATTR_ABSOLUTE_SIZE,
  PANGO_ATTR_GRAVITY,
  PANGO_ATTR_GRAVITY_HINT
} PangoAttrType;
typedef enum {
  PANGO_UNDERLINE_NONE,
  PANGO_UNDERLINE_SINGLE,
  PANGO_UNDERLINE_DOUBLE,
  PANGO_UNDERLINE_LOW,
  PANGO_UNDERLINE_ERROR
} PangoUnderline;
struct _PangoAttribute
{
  const PangoAttrClass *klass;
  guint start_index;
  guint end_index;
};
typedef gboolean (*PangoAttrFilterFunc) (PangoAttribute *attribute,
      gpointer data);
typedef gpointer (*PangoAttrDataCopyFunc) (gconstpointer data);
struct _PangoAttrClass
{
  PangoAttrType type;
  PangoAttribute * (*copy) (const PangoAttribute *attr);
  void (*destroy) (PangoAttribute *attr);
  gboolean (*equal) (const PangoAttribute *attr1, const PangoAttribute *attr2);
};
struct _PangoAttrString
{
  PangoAttribute attr;
  char *value;
};
struct _PangoAttrLanguage
{
  PangoAttribute attr;
  PangoLanguage *value;
};
struct _PangoAttrInt
{
  PangoAttribute attr;
  int value;
};
struct _PangoAttrFloat
{
  PangoAttribute attr;
  double value;
};
struct _PangoAttrColor
{
  PangoAttribute attr;
  PangoColor color;
};
struct _PangoAttrSize
{
  PangoAttribute attr;
  int size;
  guint absolute : 1;
};
struct _PangoAttrShape
{
  PangoAttribute attr;
  PangoRectangle ink_rect;
  PangoRectangle logical_rect;
  gpointer data;
  PangoAttrDataCopyFunc copy_func;
  GDestroyNotify destroy_func;
};
struct _PangoAttrFontDesc
{
  PangoAttribute attr;
  PangoFontDescription *desc;
};
PangoAttrType pango_attr_type_register (const gchar *name);
PangoAttribute * pango_attribute_copy (const PangoAttribute *attr);
void pango_attribute_destroy (PangoAttribute *attr);
gboolean pango_attribute_equal (const PangoAttribute *attr1,
      const PangoAttribute *attr2) __attribute__((__pure__));
PangoAttribute *pango_attr_language_new (PangoLanguage *language);
PangoAttribute *pango_attr_family_new (const char *family);
PangoAttribute *pango_attr_foreground_new (guint16 red,
           guint16 green,
           guint16 blue);
PangoAttribute *pango_attr_background_new (guint16 red,
           guint16 green,
           guint16 blue);
PangoAttribute *pango_attr_size_new (int size);
PangoAttribute *pango_attr_size_new_absolute (int size);
PangoAttribute *pango_attr_style_new (PangoStyle style);
PangoAttribute *pango_attr_weight_new (PangoWeight weight);
PangoAttribute *pango_attr_variant_new (PangoVariant variant);
PangoAttribute *pango_attr_stretch_new (PangoStretch stretch);
PangoAttribute *pango_attr_font_desc_new (const PangoFontDescription *desc);
PangoAttribute *pango_attr_underline_new (PangoUnderline underline);
PangoAttribute *pango_attr_underline_color_new (guint16 red,
          guint16 green,
          guint16 blue);
PangoAttribute *pango_attr_strikethrough_new (gboolean strikethrough);
PangoAttribute *pango_attr_strikethrough_color_new (guint16 red,
          guint16 green,
          guint16 blue);
PangoAttribute *pango_attr_rise_new (int rise);
PangoAttribute *pango_attr_scale_new (double scale_factor);
PangoAttribute *pango_attr_fallback_new (gboolean enable_fallback);
PangoAttribute *pango_attr_letter_spacing_new (int letter_spacing);
PangoAttribute *pango_attr_shape_new (const PangoRectangle *ink_rect,
      const PangoRectangle *logical_rect);
PangoAttribute *pango_attr_shape_new_with_data (const PangoRectangle *ink_rect,
      const PangoRectangle *logical_rect,
      gpointer data,
      PangoAttrDataCopyFunc copy_func,
      GDestroyNotify destroy_func);
PangoAttribute *pango_attr_gravity_new (PangoGravity gravity);
PangoAttribute *pango_attr_gravity_hint_new (PangoGravityHint hint);
GType pango_attr_list_get_type (void) __attribute__((__const__));
PangoAttrList * pango_attr_list_new (void);
PangoAttrList * pango_attr_list_ref (PangoAttrList *list);
void pango_attr_list_unref (PangoAttrList *list);
PangoAttrList * pango_attr_list_copy (PangoAttrList *list);
void pango_attr_list_insert (PangoAttrList *list,
        PangoAttribute *attr);
void pango_attr_list_insert_before (PangoAttrList *list,
        PangoAttribute *attr);
void pango_attr_list_change (PangoAttrList *list,
        PangoAttribute *attr);
void pango_attr_list_splice (PangoAttrList *list,
        PangoAttrList *other,
        gint pos,
        gint len);
PangoAttrList *pango_attr_list_filter (PangoAttrList *list,
           PangoAttrFilterFunc func,
           gpointer data);
PangoAttrIterator *pango_attr_list_get_iterator (PangoAttrList *list);
void pango_attr_iterator_range (PangoAttrIterator *iterator,
       gint *start,
       gint *end);
gboolean pango_attr_iterator_next (PangoAttrIterator *iterator);
PangoAttrIterator *pango_attr_iterator_copy (PangoAttrIterator *iterator);
void pango_attr_iterator_destroy (PangoAttrIterator *iterator);
PangoAttribute * pango_attr_iterator_get (PangoAttrIterator *iterator,
       PangoAttrType type);
void pango_attr_iterator_get_font (PangoAttrIterator *iterator,
       PangoFontDescription *desc,
       PangoLanguage **language,
       GSList **extra_attrs);
GSList * pango_attr_iterator_get_attrs (PangoAttrIterator *iterator);
gboolean pango_parse_markup (const char *markup_text,
        int length,
        gunichar accel_marker,
        PangoAttrList **attr_list,
        char **text,
        gunichar *accel_char,
        GError **error);
}
extern "C" {
extern "C" {
typedef struct _PangoAnalysis PangoAnalysis;
typedef struct _PangoItem PangoItem;
struct _PangoAnalysis
{
  PangoEngineShape *shape_engine;
  PangoEngineLang *lang_engine;
  PangoFont *font;
  guint8 level;
  guint8 gravity;
  guint8 flags;
  guint8 script;
  PangoLanguage *language;
  GSList *extra_attrs;
};
struct _PangoItem
{
  gint offset;
  gint length;
  gint num_chars;
  PangoAnalysis analysis;
};
GType pango_item_get_type (void) __attribute__((__const__));
PangoItem *pango_item_new (void);
PangoItem *pango_item_copy (PangoItem *item);
void pango_item_free (PangoItem *item);
PangoItem *pango_item_split (PangoItem *orig,
        int split_index,
        int split_offset);
}
struct _PangoLogAttr
{
  guint is_line_break : 1;
  guint is_mandatory_break : 1;
  guint is_char_break : 1;
  guint is_white : 1;
  guint is_cursor_position : 1;
  guint is_word_start : 1;
  guint is_word_end : 1;
  guint is_sentence_boundary : 1;
  guint is_sentence_start : 1;
  guint is_sentence_end : 1;
  guint backspace_deletes_character : 1;
  guint is_expandable_space : 1;
};
void pango_break (const gchar *text,
    int length,
    PangoAnalysis *analysis,
    PangoLogAttr *attrs,
    int attrs_len);
void pango_find_paragraph_boundary (const gchar *text,
        gint length,
        gint *paragraph_delimiter_index,
        gint *next_paragraph_start);
void pango_get_log_attrs (const char *text,
     int length,
     int level,
     PangoLanguage *language,
     PangoLogAttr *log_attrs,
     int attrs_len);
}
extern "C" {
GType pango_fontset_get_type (void) __attribute__((__const__));
typedef struct _PangoFontset PangoFontset;
typedef gboolean (*PangoFontsetForeachFunc) (PangoFontset *fontset,
          PangoFont *font,
          gpointer data);
PangoFont * pango_fontset_get_font (PangoFontset *fontset,
          guint wc);
PangoFontMetrics *pango_fontset_get_metrics (PangoFontset *fontset);
void pango_fontset_foreach (PangoFontset *fontset,
          PangoFontsetForeachFunc func,
          gpointer data);
}
extern "C" {
typedef struct _PangoContext PangoContext;
GType pango_font_map_get_type (void) __attribute__((__const__));
PangoFont * pango_font_map_load_font (PangoFontMap *fontmap,
         PangoContext *context,
         const PangoFontDescription *desc);
PangoFontset *pango_font_map_load_fontset (PangoFontMap *fontmap,
         PangoContext *context,
         const PangoFontDescription *desc,
         PangoLanguage *language);
void pango_font_map_list_families (PangoFontMap *fontmap,
         PangoFontFamily ***families,
         int *n_families);
}
extern "C" {
typedef struct _PangoContextClass PangoContextClass;
GType pango_context_get_type (void) __attribute__((__const__));
PangoFontMap *pango_context_get_font_map (PangoContext *context);
void pango_context_list_families (PangoContext *context,
        PangoFontFamily ***families,
        int *n_families);
PangoFont * pango_context_load_font (PangoContext *context,
        const PangoFontDescription *desc);
PangoFontset *pango_context_load_fontset (PangoContext *context,
        const PangoFontDescription *desc,
        PangoLanguage *language);
PangoFontMetrics *pango_context_get_metrics (PangoContext *context,
            const PangoFontDescription *desc,
            PangoLanguage *language);
void pango_context_set_font_description (PangoContext *context,
             const PangoFontDescription *desc);
PangoFontDescription * pango_context_get_font_description (PangoContext *context);
PangoLanguage *pango_context_get_language (PangoContext *context);
void pango_context_set_language (PangoContext *context,
             PangoLanguage *language);
void pango_context_set_base_dir (PangoContext *context,
             PangoDirection direction);
PangoDirection pango_context_get_base_dir (PangoContext *context);
void pango_context_set_base_gravity (PangoContext *context,
             PangoGravity gravity);
PangoGravity pango_context_get_base_gravity (PangoContext *context);
PangoGravity pango_context_get_gravity (PangoContext *context);
void pango_context_set_gravity_hint (PangoContext *context,
             PangoGravityHint hint);
PangoGravityHint pango_context_get_gravity_hint (PangoContext *context);
void pango_context_set_matrix (PangoContext *context,
            const PangoMatrix *matrix);
const PangoMatrix *pango_context_get_matrix (PangoContext *context);
GList *pango_itemize (PangoContext *context,
         const char *text,
         int start_index,
         int length,
         PangoAttrList *attrs,
         PangoAttrIterator *cached_iter);
GList *pango_itemize_with_base_dir (PangoContext *context,
         PangoDirection base_dir,
         const char *text,
         int start_index,
         int length,
         PangoAttrList *attrs,
         PangoAttrIterator *cached_iter);
}
extern "C" {
typedef struct _PangoGlyphGeometry PangoGlyphGeometry;
typedef struct _PangoGlyphVisAttr PangoGlyphVisAttr;
typedef struct _PangoGlyphInfo PangoGlyphInfo;
typedef struct _PangoGlyphString PangoGlyphString;
typedef gint32 PangoGlyphUnit;
struct _PangoGlyphGeometry
{
  PangoGlyphUnit width;
  PangoGlyphUnit x_offset;
  PangoGlyphUnit y_offset;
};
struct _PangoGlyphVisAttr
{
  guint is_cluster_start : 1;
};
struct _PangoGlyphInfo
{
  PangoGlyph glyph;
  PangoGlyphGeometry geometry;
  PangoGlyphVisAttr attr;
};
struct _PangoGlyphString {
  gint num_glyphs;
  PangoGlyphInfo *glyphs;
  gint *log_clusters;
  gint space;
};
PangoGlyphString *pango_glyph_string_new (void);
void pango_glyph_string_set_size (PangoGlyphString *string,
            gint new_len);
GType pango_glyph_string_get_type (void) __attribute__((__const__));
PangoGlyphString *pango_glyph_string_copy (PangoGlyphString *string);
void pango_glyph_string_free (PangoGlyphString *string);
void pango_glyph_string_extents (PangoGlyphString *glyphs,
            PangoFont *font,
            PangoRectangle *ink_rect,
            PangoRectangle *logical_rect);
int pango_glyph_string_get_width(PangoGlyphString *glyphs) __attribute__((__pure__));
void pango_glyph_string_extents_range (PangoGlyphString *glyphs,
           int start,
           int end,
           PangoFont *font,
           PangoRectangle *ink_rect,
           PangoRectangle *logical_rect);
void pango_glyph_string_get_logical_widths (PangoGlyphString *glyphs,
         const char *text,
         int length,
         int embedding_level,
         int *logical_widths);
void pango_glyph_string_index_to_x (PangoGlyphString *glyphs,
        char *text,
        int length,
        PangoAnalysis *analysis,
        int index_,
        gboolean trailing,
        int *x_pos);
void pango_glyph_string_x_to_index (PangoGlyphString *glyphs,
        char *text,
        int length,
        PangoAnalysis *analysis,
        int x_pos,
        int *index_,
        int *trailing);
void pango_shape (const gchar *text,
    gint length,
    const PangoAnalysis *analysis,
    PangoGlyphString *glyphs);
GList *pango_reorder_items (GList *logical_items);
}
extern "C" {
}
extern "C" {
GType pango_attr_type_get_type (void);
GType pango_underline_get_type (void);
GType pango_coverage_level_get_type (void);
GType pango_style_get_type (void);
GType pango_variant_get_type (void);
GType pango_weight_get_type (void);
GType pango_stretch_get_type (void);
GType pango_font_mask_get_type (void);
GType pango_gravity_get_type (void);
GType pango_gravity_hint_get_type (void);
GType pango_alignment_get_type (void);
GType pango_wrap_mode_get_type (void);
GType pango_ellipsize_mode_get_type (void);
GType pango_render_part_get_type (void);
GType pango_script_get_type (void);
GType pango_tab_align_get_type (void);
GType pango_direction_get_type (void);
}
extern "C" {
typedef struct _PangoGlyphItem PangoGlyphItem;
struct _PangoGlyphItem
{
  PangoItem *item;
  PangoGlyphString *glyphs;
};
PangoGlyphItem *pango_glyph_item_split (PangoGlyphItem *orig,
            const char *text,
            int split_index);
void pango_glyph_item_free (PangoGlyphItem *glyph_item);
GSList * pango_glyph_item_apply_attrs (PangoGlyphItem *glyph_item,
            const char *text,
            PangoAttrList *list);
void pango_glyph_item_letter_space (PangoGlyphItem *glyph_item,
            const char *text,
            PangoLogAttr *log_attrs,
            int letter_spacing);
}
extern "C" {
typedef struct _PangoTabArray PangoTabArray;
typedef enum
{
  PANGO_TAB_LEFT
} PangoTabAlign;
PangoTabArray *pango_tab_array_new (gint initial_size,
           gboolean positions_in_pixels);
PangoTabArray *pango_tab_array_new_with_positions (gint size,
           gboolean positions_in_pixels,
           PangoTabAlign first_alignment,
           gint first_position,
           ...);
GType pango_tab_array_get_type (void) __attribute__((__const__));
PangoTabArray *pango_tab_array_copy (PangoTabArray *src);
void pango_tab_array_free (PangoTabArray *tab_array);
gint pango_tab_array_get_size (PangoTabArray *tab_array);
void pango_tab_array_resize (PangoTabArray *tab_array,
           gint new_size);
void pango_tab_array_set_tab (PangoTabArray *tab_array,
           gint tab_index,
           PangoTabAlign alignment,
           gint location);
void pango_tab_array_get_tab (PangoTabArray *tab_array,
           gint tab_index,
           PangoTabAlign *alignment,
           gint *location);
void pango_tab_array_get_tabs (PangoTabArray *tab_array,
           PangoTabAlign **alignments,
           gint **locations);
gboolean pango_tab_array_get_positions_in_pixels (PangoTabArray *tab_array);
}
extern "C" {
typedef struct _PangoLayout PangoLayout;
typedef struct _PangoLayoutClass PangoLayoutClass;
typedef struct _PangoLayoutLine PangoLayoutLine;
typedef PangoGlyphItem PangoLayoutRun;
typedef enum {
  PANGO_ALIGN_LEFT,
  PANGO_ALIGN_CENTER,
  PANGO_ALIGN_RIGHT
} PangoAlignment;
typedef enum {
  PANGO_WRAP_WORD,
  PANGO_WRAP_CHAR,
  PANGO_WRAP_WORD_CHAR
} PangoWrapMode;
typedef enum {
  PANGO_ELLIPSIZE_NONE,
  PANGO_ELLIPSIZE_START,
  PANGO_ELLIPSIZE_MIDDLE,
  PANGO_ELLIPSIZE_END
} PangoEllipsizeMode;
struct _PangoLayoutLine
{
  PangoLayout *layout;
  gint start_index;
  gint length;
  GSList *runs;
  guint is_paragraph_start : 1;
  guint resolved_dir : 3;
};
GType pango_layout_get_type (void) __attribute__((__const__));
PangoLayout *pango_layout_new (PangoContext *context);
PangoLayout *pango_layout_copy (PangoLayout *src);
PangoContext *pango_layout_get_context (PangoLayout *layout);
void pango_layout_set_attributes (PangoLayout *layout,
         PangoAttrList *attrs);
PangoAttrList *pango_layout_get_attributes (PangoLayout *layout);
void pango_layout_set_text (PangoLayout *layout,
         const char *text,
         int length);
const char *pango_layout_get_text (PangoLayout *layout);
void pango_layout_set_markup (PangoLayout *layout,
         const char *markup,
         int length);
void pango_layout_set_markup_with_accel (PangoLayout *layout,
         const char *markup,
         int length,
         gunichar accel_marker,
         gunichar *accel_char);
void pango_layout_set_font_description (PangoLayout *layout,
        const PangoFontDescription *desc);
const PangoFontDescription *pango_layout_get_font_description (PangoLayout *layout);
void pango_layout_set_width (PangoLayout *layout,
        int width);
int pango_layout_get_width (PangoLayout *layout);
void pango_layout_set_wrap (PangoLayout *layout,
        PangoWrapMode wrap);
PangoWrapMode pango_layout_get_wrap (PangoLayout *layout);
gboolean pango_layout_is_wrapped (PangoLayout *layout);
void pango_layout_set_indent (PangoLayout *layout,
        int indent);
int pango_layout_get_indent (PangoLayout *layout);
void pango_layout_set_spacing (PangoLayout *layout,
        int spacing);
int pango_layout_get_spacing (PangoLayout *layout);
void pango_layout_set_justify (PangoLayout *layout,
        gboolean justify);
gboolean pango_layout_get_justify (PangoLayout *layout);
void pango_layout_set_auto_dir (PangoLayout *layout,
        gboolean auto_dir);
gboolean pango_layout_get_auto_dir (PangoLayout *layout);
void pango_layout_set_alignment (PangoLayout *layout,
        PangoAlignment alignment);
PangoAlignment pango_layout_get_alignment (PangoLayout *layout);
void pango_layout_set_tabs (PangoLayout *layout,
        PangoTabArray *tabs);
PangoTabArray* pango_layout_get_tabs (PangoLayout *layout);
void pango_layout_set_single_paragraph_mode (PangoLayout *layout,
             gboolean setting);
gboolean pango_layout_get_single_paragraph_mode (PangoLayout *layout);
void pango_layout_set_ellipsize (PangoLayout *layout,
            PangoEllipsizeMode ellipsize);
PangoEllipsizeMode pango_layout_get_ellipsize (PangoLayout *layout);
gboolean pango_layout_is_ellipsized (PangoLayout *layout);
int pango_layout_get_unknown_glyphs_count (PangoLayout *layout);
void pango_layout_context_changed (PangoLayout *layout);
void pango_layout_get_log_attrs (PangoLayout *layout,
         PangoLogAttr **attrs,
         gint *n_attrs);
void pango_layout_index_to_pos (PangoLayout *layout,
         int index_,
         PangoRectangle *pos);
void pango_layout_index_to_line_x (PangoLayout *layout,
         int index_,
         gboolean trailing,
         int *line,
         int *x_pos);
void pango_layout_get_cursor_pos (PangoLayout *layout,
         int index_,
         PangoRectangle *strong_pos,
         PangoRectangle *weak_pos);
void pango_layout_move_cursor_visually (PangoLayout *layout,
         gboolean strong,
         int old_index,
         int old_trailing,
         int direction,
         int *new_index,
         int *new_trailing);
gboolean pango_layout_xy_to_index (PangoLayout *layout,
         int x,
         int y,
         int *index_,
         int *trailing);
void pango_layout_get_extents (PangoLayout *layout,
         PangoRectangle *ink_rect,
         PangoRectangle *logical_rect);
void pango_layout_get_pixel_extents (PangoLayout *layout,
         PangoRectangle *ink_rect,
         PangoRectangle *logical_rect);
void pango_layout_get_size (PangoLayout *layout,
         int *width,
         int *height);
void pango_layout_get_pixel_size (PangoLayout *layout,
         int *width,
         int *height);
int pango_layout_get_line_count (PangoLayout *layout);
PangoLayoutLine *pango_layout_get_line (PangoLayout *layout,
          int line);
PangoLayoutLine *pango_layout_get_line_readonly (PangoLayout *layout,
          int line);
GSList * pango_layout_get_lines (PangoLayout *layout);
GSList * pango_layout_get_lines_readonly (PangoLayout *layout);
GType pango_layout_line_get_type (void) __attribute__((__const__));
PangoLayoutLine *pango_layout_line_ref (PangoLayoutLine *line);
void pango_layout_line_unref (PangoLayoutLine *line);
gboolean pango_layout_line_x_to_index (PangoLayoutLine *line,
      int x_pos,
      int *index_,
      int *trailing);
void pango_layout_line_index_to_x (PangoLayoutLine *line,
      int index_,
      gboolean trailing,
      int *x_pos);
void pango_layout_line_get_x_ranges (PangoLayoutLine *line,
      int start_index,
      int end_index,
      int **ranges,
      int *n_ranges);
void pango_layout_line_get_extents (PangoLayoutLine *line,
      PangoRectangle *ink_rect,
      PangoRectangle *logical_rect);
void pango_layout_line_get_pixel_extents (PangoLayoutLine *layout_line,
           PangoRectangle *ink_rect,
           PangoRectangle *logical_rect);
typedef struct _PangoLayoutIter PangoLayoutIter;
GType pango_layout_iter_get_type (void) __attribute__((__const__));
PangoLayoutIter *pango_layout_get_iter (PangoLayout *layout);
void pango_layout_iter_free (PangoLayoutIter *iter);
int pango_layout_iter_get_index (PangoLayoutIter *iter);
PangoLayoutRun *pango_layout_iter_get_run (PangoLayoutIter *iter);
PangoLayoutRun *pango_layout_iter_get_run_readonly (PangoLayoutIter *iter);
PangoLayoutLine *pango_layout_iter_get_line (PangoLayoutIter *iter);
PangoLayoutLine *pango_layout_iter_get_line_readonly (PangoLayoutIter *iter);
gboolean pango_layout_iter_at_last_line (PangoLayoutIter *iter);
gboolean pango_layout_iter_next_char (PangoLayoutIter *iter);
gboolean pango_layout_iter_next_cluster (PangoLayoutIter *iter);
gboolean pango_layout_iter_next_run (PangoLayoutIter *iter);
gboolean pango_layout_iter_next_line (PangoLayoutIter *iter);
void pango_layout_iter_get_char_extents (PangoLayoutIter *iter,
         PangoRectangle *logical_rect);
void pango_layout_iter_get_cluster_extents (PangoLayoutIter *iter,
         PangoRectangle *ink_rect,
         PangoRectangle *logical_rect);
void pango_layout_iter_get_run_extents (PangoLayoutIter *iter,
         PangoRectangle *ink_rect,
         PangoRectangle *logical_rect);
void pango_layout_iter_get_line_extents (PangoLayoutIter *iter,
         PangoRectangle *ink_rect,
         PangoRectangle *logical_rect);
void pango_layout_iter_get_line_yrange (PangoLayoutIter *iter,
         int *y0_,
         int *y1_);
void pango_layout_iter_get_layout_extents (PangoLayoutIter *iter,
         PangoRectangle *ink_rect,
         PangoRectangle *logical_rect);
int pango_layout_iter_get_baseline (PangoLayoutIter *iter);
}
extern "C" {
typedef struct _PangoRenderer PangoRenderer;
typedef struct _PangoRendererClass PangoRendererClass;
typedef struct _PangoRendererPrivate PangoRendererPrivate;
typedef enum
{
  PANGO_RENDER_PART_FOREGROUND,
  PANGO_RENDER_PART_BACKGROUND,
  PANGO_RENDER_PART_UNDERLINE,
  PANGO_RENDER_PART_STRIKETHROUGH
} PangoRenderPart;
struct _PangoRenderer
{
  GObject parent_instance;
  PangoUnderline underline;
  gboolean strikethrough;
  int active_count;
  PangoMatrix *matrix;
  PangoRendererPrivate *priv;
};
struct _PangoRendererClass
{
  GObjectClass parent_class;
  void (*draw_glyphs) (PangoRenderer *renderer,
         PangoFont *font,
         PangoGlyphString *glyphs,
         int x,
         int y);
  void (*draw_rectangle) (PangoRenderer *renderer,
     PangoRenderPart part,
     int x,
     int y,
     int width,
     int height);
  void (*draw_error_underline) (PangoRenderer *renderer,
    int x,
    int y,
    int width,
    int height);
  void (*draw_shape) (PangoRenderer *renderer,
        PangoAttrShape *attr,
        int x,
        int y);
  void (*draw_trapezoid) (PangoRenderer *renderer,
     PangoRenderPart part,
     double y1_,
     double x11,
     double x21,
     double y2,
     double x12,
     double x22);
  void (*draw_glyph) (PangoRenderer *renderer,
        PangoFont *font,
        PangoGlyph glyph,
        double x,
        double y);
  void (*part_changed) (PangoRenderer *renderer,
   PangoRenderPart part);
  void (*begin) (PangoRenderer *renderer);
  void (*end) (PangoRenderer *renderer);
  void (*prepare_run) (PangoRenderer *renderer,
         PangoLayoutRun *run);
  void (*_pango_reserved1) (void);
  void (*_pango_reserved2) (void);
  void (*_pango_reserved3) (void);
  void (*_pango_reserved4) (void);
};
GType pango_renderer_get_type (void) __attribute__((__const__));
void pango_renderer_draw_layout (PangoRenderer *renderer,
       PangoLayout *layout,
       int x,
       int y);
void pango_renderer_draw_layout_line (PangoRenderer *renderer,
       PangoLayoutLine *line,
       int x,
       int y);
void pango_renderer_draw_glyphs (PangoRenderer *renderer,
       PangoFont *font,
       PangoGlyphString *glyphs,
       int x,
       int y);
void pango_renderer_draw_rectangle (PangoRenderer *renderer,
       PangoRenderPart part,
       int x,
       int y,
       int width,
       int height);
void pango_renderer_draw_error_underline (PangoRenderer *renderer,
       int x,
       int y,
       int width,
       int height);
void pango_renderer_draw_trapezoid (PangoRenderer *renderer,
       PangoRenderPart part,
       double y1_,
       double x11,
       double x21,
       double y2,
       double x12,
       double x22);
void pango_renderer_draw_glyph (PangoRenderer *renderer,
       PangoFont *font,
       PangoGlyph glyph,
       double x,
       double y);
void pango_renderer_activate (PangoRenderer *renderer);
void pango_renderer_deactivate (PangoRenderer *renderer);
void pango_renderer_part_changed (PangoRenderer *renderer,
      PangoRenderPart part);
void pango_renderer_set_color (PangoRenderer *renderer,
          PangoRenderPart part,
          const PangoColor *color);
PangoColor *pango_renderer_get_color (PangoRenderer *renderer,
          PangoRenderPart part);
void pango_renderer_set_matrix (PangoRenderer *renderer,
             const PangoMatrix *matrix);
const PangoMatrix *pango_renderer_get_matrix (PangoRenderer *renderer);
}
extern "C" {
char ** pango_split_file_list (const char *str);
char *pango_trim_string (const char *str);
gint pango_read_line (FILE *stream,
          GString *str);
gboolean pango_skip_space (const char **pos);
gboolean pango_scan_word (const char **pos,
          GString *out);
gboolean pango_scan_string (const char **pos,
          GString *out);
gboolean pango_scan_int (const char **pos,
          int *out);
gboolean pango_parse_enum (GType type,
          const char *str,
          int *value,
          gboolean warn,
          char **possible_values);
gboolean pango_parse_style (const char *str,
         PangoStyle *style,
         gboolean warn);
gboolean pango_parse_variant (const char *str,
         PangoVariant *variant,
         gboolean warn);
gboolean pango_parse_weight (const char *str,
         PangoWeight *weight,
         gboolean warn);
gboolean pango_parse_stretch (const char *str,
         PangoStretch *stretch,
         gboolean warn);
void pango_quantize_line_geometry (int *thickness,
       int *position);
guint8 * pango_log2vis_get_embedding_levels (const gchar *text,
          int length,
          PangoDirection *pbase_dir);
gboolean pango_is_zero_width (gunichar ch) __attribute__((__const__));
int pango_version (void) __attribute__((__const__));
const char * pango_version_string (void) __attribute__((__const__));
const char * pango_version_check (int required_major,
        int required_minor,
        int required_micro) __attribute__((__const__));
}
extern "C" {
}
extern "C" {
typedef struct _GdkPoint GdkPoint;
typedef struct _GdkRectangle GdkRectangle;
typedef struct _GdkSegment GdkSegment;
typedef struct _GdkSpan GdkSpan;
typedef guint32 GdkWChar;
typedef struct _GdkAtom *GdkAtom;
typedef guint32 GdkNativeWindow;
typedef struct _GdkColor GdkColor;
typedef struct _GdkColormap GdkColormap;
typedef struct _GdkCursor GdkCursor;
typedef struct _GdkFont GdkFont;
typedef struct _GdkGC GdkGC;
typedef struct _GdkImage GdkImage;
typedef struct _GdkRegion GdkRegion;
typedef struct _GdkVisual GdkVisual;
typedef struct _GdkDrawable GdkDrawable;
typedef struct _GdkDrawable GdkBitmap;
typedef struct _GdkDrawable GdkPixmap;
typedef struct _GdkDrawable GdkWindow;
typedef struct _GdkDisplay GdkDisplay;
typedef struct _GdkScreen GdkScreen;
typedef enum
{
  GDK_LSB_FIRST,
  GDK_MSB_FIRST
} GdkByteOrder;
typedef enum
{
  GDK_SHIFT_MASK = 1 << 0,
  GDK_LOCK_MASK = 1 << 1,
  GDK_CONTROL_MASK = 1 << 2,
  GDK_MOD1_MASK = 1 << 3,
  GDK_MOD2_MASK = 1 << 4,
  GDK_MOD3_MASK = 1 << 5,
  GDK_MOD4_MASK = 1 << 6,
  GDK_MOD5_MASK = 1 << 7,
  GDK_BUTTON1_MASK = 1 << 8,
  GDK_BUTTON2_MASK = 1 << 9,
  GDK_BUTTON3_MASK = 1 << 10,
  GDK_BUTTON4_MASK = 1 << 11,
  GDK_BUTTON5_MASK = 1 << 12,
  GDK_SUPER_MASK = 1 << 26,
  GDK_HYPER_MASK = 1 << 27,
  GDK_META_MASK = 1 << 28,
  GDK_RELEASE_MASK = 1 << 30,
  GDK_MODIFIER_MASK = 0x5c001fff
} GdkModifierType;
typedef enum
{
  GDK_INPUT_READ = 1 << 0,
  GDK_INPUT_WRITE = 1 << 1,
  GDK_INPUT_EXCEPTION = 1 << 2
} GdkInputCondition;
typedef enum
{
  GDK_OK = 0,
  GDK_ERROR = -1,
  GDK_ERROR_PARAM = -2,
  GDK_ERROR_FILE = -3,
  GDK_ERROR_MEM = -4
} GdkStatus;
typedef enum
{
  GDK_GRAB_SUCCESS = 0,
  GDK_GRAB_ALREADY_GRABBED = 1,
  GDK_GRAB_INVALID_TIME = 2,
  GDK_GRAB_NOT_VIEWABLE = 3,
  GDK_GRAB_FROZEN = 4
} GdkGrabStatus;
typedef void (*GdkInputFunction) (gpointer data,
      gint source,
      GdkInputCondition condition);
typedef void (*GdkDestroyNotify) (gpointer data);
struct _GdkPoint
{
  gint x;
  gint y;
};
struct _GdkRectangle
{
  gint x;
  gint y;
  gint width;
  gint height;
};
struct _GdkSegment
{
  gint x1;
  gint y1;
  gint x2;
  gint y2;
};
struct _GdkSpan
{
  gint x;
  gint y;
  gint width;
};
}
extern "C" {
struct _GdkColor
{
  guint32 pixel;
  guint16 red;
  guint16 green;
  guint16 blue;
};
typedef struct _GdkColormapClass GdkColormapClass;
struct _GdkColormap
{
  GObject parent_instance;
  gint size;
  GdkColor *colors;
  GdkVisual *visual;
  gpointer windowing_data;
};
struct _GdkColormapClass
{
  GObjectClass parent_class;
};
GType gdk_colormap_get_type (void) __attribute__((__const__));
GdkColormap* gdk_colormap_new (GdkVisual *visual,
       gboolean allocate);
GdkColormap* gdk_colormap_ref (GdkColormap *cmap);
void gdk_colormap_unref (GdkColormap *cmap);
GdkColormap* gdk_colormap_get_system (void);
GdkScreen *gdk_colormap_get_screen (GdkColormap *cmap);
gint gdk_colormap_get_system_size (void);
void gdk_colormap_change (GdkColormap *colormap,
     gint ncolors);
gint gdk_colormap_alloc_colors (GdkColormap *colormap,
       GdkColor *colors,
       gint ncolors,
       gboolean writeable,
       gboolean best_match,
       gboolean *success);
gboolean gdk_colormap_alloc_color (GdkColormap *colormap,
       GdkColor *color,
       gboolean writeable,
       gboolean best_match);
void gdk_colormap_free_colors (GdkColormap *colormap,
       GdkColor *colors,
       gint ncolors);
void gdk_colormap_query_color (GdkColormap *colormap,
       gulong pixel,
       GdkColor *result);
GdkVisual *gdk_colormap_get_visual (GdkColormap *colormap);
GdkColor *gdk_color_copy (const GdkColor *color);
void gdk_color_free (GdkColor *color);
gboolean gdk_color_parse (const gchar *spec,
          GdkColor *color);
guint gdk_color_hash (const GdkColor *colora);
gboolean gdk_color_equal (const GdkColor *colora,
          const GdkColor *colorb);
gchar * gdk_color_to_string (const GdkColor *color);
GType gdk_color_get_type (void) __attribute__((__const__));
void gdk_colors_store (GdkColormap *colormap,
     GdkColor *colors,
     gint ncolors);
gint gdk_color_white (GdkColormap *colormap,
     GdkColor *color);
gint gdk_color_black (GdkColormap *colormap,
     GdkColor *color);
gint gdk_color_alloc (GdkColormap *colormap,
     GdkColor *color);
gint gdk_color_change (GdkColormap *colormap,
     GdkColor *color);
gint gdk_colors_alloc (GdkColormap *colormap,
     gboolean contiguous,
     gulong *planes,
     gint nplanes,
     gulong *pixels,
     gint npixels);
void gdk_colors_free (GdkColormap *colormap,
     gulong *pixels,
     gint npixels,
     gulong planes);
}
extern "C" {
typedef struct _GdkRgbCmap GdkRgbCmap;
struct _GdkRgbCmap {
  guint32 colors[256];
  gint n_colors;
  GSList *info_list;
};
void gdk_rgb_init (void);
gulong gdk_rgb_xpixel_from_rgb (guint32 rgb) __attribute__((__const__));
void gdk_rgb_gc_set_foreground (GdkGC *gc,
      guint32 rgb);
void gdk_rgb_gc_set_background (GdkGC *gc,
      guint32 rgb);
void gdk_rgb_find_color (GdkColormap *colormap,
      GdkColor *color);
typedef enum
{
  GDK_RGB_DITHER_NONE,
  GDK_RGB_DITHER_NORMAL,
  GDK_RGB_DITHER_MAX
} GdkRgbDither;
void gdk_draw_rgb_image (GdkDrawable *drawable,
          GdkGC *gc,
          gint x,
          gint y,
          gint width,
          gint height,
          GdkRgbDither dith,
          guchar *rgb_buf,
          gint rowstride);
void gdk_draw_rgb_image_dithalign (GdkDrawable *drawable,
          GdkGC *gc,
          gint x,
          gint y,
          gint width,
          gint height,
          GdkRgbDither dith,
          guchar *rgb_buf,
          gint rowstride,
          gint xdith,
          gint ydith);
void gdk_draw_rgb_32_image (GdkDrawable *drawable,
          GdkGC *gc,
          gint x,
          gint y,
          gint width,
          gint height,
          GdkRgbDither dith,
          guchar *buf,
          gint rowstride);
void gdk_draw_rgb_32_image_dithalign (GdkDrawable *drawable,
          GdkGC *gc,
          gint x,
          gint y,
          gint width,
          gint height,
          GdkRgbDither dith,
          guchar *buf,
          gint rowstride,
          gint xdith,
          gint ydith);
void gdk_draw_gray_image (GdkDrawable *drawable,
          GdkGC *gc,
          gint x,
          gint y,
          gint width,
          gint height,
          GdkRgbDither dith,
          guchar *buf,
          gint rowstride);
void gdk_draw_indexed_image (GdkDrawable *drawable,
          GdkGC *gc,
          gint x,
          gint y,
          gint width,
          gint height,
          GdkRgbDither dith,
          guchar *buf,
          gint rowstride,
          GdkRgbCmap *cmap);
GdkRgbCmap *gdk_rgb_cmap_new (guint32 *colors,
          gint n_colors);
void gdk_rgb_cmap_free (GdkRgbCmap *cmap);
void gdk_rgb_set_verbose (gboolean verbose);
void gdk_rgb_set_install (gboolean install);
void gdk_rgb_set_min_colors (gint min_colors);
GdkColormap *gdk_rgb_get_colormap (void);
GdkVisual * gdk_rgb_get_visual (void);
gboolean gdk_rgb_ditherable (void);
gboolean gdk_rgb_colormap_ditherable (GdkColormap *cmap);
}
extern const guint gdk_pixbuf_major_version;
extern const guint gdk_pixbuf_minor_version;
extern const guint gdk_pixbuf_micro_version;
extern const char *gdk_pixbuf_version;
extern "C" {
typedef enum
{
        GDK_PIXBUF_ALPHA_BILEVEL,
        GDK_PIXBUF_ALPHA_FULL
} GdkPixbufAlphaMode;
typedef enum {
 GDK_COLORSPACE_RGB
} GdkColorspace;
typedef struct _GdkPixbuf GdkPixbuf;
typedef void (* GdkPixbufDestroyNotify) (guchar *pixels, gpointer data);
typedef enum {
        GDK_PIXBUF_ERROR_CORRUPT_IMAGE,
        GDK_PIXBUF_ERROR_INSUFFICIENT_MEMORY,
        GDK_PIXBUF_ERROR_BAD_OPTION,
        GDK_PIXBUF_ERROR_UNKNOWN_TYPE,
        GDK_PIXBUF_ERROR_UNSUPPORTED_OPERATION,
        GDK_PIXBUF_ERROR_FAILED
} GdkPixbufError;
GQuark gdk_pixbuf_error_quark (void);
GType gdk_pixbuf_get_type (void) __attribute__((__const__));
GdkPixbuf *gdk_pixbuf_ref (GdkPixbuf *pixbuf);
void gdk_pixbuf_unref (GdkPixbuf *pixbuf);
GdkColorspace gdk_pixbuf_get_colorspace (const GdkPixbuf *pixbuf);
int gdk_pixbuf_get_n_channels (const GdkPixbuf *pixbuf);
gboolean gdk_pixbuf_get_has_alpha (const GdkPixbuf *pixbuf);
int gdk_pixbuf_get_bits_per_sample (const GdkPixbuf *pixbuf);
guchar *gdk_pixbuf_get_pixels (const GdkPixbuf *pixbuf);
int gdk_pixbuf_get_width (const GdkPixbuf *pixbuf);
int gdk_pixbuf_get_height (const GdkPixbuf *pixbuf);
int gdk_pixbuf_get_rowstride (const GdkPixbuf *pixbuf);
GdkPixbuf *gdk_pixbuf_new (GdkColorspace colorspace, gboolean has_alpha, int bits_per_sample,
      int width, int height);
GdkPixbuf *gdk_pixbuf_copy (const GdkPixbuf *pixbuf);
GdkPixbuf *gdk_pixbuf_new_subpixbuf (GdkPixbuf *src_pixbuf,
                                     int src_x,
                                     int src_y,
                                     int width,
                                     int height);
GdkPixbuf *gdk_pixbuf_new_from_file (const char *filename,
                                     GError **error);
GdkPixbuf *gdk_pixbuf_new_from_file_at_size (const char *filename,
          int width,
          int height,
          GError **error);
GdkPixbuf *gdk_pixbuf_new_from_file_at_scale (const char *filename,
           int width,
           int height,
           gboolean preserve_aspect_ratio,
           GError **error);
GdkPixbuf *gdk_pixbuf_new_from_data (const guchar *data,
         GdkColorspace colorspace,
         gboolean has_alpha,
         int bits_per_sample,
         int width, int height,
         int rowstride,
         GdkPixbufDestroyNotify destroy_fn,
         gpointer destroy_fn_data);
GdkPixbuf *gdk_pixbuf_new_from_xpm_data (const char **data);
GdkPixbuf* gdk_pixbuf_new_from_inline (gint data_length,
      const guint8 *data,
      gboolean copy_pixels,
      GError **error);
void gdk_pixbuf_fill (GdkPixbuf *pixbuf,
                                         guint32 pixel);
gboolean gdk_pixbuf_save (GdkPixbuf *pixbuf,
                                    const char *filename,
                                    const char *type,
                                    GError **error,
                                    ...) __attribute__((__sentinel__));
gboolean gdk_pixbuf_savev (GdkPixbuf *pixbuf,
                                    const char *filename,
                                    const char *type,
                                    char **option_keys,
                                    char **option_values,
                                    GError **error);
typedef gboolean (*GdkPixbufSaveFunc) (const gchar *buf,
      gsize count,
      GError **error,
      gpointer data);
gboolean gdk_pixbuf_save_to_callback (GdkPixbuf *pixbuf,
      GdkPixbufSaveFunc save_func,
      gpointer user_data,
      const char *type,
      GError **error,
      ...) __attribute__((__sentinel__));
gboolean gdk_pixbuf_save_to_callbackv (GdkPixbuf *pixbuf,
      GdkPixbufSaveFunc save_func,
      gpointer user_data,
      const char *type,
      char **option_keys,
      char **option_values,
      GError **error);
gboolean gdk_pixbuf_save_to_buffer (GdkPixbuf *pixbuf,
      gchar **buffer,
      gsize *buffer_size,
      const char *type,
      GError **error,
      ...) __attribute__((__sentinel__));
gboolean gdk_pixbuf_save_to_bufferv (GdkPixbuf *pixbuf,
      gchar **buffer,
      gsize *buffer_size,
      const char *type,
      char **option_keys,
      char **option_values,
      GError **error);
GdkPixbuf *gdk_pixbuf_add_alpha (const GdkPixbuf *pixbuf, gboolean substitute_color,
     guchar r, guchar g, guchar b);
void gdk_pixbuf_copy_area (const GdkPixbuf *src_pixbuf,
      int src_x, int src_y,
      int width, int height,
      GdkPixbuf *dest_pixbuf,
      int dest_x, int dest_y);
void gdk_pixbuf_saturate_and_pixelate (const GdkPixbuf *src,
                                       GdkPixbuf *dest,
                                       gfloat saturation,
                                       gboolean pixelate);
GdkPixbuf *gdk_pixbuf_apply_embedded_orientation (GdkPixbuf *src);
const gchar * gdk_pixbuf_get_option (GdkPixbuf *pixbuf,
                                              const gchar *key);
}
extern "C" {
typedef enum {
 GDK_INTERP_NEAREST,
 GDK_INTERP_TILES,
 GDK_INTERP_BILINEAR,
 GDK_INTERP_HYPER
} GdkInterpType;
typedef enum {
 GDK_PIXBUF_ROTATE_NONE = 0,
 GDK_PIXBUF_ROTATE_COUNTERCLOCKWISE = 90,
 GDK_PIXBUF_ROTATE_UPSIDEDOWN = 180,
 GDK_PIXBUF_ROTATE_CLOCKWISE = 270
} GdkPixbufRotation;
void gdk_pixbuf_scale (const GdkPixbuf *src,
     GdkPixbuf *dest,
     int dest_x,
     int dest_y,
     int dest_width,
     int dest_height,
     double offset_x,
     double offset_y,
     double scale_x,
     double scale_y,
     GdkInterpType interp_type);
void gdk_pixbuf_composite (const GdkPixbuf *src,
     GdkPixbuf *dest,
     int dest_x,
     int dest_y,
     int dest_width,
     int dest_height,
     double offset_x,
     double offset_y,
     double scale_x,
     double scale_y,
     GdkInterpType interp_type,
     int overall_alpha);
void gdk_pixbuf_composite_color (const GdkPixbuf *src,
     GdkPixbuf *dest,
     int dest_x,
     int dest_y,
     int dest_width,
     int dest_height,
     double offset_x,
     double offset_y,
     double scale_x,
     double scale_y,
     GdkInterpType interp_type,
     int overall_alpha,
     int check_x,
     int check_y,
     int check_size,
     guint32 color1,
     guint32 color2);
GdkPixbuf *gdk_pixbuf_scale_simple (const GdkPixbuf *src,
           int dest_width,
           int dest_height,
           GdkInterpType interp_type);
GdkPixbuf *gdk_pixbuf_composite_color_simple (const GdkPixbuf *src,
           int dest_width,
           int dest_height,
           GdkInterpType interp_type,
           int overall_alpha,
           int check_size,
           guint32 color1,
           guint32 color2);
GdkPixbuf *gdk_pixbuf_rotate_simple (const GdkPixbuf *src,
                  GdkPixbufRotation angle);
GdkPixbuf *gdk_pixbuf_flip (const GdkPixbuf *src,
                  gboolean horizontal);
}
extern "C" {
typedef struct _GdkPixbufAnimation GdkPixbufAnimation;
typedef struct _GdkPixbufAnimationIter GdkPixbufAnimationIter;
GType gdk_pixbuf_animation_get_type (void) __attribute__((__const__));
GdkPixbufAnimation *gdk_pixbuf_animation_new_from_file (const char *filename,
                                                          GError **error);
GdkPixbufAnimation *gdk_pixbuf_animation_ref (GdkPixbufAnimation *animation);
void gdk_pixbuf_animation_unref (GdkPixbufAnimation *animation);
int gdk_pixbuf_animation_get_width (GdkPixbufAnimation *animation);
int gdk_pixbuf_animation_get_height (GdkPixbufAnimation *animation);
gboolean gdk_pixbuf_animation_is_static_image (GdkPixbufAnimation *animation);
GdkPixbuf *gdk_pixbuf_animation_get_static_image (GdkPixbufAnimation *animation);
GdkPixbufAnimationIter *gdk_pixbuf_animation_get_iter (GdkPixbufAnimation *animation,
                                                                              const GTimeVal *start_time);
GType gdk_pixbuf_animation_iter_get_type (void) __attribute__((__const__));
int gdk_pixbuf_animation_iter_get_delay_time (GdkPixbufAnimationIter *iter);
GdkPixbuf *gdk_pixbuf_animation_iter_get_pixbuf (GdkPixbufAnimationIter *iter);
gboolean gdk_pixbuf_animation_iter_on_currently_loading_frame (GdkPixbufAnimationIter *iter);
gboolean gdk_pixbuf_animation_iter_advance (GdkPixbufAnimationIter *iter,
                                                                              const GTimeVal *current_time);
}
extern "C" {
typedef struct _GdkPixbufSimpleAnim GdkPixbufSimpleAnim;
typedef struct _GdkPixbufSimpleAnimClass GdkPixbufSimpleAnimClass;
GType gdk_pixbuf_simple_anim_get_type (void) __attribute__((__const__));
GType gdk_pixbuf_simple_anim_iter_get_type (void) __attribute__((__const__));
GdkPixbufSimpleAnim *gdk_pixbuf_simple_anim_new (gint width,
                                                           gint height,
                                                           gfloat rate);
void gdk_pixbuf_simple_anim_add_frame (GdkPixbufSimpleAnim *animation,
                                                           GdkPixbuf *pixbuf);
}
extern "C" {
typedef enum
{
  G_MODULE_BIND_LAZY = 1 << 0,
  G_MODULE_BIND_LOCAL = 1 << 1,
  G_MODULE_BIND_MASK = 0x03
} GModuleFlags;
typedef struct _GModule GModule;
typedef const gchar* (*GModuleCheckInit) (GModule *module);
typedef void (*GModuleUnload) (GModule *module);
gboolean g_module_supported (void) __attribute__((__const__));
GModule* g_module_open (const gchar *file_name,
           GModuleFlags flags);
gboolean g_module_close (GModule *module);
void g_module_make_resident (GModule *module);
const gchar* g_module_error (void);
gboolean g_module_symbol (GModule *module,
           const gchar *symbol_name,
           gpointer *symbol);
const gchar* g_module_name (GModule *module);
gchar* g_module_build_path (const gchar *directory,
           const gchar *module_name);
}
extern "C" {
typedef struct _GdkPixbufFormat GdkPixbufFormat;
GSList *gdk_pixbuf_get_formats (void);
gchar *gdk_pixbuf_format_get_name (GdkPixbufFormat *format);
gchar *gdk_pixbuf_format_get_description (GdkPixbufFormat *format);
gchar **gdk_pixbuf_format_get_mime_types (GdkPixbufFormat *format);
gchar **gdk_pixbuf_format_get_extensions (GdkPixbufFormat *format);
gboolean gdk_pixbuf_format_is_writable (GdkPixbufFormat *format);
gboolean gdk_pixbuf_format_is_scalable (GdkPixbufFormat *format);
gboolean gdk_pixbuf_format_is_disabled (GdkPixbufFormat *format);
void gdk_pixbuf_format_set_disabled (GdkPixbufFormat *format,
           gboolean disabled);
gchar *gdk_pixbuf_format_get_license (GdkPixbufFormat *format);
GdkPixbufFormat *gdk_pixbuf_get_file_info (const gchar *filename,
           gint *width,
           gint *height);
}
extern "C" {
typedef struct _GdkPixbufLoader GdkPixbufLoader;
struct _GdkPixbufLoader
{
  GObject parent_instance;
  gpointer priv;
};
typedef struct _GdkPixbufLoaderClass GdkPixbufLoaderClass;
struct _GdkPixbufLoaderClass
{
  GObjectClass parent_class;
  void (*size_prepared) (GdkPixbufLoader *loader,
         int width,
         int height);
  void (*area_prepared) (GdkPixbufLoader *loader);
  void (*area_updated) (GdkPixbufLoader *loader,
                              int x,
                              int y,
         int width,
         int height);
  void (*closed) (GdkPixbufLoader *loader);
};
GType gdk_pixbuf_loader_get_type (void) __attribute__((__const__));
GdkPixbufLoader * gdk_pixbuf_loader_new (void);
GdkPixbufLoader * gdk_pixbuf_loader_new_with_type (const char *image_type,
                                                      GError **error);
GdkPixbufLoader * gdk_pixbuf_loader_new_with_mime_type (const char *mime_type,
          GError **error);
void gdk_pixbuf_loader_set_size (GdkPixbufLoader *loader,
                                                 int width,
       int height);
gboolean gdk_pixbuf_loader_write (GdkPixbufLoader *loader,
            const guchar *buf,
            gsize count,
                                                      GError **error);
GdkPixbuf * gdk_pixbuf_loader_get_pixbuf (GdkPixbufLoader *loader);
GdkPixbufAnimation * gdk_pixbuf_loader_get_animation (GdkPixbufLoader *loader);
gboolean gdk_pixbuf_loader_close (GdkPixbufLoader *loader,
                                                      GError **error);
GdkPixbufFormat *gdk_pixbuf_loader_get_format (GdkPixbufLoader *loader);
}
extern "C" {
GType gdk_pixbuf_alpha_mode_get_type (void) __attribute__((__const__));
GType gdk_colorspace_get_type (void) __attribute__((__const__));
GType gdk_pixbuf_error_get_type (void) __attribute__((__const__));
GType gdk_interp_type_get_type (void) __attribute__((__const__));
GType gdk_pixbuf_rotation_get_type (void) __attribute__((__const__));
}
extern "C" {
void gdk_pixbuf_render_threshold_alpha (GdkPixbuf *pixbuf,
       GdkBitmap *bitmap,
       int src_x,
       int src_y,
       int dest_x,
       int dest_y,
       int width,
       int height,
       int alpha_threshold);
void gdk_pixbuf_render_to_drawable (GdkPixbuf *pixbuf,
       GdkDrawable *drawable,
       GdkGC *gc,
       int src_x,
       int src_y,
       int dest_x,
       int dest_y,
       int width,
       int height,
       GdkRgbDither dither,
       int x_dither,
       int y_dither);
void gdk_pixbuf_render_to_drawable_alpha (GdkPixbuf *pixbuf,
       GdkDrawable *drawable,
       int src_x,
       int src_y,
       int dest_x,
       int dest_y,
       int width,
       int height,
       GdkPixbufAlphaMode alpha_mode,
       int alpha_threshold,
       GdkRgbDither dither,
       int x_dither,
       int y_dither);
void gdk_pixbuf_render_pixmap_and_mask_for_colormap (GdkPixbuf *pixbuf,
           GdkColormap *colormap,
           GdkPixmap **pixmap_return,
           GdkBitmap **mask_return,
           int alpha_threshold);
void gdk_pixbuf_render_pixmap_and_mask (GdkPixbuf *pixbuf,
           GdkPixmap **pixmap_return,
           GdkBitmap **mask_return,
           int alpha_threshold);
GdkPixbuf *gdk_pixbuf_get_from_drawable (GdkPixbuf *dest,
      GdkDrawable *src,
      GdkColormap *cmap,
      int src_x,
      int src_y,
      int dest_x,
      int dest_y,
      int width,
      int height);
GdkPixbuf *gdk_pixbuf_get_from_image (GdkPixbuf *dest,
                                         GdkImage *src,
                                         GdkColormap *cmap,
                                         int src_x,
                                         int src_y,
                                         int dest_x,
                                         int dest_y,
                                         int width,
                                         int height);
}
extern "C" {
typedef struct _PangoCairoFont PangoCairoFont;
typedef struct _PangoCairoFontMap PangoCairoFontMap;
typedef void (* PangoCairoShapeRendererFunc) (cairo_t *cr,
           PangoAttrShape *attr,
           gboolean do_path,
           gpointer data);
GType pango_cairo_font_map_get_type (void) __attribute__((__const__));
PangoFontMap *pango_cairo_font_map_new (void);
PangoFontMap *pango_cairo_font_map_new_for_font_type (cairo_font_type_t fonttype);
PangoFontMap *pango_cairo_font_map_get_default (void);
cairo_font_type_t pango_cairo_font_map_get_font_type (PangoCairoFontMap *fontmap);
void pango_cairo_font_map_set_resolution (PangoCairoFontMap *fontmap,
         double dpi);
double pango_cairo_font_map_get_resolution (PangoCairoFontMap *fontmap);
PangoContext *pango_cairo_font_map_create_context (PangoCairoFontMap *fontmap);
GType pango_cairo_font_get_type (void) __attribute__((__const__));
cairo_scaled_font_t *pango_cairo_font_get_scaled_font (PangoCairoFont *font);
void pango_cairo_update_context (cairo_t *cr,
      PangoContext *context);
void pango_cairo_context_set_font_options (PangoContext *context,
          const cairo_font_options_t *options);
const cairo_font_options_t *pango_cairo_context_get_font_options (PangoContext *context);
void pango_cairo_context_set_resolution (PangoContext *context,
          double dpi);
double pango_cairo_context_get_resolution (PangoContext *context);
void pango_cairo_context_set_shape_renderer (PangoContext *context,
            PangoCairoShapeRendererFunc func,
            gpointer data,
            GDestroyNotify dnotify);
PangoCairoShapeRendererFunc pango_cairo_context_get_shape_renderer (PangoContext *context,
            gpointer *data);
PangoLayout *pango_cairo_create_layout (cairo_t *cr);
void pango_cairo_update_layout (cairo_t *cr,
     PangoLayout *layout);
void pango_cairo_show_glyph_string (cairo_t *cr,
        PangoFont *font,
        PangoGlyphString *glyphs);
void pango_cairo_show_layout_line (cairo_t *cr,
        PangoLayoutLine *line);
void pango_cairo_show_layout (cairo_t *cr,
        PangoLayout *layout);
void pango_cairo_show_error_underline (cairo_t *cr,
           double x,
           double y,
           double width,
           double height);
void pango_cairo_glyph_string_path (cairo_t *cr,
        PangoFont *font,
        PangoGlyphString *glyphs);
void pango_cairo_layout_line_path (cairo_t *cr,
        PangoLayoutLine *line);
void pango_cairo_layout_path (cairo_t *cr,
        PangoLayout *layout);
void pango_cairo_error_underline_path (cairo_t *cr,
           double x,
           double y,
           double width,
           double height);
}
extern "C" {
cairo_t *gdk_cairo_create (GdkDrawable *drawable);
void gdk_cairo_set_source_color (cairo_t *cr,
      GdkColor *color);
void gdk_cairo_set_source_pixbuf (cairo_t *cr,
      GdkPixbuf *pixbuf,
      double pixbuf_x,
      double pixbuf_y);
void gdk_cairo_set_source_pixmap (cairo_t *cr,
      GdkPixmap *pixmap,
      double pixmap_x,
      double pixmap_y);
void gdk_cairo_rectangle (cairo_t *cr,
     GdkRectangle *rectangle);
void gdk_cairo_region (cairo_t *cr,
     GdkRegion *region);
}
extern "C" {
typedef enum
{
  GDK_X_CURSOR = 0,
  GDK_ARROW = 2,
  GDK_BASED_ARROW_DOWN = 4,
  GDK_BASED_ARROW_UP = 6,
  GDK_BOAT = 8,
  GDK_BOGOSITY = 10,
  GDK_BOTTOM_LEFT_CORNER = 12,
  GDK_BOTTOM_RIGHT_CORNER = 14,
  GDK_BOTTOM_SIDE = 16,
  GDK_BOTTOM_TEE = 18,
  GDK_BOX_SPIRAL = 20,
  GDK_CENTER_PTR = 22,
  GDK_CIRCLE = 24,
  GDK_CLOCK = 26,
  GDK_COFFEE_MUG = 28,
  GDK_CROSS = 30,
  GDK_CROSS_REVERSE = 32,
  GDK_CROSSHAIR = 34,
  GDK_DIAMOND_CROSS = 36,
  GDK_DOT = 38,
  GDK_DOTBOX = 40,
  GDK_DOUBLE_ARROW = 42,
  GDK_DRAFT_LARGE = 44,
  GDK_DRAFT_SMALL = 46,
  GDK_DRAPED_BOX = 48,
  GDK_EXCHANGE = 50,
  GDK_FLEUR = 52,
  GDK_GOBBLER = 54,
  GDK_GUMBY = 56,
  GDK_HAND1 = 58,
  GDK_HAND2 = 60,
  GDK_HEART = 62,
  GDK_ICON = 64,
  GDK_IRON_CROSS = 66,
  GDK_LEFT_PTR = 68,
  GDK_LEFT_SIDE = 70,
  GDK_LEFT_TEE = 72,
  GDK_LEFTBUTTON = 74,
  GDK_LL_ANGLE = 76,
  GDK_LR_ANGLE = 78,
  GDK_MAN = 80,
  GDK_MIDDLEBUTTON = 82,
  GDK_MOUSE = 84,
  GDK_PENCIL = 86,
  GDK_PIRATE = 88,
  GDK_PLUS = 90,
  GDK_QUESTION_ARROW = 92,
  GDK_RIGHT_PTR = 94,
  GDK_RIGHT_SIDE = 96,
  GDK_RIGHT_TEE = 98,
  GDK_RIGHTBUTTON = 100,
  GDK_RTL_LOGO = 102,
  GDK_SAILBOAT = 104,
  GDK_SB_DOWN_ARROW = 106,
  GDK_SB_H_DOUBLE_ARROW = 108,
  GDK_SB_LEFT_ARROW = 110,
  GDK_SB_RIGHT_ARROW = 112,
  GDK_SB_UP_ARROW = 114,
  GDK_SB_V_DOUBLE_ARROW = 116,
  GDK_SHUTTLE = 118,
  GDK_SIZING = 120,
  GDK_SPIDER = 122,
  GDK_SPRAYCAN = 124,
  GDK_STAR = 126,
  GDK_TARGET = 128,
  GDK_TCROSS = 130,
  GDK_TOP_LEFT_ARROW = 132,
  GDK_TOP_LEFT_CORNER = 134,
  GDK_TOP_RIGHT_CORNER = 136,
  GDK_TOP_SIDE = 138,
  GDK_TOP_TEE = 140,
  GDK_TREK = 142,
  GDK_UL_ANGLE = 144,
  GDK_UMBRELLA = 146,
  GDK_UR_ANGLE = 148,
  GDK_WATCH = 150,
  GDK_XTERM = 152,
  GDK_LAST_CURSOR,
  GDK_CURSOR_IS_PIXMAP = -1
} GdkCursorType;
struct _GdkCursor
{
  GdkCursorType type;
  guint ref_count;
};
GType gdk_cursor_get_type (void) __attribute__((__const__));
GdkCursor* gdk_cursor_new_for_display (GdkDisplay *display,
       GdkCursorType cursor_type);
GdkCursor* gdk_cursor_new (GdkCursorType cursor_type);
GdkCursor* gdk_cursor_new_from_pixmap (GdkPixmap *source,
       GdkPixmap *mask,
       const GdkColor *fg,
       const GdkColor *bg,
       gint x,
       gint y);
GdkCursor* gdk_cursor_new_from_pixbuf (GdkDisplay *display,
       GdkPixbuf *pixbuf,
       gint x,
       gint y);
GdkDisplay* gdk_cursor_get_display (GdkCursor *cursor);
GdkCursor* gdk_cursor_ref (GdkCursor *cursor);
void gdk_cursor_unref (GdkCursor *cursor);
GdkCursor* gdk_cursor_new_from_name (GdkDisplay *display,
       const gchar *name);
GdkPixbuf* gdk_cursor_get_image (GdkCursor *cursor);
}
extern "C" {
typedef struct _GdkDragContext GdkDragContext;
typedef enum
{
  GDK_ACTION_DEFAULT = 1 << 0,
  GDK_ACTION_COPY = 1 << 1,
  GDK_ACTION_MOVE = 1 << 2,
  GDK_ACTION_LINK = 1 << 3,
  GDK_ACTION_PRIVATE = 1 << 4,
  GDK_ACTION_ASK = 1 << 5
} GdkDragAction;
typedef enum
{
  GDK_DRAG_PROTO_MOTIF,
  GDK_DRAG_PROTO_XDND,
  GDK_DRAG_PROTO_ROOTWIN,
  GDK_DRAG_PROTO_NONE,
  GDK_DRAG_PROTO_WIN32_DROPFILES,
  GDK_DRAG_PROTO_OLE2,
  GDK_DRAG_PROTO_LOCAL
} GdkDragProtocol;
typedef struct _GdkDragContextClass GdkDragContextClass;
struct _GdkDragContext {
  GObject parent_instance;
  GdkDragProtocol protocol;
  gboolean is_source;
  GdkWindow *source_window;
  GdkWindow *dest_window;
  GList *targets;
  GdkDragAction actions;
  GdkDragAction suggested_action;
  GdkDragAction action;
  guint32 start_time;
  gpointer windowing_data;
};
struct _GdkDragContextClass {
  GObjectClass parent_class;
};
GType gdk_drag_context_get_type (void) __attribute__((__const__));
GdkDragContext * gdk_drag_context_new (void);
void gdk_drag_context_ref (GdkDragContext *context);
void gdk_drag_context_unref (GdkDragContext *context);
void gdk_drag_status (GdkDragContext *context,
             GdkDragAction action,
      guint32 time_);
void gdk_drop_reply (GdkDragContext *context,
      gboolean ok,
      guint32 time_);
void gdk_drop_finish (GdkDragContext *context,
      gboolean success,
      guint32 time_);
GdkAtom gdk_drag_get_selection (GdkDragContext *context);
GdkDragContext * gdk_drag_begin (GdkWindow *window,
          GList *targets);
guint32 gdk_drag_get_protocol_for_display (GdkDisplay *display,
        guint32 xid,
        GdkDragProtocol *protocol);
void gdk_drag_find_window_for_screen (GdkDragContext *context,
        GdkWindow *drag_window,
        GdkScreen *screen,
        gint x_root,
        gint y_root,
        GdkWindow **dest_window,
        GdkDragProtocol *protocol);
guint32 gdk_drag_get_protocol (guint32 xid,
          GdkDragProtocol *protocol);
void gdk_drag_find_window (GdkDragContext *context,
          GdkWindow *drag_window,
          gint x_root,
          gint y_root,
          GdkWindow **dest_window,
          GdkDragProtocol *protocol);
gboolean gdk_drag_motion (GdkDragContext *context,
          GdkWindow *dest_window,
          GdkDragProtocol protocol,
          gint x_root,
          gint y_root,
          GdkDragAction suggested_action,
          GdkDragAction possible_actions,
          guint32 time_);
void gdk_drag_drop (GdkDragContext *context,
          guint32 time_);
void gdk_drag_abort (GdkDragContext *context,
          guint32 time_);
gboolean gdk_drag_drop_succeeded (GdkDragContext *context);
}
extern "C" {
typedef struct _GdkDeviceKey GdkDeviceKey;
typedef struct _GdkDeviceAxis GdkDeviceAxis;
typedef struct _GdkDevice GdkDevice;
typedef struct _GdkDeviceClass GdkDeviceClass;
typedef struct _GdkTimeCoord GdkTimeCoord;
typedef enum
{
  GDK_EXTENSION_EVENTS_NONE,
  GDK_EXTENSION_EVENTS_ALL,
  GDK_EXTENSION_EVENTS_CURSOR
} GdkExtensionMode;
typedef enum
{
  GDK_SOURCE_MOUSE,
  GDK_SOURCE_PEN,
  GDK_SOURCE_ERASER,
  GDK_SOURCE_CURSOR
} GdkInputSource;
typedef enum
{
  GDK_MODE_DISABLED,
  GDK_MODE_SCREEN,
  GDK_MODE_WINDOW
} GdkInputMode;
typedef enum
{
  GDK_AXIS_IGNORE,
  GDK_AXIS_X,
  GDK_AXIS_Y,
  GDK_AXIS_PRESSURE,
  GDK_AXIS_XTILT,
  GDK_AXIS_YTILT,
  GDK_AXIS_WHEEL,
  GDK_AXIS_LAST
} GdkAxisUse;
struct _GdkDeviceKey
{
  guint keyval;
  GdkModifierType modifiers;
};
struct _GdkDeviceAxis
{
  GdkAxisUse use;
  gdouble min;
  gdouble max;
};
struct _GdkDevice
{
  GObject parent_instance;
  gchar *name;
  GdkInputSource source;
  GdkInputMode mode;
  gboolean has_cursor;
  gint num_axes;
  GdkDeviceAxis *axes;
  gint num_keys;
  GdkDeviceKey *keys;
};
struct _GdkTimeCoord
{
  guint32 time;
  gdouble axes[128];
};
GType gdk_device_get_type (void) __attribute__((__const__));
GList * gdk_devices_list (void);
void gdk_device_set_source (GdkDevice *device,
      GdkInputSource source);
gboolean gdk_device_set_mode (GdkDevice *device,
      GdkInputMode mode);
void gdk_device_set_key (GdkDevice *device,
      guint index_,
      guint keyval,
      GdkModifierType modifiers);
void gdk_device_set_axis_use (GdkDevice *device,
      guint index_,
      GdkAxisUse use);
void gdk_device_get_state (GdkDevice *device,
      GdkWindow *window,
      gdouble *axes,
      GdkModifierType *mask);
gboolean gdk_device_get_history (GdkDevice *device,
      GdkWindow *window,
      guint32 start,
      guint32 stop,
      GdkTimeCoord ***events,
      gint *n_events);
void gdk_device_free_history (GdkTimeCoord **events,
      gint n_events);
gboolean gdk_device_get_axis (GdkDevice *device,
      gdouble *axes,
      GdkAxisUse use,
      gdouble *value);
void gdk_input_set_extension_events (GdkWindow *window,
         gint mask,
         GdkExtensionMode mode);
GdkDevice *gdk_device_get_core_pointer (void);
}
extern "C" {
typedef struct _GdkEventAny GdkEventAny;
typedef struct _GdkEventExpose GdkEventExpose;
typedef struct _GdkEventNoExpose GdkEventNoExpose;
typedef struct _GdkEventVisibility GdkEventVisibility;
typedef struct _GdkEventMotion GdkEventMotion;
typedef struct _GdkEventButton GdkEventButton;
typedef struct _GdkEventScroll GdkEventScroll;
typedef struct _GdkEventKey GdkEventKey;
typedef struct _GdkEventFocus GdkEventFocus;
typedef struct _GdkEventCrossing GdkEventCrossing;
typedef struct _GdkEventConfigure GdkEventConfigure;
typedef struct _GdkEventProperty GdkEventProperty;
typedef struct _GdkEventSelection GdkEventSelection;
typedef struct _GdkEventOwnerChange GdkEventOwnerChange;
typedef struct _GdkEventProximity GdkEventProximity;
typedef struct _GdkEventClient GdkEventClient;
typedef struct _GdkEventDND GdkEventDND;
typedef struct _GdkEventWindowState GdkEventWindowState;
typedef struct _GdkEventSetting GdkEventSetting;
typedef struct _GdkEventGrabBroken GdkEventGrabBroken;
typedef union _GdkEvent GdkEvent;
typedef void (*GdkEventFunc) (GdkEvent *event,
         gpointer data);
typedef void GdkXEvent;
typedef enum {
  GDK_FILTER_CONTINUE,
  GDK_FILTER_TRANSLATE,
  GDK_FILTER_REMOVE
} GdkFilterReturn;
typedef GdkFilterReturn (*GdkFilterFunc) (GdkXEvent *xevent,
       GdkEvent *event,
       gpointer data);
typedef enum
{
  GDK_NOTHING = -1,
  GDK_DELETE = 0,
  GDK_DESTROY = 1,
  GDK_EXPOSE = 2,
  GDK_MOTION_NOTIFY = 3,
  GDK_BUTTON_PRESS = 4,
  GDK_2BUTTON_PRESS = 5,
  GDK_3BUTTON_PRESS = 6,
  GDK_BUTTON_RELEASE = 7,
  GDK_KEY_PRESS = 8,
  GDK_KEY_RELEASE = 9,
  GDK_ENTER_NOTIFY = 10,
  GDK_LEAVE_NOTIFY = 11,
  GDK_FOCUS_CHANGE = 12,
  GDK_CONFIGURE = 13,
  GDK_MAP = 14,
  GDK_UNMAP = 15,
  GDK_PROPERTY_NOTIFY = 16,
  GDK_SELECTION_CLEAR = 17,
  GDK_SELECTION_REQUEST = 18,
  GDK_SELECTION_NOTIFY = 19,
  GDK_PROXIMITY_IN = 20,
  GDK_PROXIMITY_OUT = 21,
  GDK_DRAG_ENTER = 22,
  GDK_DRAG_LEAVE = 23,
  GDK_DRAG_MOTION = 24,
  GDK_DRAG_STATUS = 25,
  GDK_DROP_START = 26,
  GDK_DROP_FINISHED = 27,
  GDK_CLIENT_EVENT = 28,
  GDK_VISIBILITY_NOTIFY = 29,
  GDK_NO_EXPOSE = 30,
  GDK_SCROLL = 31,
  GDK_WINDOW_STATE = 32,
  GDK_SETTING = 33,
  GDK_OWNER_CHANGE = 34,
  GDK_GRAB_BROKEN = 35
} GdkEventType;
typedef enum
{
  GDK_EXPOSURE_MASK = 1 << 1,
  GDK_POINTER_MOTION_MASK = 1 << 2,
  GDK_POINTER_MOTION_HINT_MASK = 1 << 3,
  GDK_BUTTON_MOTION_MASK = 1 << 4,
  GDK_BUTTON1_MOTION_MASK = 1 << 5,
  GDK_BUTTON2_MOTION_MASK = 1 << 6,
  GDK_BUTTON3_MOTION_MASK = 1 << 7,
  GDK_BUTTON_PRESS_MASK = 1 << 8,
  GDK_BUTTON_RELEASE_MASK = 1 << 9,
  GDK_KEY_PRESS_MASK = 1 << 10,
  GDK_KEY_RELEASE_MASK = 1 << 11,
  GDK_ENTER_NOTIFY_MASK = 1 << 12,
  GDK_LEAVE_NOTIFY_MASK = 1 << 13,
  GDK_FOCUS_CHANGE_MASK = 1 << 14,
  GDK_STRUCTURE_MASK = 1 << 15,
  GDK_PROPERTY_CHANGE_MASK = 1 << 16,
  GDK_VISIBILITY_NOTIFY_MASK = 1 << 17,
  GDK_PROXIMITY_IN_MASK = 1 << 18,
  GDK_PROXIMITY_OUT_MASK = 1 << 19,
  GDK_SUBSTRUCTURE_MASK = 1 << 20,
  GDK_SCROLL_MASK = 1 << 21,
  GDK_ALL_EVENTS_MASK = 0x3FFFFE
} GdkEventMask;
typedef enum
{
  GDK_VISIBILITY_UNOBSCURED,
  GDK_VISIBILITY_PARTIAL,
  GDK_VISIBILITY_FULLY_OBSCURED
} GdkVisibilityState;
typedef enum
{
  GDK_SCROLL_UP,
  GDK_SCROLL_DOWN,
  GDK_SCROLL_LEFT,
  GDK_SCROLL_RIGHT
} GdkScrollDirection;
typedef enum
{
  GDK_NOTIFY_ANCESTOR = 0,
  GDK_NOTIFY_VIRTUAL = 1,
  GDK_NOTIFY_INFERIOR = 2,
  GDK_NOTIFY_NONLINEAR = 3,
  GDK_NOTIFY_NONLINEAR_VIRTUAL = 4,
  GDK_NOTIFY_UNKNOWN = 5
} GdkNotifyType;
typedef enum
{
  GDK_CROSSING_NORMAL,
  GDK_CROSSING_GRAB,
  GDK_CROSSING_UNGRAB
} GdkCrossingMode;
typedef enum
{
  GDK_PROPERTY_NEW_VALUE,
  GDK_PROPERTY_DELETE
} GdkPropertyState;
typedef enum
{
  GDK_WINDOW_STATE_WITHDRAWN = 1 << 0,
  GDK_WINDOW_STATE_ICONIFIED = 1 << 1,
  GDK_WINDOW_STATE_MAXIMIZED = 1 << 2,
  GDK_WINDOW_STATE_STICKY = 1 << 3,
  GDK_WINDOW_STATE_FULLSCREEN = 1 << 4,
  GDK_WINDOW_STATE_ABOVE = 1 << 5,
  GDK_WINDOW_STATE_BELOW = 1 << 6
} GdkWindowState;
typedef enum
{
  GDK_SETTING_ACTION_NEW,
  GDK_SETTING_ACTION_CHANGED,
  GDK_SETTING_ACTION_DELETED
} GdkSettingAction;
typedef enum
{
  GDK_OWNER_CHANGE_NEW_OWNER,
  GDK_OWNER_CHANGE_DESTROY,
  GDK_OWNER_CHANGE_CLOSE
} GdkOwnerChange;
struct _GdkEventAny
{
  GdkEventType type;
  GdkWindow *window;
  gint8 send_event;
};
struct _GdkEventExpose
{
  GdkEventType type;
  GdkWindow *window;
  gint8 send_event;
  GdkRectangle area;
  GdkRegion *region;
  gint count;
};
struct _GdkEventNoExpose
{
  GdkEventType type;
  GdkWindow *window;
  gint8 send_event;
};
struct _GdkEventVisibility
{
  GdkEventType type;
  GdkWindow *window;
  gint8 send_event;
  GdkVisibilityState state;
};
struct _GdkEventMotion
{
  GdkEventType type;
  GdkWindow *window;
  gint8 send_event;
  guint32 time;
  gdouble x;
  gdouble y;
  gdouble *axes;
  guint state;
  gint16 is_hint;
  GdkDevice *device;
  gdouble x_root, y_root;
};
struct _GdkEventButton
{
  GdkEventType type;
  GdkWindow *window;
  gint8 send_event;
  guint32 time;
  gdouble x;
  gdouble y;
  gdouble *axes;
  guint state;
  guint button;
  GdkDevice *device;
  gdouble x_root, y_root;
};
struct _GdkEventScroll
{
  GdkEventType type;
  GdkWindow *window;
  gint8 send_event;
  guint32 time;
  gdouble x;
  gdouble y;
  guint state;
  GdkScrollDirection direction;
  GdkDevice *device;
  gdouble x_root, y_root;
};
struct _GdkEventKey
{
  GdkEventType type;
  GdkWindow *window;
  gint8 send_event;
  guint32 time;
  guint state;
  guint keyval;
  gint length;
  gchar *string;
  guint16 hardware_keycode;
  guint8 group;
  guint is_modifier : 1;
};
struct _GdkEventCrossing
{
  GdkEventType type;
  GdkWindow *window;
  gint8 send_event;
  GdkWindow *subwindow;
  guint32 time;
  gdouble x;
  gdouble y;
  gdouble x_root;
  gdouble y_root;
  GdkCrossingMode mode;
  GdkNotifyType detail;
  gboolean focus;
  guint state;
};
struct _GdkEventFocus
{
  GdkEventType type;
  GdkWindow *window;
  gint8 send_event;
  gint16 in;
};
struct _GdkEventConfigure
{
  GdkEventType type;
  GdkWindow *window;
  gint8 send_event;
  gint x, y;
  gint width;
  gint height;
};
struct _GdkEventProperty
{
  GdkEventType type;
  GdkWindow *window;
  gint8 send_event;
  GdkAtom atom;
  guint32 time;
  guint state;
};
struct _GdkEventSelection
{
  GdkEventType type;
  GdkWindow *window;
  gint8 send_event;
  GdkAtom selection;
  GdkAtom target;
  GdkAtom property;
  guint32 time;
  GdkNativeWindow requestor;
};
struct _GdkEventOwnerChange
{
  GdkEventType type;
  GdkWindow *window;
  gint8 send_event;
  GdkNativeWindow owner;
  GdkOwnerChange reason;
  GdkAtom selection;
  guint32 time;
  guint32 selection_time;
};
struct _GdkEventProximity
{
  GdkEventType type;
  GdkWindow *window;
  gint8 send_event;
  guint32 time;
  GdkDevice *device;
};
struct _GdkEventClient
{
  GdkEventType type;
  GdkWindow *window;
  gint8 send_event;
  GdkAtom message_type;
  gushort data_format;
  union {
    char b[20];
    short s[10];
    long l[5];
  } data;
};
struct _GdkEventSetting
{
  GdkEventType type;
  GdkWindow *window;
  gint8 send_event;
  GdkSettingAction action;
  char *name;
};
struct _GdkEventWindowState
{
  GdkEventType type;
  GdkWindow *window;
  gint8 send_event;
  GdkWindowState changed_mask;
  GdkWindowState new_window_state;
};
struct _GdkEventGrabBroken {
  GdkEventType type;
  GdkWindow *window;
  gint8 send_event;
  gboolean keyboard;
  gboolean implicit;
  GdkWindow *grab_window;
};
struct _GdkEventDND {
  GdkEventType type;
  GdkWindow *window;
  gint8 send_event;
  GdkDragContext *context;
  guint32 time;
  gshort x_root, y_root;
};
union _GdkEvent
{
  GdkEventType type;
  GdkEventAny any;
  GdkEventExpose expose;
  GdkEventNoExpose no_expose;
  GdkEventVisibility visibility;
  GdkEventMotion motion;
  GdkEventButton button;
  GdkEventScroll scroll;
  GdkEventKey key;
  GdkEventCrossing crossing;
  GdkEventFocus focus_change;
  GdkEventConfigure configure;
  GdkEventProperty property;
  GdkEventSelection selection;
  GdkEventOwnerChange owner_change;
  GdkEventProximity proximity;
  GdkEventClient client;
  GdkEventDND dnd;
  GdkEventWindowState window_state;
  GdkEventSetting setting;
  GdkEventGrabBroken grab_broken;
};
GType gdk_event_get_type (void) __attribute__((__const__));
gboolean gdk_events_pending (void);
GdkEvent* gdk_event_get (void);
GdkEvent* gdk_event_peek (void);
GdkEvent* gdk_event_get_graphics_expose (GdkWindow *window);
void gdk_event_put (GdkEvent *event);
GdkEvent* gdk_event_new (GdkEventType type);
GdkEvent* gdk_event_copy (GdkEvent *event);
void gdk_event_free (GdkEvent *event);
guint32 gdk_event_get_time (GdkEvent *event);
gboolean gdk_event_get_state (GdkEvent *event,
                                         GdkModifierType *state);
gboolean gdk_event_get_coords (GdkEvent *event,
      gdouble *x_win,
      gdouble *y_win);
gboolean gdk_event_get_root_coords (GdkEvent *event,
      gdouble *x_root,
      gdouble *y_root);
gboolean gdk_event_get_axis (GdkEvent *event,
                                         GdkAxisUse axis_use,
                                         gdouble *value);
void gdk_event_request_motions (GdkEventMotion *event);
void gdk_event_handler_set (GdkEventFunc func,
      gpointer data,
      GDestroyNotify notify);
void gdk_event_set_screen (GdkEvent *event,
     GdkScreen *screen);
GdkScreen *gdk_event_get_screen (GdkEvent *event);
void gdk_set_show_events (gboolean show_events);
gboolean gdk_get_show_events (void);
void gdk_add_client_message_filter (GdkAtom message_type,
        GdkFilterFunc func,
        gpointer data);
gboolean gdk_setting_get (const gchar *name,
     GValue *value);
}
extern "C" {
typedef struct _GdkDisplayClass GdkDisplayClass;
typedef struct _GdkDisplayPointerHooks GdkDisplayPointerHooks;
struct _GdkDisplay
{
  GObject parent_instance;
  GList *queued_events;
  GList *queued_tail;
  guint32 button_click_time[2];
  GdkWindow *button_window[2];
  gint button_number[2];
  guint double_click_time;
  GdkDevice *core_pointer;
  const GdkDisplayPointerHooks *pointer_hooks;
  guint closed : 1;
  guint double_click_distance;
  gint button_x[2];
  gint button_y[2];
};
struct _GdkDisplayClass
{
  GObjectClass parent_class;
  const gchar * (*get_display_name) (GdkDisplay *display);
  gint (*get_n_screens) (GdkDisplay *display);
  GdkScreen * (*get_screen) (GdkDisplay *display,
          gint screen_num);
  GdkScreen * (*get_default_screen) (GdkDisplay *display);
  void (*closed) (GdkDisplay *display,
    gboolean is_error);
};
struct _GdkDisplayPointerHooks
{
  void (*get_pointer) (GdkDisplay *display,
        GdkScreen **screen,
        gint *x,
        gint *y,
        GdkModifierType *mask);
  GdkWindow* (*window_get_pointer) (GdkDisplay *display,
        GdkWindow *window,
        gint *x,
        gint *y,
        GdkModifierType *mask);
  GdkWindow* (*window_at_pointer) (GdkDisplay *display,
        gint *win_x,
        gint *win_y);
};
GType gdk_display_get_type (void) __attribute__((__const__));
GdkDisplay *gdk_display_open (const gchar *display_name);
const gchar * gdk_display_get_name (GdkDisplay *display);
gint gdk_display_get_n_screens (GdkDisplay *display);
GdkScreen * gdk_display_get_screen (GdkDisplay *display,
         gint screen_num);
GdkScreen * gdk_display_get_default_screen (GdkDisplay *display);
void gdk_display_pointer_ungrab (GdkDisplay *display,
         guint32 time_);
void gdk_display_keyboard_ungrab (GdkDisplay *display,
         guint32 time_);
gboolean gdk_display_pointer_is_grabbed (GdkDisplay *display);
void gdk_display_beep (GdkDisplay *display);
void gdk_display_sync (GdkDisplay *display);
void gdk_display_flush (GdkDisplay *display);
void gdk_display_close (GdkDisplay *display);
GList * gdk_display_list_devices (GdkDisplay *display);
GdkEvent* gdk_display_get_event (GdkDisplay *display);
GdkEvent* gdk_display_peek_event (GdkDisplay *display);
void gdk_display_put_event (GdkDisplay *display,
      GdkEvent *event);
void gdk_display_add_client_message_filter (GdkDisplay *display,
         GdkAtom message_type,
         GdkFilterFunc func,
         gpointer data);
void gdk_display_set_double_click_time (GdkDisplay *display,
         guint msec);
void gdk_display_set_double_click_distance (GdkDisplay *display,
         guint distance);
GdkDisplay *gdk_display_get_default (void);
GdkDevice *gdk_display_get_core_pointer (GdkDisplay *display);
void gdk_display_get_pointer (GdkDisplay *display,
          GdkScreen **screen,
          gint *x,
          gint *y,
          GdkModifierType *mask);
GdkWindow * gdk_display_get_window_at_pointer (GdkDisplay *display,
          gint *win_x,
          gint *win_y);
void gdk_display_warp_pointer (GdkDisplay *display,
          GdkScreen *screen,
          gint x,
          gint y);
GdkDisplayPointerHooks *gdk_display_set_pointer_hooks (GdkDisplay *display,
             const GdkDisplayPointerHooks *new_hooks);
GdkDisplay *gdk_display_open_default_libgtk_only (void);
gboolean gdk_display_supports_cursor_alpha (GdkDisplay *display);
gboolean gdk_display_supports_cursor_color (GdkDisplay *display);
guint gdk_display_get_default_cursor_size (GdkDisplay *display);
void gdk_display_get_maximal_cursor_size (GdkDisplay *display,
      guint *width,
      guint *height);
GdkWindow *gdk_display_get_default_group (GdkDisplay *display);
gboolean gdk_display_supports_selection_notification (GdkDisplay *display);
gboolean gdk_display_request_selection_notification (GdkDisplay *display,
            GdkAtom selection);
gboolean gdk_display_supports_clipboard_persistence (GdkDisplay *display);
void gdk_display_store_clipboard (GdkDisplay *display,
           GdkWindow *clipboard_window,
           guint32 time_,
           GdkAtom *targets,
           gint n_targets);
gboolean gdk_display_supports_shapes (GdkDisplay *display);
gboolean gdk_display_supports_input_shapes (GdkDisplay *display);
gboolean gdk_display_supports_composite (GdkDisplay *display);
}
extern "C" {
typedef struct _GdkGCValues GdkGCValues;
typedef struct _GdkGCClass GdkGCClass;
typedef enum
{
  GDK_CAP_NOT_LAST,
  GDK_CAP_BUTT,
  GDK_CAP_ROUND,
  GDK_CAP_PROJECTING
} GdkCapStyle;
typedef enum
{
  GDK_SOLID,
  GDK_TILED,
  GDK_STIPPLED,
  GDK_OPAQUE_STIPPLED
} GdkFill;
typedef enum
{
  GDK_COPY,
  GDK_INVERT,
  GDK_XOR,
  GDK_CLEAR,
  GDK_AND,
  GDK_AND_REVERSE,
  GDK_AND_INVERT,
  GDK_NOOP,
  GDK_OR,
  GDK_EQUIV,
  GDK_OR_REVERSE,
  GDK_COPY_INVERT,
  GDK_OR_INVERT,
  GDK_NAND,
  GDK_NOR,
  GDK_SET
} GdkFunction;
typedef enum
{
  GDK_JOIN_MITER,
  GDK_JOIN_ROUND,
  GDK_JOIN_BEVEL
} GdkJoinStyle;
typedef enum
{
  GDK_LINE_SOLID,
  GDK_LINE_ON_OFF_DASH,
  GDK_LINE_DOUBLE_DASH
} GdkLineStyle;
typedef enum
{
  GDK_CLIP_BY_CHILDREN = 0,
  GDK_INCLUDE_INFERIORS = 1
} GdkSubwindowMode;
typedef enum
{
  GDK_GC_FOREGROUND = 1 << 0,
  GDK_GC_BACKGROUND = 1 << 1,
  GDK_GC_FONT = 1 << 2,
  GDK_GC_FUNCTION = 1 << 3,
  GDK_GC_FILL = 1 << 4,
  GDK_GC_TILE = 1 << 5,
  GDK_GC_STIPPLE = 1 << 6,
  GDK_GC_CLIP_MASK = 1 << 7,
  GDK_GC_SUBWINDOW = 1 << 8,
  GDK_GC_TS_X_ORIGIN = 1 << 9,
  GDK_GC_TS_Y_ORIGIN = 1 << 10,
  GDK_GC_CLIP_X_ORIGIN = 1 << 11,
  GDK_GC_CLIP_Y_ORIGIN = 1 << 12,
  GDK_GC_EXPOSURES = 1 << 13,
  GDK_GC_LINE_WIDTH = 1 << 14,
  GDK_GC_LINE_STYLE = 1 << 15,
  GDK_GC_CAP_STYLE = 1 << 16,
  GDK_GC_JOIN_STYLE = 1 << 17
} GdkGCValuesMask;
struct _GdkGCValues
{
  GdkColor foreground;
  GdkColor background;
  GdkFont *font;
  GdkFunction function;
  GdkFill fill;
  GdkPixmap *tile;
  GdkPixmap *stipple;
  GdkPixmap *clip_mask;
  GdkSubwindowMode subwindow_mode;
  gint ts_x_origin;
  gint ts_y_origin;
  gint clip_x_origin;
  gint clip_y_origin;
  gint graphics_exposures;
  gint line_width;
  GdkLineStyle line_style;
  GdkCapStyle cap_style;
  GdkJoinStyle join_style;
};
struct _GdkGC
{
  GObject parent_instance;
  gint clip_x_origin;
  gint clip_y_origin;
  gint ts_x_origin;
  gint ts_y_origin;
  GdkColormap *colormap;
};
struct _GdkGCClass
{
  GObjectClass parent_class;
  void (*get_values) (GdkGC *gc,
     GdkGCValues *values);
  void (*set_values) (GdkGC *gc,
     GdkGCValues *values,
     GdkGCValuesMask mask);
  void (*set_dashes) (GdkGC *gc,
     gint dash_offset,
     gint8 dash_list[],
     gint n);
  void (*_gdk_reserved1) (void);
  void (*_gdk_reserved2) (void);
  void (*_gdk_reserved3) (void);
  void (*_gdk_reserved4) (void);
};
GType gdk_gc_get_type (void) __attribute__((__const__));
GdkGC *gdk_gc_new (GdkDrawable *drawable);
GdkGC *gdk_gc_new_with_values (GdkDrawable *drawable,
       GdkGCValues *values,
       GdkGCValuesMask values_mask);
GdkGC *gdk_gc_ref (GdkGC *gc);
void gdk_gc_unref (GdkGC *gc);
void gdk_gc_get_values (GdkGC *gc,
       GdkGCValues *values);
void gdk_gc_set_values (GdkGC *gc,
                                   GdkGCValues *values,
                                   GdkGCValuesMask values_mask);
void gdk_gc_set_foreground (GdkGC *gc,
       const GdkColor *color);
void gdk_gc_set_background (GdkGC *gc,
       const GdkColor *color);
void gdk_gc_set_font (GdkGC *gc,
       GdkFont *font);
void gdk_gc_set_function (GdkGC *gc,
       GdkFunction function);
void gdk_gc_set_fill (GdkGC *gc,
       GdkFill fill);
void gdk_gc_set_tile (GdkGC *gc,
       GdkPixmap *tile);
void gdk_gc_set_stipple (GdkGC *gc,
       GdkPixmap *stipple);
void gdk_gc_set_ts_origin (GdkGC *gc,
       gint x,
       gint y);
void gdk_gc_set_clip_origin (GdkGC *gc,
       gint x,
       gint y);
void gdk_gc_set_clip_mask (GdkGC *gc,
       GdkBitmap *mask);
void gdk_gc_set_clip_rectangle (GdkGC *gc,
       GdkRectangle *rectangle);
void gdk_gc_set_clip_region (GdkGC *gc,
       GdkRegion *region);
void gdk_gc_set_subwindow (GdkGC *gc,
       GdkSubwindowMode mode);
void gdk_gc_set_exposures (GdkGC *gc,
       gboolean exposures);
void gdk_gc_set_line_attributes (GdkGC *gc,
       gint line_width,
       GdkLineStyle line_style,
       GdkCapStyle cap_style,
       GdkJoinStyle join_style);
void gdk_gc_set_dashes (GdkGC *gc,
       gint dash_offset,
       gint8 dash_list[],
       gint n);
void gdk_gc_offset (GdkGC *gc,
       gint x_offset,
       gint y_offset);
void gdk_gc_copy (GdkGC *dst_gc,
       GdkGC *src_gc);
void gdk_gc_set_colormap (GdkGC *gc,
          GdkColormap *colormap);
GdkColormap *gdk_gc_get_colormap (GdkGC *gc);
void gdk_gc_set_rgb_fg_color (GdkGC *gc,
          const GdkColor *color);
void gdk_gc_set_rgb_bg_color (GdkGC *gc,
          const GdkColor *color);
GdkScreen * gdk_gc_get_screen (GdkGC *gc);
}
extern "C" {
typedef struct _GdkDrawableClass GdkDrawableClass;
typedef struct _GdkTrapezoid GdkTrapezoid;
struct _GdkDrawable
{
  GObject parent_instance;
};
struct _GdkDrawableClass
{
  GObjectClass parent_class;
  GdkGC *(*create_gc) (GdkDrawable *drawable,
            GdkGCValues *values,
            GdkGCValuesMask mask);
  void (*draw_rectangle) (GdkDrawable *drawable,
     GdkGC *gc,
     gboolean filled,
     gint x,
     gint y,
     gint width,
     gint height);
  void (*draw_arc) (GdkDrawable *drawable,
     GdkGC *gc,
     gboolean filled,
     gint x,
     gint y,
     gint width,
     gint height,
     gint angle1,
     gint angle2);
  void (*draw_polygon) (GdkDrawable *drawable,
     GdkGC *gc,
     gboolean filled,
     GdkPoint *points,
     gint npoints);
  void (*draw_text) (GdkDrawable *drawable,
     GdkFont *font,
     GdkGC *gc,
     gint x,
     gint y,
     const gchar *text,
     gint text_length);
  void (*draw_text_wc) (GdkDrawable *drawable,
     GdkFont *font,
     GdkGC *gc,
     gint x,
     gint y,
     const GdkWChar *text,
     gint text_length);
  void (*draw_drawable) (GdkDrawable *drawable,
     GdkGC *gc,
     GdkDrawable *src,
     gint xsrc,
     gint ysrc,
     gint xdest,
     gint ydest,
     gint width,
     gint height);
  void (*draw_points) (GdkDrawable *drawable,
     GdkGC *gc,
     GdkPoint *points,
     gint npoints);
  void (*draw_segments) (GdkDrawable *drawable,
     GdkGC *gc,
     GdkSegment *segs,
     gint nsegs);
 void (*draw_lines) (GdkDrawable *drawable,
     GdkGC *gc,
     GdkPoint *points,
     gint npoints);
  void (*draw_glyphs) (GdkDrawable *drawable,
     GdkGC *gc,
     PangoFont *font,
     gint x,
     gint y,
     PangoGlyphString *glyphs);
  void (*draw_image) (GdkDrawable *drawable,
                          GdkGC *gc,
                          GdkImage *image,
                          gint xsrc,
                          gint ysrc,
                          gint xdest,
                          gint ydest,
                          gint width,
                          gint height);
  gint (*get_depth) (GdkDrawable *drawable);
  void (*get_size) (GdkDrawable *drawable,
                          gint *width,
                          gint *height);
  void (*set_colormap) (GdkDrawable *drawable,
                          GdkColormap *cmap);
  GdkColormap* (*get_colormap) (GdkDrawable *drawable);
  GdkVisual* (*get_visual) (GdkDrawable *drawable);
  GdkScreen* (*get_screen) (GdkDrawable *drawable);
  GdkImage* (*get_image) (GdkDrawable *drawable,
                              gint x,
                              gint y,
                              gint width,
                              gint height);
  GdkRegion* (*get_clip_region) (GdkDrawable *drawable);
  GdkRegion* (*get_visible_region) (GdkDrawable *drawable);
  GdkDrawable* (*get_composite_drawable) (GdkDrawable *drawable,
                                          gint x,
                                          gint y,
                                          gint width,
                                          gint height,
                                          gint *composite_x_offset,
                                          gint *composite_y_offset);
  void (*draw_pixbuf) (GdkDrawable *drawable,
          GdkGC *gc,
          GdkPixbuf *pixbuf,
          gint src_x,
          gint src_y,
          gint dest_x,
          gint dest_y,
          gint width,
          gint height,
          GdkRgbDither dither,
          gint x_dither,
          gint y_dither);
  GdkImage* (*_copy_to_image) (GdkDrawable *drawable,
      GdkImage *image,
      gint src_x,
      gint src_y,
      gint dest_x,
      gint dest_y,
      gint width,
      gint height);
  void (*draw_glyphs_transformed) (GdkDrawable *drawable,
       GdkGC *gc,
       PangoMatrix *matrix,
       PangoFont *font,
       gint x,
       gint y,
       PangoGlyphString *glyphs);
  void (*draw_trapezoids) (GdkDrawable *drawable,
       GdkGC *gc,
       GdkTrapezoid *trapezoids,
       gint n_trapezoids);
  cairo_surface_t *(*ref_cairo_surface) (GdkDrawable *drawable);
  void (*_gdk_reserved4) (void);
  void (*_gdk_reserved5) (void);
  void (*_gdk_reserved6) (void);
  void (*_gdk_reserved7) (void);
  void (*_gdk_reserved9) (void);
  void (*_gdk_reserved10) (void);
  void (*_gdk_reserved11) (void);
  void (*_gdk_reserved12) (void);
  void (*_gdk_reserved13) (void);
  void (*_gdk_reserved14) (void);
  void (*_gdk_reserved15) (void);
  void (*_gdk_reserved16) (void);
};
struct _GdkTrapezoid
{
  double y1, x11, x21, y2, x12, x22;
};
GType gdk_drawable_get_type (void) __attribute__((__const__));
void gdk_drawable_set_data (GdkDrawable *drawable,
        const gchar *key,
        gpointer data,
        GDestroyNotify destroy_func);
gpointer gdk_drawable_get_data (GdkDrawable *drawable,
        const gchar *key);
void gdk_drawable_get_size (GdkDrawable *drawable,
        gint *width,
        gint *height);
void gdk_drawable_set_colormap (GdkDrawable *drawable,
        GdkColormap *colormap);
GdkColormap* gdk_drawable_get_colormap (GdkDrawable *drawable);
GdkVisual* gdk_drawable_get_visual (GdkDrawable *drawable);
gint gdk_drawable_get_depth (GdkDrawable *drawable);
GdkScreen* gdk_drawable_get_screen (GdkDrawable *drawable);
GdkDisplay* gdk_drawable_get_display (GdkDrawable *drawable);
GdkDrawable* gdk_drawable_ref (GdkDrawable *drawable);
void gdk_drawable_unref (GdkDrawable *drawable);
void gdk_draw_point (GdkDrawable *drawable,
    GdkGC *gc,
    gint x,
    gint y);
void gdk_draw_line (GdkDrawable *drawable,
    GdkGC *gc,
    gint x1_,
    gint y1_,
    gint x2_,
    gint y2_);
void gdk_draw_rectangle (GdkDrawable *drawable,
    GdkGC *gc,
    gboolean filled,
    gint x,
    gint y,
    gint width,
    gint height);
void gdk_draw_arc (GdkDrawable *drawable,
    GdkGC *gc,
    gboolean filled,
    gint x,
    gint y,
    gint width,
    gint height,
    gint angle1,
    gint angle2);
void gdk_draw_polygon (GdkDrawable *drawable,
    GdkGC *gc,
    gboolean filled,
    GdkPoint *points,
    gint npoints);
void gdk_draw_string (GdkDrawable *drawable,
    GdkFont *font,
    GdkGC *gc,
    gint x,
    gint y,
    const gchar *string);
void gdk_draw_text (GdkDrawable *drawable,
    GdkFont *font,
    GdkGC *gc,
    gint x,
    gint y,
    const gchar *text,
    gint text_length);
void gdk_draw_text_wc (GdkDrawable *drawable,
    GdkFont *font,
    GdkGC *gc,
    gint x,
    gint y,
    const GdkWChar *text,
    gint text_length);
void gdk_draw_drawable (GdkDrawable *drawable,
    GdkGC *gc,
    GdkDrawable *src,
    gint xsrc,
    gint ysrc,
    gint xdest,
    gint ydest,
    gint width,
    gint height);
void gdk_draw_image (GdkDrawable *drawable,
    GdkGC *gc,
    GdkImage *image,
    gint xsrc,
    gint ysrc,
    gint xdest,
    gint ydest,
    gint width,
    gint height);
void gdk_draw_points (GdkDrawable *drawable,
    GdkGC *gc,
    GdkPoint *points,
    gint npoints);
void gdk_draw_segments (GdkDrawable *drawable,
    GdkGC *gc,
    GdkSegment *segs,
    gint nsegs);
void gdk_draw_lines (GdkDrawable *drawable,
    GdkGC *gc,
    GdkPoint *points,
    gint npoints);
void gdk_draw_pixbuf (GdkDrawable *drawable,
    GdkGC *gc,
    GdkPixbuf *pixbuf,
    gint src_x,
    gint src_y,
    gint dest_x,
    gint dest_y,
    gint width,
    gint height,
    GdkRgbDither dither,
    gint x_dither,
    gint y_dither);
void gdk_draw_glyphs (GdkDrawable *drawable,
      GdkGC *gc,
      PangoFont *font,
      gint x,
      gint y,
      PangoGlyphString *glyphs);
void gdk_draw_layout_line (GdkDrawable *drawable,
      GdkGC *gc,
      gint x,
      gint y,
      PangoLayoutLine *line);
void gdk_draw_layout (GdkDrawable *drawable,
      GdkGC *gc,
      gint x,
      gint y,
      PangoLayout *layout);
void gdk_draw_layout_line_with_colors (GdkDrawable *drawable,
                                       GdkGC *gc,
                                       gint x,
                                       gint y,
                                       PangoLayoutLine *line,
                                       const GdkColor *foreground,
                                       const GdkColor *background);
void gdk_draw_layout_with_colors (GdkDrawable *drawable,
                                       GdkGC *gc,
                                       gint x,
                                       gint y,
                                       PangoLayout *layout,
                                       const GdkColor *foreground,
                                       const GdkColor *background);
void gdk_draw_glyphs_transformed (GdkDrawable *drawable,
      GdkGC *gc,
      PangoMatrix *matrix,
      PangoFont *font,
      gint x,
      gint y,
      PangoGlyphString *glyphs);
void gdk_draw_trapezoids (GdkDrawable *drawable,
      GdkGC *gc,
      GdkTrapezoid *trapezoids,
      gint n_trapezoids);
GdkImage* gdk_drawable_get_image (GdkDrawable *drawable,
                                       gint x,
                                       gint y,
                                       gint width,
                                       gint height);
GdkImage *gdk_drawable_copy_to_image (GdkDrawable *drawable,
          GdkImage *image,
          gint src_x,
          gint src_y,
          gint dest_x,
          gint dest_y,
          gint width,
          gint height);
GdkRegion *gdk_drawable_get_clip_region (GdkDrawable *drawable);
GdkRegion *gdk_drawable_get_visible_region (GdkDrawable *drawable);
}
extern "C" {
GType gdk_cursor_type_get_type (void) __attribute__((__const__));
GType gdk_drag_action_get_type (void) __attribute__((__const__));
GType gdk_drag_protocol_get_type (void) __attribute__((__const__));
GType gdk_filter_return_get_type (void) __attribute__((__const__));
GType gdk_event_type_get_type (void) __attribute__((__const__));
GType gdk_event_mask_get_type (void) __attribute__((__const__));
GType gdk_visibility_state_get_type (void) __attribute__((__const__));
GType gdk_scroll_direction_get_type (void) __attribute__((__const__));
GType gdk_notify_type_get_type (void) __attribute__((__const__));
GType gdk_crossing_mode_get_type (void) __attribute__((__const__));
GType gdk_property_state_get_type (void) __attribute__((__const__));
GType gdk_window_state_get_type (void) __attribute__((__const__));
GType gdk_setting_action_get_type (void) __attribute__((__const__));
GType gdk_owner_change_get_type (void) __attribute__((__const__));
GType gdk_font_type_get_type (void) __attribute__((__const__));
GType gdk_cap_style_get_type (void) __attribute__((__const__));
GType gdk_fill_get_type (void) __attribute__((__const__));
GType gdk_function_get_type (void) __attribute__((__const__));
GType gdk_join_style_get_type (void) __attribute__((__const__));
GType gdk_line_style_get_type (void) __attribute__((__const__));
GType gdk_subwindow_mode_get_type (void) __attribute__((__const__));
GType gdk_gc_values_mask_get_type (void) __attribute__((__const__));
GType gdk_image_type_get_type (void) __attribute__((__const__));
GType gdk_extension_mode_get_type (void) __attribute__((__const__));
GType gdk_input_source_get_type (void) __attribute__((__const__));
GType gdk_input_mode_get_type (void) __attribute__((__const__));
GType gdk_axis_use_get_type (void) __attribute__((__const__));
GType gdk_prop_mode_get_type (void) __attribute__((__const__));
GType gdk_fill_rule_get_type (void) __attribute__((__const__));
GType gdk_overlap_type_get_type (void) __attribute__((__const__));
GType gdk_rgb_dither_get_type (void) __attribute__((__const__));
GType gdk_byte_order_get_type (void) __attribute__((__const__));
GType gdk_modifier_type_get_type (void) __attribute__((__const__));
GType gdk_input_condition_get_type (void) __attribute__((__const__));
GType gdk_status_get_type (void) __attribute__((__const__));
GType gdk_grab_status_get_type (void) __attribute__((__const__));
GType gdk_visual_type_get_type (void) __attribute__((__const__));
GType gdk_window_class_get_type (void) __attribute__((__const__));
GType gdk_window_type_get_type (void) __attribute__((__const__));
GType gdk_window_attributes_type_get_type (void) __attribute__((__const__));
GType gdk_window_hints_get_type (void) __attribute__((__const__));
GType gdk_window_type_hint_get_type (void) __attribute__((__const__));
GType gdk_wm_decoration_get_type (void) __attribute__((__const__));
GType gdk_wm_function_get_type (void) __attribute__((__const__));
GType gdk_gravity_get_type (void) __attribute__((__const__));
GType gdk_window_edge_get_type (void) __attribute__((__const__));
}
extern "C" {
typedef enum
{
  GDK_FONT_FONT,
  GDK_FONT_FONTSET
} GdkFontType;
struct _GdkFont
{
  GdkFontType type;
  gint ascent;
  gint descent;
};
GType gdk_font_get_type (void) __attribute__((__const__));
GdkFont* gdk_font_ref (GdkFont *font);
void gdk_font_unref (GdkFont *font);
gint gdk_font_id (const GdkFont *font);
gboolean gdk_font_equal (const GdkFont *fonta,
        const GdkFont *fontb);
GdkFont *gdk_font_load_for_display (GdkDisplay *display,
      const gchar *font_name);
GdkFont *gdk_fontset_load_for_display (GdkDisplay *display,
      const gchar *fontset_name);
GdkFont *gdk_font_from_description_for_display (GdkDisplay *display,
      PangoFontDescription *font_desc);
GdkFont* gdk_font_load (const gchar *font_name);
GdkFont* gdk_fontset_load (const gchar *fontset_name);
GdkFont* gdk_font_from_description (PangoFontDescription *font_desc);
gint gdk_string_width (GdkFont *font,
        const gchar *string);
gint gdk_text_width (GdkFont *font,
        const gchar *text,
        gint text_length);
gint gdk_text_width_wc (GdkFont *font,
        const GdkWChar *text,
        gint text_length);
gint gdk_char_width (GdkFont *font,
        gchar character);
gint gdk_char_width_wc (GdkFont *font,
        GdkWChar character);
gint gdk_string_measure (GdkFont *font,
        const gchar *string);
gint gdk_text_measure (GdkFont *font,
        const gchar *text,
        gint text_length);
gint gdk_char_measure (GdkFont *font,
        gchar character);
gint gdk_string_height (GdkFont *font,
        const gchar *string);
gint gdk_text_height (GdkFont *font,
        const gchar *text,
        gint text_length);
gint gdk_char_height (GdkFont *font,
        gchar character);
void gdk_text_extents (GdkFont *font,
        const gchar *text,
        gint text_length,
        gint *lbearing,
        gint *rbearing,
        gint *width,
        gint *ascent,
        gint *descent);
void gdk_text_extents_wc (GdkFont *font,
        const GdkWChar *text,
        gint text_length,
        gint *lbearing,
        gint *rbearing,
        gint *width,
        gint *ascent,
        gint *descent);
void gdk_string_extents (GdkFont *font,
        const gchar *string,
        gint *lbearing,
        gint *rbearing,
        gint *width,
        gint *ascent,
        gint *descent);
GdkDisplay * gdk_font_get_display (GdkFont *font);
}
extern "C" {
typedef enum
{
  GDK_IMAGE_NORMAL,
  GDK_IMAGE_SHARED,
  GDK_IMAGE_FASTEST
} GdkImageType;
typedef struct _GdkImageClass GdkImageClass;
struct _GdkImage
{
  GObject parent_instance;
  GdkImageType type;
  GdkVisual *visual;
  GdkByteOrder byte_order;
  gint width;
  gint height;
  guint16 depth;
  guint16 bpp;
  guint16 bpl;
  guint16 bits_per_pixel;
  gpointer mem;
  GdkColormap *colormap;
  gpointer windowing_data;
};
struct _GdkImageClass
{
  GObjectClass parent_class;
};
GType gdk_image_get_type (void) __attribute__((__const__));
GdkImage* gdk_image_new (GdkImageType type,
    GdkVisual *visual,
    gint width,
    gint height);
GdkImage* gdk_image_get (GdkDrawable *drawable,
    gint x,
    gint y,
    gint width,
    gint height);
GdkImage * gdk_image_ref (GdkImage *image);
void gdk_image_unref (GdkImage *image);
void gdk_image_put_pixel (GdkImage *image,
    gint x,
    gint y,
    guint32 pixel);
guint32 gdk_image_get_pixel (GdkImage *image,
    gint x,
    gint y);
void gdk_image_set_colormap (GdkImage *image,
                                   GdkColormap *colormap);
GdkColormap* gdk_image_get_colormap (GdkImage *image);
}
extern "C" {
typedef struct _GdkKeymapKey GdkKeymapKey;
struct _GdkKeymapKey
{
  guint keycode;
  gint group;
  gint level;
};
typedef struct _GdkKeymap GdkKeymap;
typedef struct _GdkKeymapClass GdkKeymapClass;
struct _GdkKeymap
{
  GObject parent_instance;
  GdkDisplay *display;
};
struct _GdkKeymapClass
{
  GObjectClass parent_class;
  void (*direction_changed) (GdkKeymap *keymap);
  void (*keys_changed) (GdkKeymap *keymap);
};
GType gdk_keymap_get_type (void) __attribute__((__const__));
GdkKeymap* gdk_keymap_get_default (void);
GdkKeymap* gdk_keymap_get_for_display (GdkDisplay *display);
guint gdk_keymap_lookup_key (GdkKeymap *keymap,
          const GdkKeymapKey *key);
gboolean gdk_keymap_translate_keyboard_state (GdkKeymap *keymap,
          guint hardware_keycode,
          GdkModifierType state,
          gint group,
          guint *keyval,
          gint *effective_group,
          gint *level,
          GdkModifierType *consumed_modifiers);
gboolean gdk_keymap_get_entries_for_keyval (GdkKeymap *keymap,
          guint keyval,
          GdkKeymapKey **keys,
          gint *n_keys);
gboolean gdk_keymap_get_entries_for_keycode (GdkKeymap *keymap,
          guint hardware_keycode,
          GdkKeymapKey **keys,
          guint **keyvals,
          gint *n_entries);
PangoDirection gdk_keymap_get_direction (GdkKeymap *keymap);
gboolean gdk_keymap_have_bidi_layouts (GdkKeymap *keymap);
gchar* gdk_keyval_name (guint keyval) __attribute__((__const__));
guint gdk_keyval_from_name (const gchar *keyval_name);
void gdk_keyval_convert_case (guint symbol,
      guint *lower,
      guint *upper);
guint gdk_keyval_to_upper (guint keyval) __attribute__((__const__));
guint gdk_keyval_to_lower (guint keyval) __attribute__((__const__));
gboolean gdk_keyval_is_upper (guint keyval) __attribute__((__const__));
gboolean gdk_keyval_is_lower (guint keyval) __attribute__((__const__));
guint32 gdk_keyval_to_unicode (guint keyval) __attribute__((__const__));
guint gdk_unicode_to_keyval (guint32 wc) __attribute__((__const__));
}
extern "C" {
typedef struct _GdkDisplayManager GdkDisplayManager;
typedef struct _GdkDisplayManagerClass GdkDisplayManagerClass;
struct _GdkDisplayManagerClass
{
  GObjectClass parent_class;
  void (*display_opened) (GdkDisplayManager *display_manager,
     GdkDisplay *display);
};
GType gdk_display_manager_get_type (void) __attribute__((__const__));
GdkDisplayManager *gdk_display_manager_get (void);
GdkDisplay * gdk_display_manager_get_default_display (GdkDisplayManager *display_manager);
void gdk_display_manager_set_default_display (GdkDisplayManager *display_manager,
           GdkDisplay *display);
GSList * gdk_display_manager_list_displays (GdkDisplayManager *display_manager);
}
extern "C" {
typedef struct _GdkPangoRenderer GdkPangoRenderer;
typedef struct _GdkPangoRendererClass GdkPangoRendererClass;
typedef struct _GdkPangoRendererPrivate GdkPangoRendererPrivate;
struct _GdkPangoRenderer
{
  PangoRenderer parent_instance;
  GdkPangoRendererPrivate *priv;
};
struct _GdkPangoRendererClass
{
  PangoRendererClass parent_class;
};
GType gdk_pango_renderer_get_type (void) __attribute__((__const__));
PangoRenderer *gdk_pango_renderer_new (GdkScreen *screen);
PangoRenderer *gdk_pango_renderer_get_default (GdkScreen *screen);
void gdk_pango_renderer_set_drawable (GdkPangoRenderer *gdk_renderer,
         GdkDrawable *drawable);
void gdk_pango_renderer_set_gc (GdkPangoRenderer *gdk_renderer,
         GdkGC *gc);
void gdk_pango_renderer_set_stipple (GdkPangoRenderer *gdk_renderer,
         PangoRenderPart part,
         GdkBitmap *stipple);
void gdk_pango_renderer_set_override_color (GdkPangoRenderer *gdk_renderer,
         PangoRenderPart part,
         const GdkColor *color);
PangoContext *gdk_pango_context_get_for_screen (GdkScreen *screen);
PangoContext *gdk_pango_context_get (void);
void gdk_pango_context_set_colormap (PangoContext *context,
                                                GdkColormap *colormap);
GdkRegion *gdk_pango_layout_line_get_clip_region (PangoLayoutLine *line,
                                                     gint x_origin,
                                                     gint y_origin,
                                                     gint *index_ranges,
                                                     gint n_ranges);
GdkRegion *gdk_pango_layout_get_clip_region (PangoLayout *layout,
                                                     gint x_origin,
                                                     gint y_origin,
                                                     gint *index_ranges,
                                                     gint n_ranges);
typedef struct _GdkPangoAttrStipple GdkPangoAttrStipple;
typedef struct _GdkPangoAttrEmbossed GdkPangoAttrEmbossed;
typedef struct _GdkPangoAttrEmbossColor GdkPangoAttrEmbossColor;
struct _GdkPangoAttrStipple
{
  PangoAttribute attr;
  GdkBitmap *stipple;
};
struct _GdkPangoAttrEmbossed
{
  PangoAttribute attr;
  gboolean embossed;
};
struct _GdkPangoAttrEmbossColor
{
  PangoAttribute attr;
  PangoColor color;
};
PangoAttribute *gdk_pango_attr_stipple_new (GdkBitmap *stipple);
PangoAttribute *gdk_pango_attr_embossed_new (gboolean embossed);
PangoAttribute *gdk_pango_attr_emboss_color_new (const GdkColor *color);
}
extern "C" {
typedef struct _GdkPixmapObject GdkPixmapObject;
typedef struct _GdkPixmapObjectClass GdkPixmapObjectClass;
struct _GdkPixmapObject
{
  GdkDrawable parent_instance;
  GdkDrawable *impl;
  gint depth;
};
struct _GdkPixmapObjectClass
{
  GdkDrawableClass parent_class;
};
GType gdk_pixmap_get_type (void) __attribute__((__const__));
GdkPixmap* gdk_pixmap_new (GdkDrawable *drawable,
      gint width,
      gint height,
      gint depth);
GdkBitmap* gdk_bitmap_create_from_data (GdkDrawable *drawable,
      const gchar *data,
      gint width,
      gint height);
GdkPixmap* gdk_pixmap_create_from_data (GdkDrawable *drawable,
      const gchar *data,
      gint width,
      gint height,
      gint depth,
      const GdkColor *fg,
      const GdkColor *bg);
GdkPixmap* gdk_pixmap_create_from_xpm (GdkDrawable *drawable,
        GdkBitmap **mask,
        const GdkColor *transparent_color,
        const gchar *filename);
GdkPixmap* gdk_pixmap_colormap_create_from_xpm (GdkDrawable *drawable,
        GdkColormap *colormap,
        GdkBitmap **mask,
        const GdkColor *transparent_color,
        const gchar *filename);
GdkPixmap* gdk_pixmap_create_from_xpm_d (GdkDrawable *drawable,
        GdkBitmap **mask,
        const GdkColor *transparent_color,
        gchar **data);
GdkPixmap* gdk_pixmap_colormap_create_from_xpm_d (GdkDrawable *drawable,
        GdkColormap *colormap,
        GdkBitmap **mask,
        const GdkColor *transparent_color,
        gchar **data);
GdkPixmap* gdk_pixmap_foreign_new (GdkNativeWindow anid);
GdkPixmap* gdk_pixmap_lookup (GdkNativeWindow anid);
GdkPixmap* gdk_pixmap_foreign_new_for_display (GdkDisplay *display,
        GdkNativeWindow anid);
GdkPixmap* gdk_pixmap_lookup_for_display (GdkDisplay *display,
        GdkNativeWindow anid);
GdkPixmap* gdk_pixmap_foreign_new_for_screen (GdkScreen *screen,
        GdkNativeWindow anid,
        gint width,
                                                  gint height,
                                                  gint depth);
}
extern "C" {
typedef enum
{
  GDK_PROP_MODE_REPLACE,
  GDK_PROP_MODE_PREPEND,
  GDK_PROP_MODE_APPEND
} GdkPropMode;
GdkAtom gdk_atom_intern (const gchar *atom_name,
    gboolean only_if_exists);
GdkAtom gdk_atom_intern_static_string (const gchar *atom_name);
gchar* gdk_atom_name (GdkAtom atom);
gboolean gdk_property_get (GdkWindow *window,
         GdkAtom property,
         GdkAtom type,
         gulong offset,
         gulong length,
         gint pdelete,
         GdkAtom *actual_property_type,
         gint *actual_format,
         gint *actual_length,
         guchar **data);
void gdk_property_change (GdkWindow *window,
         GdkAtom property,
         GdkAtom type,
         gint format,
         GdkPropMode mode,
         const guchar *data,
         gint nelements);
void gdk_property_delete (GdkWindow *window,
         GdkAtom property);
gint gdk_text_property_to_text_list (GdkAtom encoding,
         gint format,
         const guchar *text,
         gint length,
         gchar ***list);
gint gdk_text_property_to_utf8_list (GdkAtom encoding,
         gint format,
         const guchar *text,
         gint length,
         gchar ***list);
gboolean gdk_utf8_to_compound_text (const gchar *str,
        GdkAtom *encoding,
        gint *format,
        guchar **ctext,
        gint *length);
gint gdk_string_to_compound_text (const gchar *str,
         GdkAtom *encoding,
         gint *format,
         guchar **ctext,
         gint *length);
gint gdk_text_property_to_text_list_for_display (GdkDisplay *display,
       GdkAtom encoding,
       gint format,
       const guchar *text,
       gint length,
       gchar ***list);
gint gdk_text_property_to_utf8_list_for_display (GdkDisplay *display,
       GdkAtom encoding,
       gint format,
       const guchar *text,
       gint length,
       gchar ***list);
gchar *gdk_utf8_to_string_target (const gchar *str);
gint gdk_string_to_compound_text_for_display (GdkDisplay *display,
        const gchar *str,
        GdkAtom *encoding,
        gint *format,
        guchar **ctext,
        gint *length);
gboolean gdk_utf8_to_compound_text_for_display (GdkDisplay *display,
        const gchar *str,
        GdkAtom *encoding,
        gint *format,
        guchar **ctext,
        gint *length);
void gdk_free_text_list (gchar **list);
void gdk_free_compound_text (guchar *ctext);
}
extern "C" {
typedef enum
{
  GDK_EVEN_ODD_RULE,
  GDK_WINDING_RULE
} GdkFillRule;
typedef enum
{
  GDK_OVERLAP_RECTANGLE_IN,
  GDK_OVERLAP_RECTANGLE_OUT,
  GDK_OVERLAP_RECTANGLE_PART
} GdkOverlapType;
typedef void (*GdkSpanFunc) (GdkSpan *span,
        gpointer data);
GdkRegion *gdk_region_new (void);
GdkRegion *gdk_region_polygon (GdkPoint *points,
     gint npoints,
     GdkFillRule fill_rule);
GdkRegion *gdk_region_copy (GdkRegion *region);
GdkRegion *gdk_region_rectangle (GdkRectangle *rectangle);
void gdk_region_destroy (GdkRegion *region);
void gdk_region_get_clipbox (GdkRegion *region,
                                          GdkRectangle *rectangle);
void gdk_region_get_rectangles (GdkRegion *region,
                                          GdkRectangle **rectangles,
                                          gint *n_rectangles);
gboolean gdk_region_empty (GdkRegion *region);
gboolean gdk_region_equal (GdkRegion *region1,
        GdkRegion *region2);
gboolean gdk_region_point_in (GdkRegion *region,
        int x,
        int y);
GdkOverlapType gdk_region_rect_in (GdkRegion *region,
        GdkRectangle *rectangle);
void gdk_region_offset (GdkRegion *region,
     gint dx,
     gint dy);
void gdk_region_shrink (GdkRegion *region,
     gint dx,
     gint dy);
void gdk_region_union_with_rect (GdkRegion *region,
     GdkRectangle *rect);
void gdk_region_intersect (GdkRegion *source1,
     GdkRegion *source2);
void gdk_region_union (GdkRegion *source1,
      GdkRegion *source2);
void gdk_region_subtract (GdkRegion *source1,
     GdkRegion *source2);
void gdk_region_xor (GdkRegion *source1,
     GdkRegion *source2);
void gdk_region_spans_intersect_foreach (GdkRegion *region,
      GdkSpan *spans,
      int n_spans,
      gboolean sorted,
      GdkSpanFunc function,
      gpointer data);
}
extern "C" {
typedef struct _GdkScreenClass GdkScreenClass;
struct _GdkScreen
{
  GObject parent_instance;
  guint closed : 1;
  GdkGC *normal_gcs[32];
  GdkGC *exposure_gcs[32];
  cairo_font_options_t *font_options;
  double resolution;
};
struct _GdkScreenClass
{
  GObjectClass parent_class;
  void (*size_changed) (GdkScreen *screen);
  void (*composited_changed) (GdkScreen *screen);
};
GType gdk_screen_get_type (void) __attribute__((__const__));
GdkColormap *gdk_screen_get_default_colormap (GdkScreen *screen);
void gdk_screen_set_default_colormap (GdkScreen *screen,
            GdkColormap *colormap);
GdkColormap* gdk_screen_get_system_colormap (GdkScreen *screen);
GdkVisual* gdk_screen_get_system_visual (GdkScreen *screen);
GdkColormap *gdk_screen_get_rgb_colormap (GdkScreen *screen);
GdkVisual * gdk_screen_get_rgb_visual (GdkScreen *screen);
GdkColormap *gdk_screen_get_rgba_colormap (GdkScreen *screen);
GdkVisual * gdk_screen_get_rgba_visual (GdkScreen *screen);
gboolean gdk_screen_is_composited (GdkScreen *screen);
GdkWindow * gdk_screen_get_root_window (GdkScreen *screen);
GdkDisplay * gdk_screen_get_display (GdkScreen *screen);
gint gdk_screen_get_number (GdkScreen *screen);
gint gdk_screen_get_width (GdkScreen *screen);
gint gdk_screen_get_height (GdkScreen *screen);
gint gdk_screen_get_width_mm (GdkScreen *screen);
gint gdk_screen_get_height_mm (GdkScreen *screen);
GList * gdk_screen_list_visuals (GdkScreen *screen);
GList * gdk_screen_get_toplevel_windows (GdkScreen *screen);
gchar * gdk_screen_make_display_name (GdkScreen *screen);
gint gdk_screen_get_n_monitors (GdkScreen *screen);
void gdk_screen_get_monitor_geometry (GdkScreen *screen,
      gint monitor_num,
      GdkRectangle *dest);
gint gdk_screen_get_monitor_at_point (GdkScreen *screen,
      gint x,
      gint y);
gint gdk_screen_get_monitor_at_window (GdkScreen *screen,
      GdkWindow *window);
void gdk_screen_broadcast_client_message (GdkScreen *screen,
          GdkEvent *event);
GdkScreen *gdk_screen_get_default (void);
gboolean gdk_screen_get_setting (GdkScreen *screen,
       const gchar *name,
       GValue *value);
void gdk_screen_set_font_options (GdkScreen *screen,
        const cairo_font_options_t *options);
const cairo_font_options_t *gdk_screen_get_font_options (GdkScreen *screen);
void gdk_screen_set_resolution (GdkScreen *screen,
       gdouble dpi);
gdouble gdk_screen_get_resolution (GdkScreen *screen);
GdkWindow *gdk_screen_get_active_window (GdkScreen *screen);
GList *gdk_screen_get_window_stack (GdkScreen *screen);
}
extern "C" {
typedef GdkAtom GdkSelection;
typedef GdkAtom GdkTarget;
typedef GdkAtom GdkSelectionType;
gboolean gdk_selection_owner_set (GdkWindow *owner,
        GdkAtom selection,
        guint32 time_,
        gboolean send_event);
GdkWindow* gdk_selection_owner_get (GdkAtom selection);
gboolean gdk_selection_owner_set_for_display (GdkDisplay *display,
      GdkWindow *owner,
      GdkAtom selection,
      guint32 time_,
      gboolean send_event);
GdkWindow *gdk_selection_owner_get_for_display (GdkDisplay *display,
      GdkAtom selection);
void gdk_selection_convert (GdkWindow *requestor,
        GdkAtom selection,
        GdkAtom target,
        guint32 time_);
gboolean gdk_selection_property_get (GdkWindow *requestor,
           guchar **data,
           GdkAtom *prop_type,
           gint *prop_format);
void gdk_selection_send_notify (guint32 requestor,
          GdkAtom selection,
          GdkAtom target,
          GdkAtom property,
          guint32 time_);
void gdk_selection_send_notify_for_display (GdkDisplay *display,
        guint32 requestor,
        GdkAtom selection,
        GdkAtom target,
        GdkAtom property,
        guint32 time_);
}
extern "C" {
gboolean gdk_spawn_on_screen (GdkScreen *screen,
        const gchar *working_directory,
        gchar **argv,
        gchar **envp,
        GSpawnFlags flags,
        GSpawnChildSetupFunc child_setup,
        gpointer user_data,
        gint *child_pid,
        GError **error);
gboolean gdk_spawn_on_screen_with_pipes (GdkScreen *screen,
        const gchar *working_directory,
        gchar **argv,
        gchar **envp,
        GSpawnFlags flags,
        GSpawnChildSetupFunc child_setup,
        gpointer user_data,
        gint *child_pid,
        gint *standard_input,
        gint *standard_output,
        gint *standard_error,
        GError **error);
gboolean gdk_spawn_command_line_on_screen (GdkScreen *screen,
        const gchar *command_line,
        GError **error);
}
extern "C" {
typedef struct _GdkVisualClass GdkVisualClass;
typedef enum
{
  GDK_VISUAL_STATIC_GRAY,
  GDK_VISUAL_GRAYSCALE,
  GDK_VISUAL_STATIC_COLOR,
  GDK_VISUAL_PSEUDO_COLOR,
  GDK_VISUAL_TRUE_COLOR,
  GDK_VISUAL_DIRECT_COLOR
} GdkVisualType;
struct _GdkVisual
{
  GObject parent_instance;
  GdkVisualType type;
  gint depth;
  GdkByteOrder byte_order;
  gint colormap_size;
  gint bits_per_rgb;
  guint32 red_mask;
  gint red_shift;
  gint red_prec;
  guint32 green_mask;
  gint green_shift;
  gint green_prec;
  guint32 blue_mask;
  gint blue_shift;
  gint blue_prec;
};
GType gdk_visual_get_type (void) __attribute__((__const__));
gint gdk_visual_get_best_depth (void);
GdkVisualType gdk_visual_get_best_type (void);
GdkVisual* gdk_visual_get_system (void);
GdkVisual* gdk_visual_get_best (void);
GdkVisual* gdk_visual_get_best_with_depth (gint depth);
GdkVisual* gdk_visual_get_best_with_type (GdkVisualType visual_type);
GdkVisual* gdk_visual_get_best_with_both (gint depth,
           GdkVisualType visual_type);
void gdk_query_depths (gint **depths,
        gint *count);
void gdk_query_visual_types (GdkVisualType **visual_types,
        gint *count);
GList* gdk_list_visuals (void);
GdkScreen *gdk_visual_get_screen (GdkVisual *visual);
}
extern "C" {
typedef struct _GdkGeometry GdkGeometry;
typedef struct _GdkWindowAttr GdkWindowAttr;
typedef struct _GdkPointerHooks GdkPointerHooks;
typedef enum
{
  GDK_INPUT_OUTPUT,
  GDK_INPUT_ONLY
} GdkWindowClass;
typedef enum
{
  GDK_WINDOW_ROOT,
  GDK_WINDOW_TOPLEVEL,
  GDK_WINDOW_CHILD,
  GDK_WINDOW_DIALOG,
  GDK_WINDOW_TEMP,
  GDK_WINDOW_FOREIGN
} GdkWindowType;
typedef enum
{
  GDK_WA_TITLE = 1 << 1,
  GDK_WA_X = 1 << 2,
  GDK_WA_Y = 1 << 3,
  GDK_WA_CURSOR = 1 << 4,
  GDK_WA_COLORMAP = 1 << 5,
  GDK_WA_VISUAL = 1 << 6,
  GDK_WA_WMCLASS = 1 << 7,
  GDK_WA_NOREDIR = 1 << 8,
  GDK_WA_TYPE_HINT = 1 << 9
} GdkWindowAttributesType;
typedef enum
{
  GDK_HINT_POS = 1 << 0,
  GDK_HINT_MIN_SIZE = 1 << 1,
  GDK_HINT_MAX_SIZE = 1 << 2,
  GDK_HINT_BASE_SIZE = 1 << 3,
  GDK_HINT_ASPECT = 1 << 4,
  GDK_HINT_RESIZE_INC = 1 << 5,
  GDK_HINT_WIN_GRAVITY = 1 << 6,
  GDK_HINT_USER_POS = 1 << 7,
  GDK_HINT_USER_SIZE = 1 << 8
} GdkWindowHints;
typedef enum
{
  GDK_WINDOW_TYPE_HINT_NORMAL,
  GDK_WINDOW_TYPE_HINT_DIALOG,
  GDK_WINDOW_TYPE_HINT_MENU,
  GDK_WINDOW_TYPE_HINT_TOOLBAR,
  GDK_WINDOW_TYPE_HINT_SPLASHSCREEN,
  GDK_WINDOW_TYPE_HINT_UTILITY,
  GDK_WINDOW_TYPE_HINT_DOCK,
  GDK_WINDOW_TYPE_HINT_DESKTOP,
  GDK_WINDOW_TYPE_HINT_DROPDOWN_MENU,
  GDK_WINDOW_TYPE_HINT_POPUP_MENU,
  GDK_WINDOW_TYPE_HINT_TOOLTIP,
  GDK_WINDOW_TYPE_HINT_NOTIFICATION,
  GDK_WINDOW_TYPE_HINT_COMBO,
  GDK_WINDOW_TYPE_HINT_DND
} GdkWindowTypeHint;
typedef enum
{
  GDK_DECOR_ALL = 1 << 0,
  GDK_DECOR_BORDER = 1 << 1,
  GDK_DECOR_RESIZEH = 1 << 2,
  GDK_DECOR_TITLE = 1 << 3,
  GDK_DECOR_MENU = 1 << 4,
  GDK_DECOR_MINIMIZE = 1 << 5,
  GDK_DECOR_MAXIMIZE = 1 << 6
} GdkWMDecoration;
typedef enum
{
  GDK_FUNC_ALL = 1 << 0,
  GDK_FUNC_RESIZE = 1 << 1,
  GDK_FUNC_MOVE = 1 << 2,
  GDK_FUNC_MINIMIZE = 1 << 3,
  GDK_FUNC_MAXIMIZE = 1 << 4,
  GDK_FUNC_CLOSE = 1 << 5
} GdkWMFunction;
typedef enum
{
  GDK_GRAVITY_NORTH_WEST = 1,
  GDK_GRAVITY_NORTH,
  GDK_GRAVITY_NORTH_EAST,
  GDK_GRAVITY_WEST,
  GDK_GRAVITY_CENTER,
  GDK_GRAVITY_EAST,
  GDK_GRAVITY_SOUTH_WEST,
  GDK_GRAVITY_SOUTH,
  GDK_GRAVITY_SOUTH_EAST,
  GDK_GRAVITY_STATIC
} GdkGravity;
typedef enum
{
  GDK_WINDOW_EDGE_NORTH_WEST,
  GDK_WINDOW_EDGE_NORTH,
  GDK_WINDOW_EDGE_NORTH_EAST,
  GDK_WINDOW_EDGE_WEST,
  GDK_WINDOW_EDGE_EAST,
  GDK_WINDOW_EDGE_SOUTH_WEST,
  GDK_WINDOW_EDGE_SOUTH,
  GDK_WINDOW_EDGE_SOUTH_EAST
} GdkWindowEdge;
struct _GdkWindowAttr
{
  gchar *title;
  gint event_mask;
  gint x, y;
  gint width;
  gint height;
  GdkWindowClass wclass;
  GdkVisual *visual;
  GdkColormap *colormap;
  GdkWindowType window_type;
  GdkCursor *cursor;
  gchar *wmclass_name;
  gchar *wmclass_class;
  gboolean override_redirect;
  GdkWindowTypeHint type_hint;
};
struct _GdkGeometry
{
  gint min_width;
  gint min_height;
  gint max_width;
  gint max_height;
  gint base_width;
  gint base_height;
  gint width_inc;
  gint height_inc;
  gdouble min_aspect;
  gdouble max_aspect;
  GdkGravity win_gravity;
};
struct _GdkPointerHooks
{
  GdkWindow* (*get_pointer) (GdkWindow *window,
              gint *x,
              gint *y,
              GdkModifierType *mask);
  GdkWindow* (*window_at_pointer) (GdkScreen *screen,
                                   gint *win_x,
                                   gint *win_y);
};
typedef struct _GdkWindowObject GdkWindowObject;
typedef struct _GdkWindowObjectClass GdkWindowObjectClass;
struct _GdkWindowObject
{
  GdkDrawable parent_instance;
  GdkDrawable *impl;
  GdkWindowObject *parent;
  gpointer user_data;
  gint x;
  gint y;
  gint extension_events;
  GList *filters;
  GList *children;
  GdkColor bg_color;
  GdkPixmap *bg_pixmap;
  GSList *paint_stack;
  GdkRegion *update_area;
  guint update_freeze_count;
  guint8 window_type;
  guint8 depth;
  guint8 resize_count;
  GdkWindowState state;
  guint guffaw_gravity : 1;
  guint input_only : 1;
  guint modal_hint : 1;
  guint composited : 1;
  guint destroyed : 2;
  guint accept_focus : 1;
  guint focus_on_map : 1;
  guint shaped : 1;
  GdkEventMask event_mask;
  guint update_and_descendants_freeze_count;
};
struct _GdkWindowObjectClass
{
  GdkDrawableClass parent_class;
};
GType gdk_window_object_get_type (void) __attribute__((__const__));
GdkWindow* gdk_window_new (GdkWindow *parent,
                                                GdkWindowAttr *attributes,
                                                gint attributes_mask);
void gdk_window_destroy (GdkWindow *window);
GdkWindowType gdk_window_get_window_type (GdkWindow *window);
GdkWindow* gdk_window_at_pointer (gint *win_x,
                                                gint *win_y);
void gdk_window_show (GdkWindow *window);
void gdk_window_hide (GdkWindow *window);
void gdk_window_withdraw (GdkWindow *window);
void gdk_window_show_unraised (GdkWindow *window);
void gdk_window_move (GdkWindow *window,
                                                gint x,
                                                gint y);
void gdk_window_resize (GdkWindow *window,
                                                gint width,
                                                gint height);
void gdk_window_move_resize (GdkWindow *window,
                                                gint x,
                                                gint y,
                                                gint width,
                                                gint height);
void gdk_window_reparent (GdkWindow *window,
                                                GdkWindow *new_parent,
                                                gint x,
                                                gint y);
void gdk_window_clear (GdkWindow *window);
void gdk_window_clear_area (GdkWindow *window,
                                                gint x,
                                                gint y,
                                                gint width,
                                                gint height);
void gdk_window_clear_area_e (GdkWindow *window,
                                                gint x,
                                                gint y,
                                                gint width,
                                                gint height);
void gdk_window_raise (GdkWindow *window);
void gdk_window_lower (GdkWindow *window);
void gdk_window_focus (GdkWindow *window,
                                                guint32 timestamp);
void gdk_window_set_user_data (GdkWindow *window,
                                                gpointer user_data);
void gdk_window_set_override_redirect (GdkWindow *window,
                                                gboolean override_redirect);
void gdk_window_set_accept_focus (GdkWindow *window,
             gboolean accept_focus);
void gdk_window_set_focus_on_map (GdkWindow *window,
             gboolean focus_on_map);
void gdk_window_add_filter (GdkWindow *window,
                                                GdkFilterFunc function,
                                                gpointer data);
void gdk_window_remove_filter (GdkWindow *window,
                                                GdkFilterFunc function,
                                                gpointer data);
void gdk_window_scroll (GdkWindow *window,
                                                gint dx,
                                                gint dy);
void gdk_window_move_region (GdkWindow *window,
      GdkRegion *region,
      gint dx,
      gint dy);
void gdk_window_shape_combine_mask (GdkWindow *window,
                                     GdkBitmap *mask,
                                     gint x,
                                     gint y);
void gdk_window_shape_combine_region (GdkWindow *window,
                                      GdkRegion *shape_region,
                                      gint offset_x,
                                      gint offset_y);
void gdk_window_set_child_shapes (GdkWindow *window);
void gdk_window_set_composited (GdkWindow *window,
                                  gboolean composited);
void gdk_window_merge_child_shapes (GdkWindow *window);
void gdk_window_input_shape_combine_mask (GdkWindow *window,
         GdkBitmap *mask,
         gint x,
         gint y);
void gdk_window_input_shape_combine_region (GdkWindow *window,
                                            GdkRegion *shape_region,
                                            gint offset_x,
                                            gint offset_y);
void gdk_window_set_child_input_shapes (GdkWindow *window);
void gdk_window_merge_child_input_shapes (GdkWindow *window);
gboolean gdk_window_is_visible (GdkWindow *window);
gboolean gdk_window_is_viewable (GdkWindow *window);
GdkWindowState gdk_window_get_state (GdkWindow *window);
gboolean gdk_window_set_static_gravities (GdkWindow *window,
       gboolean use_static);
GdkWindow* gdk_window_foreign_new (GdkNativeWindow anid);
GdkWindow* gdk_window_lookup (GdkNativeWindow anid);
GdkWindow *gdk_window_foreign_new_for_display (GdkDisplay *display,
        GdkNativeWindow anid);
GdkWindow* gdk_window_lookup_for_display (GdkDisplay *display,
          GdkNativeWindow anid);
void gdk_window_set_hints (GdkWindow *window,
       gint x,
       gint y,
       gint min_width,
       gint min_height,
       gint max_width,
       gint max_height,
       gint flags);
void gdk_window_set_type_hint (GdkWindow *window,
                                            GdkWindowTypeHint hint);
GdkWindowTypeHint gdk_window_get_type_hint (GdkWindow *window);
void gdk_window_set_modal_hint (GdkWindow *window,
                                           gboolean modal);
void gdk_window_set_skip_taskbar_hint (GdkWindow *window,
                                       gboolean skips_taskbar);
void gdk_window_set_skip_pager_hint (GdkWindow *window,
                                       gboolean skips_pager);
void gdk_window_set_urgency_hint (GdkWindow *window,
           gboolean urgent);
void gdk_window_set_geometry_hints (GdkWindow *window,
          GdkGeometry *geometry,
          GdkWindowHints geom_mask);
void gdk_set_sm_client_id (const gchar *sm_client_id);
void gdk_window_begin_paint_rect (GdkWindow *window,
          GdkRectangle *rectangle);
void gdk_window_begin_paint_region (GdkWindow *window,
          GdkRegion *region);
void gdk_window_end_paint (GdkWindow *window);
void gdk_window_set_title (GdkWindow *window,
         const gchar *title);
void gdk_window_set_role (GdkWindow *window,
         const gchar *role);
void gdk_window_set_startup_id (GdkWindow *window,
         const gchar *startup_id);
void gdk_window_set_transient_for (GdkWindow *window,
         GdkWindow *parent);
void gdk_window_set_background (GdkWindow *window,
       const GdkColor *color);
void gdk_window_set_back_pixmap (GdkWindow *window,
       GdkPixmap *pixmap,
       gboolean parent_relative);
void gdk_window_set_cursor (GdkWindow *window,
       GdkCursor *cursor);
void gdk_window_get_user_data (GdkWindow *window,
       gpointer *data);
void gdk_window_get_geometry (GdkWindow *window,
       gint *x,
       gint *y,
       gint *width,
       gint *height,
       gint *depth);
void gdk_window_get_position (GdkWindow *window,
       gint *x,
       gint *y);
gint gdk_window_get_origin (GdkWindow *window,
       gint *x,
       gint *y);
gboolean gdk_window_get_deskrelative_origin (GdkWindow *window,
       gint *x,
       gint *y);
void gdk_window_get_root_origin (GdkWindow *window,
       gint *x,
       gint *y);
void gdk_window_get_frame_extents (GdkWindow *window,
                                            GdkRectangle *rect);
GdkWindow* gdk_window_get_pointer (GdkWindow *window,
       gint *x,
       gint *y,
       GdkModifierType *mask);
GdkWindow * gdk_window_get_parent (GdkWindow *window);
GdkWindow * gdk_window_get_toplevel (GdkWindow *window);
GList * gdk_window_get_children (GdkWindow *window);
GList * gdk_window_peek_children (GdkWindow *window);
GdkEventMask gdk_window_get_events (GdkWindow *window);
void gdk_window_set_events (GdkWindow *window,
       GdkEventMask event_mask);
void gdk_window_set_icon_list (GdkWindow *window,
       GList *pixbufs);
void gdk_window_set_icon (GdkWindow *window,
       GdkWindow *icon_window,
       GdkPixmap *pixmap,
       GdkBitmap *mask);
void gdk_window_set_icon_name (GdkWindow *window,
       const gchar *name);
void gdk_window_set_group (GdkWindow *window,
       GdkWindow *leader);
GdkWindow* gdk_window_get_group (GdkWindow *window);
void gdk_window_set_decorations (GdkWindow *window,
       GdkWMDecoration decorations);
gboolean gdk_window_get_decorations (GdkWindow *window,
       GdkWMDecoration *decorations);
void gdk_window_set_functions (GdkWindow *window,
       GdkWMFunction functions);
GList * gdk_window_get_toplevels (void);
void gdk_window_beep (GdkWindow *window);
void gdk_window_iconify (GdkWindow *window);
void gdk_window_deiconify (GdkWindow *window);
void gdk_window_stick (GdkWindow *window);
void gdk_window_unstick (GdkWindow *window);
void gdk_window_maximize (GdkWindow *window);
void gdk_window_unmaximize (GdkWindow *window);
void gdk_window_fullscreen (GdkWindow *window);
void gdk_window_unfullscreen (GdkWindow *window);
void gdk_window_set_keep_above (GdkWindow *window,
                                          gboolean setting);
void gdk_window_set_keep_below (GdkWindow *window,
                                          gboolean setting);
void gdk_window_set_opacity (GdkWindow *window,
                                          gdouble opacity);
void gdk_window_register_dnd (GdkWindow *window);
void gdk_window_begin_resize_drag (GdkWindow *window,
                                   GdkWindowEdge edge,
                                   gint button,
                                   gint root_x,
                                   gint root_y,
                                   guint32 timestamp);
void gdk_window_begin_move_drag (GdkWindow *window,
                                   gint button,
                                   gint root_x,
                                   gint root_y,
                                   guint32 timestamp);
void gdk_window_invalidate_rect (GdkWindow *window,
              GdkRectangle *rect,
              gboolean invalidate_children);
void gdk_window_invalidate_region (GdkWindow *window,
              GdkRegion *region,
              gboolean invalidate_children);
void gdk_window_invalidate_maybe_recurse (GdkWindow *window,
       GdkRegion *region,
       gboolean (*child_func) (GdkWindow *, gpointer),
       gpointer user_data);
GdkRegion *gdk_window_get_update_area (GdkWindow *window);
void gdk_window_freeze_updates (GdkWindow *window);
void gdk_window_thaw_updates (GdkWindow *window);
void gdk_window_freeze_toplevel_updates_libgtk_only (GdkWindow *window);
void gdk_window_thaw_toplevel_updates_libgtk_only (GdkWindow *window);
void gdk_window_process_all_updates (void);
void gdk_window_process_updates (GdkWindow *window,
        gboolean update_children);
void gdk_window_set_debug_updates (gboolean setting);
void gdk_window_constrain_size (GdkGeometry *geometry,
                                           guint flags,
                                           gint width,
                                           gint height,
                                           gint *new_width,
                                           gint *new_height);
void gdk_window_get_internal_paint_info (GdkWindow *window,
      GdkDrawable **real_drawable,
      gint *x_offset,
      gint *y_offset);
void gdk_window_enable_synchronized_configure (GdkWindow *window);
void gdk_window_configure_finished (GdkWindow *window);
GdkPointerHooks *gdk_set_pointer_hooks (const GdkPointerHooks *new_hooks);
GdkWindow *gdk_get_default_root_window (void);
}
extern "C" {
void gdk_parse_args (gint *argc,
      gchar ***argv);
void gdk_init (gint *argc,
      gchar ***argv);
gboolean gdk_init_check (gint *argc,
      gchar ***argv);
void gdk_add_option_entries_libgtk_only (GOptionGroup *group);
void gdk_pre_parse_libgtk_only (void);
void gdk_exit (gint error_code);
gchar* gdk_set_locale (void);
const char *gdk_get_program_class (void);
void gdk_set_program_class (const char *program_class);
void gdk_error_trap_push (void);
gint gdk_error_trap_pop (void);
void gdk_set_use_xshm (gboolean use_xshm);
gboolean gdk_get_use_xshm (void);
gchar* gdk_get_display (void);
const gchar* gdk_get_display_arg_name (void);
gint gdk_input_add_full (gint source,
      GdkInputCondition condition,
      GdkInputFunction function,
      gpointer data,
      GdkDestroyNotify destroy);
gint gdk_input_add (gint source,
      GdkInputCondition condition,
      GdkInputFunction function,
      gpointer data);
void gdk_input_remove (gint tag);
GdkGrabStatus gdk_pointer_grab (GdkWindow *window,
          gboolean owner_events,
          GdkEventMask event_mask,
          GdkWindow *confine_to,
          GdkCursor *cursor,
          guint32 time_);
GdkGrabStatus gdk_keyboard_grab (GdkWindow *window,
          gboolean owner_events,
          guint32 time_);
gboolean gdk_pointer_grab_info_libgtk_only (GdkDisplay *display,
         GdkWindow **grab_window,
         gboolean *owner_events);
gboolean gdk_keyboard_grab_info_libgtk_only (GdkDisplay *display,
          GdkWindow **grab_window,
          gboolean *owner_events);
void gdk_pointer_ungrab (guint32 time_);
void gdk_keyboard_ungrab (guint32 time_);
gboolean gdk_pointer_is_grabbed (void);
gint gdk_screen_width (void) __attribute__((__const__));
gint gdk_screen_height (void) __attribute__((__const__));
gint gdk_screen_width_mm (void) __attribute__((__const__));
gint gdk_screen_height_mm (void) __attribute__((__const__));
void gdk_beep (void);
void gdk_flush (void);
void gdk_set_double_click_time (guint msec);
gboolean gdk_rectangle_intersect (GdkRectangle *src1,
      GdkRectangle *src2,
      GdkRectangle *dest);
void gdk_rectangle_union (GdkRectangle *src1,
      GdkRectangle *src2,
      GdkRectangle *dest);
GType gdk_rectangle_get_type (void) __attribute__((__const__));
gchar *gdk_wcstombs (const GdkWChar *src);
gint gdk_mbstowcs (GdkWChar *dest,
      const gchar *src,
      gint dest_max);
gboolean gdk_event_send_client_message (GdkEvent *event,
          GdkNativeWindow winid);
void gdk_event_send_clientmessage_toall (GdkEvent *event);
gboolean gdk_event_send_client_message_for_display (GdkDisplay *display,
          GdkEvent *event,
          GdkNativeWindow winid);
void gdk_notify_startup_complete (void);
void gdk_notify_startup_complete_with_id (const gchar* startup_id);
extern GMutex *gdk_threads_mutex;
extern GCallback gdk_threads_lock;
extern GCallback gdk_threads_unlock;
void gdk_threads_enter (void);
void gdk_threads_leave (void);
void gdk_threads_init (void);
void gdk_threads_set_lock_functions (GCallback enter_fn,
        GCallback leave_fn);
guint gdk_threads_add_idle_full (gint priority,
                             GSourceFunc function,
                             gpointer data,
                             GDestroyNotify notify);
guint gdk_threads_add_idle (GSourceFunc function,
                             gpointer data);
guint gdk_threads_add_timeout_full (gint priority,
                                           guint interval,
                                           GSourceFunc function,
                                           gpointer data,
                                           GDestroyNotify notify);
guint gdk_threads_add_timeout (guint interval,
                                           GSourceFunc function,
                                           gpointer data);
}
namespace Gdk
{
class Bitmap;
class Colormap;
class Pixmap;
class Window;
class Font;
class GC;
class Color;
class Image;
enum ByteOrder
{
  LSB_FIRST,
  MSB_FIRST
};
}
namespace Glib
{
template <>
class Value<Gdk::ByteOrder> : public Glib::Value_Enum<Gdk::ByteOrder>
{
public:
  static GType value_type() __attribute__((__const__));
};
}
namespace Gdk
{
enum ModifierType
{
  SHIFT_MASK = 1 << 0,
  LOCK_MASK = 1 << 1,
  CONTROL_MASK = 1 << 2,
  MOD1_MASK = 1 << 3,
  MOD2_MASK = 1 << 4,
  MOD3_MASK = 1 << 5,
  MOD4_MASK = 1 << 6,
  MOD5_MASK = 1 << 7,
  BUTTON1_MASK = 1 << 8,
  BUTTON2_MASK = 1 << 9,
  BUTTON3_MASK = 1 << 10,
  BUTTON4_MASK = 1 << 11,
  BUTTON5_MASK = 1 << 12,
  SUPER_MASK = 1 << 26,
  HYPER_MASK = 1 << 27,
  META_MASK = 1 << 28,
  RELEASE_MASK = 1 << 30,
  MODIFIER_MASK = 0x5c001fff
};
inline ModifierType operator|(ModifierType lhs, ModifierType rhs)
  { return static_cast<ModifierType>(static_cast<unsigned>(lhs) | static_cast<unsigned>(rhs)); }
inline ModifierType operator&(ModifierType lhs, ModifierType rhs)
  { return static_cast<ModifierType>(static_cast<unsigned>(lhs) & static_cast<unsigned>(rhs)); }
inline ModifierType operator^(ModifierType lhs, ModifierType rhs)
  { return static_cast<ModifierType>(static_cast<unsigned>(lhs) ^ static_cast<unsigned>(rhs)); }
inline ModifierType operator~(ModifierType flags)
  { return static_cast<ModifierType>(~static_cast<unsigned>(flags)); }
inline ModifierType& operator|=(ModifierType& lhs, ModifierType rhs)
  { return (lhs = static_cast<ModifierType>(static_cast<unsigned>(lhs) | static_cast<unsigned>(rhs))); }
inline ModifierType& operator&=(ModifierType& lhs, ModifierType rhs)
  { return (lhs = static_cast<ModifierType>(static_cast<unsigned>(lhs) & static_cast<unsigned>(rhs))); }
inline ModifierType& operator^=(ModifierType& lhs, ModifierType rhs)
  { return (lhs = static_cast<ModifierType>(static_cast<unsigned>(lhs) ^ static_cast<unsigned>(rhs))); }
}
namespace Glib
{
template <>
class Value<Gdk::ModifierType> : public Glib::Value_Flags<Gdk::ModifierType>
{
public:
  static GType value_type() __attribute__((__const__));
};
}
namespace Gdk
{
enum Status
{
  OK = 0,
  ERROR = -1,
  ERROR_PARAM = -2,
  ERROR_FILE = -3,
  ERROR_MEM = -4
};
}
namespace Glib
{
template <>
class Value<Gdk::Status> : public Glib::Value_Enum<Gdk::Status>
{
public:
  static GType value_type() __attribute__((__const__));
};
}
namespace Gdk
{
enum InputCondition
{
  INPUT_READ = 1 << 0,
  INPUT_WRITE = 1 << 1,
  INPUT_EXCEPTION = 1 << 2
};
inline InputCondition operator|(InputCondition lhs, InputCondition rhs)
  { return static_cast<InputCondition>(static_cast<unsigned>(lhs) | static_cast<unsigned>(rhs)); }
inline InputCondition operator&(InputCondition lhs, InputCondition rhs)
  { return static_cast<InputCondition>(static_cast<unsigned>(lhs) & static_cast<unsigned>(rhs)); }
inline InputCondition operator^(InputCondition lhs, InputCondition rhs)
  { return static_cast<InputCondition>(static_cast<unsigned>(lhs) ^ static_cast<unsigned>(rhs)); }
inline InputCondition operator~(InputCondition flags)
  { return static_cast<InputCondition>(~static_cast<unsigned>(flags)); }
inline InputCondition& operator|=(InputCondition& lhs, InputCondition rhs)
  { return (lhs = static_cast<InputCondition>(static_cast<unsigned>(lhs) | static_cast<unsigned>(rhs))); }
inline InputCondition& operator&=(InputCondition& lhs, InputCondition rhs)
  { return (lhs = static_cast<InputCondition>(static_cast<unsigned>(lhs) & static_cast<unsigned>(rhs))); }
inline InputCondition& operator^=(InputCondition& lhs, InputCondition rhs)
  { return (lhs = static_cast<InputCondition>(static_cast<unsigned>(lhs) ^ static_cast<unsigned>(rhs))); }
}
namespace Glib
{
template <>
class Value<Gdk::InputCondition> : public Glib::Value_Flags<Gdk::InputCondition>
{
public:
  static GType value_type() __attribute__((__const__));
};
}
namespace Gdk
{
typedef GdkGeometry Geometry;
typedef GdkNativeWindow NativeWindow;
class Point
{
  public:
  typedef Point CppObjectType;
  typedef GdkPoint BaseObjectType;
private:
public:
  Point();
  Point(int x, int y);
  void set_x(int x) { gobject_.x = x; }
  void set_y(int y) { gobject_.y = y; }
  int get_x() const { return gobject_.x; }
  int get_y() const { return gobject_.y; }
  bool equal(const Gdk::Point& rhs) const;
  GdkPoint* gobj() { return &gobject_; }
  const GdkPoint* gobj() const { return &gobject_; }
protected:
  GdkPoint gobject_;
};
inline bool operator==(const Point& lhs, const Point& rhs)
  { return lhs.equal(rhs); }
inline bool operator!=(const Point& lhs, const Point& rhs)
  { return !lhs.equal(rhs); }
struct AtomStringTraits
{
  typedef std::string CppType;
  typedef GdkAtom CType;
  typedef GdkAtom CTypeNonConst;
  static GdkAtom to_c_type(GdkAtom atom) { return atom; }
  static void release_c_type(GdkAtom) {}
  static GdkAtom to_c_type (const std::string& atom_name);
  static std::string to_cpp_type(GdkAtom atom);
};
typedef AtomStringTraits AtomString;
typedef Glib::ArrayHandle<std::string,AtomStringTraits> ArrayHandle_AtomString;
typedef Glib::ListHandle<std::string,AtomStringTraits> ListHandle_AtomString;
}
namespace Glib
{
Gdk::Point& wrap(GdkPoint* object);
const Gdk::Point& wrap(const GdkPoint* object);
}
namespace Gdk
{
class Rectangle
{
  public:
  typedef Rectangle CppObjectType;
  typedef GdkRectangle BaseObjectType;
  static GType get_type() __attribute__((__const__));
  Rectangle();
  explicit Rectangle(const GdkRectangle* gobject);
  GdkRectangle* gobj() { return &gobject_; }
  const GdkRectangle* gobj() const { return &gobject_; }
protected:
  GdkRectangle gobject_;
private:
public:
  Rectangle(int x, int y, int width, int height);
  Rectangle& join(const Rectangle& src2);
  Rectangle& intersect(const Rectangle& src2);
  Rectangle& intersect(const Rectangle& src2, bool& rectangles_intersect);
  bool has_zero_area() const;
   int get_x() const;
    void set_x(const int& value);
    int get_y() const;
    void set_y(const int& value);
    int get_width() const;
    void set_width(const int& value);
    int get_height() const;
    void set_height(const int& value);
};
}
namespace Glib
{
Gdk::Rectangle& wrap(GdkRectangle* object);
const Gdk::Rectangle& wrap(const GdkRectangle* object);
template <>
class Value<Gdk::Rectangle> : public Glib::Value_Boxed<Gdk::Rectangle>
{};
}
namespace Cairo
{
typedef cairo_status_t ErrorStatus;
typedef enum
{
    OPERATOR_CLEAR = CAIRO_OPERATOR_CLEAR,
    OPERATOR_SOURCE = CAIRO_OPERATOR_SOURCE,
    OPERATOR_OVER = CAIRO_OPERATOR_OVER,
    OPERATOR_IN = CAIRO_OPERATOR_IN,
    OPERATOR_OUT = CAIRO_OPERATOR_OUT,
    OPERATOR_ATOP = CAIRO_OPERATOR_ATOP,
    OPERATOR_DEST = CAIRO_OPERATOR_DEST,
    OPERATOR_DEST_OVER = CAIRO_OPERATOR_DEST_OVER,
    OPERATOR_DEST_IN = CAIRO_OPERATOR_DEST_IN,
    OPERATOR_DEST_OUT = CAIRO_OPERATOR_DEST_OUT,
    OPERATOR_DEST_ATOP = CAIRO_OPERATOR_DEST_ATOP,
    OPERATOR_XOR = CAIRO_OPERATOR_XOR,
    OPERATOR_ADD = CAIRO_OPERATOR_ADD,
    OPERATOR_SATURATE = CAIRO_OPERATOR_SATURATE
} Operator;
typedef enum
{
    ANTIALIAS_DEFAULT = CAIRO_ANTIALIAS_DEFAULT,
    ANTIALIAS_NONE = CAIRO_ANTIALIAS_NONE,
    ANTIALIAS_GRAY = CAIRO_ANTIALIAS_GRAY,
    ANTIALIAS_SUBPIXEL = CAIRO_ANTIALIAS_SUBPIXEL
} Antialias;
typedef enum
{
    FILL_RULE_WINDING = CAIRO_FILL_RULE_WINDING,
    FILL_RULE_EVEN_ODD = CAIRO_FILL_RULE_EVEN_ODD
} FillRule;
typedef enum
{
    LINE_CAP_BUTT = CAIRO_LINE_CAP_BUTT,
    LINE_CAP_ROUND = CAIRO_LINE_CAP_ROUND,
    LINE_CAP_SQUARE = CAIRO_LINE_CAP_SQUARE
} LineCap;
typedef enum
{
    LINE_JOIN_MITER = CAIRO_LINE_JOIN_MITER,
    LINE_JOIN_ROUND = CAIRO_LINE_JOIN_ROUND,
    LINE_JOIN_BEVEL = CAIRO_LINE_JOIN_BEVEL
} LineJoin;
typedef enum
{
  FONT_SLANT_NORMAL = CAIRO_FONT_SLANT_NORMAL,
  FONT_SLANT_ITALIC = CAIRO_FONT_SLANT_ITALIC,
  FONT_SLANT_OBLIQUE = CAIRO_FONT_SLANT_OBLIQUE
} FontSlant;
typedef enum
{
  FONT_WEIGHT_NORMAL = CAIRO_FONT_WEIGHT_NORMAL,
  FONT_WEIGHT_BOLD = CAIRO_FONT_WEIGHT_BOLD
} FontWeight;
typedef enum
{
    CONTENT_COLOR = CAIRO_CONTENT_COLOR,
    CONTENT_ALPHA = CAIRO_CONTENT_ALPHA,
    CONTENT_COLOR_ALPHA = CAIRO_CONTENT_COLOR_ALPHA
} Content;
typedef enum
{
    FORMAT_ARGB32 = CAIRO_FORMAT_ARGB32,
    FORMAT_RGB24 = CAIRO_FORMAT_RGB24,
    FORMAT_A8 = CAIRO_FORMAT_A8,
    FORMAT_A1 = CAIRO_FORMAT_A1,
    FORMAT_RGB16_565 = 4
} Format;
typedef enum
{
    EXTEND_NONE = CAIRO_EXTEND_NONE,
    EXTEND_REPEAT = CAIRO_EXTEND_REPEAT,
    EXTEND_REFLECT = CAIRO_EXTEND_REFLECT,
    EXTEND_PAD = CAIRO_EXTEND_PAD
} Extend;
typedef enum
{
    FILTER_FAST = CAIRO_FILTER_FAST,
    FILTER_GOOD = CAIRO_FILTER_GOOD,
    FILTER_BEST = CAIRO_FILTER_BEST,
    FILTER_NEAREST = CAIRO_FILTER_NEAREST,
    FILTER_BILINEAR = CAIRO_FILTER_BILINEAR,
    FILTER_GAUSSIAN = CAIRO_FILTER_GAUSSIAN
} Filter;
typedef enum
{
    SUBPIXEL_ORDER_DEFAULT = CAIRO_SUBPIXEL_ORDER_DEFAULT,
    SUBPIXEL_ORDER_RGB = CAIRO_SUBPIXEL_ORDER_RGB,
    SUBPIXEL_ORDER_BGR = CAIRO_SUBPIXEL_ORDER_BGR,
    SUBPIXEL_ORDER_VRGB = CAIRO_SUBPIXEL_ORDER_VRGB,
    SUBPIXEL_ORDER_VBGR = CAIRO_SUBPIXEL_ORDER_VBGR
} SubpixelOrder;
typedef enum
{
    HINT_STYLE_DEFAULT = CAIRO_HINT_STYLE_DEFAULT,
    HINT_STYLE_NONE = CAIRO_HINT_STYLE_NONE,
    HINT_STYLE_SLIGHT = CAIRO_HINT_STYLE_SLIGHT,
    HINT_STYLE_MEDIUM = CAIRO_HINT_STYLE_MEDIUM,
    HINT_STYLE_FULL = CAIRO_HINT_STYLE_FULL
} HintStyle;
typedef enum
{
    HINT_METRICS_DEFAULT = CAIRO_HINT_METRICS_DEFAULT,
    HINT_METRICS_OFF = CAIRO_HINT_METRICS_OFF,
    HINT_METRICS_ON = CAIRO_HINT_METRICS_ON
} HintMetrics;
typedef enum
{
    SURFACE_TYPE_IMAGE = CAIRO_SURFACE_TYPE_IMAGE,
    SURFACE_TYPE_PDF = CAIRO_SURFACE_TYPE_PDF,
    SURFACE_TYPE_PS = CAIRO_SURFACE_TYPE_PS,
    SURFACE_TYPE_XLIB = CAIRO_SURFACE_TYPE_XLIB,
    SURFACE_TYPE_XCB = CAIRO_SURFACE_TYPE_XCB,
    SURFACE_TYPE_GLITZ = CAIRO_SURFACE_TYPE_GLITZ,
    SURFACE_TYPE_QUARTZ = CAIRO_SURFACE_TYPE_QUARTZ,
    SURFACE_TYPE_WIN32 = CAIRO_SURFACE_TYPE_WIN32,
    SURFACE_TYPE_BEOS = CAIRO_SURFACE_TYPE_BEOS,
    SURFACE_TYPE_DIRECTFB = CAIRO_SURFACE_TYPE_DIRECTFB,
    SURFACE_TYPE_SVG = CAIRO_SURFACE_TYPE_SVG,
    SURFACE_TYPE_OS2 = CAIRO_SURFACE_TYPE_OS2
} SurfaceType;
typedef enum
{
    PATTERN_TYPE_SOLID = CAIRO_PATTERN_TYPE_SOLID,
    PATTERN_TYPE_SURFACE = CAIRO_PATTERN_TYPE_SURFACE,
    PATTERN_TYPE_LINEAR = CAIRO_PATTERN_TYPE_LINEAR,
    PATTERN_TYPE_RADIAL = CAIRO_PATTERN_TYPE_RADIAL
} PatternType;
typedef enum
{
    FONT_TYPE_TOY = CAIRO_FONT_TYPE_TOY,
    FONT_TYPE_FT = CAIRO_FONT_TYPE_FT,
    FONT_TYPE_WIN32 = CAIRO_FONT_TYPE_WIN32,
    FONT_TYPE_ATSUI = CAIRO_FONT_TYPE_ATSUI
} FontType;
}
namespace Cairo
{
class FontOptions
{
public:
  FontOptions();
  explicit FontOptions(cairo_font_options_t* cobject, bool take_ownership = false);
  FontOptions(const FontOptions& src);
  virtual ~FontOptions();
  FontOptions& operator=(const FontOptions& src);
  bool operator ==(const FontOptions& src) const;
  void merge(const FontOptions& other);
  unsigned long hash() const;
  void set_antialias(Antialias antialias);
  Antialias get_antialias() const;
  void set_subpixel_order(SubpixelOrder subpixel_order);
  SubpixelOrder get_subpixel_order() const;
  void set_hint_style(HintStyle hint_style);
  HintStyle get_hint_style() const;
  void set_hint_metrics(HintMetrics hint_metrics);
  HintMetrics get_hint_metrics() const;
  typedef cairo_font_options_t cobject;
  inline cobject* cobj() { return m_cobject; }
  inline const cobject* cobj() const { return m_cobject; }
  inline ErrorStatus get_status() const
  { return cairo_font_options_status(const_cast<cairo_font_options_t*>(cobj())); }
protected:
  cobject* m_cobject;
};
}
typedef struct _GdkScreen GdkScreen;
typedef struct _GdkScreenClass GdkScreenClass;
namespace Gdk
{ class Screen_Class; }
namespace Gdk
{
class Display;
class Colormap;
class Visual;
class Window;
class Screen : public Glib::Object
{
public:
  typedef Screen CppObjectType;
  typedef Screen_Class CppClassType;
  typedef GdkScreen BaseObjectType;
  typedef GdkScreenClass BaseClassType;
private: friend class Screen_Class;
  static CppClassType screen_class_;
private:
  Screen(const Screen&);
  Screen& operator=(const Screen&);
protected:
  explicit Screen(const Glib::ConstructParams& construct_params);
  explicit Screen(GdkScreen* castitem);
public:
  virtual ~Screen();
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GdkScreen* gobj() { return reinterpret_cast<GdkScreen*>(gobject_); }
  const GdkScreen* gobj() const { return reinterpret_cast<GdkScreen*>(gobject_); }
  GdkScreen* gobj_copy();
private:
protected:
public:
  Glib::RefPtr<Colormap> get_default_colormap();
  Glib::RefPtr<const Colormap> get_default_colormap() const;
  void set_default_colormap(const Glib::RefPtr<const Colormap>& colormap);
  Glib::RefPtr<Colormap> get_system_colormap();
  Glib::RefPtr<const Colormap> get_system_colormap() const;
  Glib::RefPtr<Visual> get_system_visual();
  Glib::RefPtr<const Visual> get_system_visual() const;
  Glib::RefPtr<Colormap> get_rgb_colormap();
  Glib::RefPtr<const Colormap> get_rgb_colormap() const;
  Glib::RefPtr<Visual> get_rgb_visual();
  Glib::RefPtr<const Visual> get_rgb_visual() const;
  Glib::RefPtr<Colormap> get_rgba_colormap();
  Glib::RefPtr<const Colormap> get_rgba_colormap() const;
  Glib::RefPtr<Visual> get_rgba_visual();
  Glib::RefPtr<const Visual> get_rgba_visual() const;
  bool is_composited() const;
  Glib::RefPtr<Window> get_root_window();
  Glib::RefPtr<const Window> get_root_window() const;
  Glib::RefPtr<Display> get_display();
  Glib::RefPtr<const Display> get_display() const;
  int get_number() const;
  int get_width() const;
  int get_height() const;
  int get_width_mm() const;
  int get_height_mm() const;
  Glib::ListHandle< Glib::RefPtr<Visual> > list_visuals();
  Glib::ListHandle< Glib::RefPtr<Window> > get_toplevel_windows();
  Glib::ustring make_display_name();
  int get_n_monitors() const;
  void get_monitor_geometry(int monitor_num, Rectangle& dest) const;
  int get_monitor_at_point(int x, int y) const;
  int get_monitor_at_window(const Glib::RefPtr<Window>& window) const;
  void broadcast_client_message(GdkEvent* event);
  static Glib::RefPtr<Screen> get_default();
  template <class ValueType>
  bool get_setting(const Glib::ustring& name, ValueType& value) const;
  void set_font_options(const Cairo::FontOptions& options);
  Cairo::FontOptions get_font_options() const;
  void set_resolution(double dpi);
  double get_resolution() const;
  Glib::RefPtr<Gdk::Window> get_active_window();
  Glib::RefPtr<const Gdk::Window> get_active_window() const;
  Glib::ListHandle< Glib::RefPtr<Window> > get_window_stack();
  Glib::SignalProxy0< void > signal_size_changed();
public:
public:
protected:
  virtual void on_size_changed();
};
template <class ValueType>
bool Screen::get_setting(const Glib::ustring& name, ValueType& value) const
{
  Glib::Value<ValueType> glibmmvalue;
  glibmmvalue.init(Glib::Value<ValueType>::value_type());
  gboolean result = gdk_screen_get_setting(const_cast<GdkScreen*>(gobj()), name.c_str(), glibmmvalue.gobj());
  value = glibmmvalue.get();
  return result;
}
}
namespace Glib
{
  Glib::RefPtr<Gdk::Screen> wrap(GdkScreen* object, bool take_copy = false);
}
typedef struct _GdkVisual GdkVisual;
typedef struct _GdkVisualClass GdkVisualClass;
namespace Gdk
{ class Visual_Class; }
namespace Gdk
{
class Screen;
enum VisualType
{
  VISUAL_STATIC_GRAY,
  VISUAL_GRAYSCALE,
  VISUAL_STATIC_COLOR,
  VISUAL_PSEUDO_COLOR,
  VISUAL_TRUE_COLOR,
  VISUAL_DIRECT_COLOR
};
}
namespace Glib
{
template <>
class Value<Gdk::VisualType> : public Glib::Value_Enum<Gdk::VisualType>
{
public:
  static GType value_type() __attribute__((__const__));
};
}
namespace Gdk
{
class Visual : public Glib::Object
{
public:
  typedef Visual CppObjectType;
  typedef Visual_Class CppClassType;
  typedef GdkVisual BaseObjectType;
  typedef GdkVisualClass BaseClassType;
private: friend class Visual_Class;
  static CppClassType visual_class_;
private:
  Visual(const Visual&);
  Visual& operator=(const Visual&);
protected:
  explicit Visual(const Glib::ConstructParams& construct_params);
  explicit Visual(GdkVisual* castitem);
public:
  virtual ~Visual();
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GdkVisual* gobj() { return reinterpret_cast<GdkVisual*>(gobject_); }
  const GdkVisual* gobj() const { return reinterpret_cast<GdkVisual*>(gobject_); }
  GdkVisual* gobj_copy();
private:
protected:
  Visual();
public:
  static Glib::RefPtr<Visual> get_system();
  static Glib::RefPtr<Visual> get_best();
  static Glib::RefPtr<Visual> get_best(int depth);
  static Glib::RefPtr<Visual> get_best(VisualType visual_type);
  static Glib::RefPtr<Visual> get_best(int depth, VisualType visual_type);
  static int get_best_depth();
  static VisualType get_best_type();
  Glib::RefPtr<Screen> get_screen();
  Glib::RefPtr<const Screen> get_screen() const;
public:
public:
protected:
};
}
namespace Glib
{
  Glib::RefPtr<Gdk::Visual> wrap(GdkVisual* object, bool take_copy = false);
}
namespace Pango
{
class Rectangle
{
  public:
  typedef Rectangle CppObjectType;
  typedef PangoRectangle BaseObjectType;
private:
public:
  Rectangle();
  Rectangle(int x, int y, int width, int height);
  explicit Rectangle(const PangoRectangle* src);
  void set_x(int x) { gobject_.x = x; }
  void set_y(int y) { gobject_.y = y; }
  void set_width(int w) { gobject_.width = w; }
  void set_height(int h) { gobject_.height = h; }
  int get_x() const { return gobject_.x; }
  int get_y() const { return gobject_.y; }
  int get_width() const { return gobject_.width; }
  int get_height() const { return gobject_.height; }
  int get_ascent() const { return (-(*gobj()).y); }
  int get_descent() const { return ((*gobj()).y + (*gobj()).height); }
  int get_lbearing() const { return ((*gobj()).x); }
  int get_rbearing() const { return ((*gobj()).x + (*gobj()).width); }
  bool equal(const Rectangle& rhs) const;
  PangoRectangle* gobj() { return &gobject_; }
  const PangoRectangle* gobj() const { return &gobject_; }
protected:
  PangoRectangle gobject_;
};
inline bool operator==(const Rectangle& lhs, const Rectangle& rhs)
  { return lhs.equal(rhs); }
inline bool operator!=(const Rectangle& lhs, const Rectangle& rhs)
  { return !lhs.equal(rhs); }
}
namespace Glib
{
Pango::Rectangle& wrap(PangoRectangle* object);
const Pango::Rectangle& wrap(const PangoRectangle* object);
}
extern "C" { typedef struct _PangoLanguage PangoLanguage; }
namespace Pango
{
enum Script
{
  SCRIPT_INVALID_CODE = -1,
  SCRIPT_COMMON,
  SCRIPT_INHERITED,
  SCRIPT_ARABIC,
  SCRIPT_ARMENIAN,
  SCRIPT_BENGALI,
  SCRIPT_BOPOMOFO,
  SCRIPT_CHEROKEE,
  SCRIPT_COPTIC,
  SCRIPT_CYRILLIC,
  SCRIPT_DESERET,
  SCRIPT_DEVANAGARI,
  SCRIPT_ETHIOPIC,
  SCRIPT_GEORGIAN,
  SCRIPT_GOTHIC,
  SCRIPT_GREEK,
  SCRIPT_GUJARATI,
  SCRIPT_GURMUKHI,
  SCRIPT_HAN,
  SCRIPT_HANGUL,
  SCRIPT_HEBREW,
  SCRIPT_HIRAGANA,
  SCRIPT_KANNADA,
  SCRIPT_KATAKANA,
  SCRIPT_KHMER,
  SCRIPT_LAO,
  SCRIPT_LATIN,
  SCRIPT_MALAYALAM,
  SCRIPT_MONGOLIAN,
  SCRIPT_MYANMAR,
  SCRIPT_OGHAM,
  SCRIPT_OLD_ITALIC,
  SCRIPT_ORIYA,
  SCRIPT_RUNIC,
  SCRIPT_SINHALA,
  SCRIPT_SYRIAC,
  SCRIPT_TAMIL,
  SCRIPT_TELUGU,
  SCRIPT_THAANA,
  SCRIPT_THAI,
  SCRIPT_TIBETAN,
  SCRIPT_CANADIAN_ABORIGINAL,
  SCRIPT_YI,
  SCRIPT_TAGALOG,
  SCRIPT_HANUNOO,
  SCRIPT_BUHID,
  SCRIPT_TAGBANWA,
  SCRIPT_BRAILLE,
  SCRIPT_CYPRIOT,
  SCRIPT_LIMBU,
  SCRIPT_OSMANYA,
  SCRIPT_SHAVIAN,
  SCRIPT_LINEAR_B,
  SCRIPT_TAI_LE,
  SCRIPT_UGARITIC,
  SCRIPT_NEW_TAI_LUE,
  SCRIPT_BUGINESE,
  SCRIPT_GLAGOLITIC,
  SCRIPT_TIFINAGH,
  SCRIPT_SYLOTI_NAGRI,
  SCRIPT_OLD_PERSIAN,
  SCRIPT_KHAROSHTHI,
  SCRIPT_UNKNOWN,
  SCRIPT_BALINESE,
  SCRIPT_CUNEIFORM,
  SCRIPT_PHOENICIAN,
  SCRIPT_PHAGS_PA,
  SCRIPT_NKO
};
}
namespace Glib
{
template <>
class Value<Pango::Script> : public Glib::Value_Enum<Pango::Script>
{
public:
  static GType value_type() __attribute__((__const__));
};
}
namespace Pango
{
class Language
{
  public:
  typedef Language CppObjectType;
  typedef PangoLanguage BaseObjectType;
  static GType get_type() __attribute__((__const__));
  explicit Language(PangoLanguage* gobject, bool make_a_copy = true);
  Language(const Language& other);
  Language& operator=(const Language& other);
  ~Language();
  void swap(Language& other);
  PangoLanguage* gobj() { return gobject_; }
  const PangoLanguage* gobj() const { return gobject_; }
  PangoLanguage* gobj_copy() const;
protected:
  PangoLanguage* gobject_;
private:
public:
  Language();
  Language(const Glib::ustring& language);
  Glib::ustring get_string() const;
  bool matches(const Glib::ustring & range_list) const;
  bool includes_script(Script script) const;
};
}
namespace Pango
{
inline void swap(Language& lhs, Language& rhs)
  { lhs.swap(rhs); }
}
namespace Glib
{
Pango::Language wrap(PangoLanguage* object, bool take_copy = false);
template <>
class Value<Pango::Language> : public Glib::Value_Boxed<Pango::Language>
{};
}
namespace Pango
{
class GlyphInfo;
class GlyphGeometry;
typedef PangoGlyph Glyph;
typedef PangoGlyphUnit GlyphUnit;
typedef PangoGlyphVisAttr GlyphVisAttr;
class GlyphInfo
{
  public:
  typedef GlyphInfo CppObjectType;
  typedef PangoGlyphInfo BaseObjectType;
private:
public:
  GlyphInfo();
   Glyph get_glyph() const;
   GlyphGeometry get_geometry() const;
   GlyphVisAttr get_attr() const;
  PangoGlyphInfo* gobj() { return &gobject_; }
  const PangoGlyphInfo* gobj() const { return &gobject_; }
protected:
  PangoGlyphInfo gobject_;
};
class GlyphGeometry
{
  public:
  typedef GlyphGeometry CppObjectType;
  typedef PangoGlyphGeometry BaseObjectType;
private:
public:
  GlyphGeometry();
  explicit GlyphGeometry(const PangoGlyphGeometry* src);
   GlyphUnit get_width() const;
   GlyphUnit get_x_offset() const;
   GlyphUnit get_y_offset() const;
  PangoGlyphGeometry* gobj() { return &gobject_; }
  const PangoGlyphGeometry* gobj() const { return &gobject_; }
protected:
  PangoGlyphGeometry gobject_;
};
}
namespace Glib
{
Pango::GlyphInfo& wrap(PangoGlyphInfo* object);
const Pango::GlyphInfo& wrap(const PangoGlyphInfo* object);
Pango::GlyphGeometry& wrap(PangoGlyphGeometry* object);
const Pango::GlyphGeometry& wrap(const PangoGlyphGeometry* object);
}
extern "C" { typedef struct _PangoFontDescription PangoFontDescription; }
namespace Pango
{
enum Style
{
  STYLE_NORMAL,
  STYLE_OBLIQUE,
  STYLE_ITALIC
};
}
namespace Glib
{
template <>
class Value<Pango::Style> : public Glib::Value_Enum<Pango::Style>
{
public:
  static GType value_type() __attribute__((__const__));
};
}
namespace Pango
{
enum Variant
{
  VARIANT_NORMAL,
  VARIANT_SMALL_CAPS
};
}
namespace Glib
{
template <>
class Value<Pango::Variant> : public Glib::Value_Enum<Pango::Variant>
{
public:
  static GType value_type() __attribute__((__const__));
};
}
namespace Pango
{
enum Stretch
{
  STRETCH_ULTRA_CONDENSED,
  STRETCH_EXTRA_CONDENSED,
  STRETCH_CONDENSED,
  STRETCH_SEMI_CONDENSED,
  STRETCH_NORMAL,
  STRETCH_SEMI_EXPANDED,
  STRETCH_EXPANDED,
  STRETCH_EXTRA_EXPANDED,
  STRETCH_ULTRA_EXPANDED
};
}
namespace Glib
{
template <>
class Value<Pango::Stretch> : public Glib::Value_Enum<Pango::Stretch>
{
public:
  static GType value_type() __attribute__((__const__));
};
}
namespace Pango
{
enum Weight
{
  WEIGHT_ULTRALIGHT = 200,
  WEIGHT_LIGHT = 300,
  WEIGHT_NORMAL = 400,
  WEIGHT_SEMIBOLD = 600,
  WEIGHT_BOLD = 700,
  WEIGHT_ULTRABOLD = 800,
  WEIGHT_HEAVY = 900
};
}
namespace Glib
{
template <>
class Value<Pango::Weight> : public Glib::Value_Enum<Pango::Weight>
{
public:
  static GType value_type() __attribute__((__const__));
};
}
namespace Pango
{
enum FontMask
{
  FONT_MASK_FAMILY = 1 << 0,
  FONT_MASK_STYLE = 1 << 1,
  FONT_MASK_VARIANT = 1 << 2,
  FONT_MASK_WEIGHT = 1 << 3,
  FONT_MASK_STRETCH = 1 << 4,
  FONT_MASK_SIZE = 1 << 5,
  FONT_MASK_GRAVITY = 1 << 6
};
inline FontMask operator|(FontMask lhs, FontMask rhs)
  { return static_cast<FontMask>(static_cast<unsigned>(lhs) | static_cast<unsigned>(rhs)); }
inline FontMask operator&(FontMask lhs, FontMask rhs)
  { return static_cast<FontMask>(static_cast<unsigned>(lhs) & static_cast<unsigned>(rhs)); }
inline FontMask operator^(FontMask lhs, FontMask rhs)
  { return static_cast<FontMask>(static_cast<unsigned>(lhs) ^ static_cast<unsigned>(rhs)); }
inline FontMask operator~(FontMask flags)
  { return static_cast<FontMask>(~static_cast<unsigned>(flags)); }
inline FontMask& operator|=(FontMask& lhs, FontMask rhs)
  { return (lhs = static_cast<FontMask>(static_cast<unsigned>(lhs) | static_cast<unsigned>(rhs))); }
inline FontMask& operator&=(FontMask& lhs, FontMask rhs)
  { return (lhs = static_cast<FontMask>(static_cast<unsigned>(lhs) & static_cast<unsigned>(rhs))); }
inline FontMask& operator^=(FontMask& lhs, FontMask rhs)
  { return (lhs = static_cast<FontMask>(static_cast<unsigned>(lhs) ^ static_cast<unsigned>(rhs))); }
}
namespace Glib
{
template <>
class Value<Pango::FontMask> : public Glib::Value_Flags<Pango::FontMask>
{
public:
  static GType value_type() __attribute__((__const__));
};
}
namespace Pango
{
enum Gravity
{
  GRAVITY_SOUTH,
  GRAVITY_EAST,
  GRAVITY_NORTH,
  GRAVITY_WEST,
  GRAVITY_AUTO
};
}
namespace Glib
{
template <>
class Value<Pango::Gravity> : public Glib::Value_Enum<Pango::Gravity>
{
public:
  static GType value_type() __attribute__((__const__));
};
}
namespace Pango
{
class FontDescription
{
  public:
  typedef FontDescription CppObjectType;
  typedef PangoFontDescription BaseObjectType;
  static GType get_type() __attribute__((__const__));
  FontDescription();
  explicit FontDescription(PangoFontDescription* gobject, bool make_a_copy = true);
  FontDescription(const FontDescription& other);
  FontDescription& operator=(const FontDescription& other);
  ~FontDescription();
  void swap(FontDescription& other);
  PangoFontDescription* gobj() { return gobject_; }
  const PangoFontDescription* gobj() const { return gobject_; }
  PangoFontDescription* gobj_copy() const;
protected:
  PangoFontDescription* gobject_;
private:
public:
  explicit FontDescription(const Glib::ustring& font_name);
  guint hash() const;
  void set_family(const Glib::ustring& family);
  Glib::ustring get_family() const;
  void set_style(Style style);
  Style get_style() const;
  void set_variant(Variant variant);
  Variant get_variant() const;
  void set_weight(Weight weight);
  Weight get_weight() const;
  void set_stretch(Stretch stretch);
  Stretch get_stretch() const;
  void set_size(int size);
  int get_size() const;
  void set_absolute_size(double size);
  bool get_size_is_absolute() const;
  void set_gravity(Gravity gravity);
  Gravity get_gravity() const;
  FontMask get_set_fields() const;
  void unset_fields(FontMask to_unset);
  void merge(const FontDescription& desc_to_merge, bool replace_existing);
  bool better_match(const FontDescription& old_match, const FontDescription& new_match) const;
  Glib::ustring to_string() const;
  Glib::ustring to_filename() const;
};
}
namespace Pango
{
bool operator==(const FontDescription& lhs, const FontDescription& rhs);
bool operator!=(const FontDescription& lhs, const FontDescription& rhs);
}
namespace Pango
{
inline void swap(FontDescription& lhs, FontDescription& rhs)
  { lhs.swap(rhs); }
}
namespace Glib
{
Pango::FontDescription wrap(PangoFontDescription* object, bool take_copy = false);
template <>
class Value<Pango::FontDescription> : public Glib::Value_Boxed<Pango::FontDescription>
{};
}
extern "C" { typedef struct _PangoFontMetrics PangoFontMetrics; }
namespace Pango
{
class FontMetrics
{
  public:
  typedef FontMetrics CppObjectType;
  typedef PangoFontMetrics BaseObjectType;
  static GType get_type() __attribute__((__const__));
  FontMetrics();
  explicit FontMetrics(PangoFontMetrics* gobject, bool make_a_copy = true);
  FontMetrics(const FontMetrics& other);
  FontMetrics& operator=(const FontMetrics& other);
  ~FontMetrics();
  void swap(FontMetrics& other);
  PangoFontMetrics* gobj() { return gobject_; }
  const PangoFontMetrics* gobj() const { return gobject_; }
  PangoFontMetrics* gobj_copy() const;
protected:
  PangoFontMetrics* gobject_;
private:
public:
  int get_ascent() const;
  int get_descent() const;
  int get_approximate_char_width() const;
  int get_approximate_digit_width() const;
  int get_underline_position() const;
  int get_underline_thickness() const;
  int get_strikethrough_position() const;
  int get_strikethrough_thickness() const;
};
}
namespace Pango
{
inline void swap(FontMetrics& lhs, FontMetrics& rhs)
  { lhs.swap(rhs); }
}
namespace Glib
{
Pango::FontMetrics wrap(PangoFontMetrics* object, bool take_copy = false);
template <>
class Value<Pango::FontMetrics> : public Glib::Value_Boxed<Pango::FontMetrics>
{};
}
namespace Pango
{
enum CoverageLevel
{
  COVERAGE_NONE,
  COVERAGE_FALLBACK,
  COVERAGE_APPROXIMATE,
  COVERAGE_EXACT
};
}
namespace Glib
{
template <>
class Value<Pango::CoverageLevel> : public Glib::Value_Enum<Pango::CoverageLevel>
{
public:
  static GType value_type() __attribute__((__const__));
};
}
namespace Pango
{
class Coverage
{
  public:
  typedef Coverage CppObjectType;
  typedef PangoCoverage BaseObjectType;
  static Glib::RefPtr<Coverage> create();
  void reference() const;
  void unreference() const;
  PangoCoverage* gobj();
  const PangoCoverage* gobj() const;
  PangoCoverage* gobj_copy() const;
protected:
  Coverage();
  void operator delete(void*, size_t);
private:
  Coverage(const Coverage&);
  Coverage& operator=(const Coverage&);
public:
  static Glib::RefPtr<Coverage> create(const guchar* bytes, int n_bytes);
  CoverageLevel get(int index) const;
  void set(int index, CoverageLevel level);
  void max(const Glib::RefPtr<Coverage>& other) const;
  Glib::ArrayHandle<unsigned char> to_bytes() const;
};
}
namespace Glib
{
  Glib::RefPtr<Pango::Coverage> wrap(PangoCoverage* object, bool take_copy = false);
}
typedef struct _PangoFont PangoFont;
typedef struct _PangoFontClass PangoFontClass;
namespace Pango
{ class Font_Class; }
namespace Pango
{
const int SCALE = 1024;
const double SCALE_XX_SMALL = 0.5787037037037;
const double SCALE_X_SMALL = 0.6444444444444;
const double SCALE_SMALL = 0.8333333333333;
const double SCALE_MEDIUM = 1.0;
const double SCALE_LARGE = 1.2;
const double SCALE_X_LARGE = 1.4399999999999;
const double SCALE_XX_LARGE = 1.728;
class FontMap;
class Font : public Glib::Object
{
public:
  typedef Font CppObjectType;
  typedef Font_Class CppClassType;
  typedef PangoFont BaseObjectType;
  typedef PangoFontClass BaseClassType;
private: friend class Font_Class;
  static CppClassType font_class_;
private:
  Font(const Font&);
  Font& operator=(const Font&);
protected:
  explicit Font(const Glib::ConstructParams& construct_params);
  explicit Font(PangoFont* castitem);
public:
  virtual ~Font();
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  PangoFont* gobj() { return reinterpret_cast<PangoFont*>(gobject_); }
  const PangoFont* gobj() const { return reinterpret_cast<PangoFont*>(gobject_); }
  PangoFont* gobj_copy();
private:
public:
  FontDescription describe() const;
  FontDescription describe_with_absolute_size() const;
  Glib::RefPtr<Coverage> get_coverage(const Language& language) const;
  FontMetrics get_metrics() const;
  FontMetrics get_metrics(const Language& language) const;
  void get_glyph_extents(Glyph glyph, Rectangle& ink_rect, Rectangle& logical_rect) const;
  Glib::RefPtr<FontMap> get_font_map();
  Glib::RefPtr<const FontMap> get_font_map() const;
  Rectangle get_glyph_ink_extents(Glyph glyph) const;
  Rectangle get_glyph_logical_extents(Glyph glyph) const;
public:
public:
protected:
};
}
namespace Glib
{
  Glib::RefPtr<Pango::Font> wrap(PangoFont* object, bool take_copy = false);
}
typedef struct _PangoFontset PangoFontset;
typedef struct _PangoFontsetClass PangoFontsetClass;
namespace Pango
{ class Fontset_Class; }
namespace Pango
{
class Fontset : public Glib::Object
{
public:
  typedef Fontset CppObjectType;
  typedef Fontset_Class CppClassType;
  typedef PangoFontset BaseObjectType;
  typedef PangoFontsetClass BaseClassType;
private: friend class Fontset_Class;
  static CppClassType fontset_class_;
private:
  Fontset(const Fontset&);
  Fontset& operator=(const Fontset&);
protected:
  explicit Fontset(const Glib::ConstructParams& construct_params);
  explicit Fontset(PangoFontset* castitem);
public:
  virtual ~Fontset();
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  PangoFontset* gobj() { return reinterpret_cast<PangoFontset*>(gobject_); }
  const PangoFontset* gobj() const { return reinterpret_cast<PangoFontset*>(gobject_); }
  PangoFontset* gobj_copy();
private:
public:
  Glib::RefPtr<Font> get_font(guint wc) const;
  FontMetrics get_metrics() const;
  typedef sigc::slot< bool, const Glib::RefPtr<Font>& > ForeachSlot;
  void foreach(const ForeachSlot& slot);
public:
public:
protected:
};
}
namespace Glib
{
  Glib::RefPtr<Pango::Fontset> wrap(PangoFontset* object, bool take_copy = false);
}
typedef struct _PangoFontFace PangoFontFace;
typedef struct _PangoFontFaceClass PangoFontFaceClass;
namespace Pango
{ class FontFace_Class; }
namespace Pango
{
class FontFace : public Glib::Object
{
public:
  typedef FontFace CppObjectType;
  typedef FontFace_Class CppClassType;
  typedef PangoFontFace BaseObjectType;
  typedef PangoFontFaceClass BaseClassType;
private: friend class FontFace_Class;
  static CppClassType fontface_class_;
private:
  FontFace(const FontFace&);
  FontFace& operator=(const FontFace&);
protected:
  explicit FontFace(const Glib::ConstructParams& construct_params);
  explicit FontFace(PangoFontFace* castitem);
public:
  virtual ~FontFace();
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  PangoFontFace* gobj() { return reinterpret_cast<PangoFontFace*>(gobject_); }
  const PangoFontFace* gobj() const { return reinterpret_cast<PangoFontFace*>(gobject_); }
  PangoFontFace* gobj_copy();
private:
public:
  FontDescription describe() const;
  Glib::ustring get_name() const;
  Glib::ArrayHandle<int> list_sizes() const;
  bool is_synthesized() const;
protected:
public:
public:
protected:
};
}
namespace Glib
{
  Glib::RefPtr<Pango::FontFace> wrap(PangoFontFace* object, bool take_copy = false);
}
typedef struct _PangoFontFamily PangoFontFamily;
typedef struct _PangoFontFamilyClass PangoFontFamilyClass;
namespace Pango
{ class FontFamily_Class; }
namespace Pango
{
class FontFamily : public Glib::Object
{
public:
  typedef FontFamily CppObjectType;
  typedef FontFamily_Class CppClassType;
  typedef PangoFontFamily BaseObjectType;
  typedef PangoFontFamilyClass BaseClassType;
private: friend class FontFamily_Class;
  static CppClassType fontfamily_class_;
private:
  FontFamily(const FontFamily&);
  FontFamily& operator=(const FontFamily&);
protected:
  explicit FontFamily(const Glib::ConstructParams& construct_params);
  explicit FontFamily(PangoFontFamily* castitem);
public:
  virtual ~FontFamily();
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  PangoFontFamily* gobj() { return reinterpret_cast<PangoFontFamily*>(gobject_); }
  const PangoFontFamily* gobj() const { return reinterpret_cast<PangoFontFamily*>(gobject_); }
  PangoFontFamily* gobj_copy();
private:
public:
  Glib::ArrayHandle< Glib::RefPtr<FontFace> > list_faces() const;
  Glib::ustring get_name() const;
  bool is_monospace() const;
public:
public:
protected:
};
}
namespace Glib
{
  Glib::RefPtr<Pango::FontFamily> wrap(PangoFontFamily* object, bool take_copy = false);
}
typedef struct _PangoFontMap PangoFontMap;
typedef struct _PangoFontMapClass PangoFontMapClass;
namespace Pango
{ class FontMap_Class; }
namespace Pango
{
class Context;
class FontMap : public Glib::Object
{
public:
  typedef FontMap CppObjectType;
  typedef FontMap_Class CppClassType;
  typedef PangoFontMap BaseObjectType;
  typedef PangoFontMapClass BaseClassType;
private: friend class FontMap_Class;
  static CppClassType fontmap_class_;
private:
  FontMap(const FontMap&);
  FontMap& operator=(const FontMap&);
protected:
  explicit FontMap(const Glib::ConstructParams& construct_params);
  explicit FontMap(PangoFontMap* castitem);
public:
  virtual ~FontMap();
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  PangoFontMap* gobj() { return reinterpret_cast<PangoFontMap*>(gobject_); }
  const PangoFontMap* gobj() const { return reinterpret_cast<PangoFontMap*>(gobject_); }
  PangoFontMap* gobj_copy();
private:
public:
  Glib::RefPtr<Font> load_font(const Glib::RefPtr<Context>& context, const FontDescription& desc) const;
  Glib::RefPtr<Fontset> load_fontset(const Glib::RefPtr<Context>& context, const FontDescription& desc, const Language& language) const;
  Glib::ArrayHandle< Glib::RefPtr<FontFamily> > list_families() const;
public:
public:
protected:
};
}
namespace Glib
{
  Glib::RefPtr<Pango::FontMap> wrap(PangoFontMap* object, bool take_copy = false);
}
namespace Pango
{
class Color
{
  public:
  typedef Color CppObjectType;
  typedef PangoColor BaseObjectType;
  static GType get_type() __attribute__((__const__));
  Color();
  explicit Color(const PangoColor* gobject);
  PangoColor* gobj() { return &gobject_; }
  const PangoColor* gobj() const { return &gobject_; }
protected:
  PangoColor gobject_;
private:
public:
  operator bool();
   guint16 get_red() const;
   guint16 get_green() const;
   guint16 get_blue() const;
   void set_red(const guint16& value);
   void set_green(const guint16& value);
   void set_blue(const guint16& value);
  bool parse(const Glib::ustring& spec);
  Glib::ustring to_string() const;
};
}
namespace Glib
{
Pango::Color& wrap(PangoColor* object);
const Pango::Color& wrap(const PangoColor* object);
template <>
class Value<Pango::Color> : public Glib::Value_Boxed<Pango::Color>
{};
}
namespace Pango
{
enum AttrType
{
  ATTR_INVALID,
  ATTR_LANGUAGE,
  ATTR_FAMILY,
  ATTR_STYLE,
  ATTR_WEIGHT,
  ATTR_VARIANT,
  ATTR_STRETCH,
  ATTR_SIZE,
  ATTR_FONT_DESC,
  ATTR_FOREGROUND,
  ATTR_BACKGROUND,
  ATTR_UNDERLINE,
  ATTR_STRIKETHROUGH,
  ATTR_RISE,
  ATTR_SHAPE,
  ATTR_SCALE,
  ATTR_FALLBACK,
  ATTR_LETTER_SPACING,
  ATTR_UNDERLINE_COLOR,
  ATTR_STRIKETHROUGH_COLOR,
  ATTR_ABSOLUTE_SIZE,
  ATTR_GRAVITY,
  ATTR_GRAVITY_HINT
};
}
namespace Glib
{
template <>
class Value<Pango::AttrType> : public Glib::Value_Enum<Pango::AttrType>
{
public:
  static GType value_type() __attribute__((__const__));
};
}
namespace Pango
{
enum Underline
{
  UNDERLINE_NONE,
  UNDERLINE_SINGLE,
  UNDERLINE_DOUBLE,
  UNDERLINE_LOW,
  UNDERLINE_ERROR
};
}
namespace Glib
{
template <>
class Value<Pango::Underline> : public Glib::Value_Enum<Pango::Underline>
{
public:
  static GType value_type() __attribute__((__const__));
};
}
namespace Pango
{
typedef PangoLogAttr LogAttr;
class AttrString;
class AttrLanguage;
class AttrColor;
class AttrInt;
class AttrFloat;
class AttrFontDesc;
class AttrShape;
class Attribute
{
  public:
  typedef Attribute CppObjectType;
  typedef PangoAttribute BaseObjectType;
private:
public:
  Attribute();
  Attribute(const Attribute& src);
  explicit Attribute(PangoAttribute* castitem, bool take_copy=true);
  ~Attribute();
  Attribute& operator=(const Attribute& src);
  AttrType get_type() const;
  static AttrType register_type(const Glib::ustring& name);
   unsigned int get_start_index() const;
   unsigned int get_end_index() const;
   void set_start_index(const unsigned int& value);
   void set_end_index(const unsigned int& value);
  bool equal(const Attribute& attr2) const;
  PangoAttribute* gobj() { return gobject_; }
  PangoAttribute* const gobj() const { return gobject_; }
  static AttrString create_attr_family(const Glib::ustring& family);
  static AttrLanguage create_attr_language(const Language& language);
  static AttrColor create_attr_foreground(guint16 red, guint16 green, guint16 blue);
  static AttrColor create_attr_background(guint16 red, guint16 green, guint16 blue);
  static AttrInt create_attr_size(int size);
  static AttrInt create_attr_style(Style style);
  static AttrInt create_attr_weight(Weight weight);
  static AttrInt create_attr_variant(Variant variant);
  static AttrInt create_attr_stretch(Stretch stretch);
  static AttrFontDesc create_attr_font_desc(const FontDescription& desc);
  static AttrInt create_attr_underline(Underline underline);
  static AttrInt create_attr_strikethrough(bool strikethrough);
  static AttrInt create_attr_rise(int rise);
  static AttrFloat create_attr_scale(double scale_factor);
  static AttrShape create_attr_shape(const Rectangle& ink_rect, const Rectangle& logical_rect);
protected:
  PangoAttribute* gobject_;
};
inline bool operator==(const Attribute& lhs, const Attribute& rhs)
{
  return lhs.equal(rhs);
}
inline bool operator!=(const Attribute& lhs, const Attribute& rhs)
{
  return lhs.equal(rhs);
}
class AttrString : public Attribute
{
  public:
  typedef AttrString CppObjectType;
  typedef PangoAttrString BaseObjectType;
private:
protected:
  AttrString();
public:
  AttrString(const AttrString& src);
  explicit AttrString(PangoAttrString* castitem, bool take_copy=true);
  AttrString& operator=(const AttrString& src);
   Glib::ustring get_string() const;
  void set_string(const Glib::ustring& string);
  PangoAttrString* gobj() { return reinterpret_cast<PangoAttrString*>(gobject_); }
  const PangoAttrString* gobj() const { return reinterpret_cast<const PangoAttrString*>(gobject_); }
};
class AttrLanguage : public Attribute
{
  public:
  typedef AttrLanguage CppObjectType;
  typedef PangoAttrLanguage BaseObjectType;
private:
protected:
  AttrLanguage();
public:
  AttrLanguage(const AttrLanguage& src);
  explicit AttrLanguage(PangoAttrLanguage* castitem, bool take_copy=true);
  AttrLanguage& operator=(const AttrLanguage& src);
   Language get_language() const;
   void set_language(const Language& value);
  PangoAttrLanguage* gobj() { return reinterpret_cast<PangoAttrLanguage*>(gobject_); }
  const PangoAttrLanguage* gobj() const { return reinterpret_cast<const PangoAttrLanguage*>(gobject_); }
};
class AttrColor : public Attribute
{
  public:
  typedef AttrColor CppObjectType;
  typedef PangoAttrColor BaseObjectType;
private:
protected:
  AttrColor();
public:
  AttrColor(const AttrColor& src);
  explicit AttrColor(PangoAttrColor* castitem, bool take_copy=true);
  AttrColor& operator=(const AttrColor& src);
   Color get_color() const;
   void set_color(const Color& value);
  PangoAttrColor* gobj() { return reinterpret_cast<PangoAttrColor*>(gobject_); }
  const PangoAttrColor* gobj() const { return reinterpret_cast<const PangoAttrColor*>(gobject_); }
};
class AttrInt : public Attribute
{
  public:
  typedef AttrInt CppObjectType;
  typedef PangoAttrInt BaseObjectType;
private:
protected:
  AttrInt();
public:
  AttrInt(const AttrInt& src);
  explicit AttrInt(PangoAttrInt* castitem, bool take_copy=true);
  AttrInt& operator=(const AttrInt& src);
   int get_value() const;
   void set_value(const int& value);
  PangoAttrInt* gobj() { return reinterpret_cast<PangoAttrInt*>(gobject_); }
  const PangoAttrInt* gobj() const { return reinterpret_cast<const PangoAttrInt*>(gobject_); }
};
class AttrFloat : public Attribute
{
  public:
  typedef AttrFloat CppObjectType;
  typedef PangoAttrFloat BaseObjectType;
private:
protected:
  AttrFloat();
public:
  AttrFloat(const AttrFloat& src);
  explicit AttrFloat(PangoAttrFloat* castitem, bool take_copy=true);
  AttrFloat& operator=(const AttrFloat& src);
   double get_value() const;
   void set_value(const double& value);
  PangoAttrFloat* gobj() { return reinterpret_cast<PangoAttrFloat*>(gobject_); }
  const PangoAttrFloat* gobj() const { return reinterpret_cast<const PangoAttrFloat*>(gobject_); }
};
class AttrFontDesc : public Attribute
{
  public:
  typedef AttrFontDesc CppObjectType;
  typedef PangoAttrFontDesc BaseObjectType;
private:
protected:
  AttrFontDesc();
public:
  AttrFontDesc(const AttrFontDesc& src);
  explicit AttrFontDesc(PangoAttrFontDesc* castitem, bool take_copy=true);
  AttrFontDesc& operator=(const AttrFontDesc& src);
   FontDescription get_desc() const;
  void set_desc(const FontDescription& desc);
  PangoAttrFontDesc* gobj() { return reinterpret_cast<PangoAttrFontDesc*>(gobject_); }
  const PangoAttrFontDesc* gobj() const { return reinterpret_cast<const PangoAttrFontDesc*>(gobject_); }
};
class AttrShape : public Attribute
{
  public:
  typedef AttrShape CppObjectType;
  typedef PangoAttrShape BaseObjectType;
private:
protected:
  AttrShape();
public:
  AttrShape(const AttrShape& src);
  explicit AttrShape(PangoAttrShape* castitem, bool take_copy=true);
  AttrShape& operator=(const AttrShape& src);
   Rectangle get_ink_rect() const;
   Rectangle get_logical_rect() const;
   void set_ink_rect(const Rectangle& value);
   void set_logical_rect(const Rectangle& value);
  PangoAttrShape* gobj() { return reinterpret_cast<PangoAttrShape*>(gobject_); }
  const PangoAttrShape* gobj() const { return reinterpret_cast<const PangoAttrShape*>(gobject_); }
};
struct AttributeTraits
{
  typedef Pango::Attribute CppType;
  typedef const PangoAttribute* CType;
  typedef PangoAttribute* CTypeNonConst;
  static CType to_c_type (const CppType& obj) { return obj.gobj(); }
  static CType to_c_type (CType ptr) { return ptr; }
  static CppType to_cpp_type (CType ptr) { return CppType(const_cast<CTypeNonConst>(ptr), true); }
  static void release_c_type (CType ptr) { pango_attribute_destroy(const_cast<CTypeNonConst>(ptr)); }
};
typedef Glib::SListHandle<Attribute, AttributeTraits> SListHandle_Attribute;
}
namespace Glib
{
Pango::Attribute wrap(PangoAttribute* object, bool take_copy = false);
Pango::AttrString wrap(PangoAttrString* object, bool take_copy = false);
Pango::AttrLanguage wrap(PangoAttrLanguage* object, bool take_copy = false);
Pango::AttrColor wrap(PangoAttrColor* object, bool take_copy = false);
Pango::AttrInt wrap(PangoAttrInt* object, bool take_copy = false);
Pango::AttrFloat wrap(PangoAttrFloat* object, bool take_copy = false);
Pango::AttrFontDesc wrap(PangoAttrFontDesc* object, bool take_copy = false);
Pango::AttrShape wrap(PangoAttrShape* object, bool take_copy = false);
}
namespace Pango
{
class Font;
class GlyphString;
class Analysis
{
  public:
  typedef Analysis CppObjectType;
  typedef PangoAnalysis BaseObjectType;
private:
protected:
  Analysis();
public:
  explicit Analysis(const PangoAnalysis* src);
public:
   Glib::RefPtr<Font> get_font();
  Glib::RefPtr<const Font> get_font() const;
   guint8 get_level() const;
   Language get_language() const;
  SListHandle_Attribute get_extra_attrs() const;
  PangoAnalysis* gobj() { return &gobject_; }
  const PangoAnalysis* gobj() const { return &gobject_; }
protected:
  PangoAnalysis gobject_;
};
class Item
{
  public:
  typedef Item CppObjectType;
  typedef PangoItem BaseObjectType;
private:
public:
  explicit Item(PangoItem* castitem, bool make_a_copy = true);
  Item(const Item& src);
  Item& operator=(const Item& src);
  ~Item();
  PangoItem* gobj_copy() const;
public:
  Item split(int split_index, int split_offset);
   int get_offset() const;
   int get_length() const;
   int get_num_chars() const;
  Analysis get_analysis() const;
  Glib::ustring get_segment(const Glib::ustring& text) const;
  GlyphString shape(const Glib::ustring& text) const;
  PangoItem* gobj() { return gobject_; }
  const PangoItem* gobj() const { return gobject_; }
protected:
  PangoItem* gobject_;
};
struct ItemTraits
{
  typedef Pango::Item CppType;
  typedef const PangoItem* CType;
  typedef PangoItem* CTypeNonConst;
  static CType to_c_type (const CppType& obj) { return obj.gobj(); }
  static CType to_c_type (CType ptr) { return ptr; }
  static CppType to_cpp_type (CType ptr) { return CppType(const_cast<CTypeNonConst>(ptr), true); }
  static void release_c_type (CType ptr) { pango_item_free(const_cast<CTypeNonConst>(ptr)); }
};
typedef Glib::ListHandle<Item, ItemTraits> ListHandle_Item;
}
namespace Glib
{
Pango::Analysis& wrap(PangoAnalysis* object);
const Pango::Analysis& wrap(const PangoAnalysis* object);
Pango::Item wrap(PangoItem* object, bool take_copy=true);
}
namespace Pango
{
class AttrIter
{
  public:
  typedef AttrIter CppObjectType;
  typedef PangoAttrIterator BaseObjectType;
private:
public:
  typedef std::forward_iterator_tag iterator_category;
  typedef int difference_type;
protected:
  AttrIter();
public:
  explicit AttrIter(PangoAttrIterator* castitem, bool take_copy=true);
  AttrIter(const AttrIter& src);
  ~AttrIter();
  AttrIter& operator=(const AttrIter& src);
  AttrIter& operator++();
  const AttrIter operator++(int);
  operator bool() const;
  bool next();
  void get_range(int& start, int& end) const;
  Attribute get_attribute(AttrType type) const;
  FontDescription get_font_desc() const;
  Language get_language() const;
  SListHandle_Attribute get_extra_attrs() const;
  SListHandle_Attribute get_attrs() const;
  PangoAttrIterator* gobj() { return gobject_; }
  const PangoAttrIterator* gobj() const { return gobject_; }
protected:
  PangoAttrIterator* gobject_;
};
}
namespace Glib
{
Pango::AttrIter wrap(PangoAttrIterator* object, bool take_copy=false);
}
extern "C" { typedef struct _PangoAttrList PangoAttrList; }
namespace Pango
{
class AttrList
{
  public:
  typedef AttrList CppObjectType;
  typedef PangoAttrList BaseObjectType;
  static GType get_type() __attribute__((__const__));
  AttrList();
  explicit AttrList(PangoAttrList* gobject, bool make_a_copy = true);
  AttrList(const AttrList& other);
  AttrList& operator=(const AttrList& other);
  ~AttrList();
  void swap(AttrList& other);
  PangoAttrList* gobj() { return gobject_; }
  const PangoAttrList* gobj() const { return gobject_; }
  PangoAttrList* gobj_copy() const;
protected:
  PangoAttrList* gobject_;
private:
public:
  explicit AttrList(const Glib::ustring& markup_text, gunichar accel_marker=0);
  AttrList(const Glib::ustring& markup_text, gunichar accel_marker, Glib::ustring& text, gunichar& accel_char);
  operator bool();
  void insert(Attribute& attr);
  void insert_before(Attribute& attr);
  void change(Attribute& attr);
  void splice(AttrList& other, int pos, int len);
  AttrIter get_iter();
};
}
namespace Pango
{
inline void swap(AttrList& lhs, AttrList& rhs)
  { lhs.swap(rhs); }
}
namespace Glib
{
Pango::AttrList wrap(PangoAttrList* object, bool take_copy = false);
template <>
class Value<Pango::AttrList> : public Glib::Value_Boxed<Pango::AttrList>
{};
}
namespace Pango
{
typedef PangoMatrix Matrix;
}
namespace std
{
  namespace rel_ops
  {
    template <class _Tp>
      inline bool
      operator!=(const _Tp& __x, const _Tp& __y)
      { return !(__x == __y); }
    template <class _Tp>
      inline bool
      operator>(const _Tp& __x, const _Tp& __y)
      { return __y < __x; }
    template <class _Tp>
      inline bool
      operator<=(const _Tp& __x, const _Tp& __y)
      { return !(__y < __x); }
    template <class _Tp>
      inline bool
      operator>=(const _Tp& __x, const _Tp& __y)
      { return !(__x < __y); }
  }
}
namespace std
{
  class logic_error : public exception
  {
    string _M_msg;
  public:
    explicit
    logic_error(const string& __arg);
    virtual
    ~logic_error() throw();
    virtual const char*
    what() const throw();
  };
  class domain_error : public logic_error
  {
  public:
    explicit domain_error(const string& __arg);
  };
  class invalid_argument : public logic_error
  {
  public:
    explicit invalid_argument(const string& __arg);
  };
  class length_error : public logic_error
  {
  public:
    explicit length_error(const string& __arg);
  };
  class out_of_range : public logic_error
  {
  public:
    explicit out_of_range(const string& __arg);
  };
  class runtime_error : public exception
  {
    string _M_msg;
  public:
    explicit
    runtime_error(const string& __arg);
    virtual
    ~runtime_error() throw();
    virtual const char*
    what() const throw();
  };
  class range_error : public runtime_error
  {
  public:
    explicit range_error(const string& __arg);
  };
  class overflow_error : public runtime_error
  {
  public:
    explicit overflow_error(const string& __arg);
  };
  class underflow_error : public runtime_error
  {
  public:
    explicit underflow_error(const string& __arg);
  };
}
namespace Cairo
{
class logic_error: public std::logic_error
{
public:
  explicit logic_error(ErrorStatus status);
  virtual ~logic_error() throw();
private:
  ErrorStatus m_status;
};
}
namespace Cairo
{
template <class T_CppObject>
class RefPtr
{
public:
  inline RefPtr();
  inline ~RefPtr();
  explicit inline RefPtr(T_CppObject* pCppObject);
  explicit inline RefPtr(T_CppObject* pCppObject, int* refcount);
  inline RefPtr(const RefPtr<T_CppObject>& src);
  template <class T_CastFrom>
  inline RefPtr(const RefPtr<T_CastFrom>& src);
  inline void swap(RefPtr<T_CppObject>& other);
  inline RefPtr<T_CppObject>& operator=(const RefPtr<T_CppObject>& src);
  template <class T_CastFrom>
  inline RefPtr<T_CppObject>& operator=(const RefPtr<T_CastFrom>& src);
  inline bool operator==(const RefPtr<T_CppObject>& src) const;
  inline bool operator!=(const RefPtr<T_CppObject>& src) const;
  inline T_CppObject* operator->() const;
  inline operator bool() const;
  inline void clear();
  template <class T_CastFrom>
  static inline RefPtr<T_CppObject> cast_dynamic(const RefPtr<T_CastFrom>& src);
  template <class T_CastFrom>
  static inline RefPtr<T_CppObject> cast_static(const RefPtr<T_CastFrom>& src);
  template <class T_CastFrom>
  static inline RefPtr<T_CppObject> cast_const(const RefPtr<T_CastFrom>& src);
  inline int* refcount_() const { return pCppRefcount_; }
private:
  void unref();
  T_CppObject* pCppObject_;
  mutable int* pCppRefcount_;
};
template <class T_CppObject> inline
T_CppObject* RefPtr<T_CppObject>::operator->() const
{
  return pCppObject_;
}
template <class T_CppObject> inline
RefPtr<T_CppObject>::RefPtr()
:
  pCppObject_(0),
  pCppRefcount_(0)
{}
template <class T_CppObject> inline
RefPtr<T_CppObject>::~RefPtr()
{
  unref();
}
template <class T_CppObject> inline
void RefPtr<T_CppObject>::unref()
{
  if(pCppRefcount_)
  {
    --(*pCppRefcount_);
    if(*pCppRefcount_ == 0)
    {
      if(pCppObject_)
      {
        delete pCppObject_;
        pCppObject_ = 0;
      }
      delete pCppRefcount_;
      pCppRefcount_ = 0;
    }
  }
}
template <class T_CppObject> inline
RefPtr<T_CppObject>::RefPtr(T_CppObject* pCppObject)
:
  pCppObject_(pCppObject),
  pCppRefcount_(0)
{
  if(pCppObject)
  {
    pCppRefcount_ = new int;
    *pCppRefcount_ = 1;
  }
}
template <class T_CppObject> inline
RefPtr<T_CppObject>::RefPtr(T_CppObject* pCppObject, int* refcount)
:
  pCppObject_(pCppObject),
  pCppRefcount_(refcount)
{
  if(pCppObject_ && pCppRefcount_)
    ++(*pCppRefcount_);
}
template <class T_CppObject> inline
RefPtr<T_CppObject>::RefPtr(const RefPtr<T_CppObject>& src)
:
  pCppObject_ (src.pCppObject_),
  pCppRefcount_(src.pCppRefcount_)
{
  if(pCppObject_ && pCppRefcount_)
    ++(*pCppRefcount_);
}
template <class T_CppObject>
  template <class T_CastFrom>
inline
RefPtr<T_CppObject>::RefPtr(const RefPtr<T_CastFrom>& src)
:
  pCppObject_ (src.operator->()),
  pCppRefcount_(src.refcount_())
{
  if(pCppObject_ && pCppRefcount_)
    ++(*pCppRefcount_);
}
template <class T_CppObject> inline
void RefPtr<T_CppObject>::swap(RefPtr<T_CppObject>& other)
{
  T_CppObject *const temp = pCppObject_;
  int* temp_count = pCppRefcount_;
  pCppObject_ = other.pCppObject_;
  pCppRefcount_ = other.pCppRefcount_;
  other.pCppObject_ = temp;
  other.pCppRefcount_ = temp_count;
}
template <class T_CppObject> inline
RefPtr<T_CppObject>& RefPtr<T_CppObject>::operator=(const RefPtr<T_CppObject>& src)
{
  RefPtr<T_CppObject> temp (src);
  this->swap(temp);
  return *this;
}
template <class T_CppObject>
  template <class T_CastFrom>
inline
RefPtr<T_CppObject>& RefPtr<T_CppObject>::operator=(const RefPtr<T_CastFrom>& src)
{
  RefPtr<T_CppObject> temp (src);
  this->swap(temp);
  return *this;
}
template <class T_CppObject> inline
bool RefPtr<T_CppObject>::operator==(const RefPtr<T_CppObject>& src) const
{
  return (pCppObject_ == src.pCppObject_);
}
template <class T_CppObject> inline
bool RefPtr<T_CppObject>::operator!=(const RefPtr<T_CppObject>& src) const
{
  return (pCppObject_ != src.pCppObject_);
}
template <class T_CppObject> inline
RefPtr<T_CppObject>::operator bool() const
{
  return (pCppObject_ != 0);
}
template <class T_CppObject> inline
void RefPtr<T_CppObject>::clear()
{
  RefPtr<T_CppObject> temp;
  this->swap(temp);
}
template <class T_CppObject>
  template <class T_CastFrom>
inline
RefPtr<T_CppObject> RefPtr<T_CppObject>::cast_dynamic(const RefPtr<T_CastFrom>& src)
{
  T_CppObject *const pCppObject = dynamic_cast<T_CppObject*>(src.operator->());
  if(pCppObject)
    return RefPtr<T_CppObject>(pCppObject, src.refcount_());
  else
    return RefPtr<T_CppObject>();
}
template <class T_CppObject>
  template <class T_CastFrom>
inline
RefPtr<T_CppObject> RefPtr<T_CppObject>::cast_static(const RefPtr<T_CastFrom>& src)
{
  T_CppObject *const pCppObject = static_cast<T_CppObject*>(src.operator->());
  return RefPtr<T_CppObject>(pCppObject, src.refcount_());
}
template <class T_CppObject>
  template <class T_CastFrom>
inline
RefPtr<T_CppObject> RefPtr<T_CppObject>::cast_const(const RefPtr<T_CastFrom>& src)
{
  T_CppObject *const pCppObject = const_cast<T_CppObject*>(src.operator->());
  return RefPtr<T_CppObject>(pCppObject, src.refcount_());
}
template <class T_CppObject> inline
void swap(RefPtr<T_CppObject>& lhs, RefPtr<T_CppObject>& rhs)
{
  lhs.swap(rhs);
}
}
extern "C" {
 cairo_surface_t *
cairo_pdf_surface_create (const char *filename,
     double width_in_points,
     double height_in_points);
 cairo_surface_t *
cairo_pdf_surface_create_for_stream (cairo_write_func_t write_func,
         void *closure,
         double width_in_points,
         double height_in_points);
 void
cairo_pdf_surface_set_size (cairo_surface_t *surface,
       double width_in_points,
       double height_in_points);
}
extern "C" {
 cairo_surface_t *
cairo_ps_surface_create (const char *filename,
    double width_in_points,
    double height_in_points);
 cairo_surface_t *
cairo_ps_surface_create_for_stream (cairo_write_func_t write_func,
        void *closure,
        double width_in_points,
        double height_in_points);
 void
cairo_ps_surface_set_size (cairo_surface_t *surface,
      double width_in_points,
      double height_in_points);
 void
cairo_ps_surface_dsc_comment (cairo_surface_t *surface,
         const char *comment);
 void
cairo_ps_surface_dsc_begin_setup (cairo_surface_t *surface);
 void
cairo_ps_surface_dsc_begin_page_setup (cairo_surface_t *surface);
}
extern "C" {
typedef enum _cairo_svg_version {
    CAIRO_SVG_VERSION_1_1,
    CAIRO_SVG_VERSION_1_2
} cairo_svg_version_t;
 cairo_surface_t *
cairo_svg_surface_create (const char *filename,
     double width_in_points,
     double height_in_points);
 cairo_surface_t *
cairo_svg_surface_create_for_stream (cairo_write_func_t write_func,
         void *closure,
         double width_in_points,
         double height_in_points);
 void
cairo_svg_surface_restrict_to_version (cairo_surface_t *surface,
           cairo_svg_version_t version);
 void
cairo_svg_get_versions (cairo_svg_version_t const **versions,
                        int *num_versions);
 const char *
cairo_svg_version_to_string (cairo_svg_version_t version);
}
namespace Cairo
{
class Surface
{
public:
  explicit Surface(cairo_surface_t* cobject, bool has_reference = false);
  virtual ~Surface();
  void get_font_options(FontOptions& options) const;
  void finish();
  void flush();
  void mark_dirty();
  void mark_dirty(int x, int y, int width, int height);
  void set_device_offset(double x_offset, double y_offset);
  void get_device_offset(double& x_offset, double& y_offset) const;
  void set_fallback_resolution(double x_pixels_per_inch, double y_pixels_per_inch);
  SurfaceType get_type() const;
  void write_to_png(const std::string& filename);
  void write_to_png(cairo_write_func_t write_func, void *closure);
  typedef cairo_surface_t cobject;
  inline cobject* cobj() { return m_cobject; }
  inline const cobject* cobj() const { return m_cobject; }
  inline ErrorStatus get_status() const
  { return cairo_surface_status(const_cast<cairo_surface_t*>(cobj())); }
  void reference() const;
  void unreference() const;
  static RefPtr<Surface> create(const RefPtr<Surface> other, Content content, int width, int height);
protected:
  cobject* m_cobject;
};
class ImageSurface : public Surface
{
protected:
public:
  explicit ImageSurface(cairo_surface_t* cobject, bool has_reference = false);
  virtual ~ImageSurface();
  int get_width() const;
  int get_height() const;
  unsigned char* get_data();
  const unsigned char* get_data() const;
  Format get_format() const;
  int get_stride() const;
  static RefPtr<ImageSurface> create(Format format, int width, int height);
  static RefPtr<ImageSurface> create(unsigned char* data, Format format, int width, int height, int stride);
  static RefPtr<ImageSurface> create_from_png(std::string filename);
  static RefPtr<ImageSurface> create_from_png(cairo_read_func_t read_func, void *closure);
};
class PdfSurface : public Surface
{
public:
  explicit PdfSurface(cairo_surface_t* cobject, bool has_reference = false);
  virtual ~PdfSurface();
  static RefPtr<PdfSurface> create(std::string filename, double width_in_points, double height_in_points);
  static RefPtr<PdfSurface> create(cairo_write_func_t write_func, void *closure, double width_in_points, double height_in_points);
  void set_size(double width_in_points, double height_in_points);
};
class PsSurface : public Surface
{
public:
  explicit PsSurface(cairo_surface_t* cobject, bool has_reference = false);
  virtual ~PsSurface();
  static RefPtr<PsSurface> create(std::string filename, double width_in_points, double height_in_points);
  static RefPtr<PsSurface> create(cairo_write_func_t write_func, void *closure, double width_in_points, double height_in_points);
  void set_size(double width_in_points, double height_in_points);
  void dsc_comment(std::string comment);
  void dsc_begin_setup();
  void dsc_begin_page_setup();
};
typedef enum
{
  SVG_VERSION_1_1 = CAIRO_SVG_VERSION_1_1,
  SVG_VERSION_1_2 = CAIRO_SVG_VERSION_1_2
} SvgVersion;
class SvgSurface : public Surface
{
public:
  explicit SvgSurface(cairo_surface_t* cobject, bool has_reference = false);
  virtual ~SvgSurface();
  static RefPtr<SvgSurface> create(std::string filename, double width_in_points, double height_in_points);
  static RefPtr<SvgSurface> create(cairo_write_func_t write_func, void *closure, double width_in_points, double height_in_points);
  void restrict_to_version(SvgVersion version);
  static const std::vector<SvgVersion> get_versions();
  static std::string version_to_string(SvgVersion version);
};
}
namespace Cairo
{
class FontFace
{
protected:
public:
  explicit FontFace(cairo_font_face_t* cobject, bool has_reference = false);
  virtual ~FontFace();
  FontType get_type() const;
  typedef cairo_font_face_t cobject;
  inline cobject* cobj() { return m_cobject; }
  inline const cobject* cobj() const { return m_cobject; }
  inline ErrorStatus get_status() const
  { return cairo_font_face_status(const_cast<cairo_font_face_t*>(cobj())); }
  void reference() const;
  void unreference() const;
protected:
  cobject* m_cobject;
};
}
namespace Cairo
{
struct ColorStop
{
  double offset;
  double red, green, blue, alpha;
};
class Pattern
{
protected:
public:
  explicit Pattern(cairo_pattern_t* cobject, bool has_reference = false);
  virtual ~Pattern();
  void set_matrix(const cairo_matrix_t &matrix);
  void get_matrix(cairo_matrix_t &matrix) const;
  PatternType get_type() const;
  typedef cairo_pattern_t cobject;
  inline cobject* cobj() { return m_cobject; }
  inline const cobject* cobj() const { return m_cobject; }
  inline ErrorStatus get_status() const
  { return cairo_pattern_status(const_cast<cairo_pattern_t*>(cobj())); }
  void reference() const;
  void unreference() const;
protected:
  Pattern();
  cobject* m_cobject;
};
class SolidPattern : public Pattern
{
protected:
public:
  explicit SolidPattern(cairo_pattern_t* cobject, bool has_reference = false);
  void get_rgba (double& red, double& green,
                 double& blue, double& alpha) const;
  static RefPtr<SolidPattern> create_rgb(double red, double green, double blue);
  static RefPtr<SolidPattern> create_rgba(double red, double green,
                                          double blue, double alpha);
  virtual ~SolidPattern();
};
class SurfacePattern : public Pattern
{
protected:
  explicit SurfacePattern(const RefPtr<Surface>& surface);
public:
  explicit SurfacePattern(cairo_pattern_t* cobject, bool has_reference = false);
  RefPtr<const Surface> get_surface () const;
  RefPtr<Surface> get_surface ();
  virtual ~SurfacePattern();
  static RefPtr<SurfacePattern> create(const RefPtr<Surface>& surface);
  void set_extend(Extend extend);
  Extend get_extend() const;
  void set_filter(Filter filter);
  Filter get_filter() const;
};
class Gradient : public Pattern
{
protected:
public:
  explicit Gradient(cairo_pattern_t* cobject, bool has_reference = false);
  virtual ~Gradient();
  void add_color_stop_rgb(double offset, double red, double green, double blue);
  void add_color_stop_rgba(double offset, double red, double green, double blue, double alpha);
  std::vector<ColorStop> get_color_stops() const;
protected:
  Gradient();
};
class LinearGradient : public Gradient
{
protected:
  LinearGradient(double x0, double y0, double x1, double y1);
public:
  explicit LinearGradient(cairo_pattern_t* cobject, bool has_reference = false);
  void get_linear_points(double &x0, double &y0,
                          double &x1, double &y1) const;
  virtual ~LinearGradient();
  static RefPtr<LinearGradient> create(double x0, double y0, double x1, double y1);
};
class RadialGradient : public Gradient
{
protected:
  RadialGradient(double cx0, double cy0, double radius0, double cx1, double cy1, double radius1);
public:
  explicit RadialGradient(cairo_pattern_t* cobject, bool has_reference = false);
  void get_radial_circles(double& x0, double& y0, double& r0,
                           double& x1, double& y1, double& r1) const;
  virtual ~RadialGradient();
  static RefPtr<RadialGradient> create(double cx0, double cy0, double radius0, double cx1, double cy1, double radius1);
};
}
namespace Cairo
{
class Path
{
public:
  explicit Path(cairo_path_t* cobject, bool take_ownership = false);
  virtual ~Path();
  typedef cairo_path_t cobject;
  inline cobject* cobj() { return m_cobject; }
  inline const cobject* cobj() const { return m_cobject; }
protected:
  cobject* m_cobject;
};
}
extern "C" {
typedef long double float_t;
typedef long double double_t;
extern double acos (double __x) throw (); extern double __acos (double __x) throw ();
extern double asin (double __x) throw (); extern double __asin (double __x) throw ();
extern double atan (double __x) throw (); extern double __atan (double __x) throw ();
extern double atan2 (double __y, double __x) throw (); extern double __atan2 (double __y, double __x) throw ();
extern double cos (double __x) throw (); extern double __cos (double __x) throw ();
extern double sin (double __x) throw (); extern double __sin (double __x) throw ();
extern double tan (double __x) throw (); extern double __tan (double __x) throw ();
extern double cosh (double __x) throw (); extern double __cosh (double __x) throw ();
extern double sinh (double __x) throw (); extern double __sinh (double __x) throw ();
extern double tanh (double __x) throw (); extern double __tanh (double __x) throw ();
extern void sincos (double __x, double *__sinx, double *__cosx) throw (); extern void __sincos (double __x, double *__sinx, double *__cosx) throw ();
extern double acosh (double __x) throw (); extern double __acosh (double __x) throw ();
extern double asinh (double __x) throw (); extern double __asinh (double __x) throw ();
extern double atanh (double __x) throw (); extern double __atanh (double __x) throw ();
extern double exp (double __x) throw (); extern double __exp (double __x) throw ();
extern double frexp (double __x, int *__exponent) throw (); extern double __frexp (double __x, int *__exponent) throw ();
extern double ldexp (double __x, int __exponent) throw (); extern double __ldexp (double __x, int __exponent) throw ();
extern double log (double __x) throw (); extern double __log (double __x) throw ();
extern double log10 (double __x) throw (); extern double __log10 (double __x) throw ();
extern double modf (double __x, double *__iptr) throw (); extern double __modf (double __x, double *__iptr) throw ();
extern double exp10 (double __x) throw (); extern double __exp10 (double __x) throw ();
extern double pow10 (double __x) throw (); extern double __pow10 (double __x) throw ();
extern double expm1 (double __x) throw (); extern double __expm1 (double __x) throw ();
extern double log1p (double __x) throw (); extern double __log1p (double __x) throw ();
extern double logb (double __x) throw (); extern double __logb (double __x) throw ();
extern double exp2 (double __x) throw (); extern double __exp2 (double __x) throw ();
extern double log2 (double __x) throw (); extern double __log2 (double __x) throw ();
extern double pow (double __x, double __y) throw (); extern double __pow (double __x, double __y) throw ();
extern double sqrt (double __x) throw (); extern double __sqrt (double __x) throw ();
extern double hypot (double __x, double __y) throw (); extern double __hypot (double __x, double __y) throw ();
extern double cbrt (double __x) throw (); extern double __cbrt (double __x) throw ();
extern double ceil (double __x) throw () __attribute__ ((__const__)); extern double __ceil (double __x) throw () __attribute__ ((__const__));
extern double fabs (double __x) throw () __attribute__ ((__const__)); extern double __fabs (double __x) throw () __attribute__ ((__const__));
extern double floor (double __x) throw () __attribute__ ((__const__)); extern double __floor (double __x) throw () __attribute__ ((__const__));
extern double fmod (double __x, double __y) throw (); extern double __fmod (double __x, double __y) throw ();
extern int __isinf (double __value) throw () __attribute__ ((__const__));
extern int __finite (double __value) throw () __attribute__ ((__const__));
extern int isinf (double __value) throw () __attribute__ ((__const__));
extern int finite (double __value) throw () __attribute__ ((__const__));
extern double drem (double __x, double __y) throw (); extern double __drem (double __x, double __y) throw ();
extern double significand (double __x) throw (); extern double __significand (double __x) throw ();
extern double copysign (double __x, double __y) throw () __attribute__ ((__const__)); extern double __copysign (double __x, double __y) throw () __attribute__ ((__const__));
extern double nan (__const char *__tagb) throw () __attribute__ ((__const__)); extern double __nan (__const char *__tagb) throw () __attribute__ ((__const__));
extern int __isnan (double __value) throw () __attribute__ ((__const__));
extern int isnan (double __value) throw () __attribute__ ((__const__));
extern double j0 (double) throw (); extern double __j0 (double) throw ();
extern double j1 (double) throw (); extern double __j1 (double) throw ();
extern double jn (int, double) throw (); extern double __jn (int, double) throw ();
extern double y0 (double) throw (); extern double __y0 (double) throw ();
extern double y1 (double) throw (); extern double __y1 (double) throw ();
extern double yn (int, double) throw (); extern double __yn (int, double) throw ();
extern double erf (double) throw (); extern double __erf (double) throw ();
extern double erfc (double) throw (); extern double __erfc (double) throw ();
extern double lgamma (double) throw (); extern double __lgamma (double) throw ();
extern double tgamma (double) throw (); extern double __tgamma (double) throw ();
extern double gamma (double) throw (); extern double __gamma (double) throw ();
extern double lgamma_r (double, int *__signgamp) throw (); extern double __lgamma_r (double, int *__signgamp) throw ();
extern double rint (double __x) throw (); extern double __rint (double __x) throw ();
extern double nextafter (double __x, double __y) throw () __attribute__ ((__const__)); extern double __nextafter (double __x, double __y) throw () __attribute__ ((__const__));
extern double nexttoward (double __x, long double __y) throw () __attribute__ ((__const__)); extern double __nexttoward (double __x, long double __y) throw () __attribute__ ((__const__));
extern double remainder (double __x, double __y) throw (); extern double __remainder (double __x, double __y) throw ();
extern double scalbn (double __x, int __n) throw (); extern double __scalbn (double __x, int __n) throw ();
extern int ilogb (double __x) throw (); extern int __ilogb (double __x) throw ();
extern double scalbln (double __x, long int __n) throw (); extern double __scalbln (double __x, long int __n) throw ();
extern double nearbyint (double __x) throw (); extern double __nearbyint (double __x) throw ();
extern double round (double __x) throw () __attribute__ ((__const__)); extern double __round (double __x) throw () __attribute__ ((__const__));
extern double trunc (double __x) throw () __attribute__ ((__const__)); extern double __trunc (double __x) throw () __attribute__ ((__const__));
extern double remquo (double __x, double __y, int *__quo) throw (); extern double __remquo (double __x, double __y, int *__quo) throw ();
extern long int lrint (double __x) throw (); extern long int __lrint (double __x) throw ();
extern long long int llrint (double __x) throw (); extern long long int __llrint (double __x) throw ();
extern long int lround (double __x) throw (); extern long int __lround (double __x) throw ();
extern long long int llround (double __x) throw (); extern long long int __llround (double __x) throw ();
extern double fdim (double __x, double __y) throw (); extern double __fdim (double __x, double __y) throw ();
extern double fmax (double __x, double __y) throw (); extern double __fmax (double __x, double __y) throw ();
extern double fmin (double __x, double __y) throw (); extern double __fmin (double __x, double __y) throw ();
extern int __fpclassify (double __value) throw ()
     __attribute__ ((__const__));
extern int __signbit (double __value) throw ()
     __attribute__ ((__const__));
extern double fma (double __x, double __y, double __z) throw (); extern double __fma (double __x, double __y, double __z) throw ();
extern double scalb (double __x, double __n) throw (); extern double __scalb (double __x, double __n) throw ();
extern float acosf (float __x) throw (); extern float __acosf (float __x) throw ();
extern float asinf (float __x) throw (); extern float __asinf (float __x) throw ();
extern float atanf (float __x) throw (); extern float __atanf (float __x) throw ();
extern float atan2f (float __y, float __x) throw (); extern float __atan2f (float __y, float __x) throw ();
extern float cosf (float __x) throw (); extern float __cosf (float __x) throw ();
extern float sinf (float __x) throw (); extern float __sinf (float __x) throw ();
extern float tanf (float __x) throw (); extern float __tanf (float __x) throw ();
extern float coshf (float __x) throw (); extern float __coshf (float __x) throw ();
extern float sinhf (float __x) throw (); extern float __sinhf (float __x) throw ();
extern float tanhf (float __x) throw (); extern float __tanhf (float __x) throw ();
extern void sincosf (float __x, float *__sinx, float *__cosx) throw (); extern void __sincosf (float __x, float *__sinx, float *__cosx) throw ();
extern float acoshf (float __x) throw (); extern float __acoshf (float __x) throw ();
extern float asinhf (float __x) throw (); extern float __asinhf (float __x) throw ();
extern float atanhf (float __x) throw (); extern float __atanhf (float __x) throw ();
extern float expf (float __x) throw (); extern float __expf (float __x) throw ();
extern float frexpf (float __x, int *__exponent) throw (); extern float __frexpf (float __x, int *__exponent) throw ();
extern float ldexpf (float __x, int __exponent) throw (); extern float __ldexpf (float __x, int __exponent) throw ();
extern float logf (float __x) throw (); extern float __logf (float __x) throw ();
extern float log10f (float __x) throw (); extern float __log10f (float __x) throw ();
extern float modff (float __x, float *__iptr) throw (); extern float __modff (float __x, float *__iptr) throw ();
extern float exp10f (float __x) throw (); extern float __exp10f (float __x) throw ();
extern float pow10f (float __x) throw (); extern float __pow10f (float __x) throw ();
extern float expm1f (float __x) throw (); extern float __expm1f (float __x) throw ();
extern float log1pf (float __x) throw (); extern float __log1pf (float __x) throw ();
extern float logbf (float __x) throw (); extern float __logbf (float __x) throw ();
extern float exp2f (float __x) throw (); extern float __exp2f (float __x) throw ();
extern float log2f (float __x) throw (); extern float __log2f (float __x) throw ();
extern float powf (float __x, float __y) throw (); extern float __powf (float __x, float __y) throw ();
extern float sqrtf (float __x) throw (); extern float __sqrtf (float __x) throw ();
extern float hypotf (float __x, float __y) throw (); extern float __hypotf (float __x, float __y) throw ();
extern float cbrtf (float __x) throw (); extern float __cbrtf (float __x) throw ();
extern float ceilf (float __x) throw () __attribute__ ((__const__)); extern float __ceilf (float __x) throw () __attribute__ ((__const__));
extern float fabsf (float __x) throw () __attribute__ ((__const__)); extern float __fabsf (float __x) throw () __attribute__ ((__const__));
extern float floorf (float __x) throw () __attribute__ ((__const__)); extern float __floorf (float __x) throw () __attribute__ ((__const__));
extern float fmodf (float __x, float __y) throw (); extern float __fmodf (float __x, float __y) throw ();
extern int __isinff (float __value) throw () __attribute__ ((__const__));
extern int __finitef (float __value) throw () __attribute__ ((__const__));
extern int isinff (float __value) throw () __attribute__ ((__const__));
extern int finitef (float __value) throw () __attribute__ ((__const__));
extern float dremf (float __x, float __y) throw (); extern float __dremf (float __x, float __y) throw ();
extern float significandf (float __x) throw (); extern float __significandf (float __x) throw ();
extern float copysignf (float __x, float __y) throw () __attribute__ ((__const__)); extern float __copysignf (float __x, float __y) throw () __attribute__ ((__const__));
extern float nanf (__const char *__tagb) throw () __attribute__ ((__const__)); extern float __nanf (__const char *__tagb) throw () __attribute__ ((__const__));
extern int __isnanf (float __value) throw () __attribute__ ((__const__));
extern int isnanf (float __value) throw () __attribute__ ((__const__));
extern float j0f (float) throw (); extern float __j0f (float) throw ();
extern float j1f (float) throw (); extern float __j1f (float) throw ();
extern float jnf (int, float) throw (); extern float __jnf (int, float) throw ();
extern float y0f (float) throw (); extern float __y0f (float) throw ();
extern float y1f (float) throw (); extern float __y1f (float) throw ();
extern float ynf (int, float) throw (); extern float __ynf (int, float) throw ();
extern float erff (float) throw (); extern float __erff (float) throw ();
extern float erfcf (float) throw (); extern float __erfcf (float) throw ();
extern float lgammaf (float) throw (); extern float __lgammaf (float) throw ();
extern float tgammaf (float) throw (); extern float __tgammaf (float) throw ();
extern float gammaf (float) throw (); extern float __gammaf (float) throw ();
extern float lgammaf_r (float, int *__signgamp) throw (); extern float __lgammaf_r (float, int *__signgamp) throw ();
extern float rintf (float __x) throw (); extern float __rintf (float __x) throw ();
extern float nextafterf (float __x, float __y) throw () __attribute__ ((__const__)); extern float __nextafterf (float __x, float __y) throw () __attribute__ ((__const__));
extern float nexttowardf (float __x, long double __y) throw () __attribute__ ((__const__)); extern float __nexttowardf (float __x, long double __y) throw () __attribute__ ((__const__));
extern float remainderf (float __x, float __y) throw (); extern float __remainderf (float __x, float __y) throw ();
extern float scalbnf (float __x, int __n) throw (); extern float __scalbnf (float __x, int __n) throw ();
extern int ilogbf (float __x) throw (); extern int __ilogbf (float __x) throw ();
extern float scalblnf (float __x, long int __n) throw (); extern float __scalblnf (float __x, long int __n) throw ();
extern float nearbyintf (float __x) throw (); extern float __nearbyintf (float __x) throw ();
extern float roundf (float __x) throw () __attribute__ ((__const__)); extern float __roundf (float __x) throw () __attribute__ ((__const__));
extern float truncf (float __x) throw () __attribute__ ((__const__)); extern float __truncf (float __x) throw () __attribute__ ((__const__));
extern float remquof (float __x, float __y, int *__quo) throw (); extern float __remquof (float __x, float __y, int *__quo) throw ();
extern long int lrintf (float __x) throw (); extern long int __lrintf (float __x) throw ();
extern long long int llrintf (float __x) throw (); extern long long int __llrintf (float __x) throw ();
extern long int lroundf (float __x) throw (); extern long int __lroundf (float __x) throw ();
extern long long int llroundf (float __x) throw (); extern long long int __llroundf (float __x) throw ();
extern float fdimf (float __x, float __y) throw (); extern float __fdimf (float __x, float __y) throw ();
extern float fmaxf (float __x, float __y) throw (); extern float __fmaxf (float __x, float __y) throw ();
extern float fminf (float __x, float __y) throw (); extern float __fminf (float __x, float __y) throw ();
extern int __fpclassifyf (float __value) throw ()
     __attribute__ ((__const__));
extern int __signbitf (float __value) throw ()
     __attribute__ ((__const__));
extern float fmaf (float __x, float __y, float __z) throw (); extern float __fmaf (float __x, float __y, float __z) throw ();
extern float scalbf (float __x, float __n) throw (); extern float __scalbf (float __x, float __n) throw ();
extern long double acosl (long double __x) throw (); extern long double __acosl (long double __x) throw ();
extern long double asinl (long double __x) throw (); extern long double __asinl (long double __x) throw ();
extern long double atanl (long double __x) throw (); extern long double __atanl (long double __x) throw ();
extern long double atan2l (long double __y, long double __x) throw (); extern long double __atan2l (long double __y, long double __x) throw ();
extern long double cosl (long double __x) throw (); extern long double __cosl (long double __x) throw ();
extern long double sinl (long double __x) throw (); extern long double __sinl (long double __x) throw ();
extern long double tanl (long double __x) throw (); extern long double __tanl (long double __x) throw ();
extern long double coshl (long double __x) throw (); extern long double __coshl (long double __x) throw ();
extern long double sinhl (long double __x) throw (); extern long double __sinhl (long double __x) throw ();
extern long double tanhl (long double __x) throw (); extern long double __tanhl (long double __x) throw ();
extern void sincosl (long double __x, long double *__sinx, long double *__cosx) throw (); extern void __sincosl (long double __x, long double *__sinx, long double *__cosx) throw ();
extern long double acoshl (long double __x) throw (); extern long double __acoshl (long double __x) throw ();
extern long double asinhl (long double __x) throw (); extern long double __asinhl (long double __x) throw ();
extern long double atanhl (long double __x) throw (); extern long double __atanhl (long double __x) throw ();
extern long double expl (long double __x) throw (); extern long double __expl (long double __x) throw ();
extern long double frexpl (long double __x, int *__exponent) throw (); extern long double __frexpl (long double __x, int *__exponent) throw ();
extern long double ldexpl (long double __x, int __exponent) throw (); extern long double __ldexpl (long double __x, int __exponent) throw ();
extern long double logl (long double __x) throw (); extern long double __logl (long double __x) throw ();
extern long double log10l (long double __x) throw (); extern long double __log10l (long double __x) throw ();
extern long double modfl (long double __x, long double *__iptr) throw (); extern long double __modfl (long double __x, long double *__iptr) throw ();
extern long double exp10l (long double __x) throw (); extern long double __exp10l (long double __x) throw ();
extern long double pow10l (long double __x) throw (); extern long double __pow10l (long double __x) throw ();
extern long double expm1l (long double __x) throw (); extern long double __expm1l (long double __x) throw ();
extern long double log1pl (long double __x) throw (); extern long double __log1pl (long double __x) throw ();
extern long double logbl (long double __x) throw (); extern long double __logbl (long double __x) throw ();
extern long double exp2l (long double __x) throw (); extern long double __exp2l (long double __x) throw ();
extern long double log2l (long double __x) throw (); extern long double __log2l (long double __x) throw ();
extern long double powl (long double __x, long double __y) throw (); extern long double __powl (long double __x, long double __y) throw ();
extern long double sqrtl (long double __x) throw (); extern long double __sqrtl (long double __x) throw ();
extern long double hypotl (long double __x, long double __y) throw (); extern long double __hypotl (long double __x, long double __y) throw ();
extern long double cbrtl (long double __x) throw (); extern long double __cbrtl (long double __x) throw ();
extern long double ceill (long double __x) throw () __attribute__ ((__const__)); extern long double __ceill (long double __x) throw () __attribute__ ((__const__));
extern long double fabsl (long double __x) throw () __attribute__ ((__const__)); extern long double __fabsl (long double __x) throw () __attribute__ ((__const__));
extern long double floorl (long double __x) throw () __attribute__ ((__const__)); extern long double __floorl (long double __x) throw () __attribute__ ((__const__));
extern long double fmodl (long double __x, long double __y) throw (); extern long double __fmodl (long double __x, long double __y) throw ();
extern int __isinfl (long double __value) throw () __attribute__ ((__const__));
extern int __finitel (long double __value) throw () __attribute__ ((__const__));
extern int isinfl (long double __value) throw () __attribute__ ((__const__));
extern int finitel (long double __value) throw () __attribute__ ((__const__));
extern long double dreml (long double __x, long double __y) throw (); extern long double __dreml (long double __x, long double __y) throw ();
extern long double significandl (long double __x) throw (); extern long double __significandl (long double __x) throw ();
extern long double copysignl (long double __x, long double __y) throw () __attribute__ ((__const__)); extern long double __copysignl (long double __x, long double __y) throw () __attribute__ ((__const__));
extern long double nanl (__const char *__tagb) throw () __attribute__ ((__const__)); extern long double __nanl (__const char *__tagb) throw () __attribute__ ((__const__));
extern int __isnanl (long double __value) throw () __attribute__ ((__const__));
extern int isnanl (long double __value) throw () __attribute__ ((__const__));
extern long double j0l (long double) throw (); extern long double __j0l (long double) throw ();
extern long double j1l (long double) throw (); extern long double __j1l (long double) throw ();
extern long double jnl (int, long double) throw (); extern long double __jnl (int, long double) throw ();
extern long double y0l (long double) throw (); extern long double __y0l (long double) throw ();
extern long double y1l (long double) throw (); extern long double __y1l (long double) throw ();
extern long double ynl (int, long double) throw (); extern long double __ynl (int, long double) throw ();
extern long double erfl (long double) throw (); extern long double __erfl (long double) throw ();
extern long double erfcl (long double) throw (); extern long double __erfcl (long double) throw ();
extern long double lgammal (long double) throw (); extern long double __lgammal (long double) throw ();
extern long double tgammal (long double) throw (); extern long double __tgammal (long double) throw ();
extern long double gammal (long double) throw (); extern long double __gammal (long double) throw ();
extern long double lgammal_r (long double, int *__signgamp) throw (); extern long double __lgammal_r (long double, int *__signgamp) throw ();
extern long double rintl (long double __x) throw (); extern long double __rintl (long double __x) throw ();
extern long double nextafterl (long double __x, long double __y) throw () __attribute__ ((__const__)); extern long double __nextafterl (long double __x, long double __y) throw () __attribute__ ((__const__));
extern long double nexttowardl (long double __x, long double __y) throw () __attribute__ ((__const__)); extern long double __nexttowardl (long double __x, long double __y) throw () __attribute__ ((__const__));
extern long double remainderl (long double __x, long double __y) throw (); extern long double __remainderl (long double __x, long double __y) throw ();
extern long double scalbnl (long double __x, int __n) throw (); extern long double __scalbnl (long double __x, int __n) throw ();
extern int ilogbl (long double __x) throw (); extern int __ilogbl (long double __x) throw ();
extern long double scalblnl (long double __x, long int __n) throw (); extern long double __scalblnl (long double __x, long int __n) throw ();
extern long double nearbyintl (long double __x) throw (); extern long double __nearbyintl (long double __x) throw ();
extern long double roundl (long double __x) throw () __attribute__ ((__const__)); extern long double __roundl (long double __x) throw () __attribute__ ((__const__));
extern long double truncl (long double __x) throw () __attribute__ ((__const__)); extern long double __truncl (long double __x) throw () __attribute__ ((__const__));
extern long double remquol (long double __x, long double __y, int *__quo) throw (); extern long double __remquol (long double __x, long double __y, int *__quo) throw ();
extern long int lrintl (long double __x) throw (); extern long int __lrintl (long double __x) throw ();
extern long long int llrintl (long double __x) throw (); extern long long int __llrintl (long double __x) throw ();
extern long int lroundl (long double __x) throw (); extern long int __lroundl (long double __x) throw ();
extern long long int llroundl (long double __x) throw (); extern long long int __llroundl (long double __x) throw ();
extern long double fdiml (long double __x, long double __y) throw (); extern long double __fdiml (long double __x, long double __y) throw ();
extern long double fmaxl (long double __x, long double __y) throw (); extern long double __fmaxl (long double __x, long double __y) throw ();
extern long double fminl (long double __x, long double __y) throw (); extern long double __fminl (long double __x, long double __y) throw ();
extern int __fpclassifyl (long double __value) throw ()
     __attribute__ ((__const__));
extern int __signbitl (long double __value) throw ()
     __attribute__ ((__const__));
extern long double fmal (long double __x, long double __y, long double __z) throw (); extern long double __fmal (long double __x, long double __y, long double __z) throw ();
extern long double scalbl (long double __x, long double __n) throw (); extern long double __scalbl (long double __x, long double __n) throw ();
extern int signgam;
enum
  {
    FP_NAN,
    FP_INFINITE,
    FP_ZERO,
    FP_SUBNORMAL,
    FP_NORMAL
  };
typedef enum
{
  _IEEE_ = -1,
  _SVID_,
  _XOPEN_,
  _POSIX_,
  _ISOC_
} _LIB_VERSION_TYPE;
extern _LIB_VERSION_TYPE _LIB_VERSION;
struct __exception
  {
    int type;
    char *name;
    double arg1;
    double arg2;
    double retval;
  };
extern int matherr (struct __exception *__exc) throw ();
}
namespace std
{
  template<typename _Tp> _Tp __cmath_power(_Tp, unsigned int);
  inline double
  abs(double __x)
  { return __builtin_fabs(__x); }
  inline float
  abs(float __x)
  { return __builtin_fabsf(__x); }
  inline long double
  abs(long double __x)
  { return __builtin_fabsl(__x); }
  using ::acos;
  inline float
  acos(float __x)
  { return __builtin_acosf(__x); }
  inline long double
  acos(long double __x)
  { return __builtin_acosl(__x); }
  template<typename _Tp>
    inline typename __enable_if<double, __is_integer<_Tp>::__value>::__type
    acos(_Tp __x)
    {
      return __builtin_acos(__x);
    }
  using ::asin;
  inline float
  asin(float __x)
  { return __builtin_asinf(__x); }
  inline long double
  asin(long double __x)
  { return __builtin_asinl(__x); }
  template<typename _Tp>
    inline typename __enable_if<double, __is_integer<_Tp>::__value>::__type
    asin(_Tp __x)
    { return __builtin_asin(__x); }
  using ::atan;
  inline float
  atan(float __x)
  { return __builtin_atanf(__x); }
  inline long double
  atan(long double __x)
  { return __builtin_atanl(__x); }
  template<typename _Tp>
    inline typename __enable_if<double, __is_integer<_Tp>::__value>::__type
    atan(_Tp __x)
    { return __builtin_atan(__x); }
  using ::atan2;
  inline float
  atan2(float __y, float __x)
  { return __builtin_atan2f(__y, __x); }
  inline long double
  atan2(long double __y, long double __x)
  { return __builtin_atan2l(__y, __x); }
  template<typename _Tp, typename _Up>
    inline typename __enable_if<double, __is_integer<_Tp>::__value
                                        && __is_integer<_Up>::__value>::__type
    atan2(_Tp __y, _Up __x)
    { return __builtin_atan2(__y, __x); }
  using ::ceil;
  inline float
  ceil(float __x)
  { return __builtin_ceilf(__x); }
  inline long double
  ceil(long double __x)
  { return __builtin_ceill(__x); }
  template<typename _Tp>
    inline typename __enable_if<double, __is_integer<_Tp>::__value>::__type
    ceil(_Tp __x)
    { return __builtin_ceil(__x); }
  using ::cos;
  inline float
  cos(float __x)
  { return __builtin_cosf(__x); }
  inline long double
  cos(long double __x)
  { return __builtin_cosl(__x); }
  template<typename _Tp>
    inline typename __enable_if<double, __is_integer<_Tp>::__value>::__type
    cos(_Tp __x)
    { return __builtin_cos(__x); }
  using ::cosh;
  inline float
  cosh(float __x)
  { return __builtin_coshf(__x); }
  inline long double
  cosh(long double __x)
  { return __builtin_coshl(__x); }
  template<typename _Tp>
    inline typename __enable_if<double, __is_integer<_Tp>::__value>::__type
    cosh(_Tp __x)
    { return __builtin_cosh(__x); }
  using ::exp;
  inline float
  exp(float __x)
  { return __builtin_expf(__x); }
  inline long double
  exp(long double __x)
  { return __builtin_expl(__x); }
  template<typename _Tp>
    inline typename __enable_if<double, __is_integer<_Tp>::__value>::__type
    exp(_Tp __x)
    { return __builtin_exp(__x); }
  using ::fabs;
  inline float
  fabs(float __x)
  { return __builtin_fabsf(__x); }
  inline long double
  fabs(long double __x)
  { return __builtin_fabsl(__x); }
  template<typename _Tp>
    inline typename __enable_if<double, __is_integer<_Tp>::__value>::__type
    fabs(_Tp __x)
    { return __builtin_fabs(__x); }
  using ::floor;
  inline float
  floor(float __x)
  { return __builtin_floorf(__x); }
  inline long double
  floor(long double __x)
  { return __builtin_floorl(__x); }
  template<typename _Tp>
    inline typename __enable_if<double, __is_integer<_Tp>::__value>::__type
    floor(_Tp __x)
    { return __builtin_floor(__x); }
  using ::fmod;
  inline float
  fmod(float __x, float __y)
  { return __builtin_fmodf(__x, __y); }
  inline long double
  fmod(long double __x, long double __y)
  { return __builtin_fmodl(__x, __y); }
  using ::frexp;
  inline float
  frexp(float __x, int* __exp)
  { return __builtin_frexpf(__x, __exp); }
  inline long double
  frexp(long double __x, int* __exp)
  { return __builtin_frexpl(__x, __exp); }
  template<typename _Tp>
    inline typename __enable_if<double, __is_integer<_Tp>::__value>::__type
    frexp(_Tp __x, int* __exp)
    { return __builtin_frexp(__x, __exp); }
  using ::ldexp;
  inline float
  ldexp(float __x, int __exp)
  { return __builtin_ldexpf(__x, __exp); }
  inline long double
  ldexp(long double __x, int __exp)
  { return __builtin_ldexpl(__x, __exp); }
  template<typename _Tp>
  inline typename __enable_if<double, __is_integer<_Tp>::__value>::__type
  ldexp(_Tp __x, int __exp)
  { return __builtin_ldexp(__x, __exp); }
  using ::log;
  inline float
  log(float __x)
  { return __builtin_logf(__x); }
  inline long double
  log(long double __x)
  { return __builtin_logl(__x); }
  template<typename _Tp>
    inline typename __enable_if<double, __is_integer<_Tp>::__value>::__type
    log(_Tp __x)
    { return __builtin_log(__x); }
  using ::log10;
  inline float
  log10(float __x)
  { return __builtin_log10f(__x); }
  inline long double
  log10(long double __x)
  { return __builtin_log10l(__x); }
  template<typename _Tp>
    inline typename __enable_if<double, __is_integer<_Tp>::__value>::__type
    log10(_Tp __x)
    { return __builtin_log10(__x); }
  using ::modf;
  inline float
  modf(float __x, float* __iptr)
  { return __builtin_modff(__x, __iptr); }
  inline long double
  modf(long double __x, long double* __iptr)
  { return __builtin_modfl(__x, __iptr); }
  template<typename _Tp>
    inline _Tp
    __pow_helper(_Tp __x, int __n)
    {
      return __n < 0
        ? _Tp(1)/__cmath_power(__x, -__n)
        : __cmath_power(__x, __n);
    }
  using ::pow;
  inline float
  pow(float __x, float __y)
  { return __builtin_powf(__x, __y); }
  inline long double
  pow(long double __x, long double __y)
  { return __builtin_powl(__x, __y); }
  inline double
  pow(double __x, int __i)
  { return __builtin_powi(__x, __i); }
  inline float
  pow(float __x, int __n)
  { return __builtin_powif(__x, __n); }
  inline long double
  pow(long double __x, int __n)
  { return __builtin_powil(__x, __n); }
  using ::sin;
  inline float
  sin(float __x)
  { return __builtin_sinf(__x); }
  inline long double
  sin(long double __x)
  { return __builtin_sinl(__x); }
  template<typename _Tp>
    inline typename __enable_if<double, __is_integer<_Tp>::__value>::__type
    sin(_Tp __x)
    { return __builtin_sin(__x); }
  using ::sinh;
  inline float
  sinh(float __x)
  { return __builtin_sinhf(__x); }
  inline long double
  sinh(long double __x)
  { return __builtin_sinhl(__x); }
  template<typename _Tp>
    inline typename __enable_if<double, __is_integer<_Tp>::__value>::__type
    sinh(_Tp __x)
    { return __builtin_sinh(__x); }
  using ::sqrt;
  inline float
  sqrt(float __x)
  { return __builtin_sqrtf(__x); }
  inline long double
  sqrt(long double __x)
  { return __builtin_sqrtl(__x); }
  template<typename _Tp>
    inline typename __enable_if<double, __is_integer<_Tp>::__value>::__type
    sqrt(_Tp __x)
    { return __builtin_sqrt(__x); }
  using ::tan;
  inline float
  tan(float __x)
  { return __builtin_tanf(__x); }
  inline long double
  tan(long double __x)
  { return __builtin_tanl(__x); }
  template<typename _Tp>
    inline typename __enable_if<double, __is_integer<_Tp>::__value>::__type
    tan(_Tp __x)
    { return __builtin_tan(__x); }
  using ::tanh;
  inline float
  tanh(float __x)
  { return __builtin_tanhf(__x); }
  inline long double
  tanh(long double __x)
  { return __builtin_tanhl(__x); }
  template<typename _Tp>
    inline typename __enable_if<double, __is_integer<_Tp>::__value>::__type
    tanh(_Tp __x)
    { return __builtin_tanh(__x); }
}
namespace __gnu_cxx
{
  template<typename _Tp>
    inline int
    __capture_fpclassify(_Tp __f) { return (sizeof (__f) == sizeof (float) ? __fpclassifyf (__f) : sizeof (__f) == sizeof (double) ? __fpclassify (__f) : __fpclassifyl (__f)); }
  template<typename _Tp>
    inline int
    __capture_isfinite(_Tp __f) { return (sizeof (__f) == sizeof (float) ? __finitef (__f) : sizeof (__f) == sizeof (double) ? __finite (__f) : __finitel (__f)); }
  template<typename _Tp>
    inline int
    __capture_isinf(_Tp __f) { return (sizeof (__f) == sizeof (float) ? __isinff (__f) : sizeof (__f) == sizeof (double) ? __isinf (__f) : __isinfl (__f)); }
  template<typename _Tp>
    inline int
    __capture_isnan(_Tp __f) { return (sizeof (__f) == sizeof (float) ? __isnanf (__f) : sizeof (__f) == sizeof (double) ? __isnan (__f) : __isnanl (__f)); }
  template<typename _Tp>
    inline int
    __capture_isnormal(_Tp __f) { return ((sizeof (__f) == sizeof (float) ? __fpclassifyf (__f) : sizeof (__f) == sizeof (double) ? __fpclassify (__f) : __fpclassifyl (__f)) == FP_NORMAL); }
  template<typename _Tp>
    inline int
    __capture_signbit(_Tp __f) { return (sizeof (__f) == sizeof (float) ? __signbitf (__f) : sizeof (__f) == sizeof (double) ? __signbit (__f) : __signbitl (__f)); }
  template<typename _Tp>
    inline int
    __capture_isgreater(_Tp __f1, _Tp __f2)
    { return __builtin_isgreater(__f1, __f2); }
  template<typename _Tp>
    inline int
    __capture_isgreaterequal(_Tp __f1, _Tp __f2)
    { return __builtin_isgreaterequal(__f1, __f2); }
  template<typename _Tp>
    inline int
    __capture_isless(_Tp __f1, _Tp __f2) { return __builtin_isless(__f1, __f2); }
  template<typename _Tp>
    inline int
    __capture_islessequal(_Tp __f1, _Tp __f2)
    { return __builtin_islessequal(__f1, __f2); }
  template<typename _Tp>
    inline int
    __capture_islessgreater(_Tp __f1, _Tp __f2)
    { return __builtin_islessgreater(__f1, __f2); }
  template<typename _Tp>
    inline int
    __capture_isunordered(_Tp __f1, _Tp __f2)
    { return __builtin_isunordered(__f1, __f2); }
}
namespace std
{
  template<typename _Tp>
    inline int
    fpclassify(_Tp __f) { return __gnu_cxx::__capture_fpclassify(__f); }
  template<typename _Tp>
    inline int
    isfinite(_Tp __f) { return __gnu_cxx::__capture_isfinite(__f); }
  template<typename _Tp>
    inline int
    isinf(_Tp __f) { return __gnu_cxx::__capture_isinf(__f); }
  template<typename _Tp>
    inline int
    isnan(_Tp __f) { return __gnu_cxx::__capture_isnan(__f); }
  template<typename _Tp>
    inline int
    isnormal(_Tp __f) { return __gnu_cxx::__capture_isnormal(__f); }
  template<typename _Tp>
    inline int
    signbit(_Tp __f) { return __gnu_cxx::__capture_signbit(__f); }
  template<typename _Tp>
    inline int
    isgreater(_Tp __f1, _Tp __f2)
    { return __gnu_cxx::__capture_isgreater(__f1, __f2); }
  template<typename _Tp>
    inline int
    isgreaterequal(_Tp __f1, _Tp __f2)
    { return __gnu_cxx::__capture_isgreaterequal(__f1, __f2); }
  template<typename _Tp>
    inline int
    isless(_Tp __f1, _Tp __f2)
    { return __gnu_cxx::__capture_isless(__f1, __f2); }
  template<typename _Tp>
    inline int
    islessequal(_Tp __f1, _Tp __f2)
    { return __gnu_cxx::__capture_islessequal(__f1, __f2); }
  template<typename _Tp>
    inline int
    islessgreater(_Tp __f1, _Tp __f2)
    { return __gnu_cxx::__capture_islessgreater(__f1, __f2); }
  template<typename _Tp>
    inline int
    isunordered(_Tp __f1, _Tp __f2)
    { return __gnu_cxx::__capture_isunordered(__f1, __f2); }
}
namespace std
{
  template<typename _Tp>
    inline _Tp
    __cmath_power(_Tp __x, unsigned int __n)
    {
      _Tp __y = __n % 2 ? __x : 1;
      while (__n >>= 1)
        {
          __x = __x * __x;
          if (__n % 2)
            __y = __y * __x;
        }
      return __y;
    }
}
namespace std
{
  template<typename _InputIterator, typename _Tp>
    _Tp
    accumulate(_InputIterator __first, _InputIterator __last, _Tp __init)
    {
      ;
      for (; __first != __last; ++__first)
 __init = __init + *__first;
      return __init;
    }
  template<typename _InputIterator, typename _Tp, typename _BinaryOperation>
    _Tp
    accumulate(_InputIterator __first, _InputIterator __last, _Tp __init,
        _BinaryOperation __binary_op)
    {
      ;
      for (; __first != __last; ++__first)
 __init = __binary_op(__init, *__first);
      return __init;
    }
  template<typename _InputIterator1, typename _InputIterator2, typename _Tp>
    _Tp
    inner_product(_InputIterator1 __first1, _InputIterator1 __last1,
    _InputIterator2 __first2, _Tp __init)
    {
      ;
      for (; __first1 != __last1; ++__first1, ++__first2)
 __init = __init + (*__first1 * *__first2);
      return __init;
    }
  template<typename _InputIterator1, typename _InputIterator2, typename _Tp,
     typename _BinaryOperation1, typename _BinaryOperation2>
    _Tp
    inner_product(_InputIterator1 __first1, _InputIterator1 __last1,
    _InputIterator2 __first2, _Tp __init,
    _BinaryOperation1 __binary_op1,
    _BinaryOperation2 __binary_op2)
    {
      ;
      for (; __first1 != __last1; ++__first1, ++__first2)
 __init = __binary_op1(__init, __binary_op2(*__first1, *__first2));
      return __init;
    }
  template<typename _InputIterator, typename _OutputIterator>
    _OutputIterator
    partial_sum(_InputIterator __first, _InputIterator __last,
  _OutputIterator __result)
    {
      typedef typename iterator_traits<_InputIterator>::value_type _ValueType;
      ;
      if (__first == __last)
 return __result;
      _ValueType __value = *__first;
      *__result = __value;
      while (++__first != __last)
 {
   __value = __value + *__first;
   *++__result = __value;
 }
      return ++__result;
    }
  template<typename _InputIterator, typename _OutputIterator,
    typename _BinaryOperation>
    _OutputIterator
    partial_sum(_InputIterator __first, _InputIterator __last,
  _OutputIterator __result, _BinaryOperation __binary_op)
    {
      typedef typename iterator_traits<_InputIterator>::value_type _ValueType;
      ;
      if (__first == __last)
 return __result;
      _ValueType __value = *__first;
      *__result = __value;
      while (++__first != __last)
 {
   __value = __binary_op(__value, *__first);
   *++__result = __value;
 }
      return ++__result;
    }
  template<typename _InputIterator, typename _OutputIterator>
    _OutputIterator
    adjacent_difference(_InputIterator __first,
   _InputIterator __last, _OutputIterator __result)
    {
      typedef typename iterator_traits<_InputIterator>::value_type _ValueType;
      ;
      if (__first == __last)
 return __result;
      _ValueType __value = *__first;
      *__result = __value;
      while (++__first != __last)
 {
   _ValueType __tmp = *__first;
   *++__result = __tmp - __value;
   __value = __tmp;
 }
      return ++__result;
    }
  template<typename _InputIterator, typename _OutputIterator,
    typename _BinaryOperation>
    _OutputIterator
    adjacent_difference(_InputIterator __first, _InputIterator __last,
   _OutputIterator __result, _BinaryOperation __binary_op)
    {
      typedef typename iterator_traits<_InputIterator>::value_type _ValueType;
      ;
      if (__first == __last)
 return __result;
      _ValueType __value = *__first;
      *__result = __value;
      while (++__first != __last)
 {
   _ValueType __tmp = *__first;
   *++__result = __binary_op(__tmp, __value);
   __value = __tmp;
 }
      return ++__result;
    }
}
namespace std
{
  template<class _Clos, typename _Tp>
    class _Expr;
  template<typename _Tp1, typename _Tp2>
    class _ValArray;
  template<class _Oper, template<class, class> class _Meta, class _Dom>
    struct _UnClos;
  template<class _Oper,
        template<class, class> class _Meta1,
        template<class, class> class _Meta2,
        class _Dom1, class _Dom2>
    class _BinClos;
  template<template<class, class> class _Meta, class _Dom>
    class _SClos;
  template<template<class, class> class _Meta, class _Dom>
    class _GClos;
  template<template<class, class> class _Meta, class _Dom>
    class _IClos;
  template<template<class, class> class _Meta, class _Dom>
    class _ValFunClos;
  template<template<class, class> class _Meta, class _Dom>
    class _RefFunClos;
  template<class _Tp> class valarray;
  class slice;
  template<class _Tp> class slice_array;
  class gslice;
  template<class _Tp> class gslice_array;
  template<class _Tp> class mask_array;
  template<class _Tp> class indirect_array;
}
namespace std
{
  inline void*
  __valarray_get_memory(size_t __n)
  { return operator new(__n); }
  template<typename _Tp>
    inline _Tp*__restrict__
    __valarray_get_storage(size_t __n)
    {
      return static_cast<_Tp*__restrict__>
 (std::__valarray_get_memory(__n * sizeof(_Tp)));
    }
  inline void
  __valarray_release_memory(void* __p)
  { operator delete(__p); }
  template<typename _Tp, bool>
    struct _Array_default_ctor
    {
      inline static void
      _S_do_it(_Tp* __restrict__ __b, _Tp* __restrict__ __e)
      {
 while (__b != __e)
   new(__b++) _Tp();
      }
    };
  template<typename _Tp>
    struct _Array_default_ctor<_Tp, true>
    {
      inline static void
      _S_do_it(_Tp* __restrict__ __b, _Tp* __restrict__ __e)
      { std::memset(__b, 0, (__e - __b) * sizeof(_Tp)); }
    };
  template<typename _Tp>
    inline void
    __valarray_default_construct(_Tp* __restrict__ __b, _Tp* __restrict__ __e)
    {
      _Array_default_ctor<_Tp, __is_fundamental<_Tp>::__value>::
 _S_do_it(__b, __e);
    }
  template<typename _Tp, bool>
    struct _Array_init_ctor
    {
      inline static void
      _S_do_it(_Tp* __restrict__ __b, _Tp* __restrict__ __e, const _Tp __t)
      {
 while (__b != __e)
   new(__b++) _Tp(__t);
      }
    };
  template<typename _Tp>
    struct _Array_init_ctor<_Tp, true>
    {
      inline static void
      _S_do_it(_Tp* __restrict__ __b, _Tp* __restrict__ __e, const _Tp __t)
      {
 while (__b != __e)
   *__b++ = __t;
      }
    };
  template<typename _Tp>
    inline void
    __valarray_fill_construct(_Tp* __restrict__ __b, _Tp* __restrict__ __e,
         const _Tp __t)
    {
      _Array_init_ctor<_Tp, __is_fundamental<_Tp>::__value>::
 _S_do_it(__b, __e, __t);
    }
  template<typename _Tp, bool>
    struct _Array_copy_ctor
    {
      inline static void
      _S_do_it(const _Tp* __restrict__ __b, const _Tp* __restrict__ __e,
        _Tp* __restrict__ __o)
      {
 while (__b != __e)
   new(__o++) _Tp(*__b++);
      }
    };
  template<typename _Tp>
    struct _Array_copy_ctor<_Tp, true>
    {
      inline static void
      _S_do_it(const _Tp* __restrict__ __b, const _Tp* __restrict__ __e,
        _Tp* __restrict__ __o)
      { std::memcpy(__o, __b, (__e - __b)*sizeof(_Tp)); }
    };
  template<typename _Tp>
    inline void
    __valarray_copy_construct(const _Tp* __restrict__ __b,
         const _Tp* __restrict__ __e,
         _Tp* __restrict__ __o)
    {
      _Array_copy_ctor<_Tp, __is_fundamental<_Tp>::__value>::
 _S_do_it(__b, __e, __o);
    }
  template<typename _Tp>
    inline void
    __valarray_copy_construct (const _Tp* __restrict__ __a, size_t __n,
          size_t __s, _Tp* __restrict__ __o)
    {
      if (__is_fundamental<_Tp>::__value)
 while (__n--)
   {
     *__o++ = *__a;
     __a += __s;
   }
      else
 while (__n--)
   {
     new(__o++) _Tp(*__a);
     __a += __s;
   }
    }
  template<typename _Tp>
    inline void
    __valarray_copy_construct (const _Tp* __restrict__ __a,
          const size_t* __restrict__ __i,
          _Tp* __restrict__ __o, size_t __n)
    {
      if (__is_fundamental<_Tp>::__value)
 while (__n--)
   *__o++ = __a[*__i++];
      else
 while (__n--)
   new (__o++) _Tp(__a[*__i++]);
    }
  template<typename _Tp>
    inline void
    __valarray_destroy_elements(_Tp* __restrict__ __b, _Tp* __restrict__ __e)
    {
      if (!__is_fundamental<_Tp>::__value)
 while (__b != __e)
   {
     __b->~_Tp();
     ++__b;
   }
    }
  template<typename _Tp>
    inline void
    __valarray_fill(_Tp* __restrict__ __a, size_t __n, const _Tp& __t)
    {
      while (__n--)
 *__a++ = __t;
    }
  template<typename _Tp>
    inline void
    __valarray_fill(_Tp* __restrict__ __a, size_t __n,
      size_t __s, const _Tp& __t)
    {
      for (size_t __i = 0; __i < __n; ++__i, __a += __s)
 *__a = __t;
    }
  template<typename _Tp>
    inline void
    __valarray_fill(_Tp* __restrict__ __a, const size_t* __restrict__ __i,
      size_t __n, const _Tp& __t)
    {
      for (size_t __j = 0; __j < __n; ++__j, ++__i)
 __a[*__i] = __t;
    }
  template<typename _Tp, bool>
    struct _Array_copier
    {
      inline static void
      _S_do_it(const _Tp* __restrict__ __a, size_t __n, _Tp* __restrict__ __b)
      {
 while(__n--)
   *__b++ = *__a++;
      }
    };
  template<typename _Tp>
    struct _Array_copier<_Tp, true>
    {
      inline static void
      _S_do_it(const _Tp* __restrict__ __a, size_t __n, _Tp* __restrict__ __b)
      { std::memcpy (__b, __a, __n * sizeof (_Tp)); }
    };
  template<typename _Tp>
    inline void
    __valarray_copy(const _Tp* __restrict__ __a, size_t __n,
      _Tp* __restrict__ __b)
    {
      _Array_copier<_Tp, __is_fundamental<_Tp>::__value>::
 _S_do_it(__a, __n, __b);
    }
  template<typename _Tp>
    inline void
    __valarray_copy(const _Tp* __restrict__ __a, size_t __n, size_t __s,
      _Tp* __restrict__ __b)
    {
      for (size_t __i = 0; __i < __n; ++__i, ++__b, __a += __s)
 *__b = *__a;
    }
  template<typename _Tp>
    inline void
    __valarray_copy(const _Tp* __restrict__ __a, _Tp* __restrict__ __b,
      size_t __n, size_t __s)
    {
      for (size_t __i = 0; __i < __n; ++__i, ++__a, __b += __s)
 *__b = *__a;
    }
  template<typename _Tp>
    inline void
    __valarray_copy(const _Tp* __restrict__ __src, size_t __n, size_t __s1,
      _Tp* __restrict__ __dst, size_t __s2)
    {
      for (size_t __i = 0; __i < __n; ++__i)
 __dst[__i * __s2] = __src[__i * __s1];
    }
  template<typename _Tp>
    inline void
    __valarray_copy(const _Tp* __restrict__ __a,
      const size_t* __restrict__ __i,
      _Tp* __restrict__ __b, size_t __n)
    {
      for (size_t __j = 0; __j < __n; ++__j, ++__b, ++__i)
 *__b = __a[*__i];
    }
  template<typename _Tp>
    inline void
    __valarray_copy(const _Tp* __restrict__ __a, size_t __n,
      _Tp* __restrict__ __b, const size_t* __restrict__ __i)
    {
      for (size_t __j = 0; __j < __n; ++__j, ++__a, ++__i)
 __b[*__i] = *__a;
    }
  template<typename _Tp>
    inline void
    __valarray_copy(const _Tp* __restrict__ __src, size_t __n,
      const size_t* __restrict__ __i,
      _Tp* __restrict__ __dst, const size_t* __restrict__ __j)
    {
      for (size_t __k = 0; __k < __n; ++__k)
 __dst[*__j++] = __src[*__i++];
    }
  template<typename _Tp>
    inline _Tp
    __valarray_sum(const _Tp* __restrict__ __f, const _Tp* __restrict__ __l)
    {
      _Tp __r = _Tp();
      while (__f != __l)
 __r += *__f++;
      return __r;
    }
  template<typename _Tp>
    inline _Tp
    __valarray_product(const _Tp* __restrict__ __f,
         const _Tp* __restrict__ __l)
    {
      _Tp __r = _Tp(1);
      while (__f != __l)
 __r = __r * *__f++;
      return __r;
    }
  template<typename _Ta>
    inline typename _Ta::value_type
    __valarray_min(const _Ta& __a)
    {
      size_t __s = __a.size();
      typedef typename _Ta::value_type _Value_type;
      _Value_type __r = __s == 0 ? _Value_type() : __a[0];
      for (size_t __i = 1; __i < __s; ++__i)
 {
   _Value_type __t = __a[__i];
   if (__t < __r)
     __r = __t;
 }
      return __r;
    }
  template<typename _Ta>
    inline typename _Ta::value_type
    __valarray_max(const _Ta& __a)
    {
      size_t __s = __a.size();
      typedef typename _Ta::value_type _Value_type;
      _Value_type __r = __s == 0 ? _Value_type() : __a[0];
      for (size_t __i = 1; __i < __s; ++__i)
 {
   _Value_type __t = __a[__i];
   if (__t > __r)
     __r = __t;
 }
      return __r;
    }
  template<typename _Tp>
    struct _Array
    {
      explicit _Array(size_t);
      explicit _Array(_Tp* const __restrict__);
      explicit _Array(const valarray<_Tp>&);
      _Array(const _Tp* __restrict__, size_t);
      _Tp* begin() const;
      _Tp* const __restrict__ _M_data;
    };
  template<typename _Tp>
    inline void
    __valarray_fill (_Array<_Tp> __a, size_t __n, const _Tp& __t)
    { std::__valarray_fill(__a._M_data, __n, __t); }
  template<typename _Tp>
    inline void
    __valarray_fill(_Array<_Tp> __a, size_t __n, size_t __s, const _Tp& __t)
    { std::__valarray_fill(__a._M_data, __n, __s, __t); }
  template<typename _Tp>
    inline void
    __valarray_fill(_Array<_Tp> __a, _Array<size_t> __i,
      size_t __n, const _Tp& __t)
    { std::__valarray_fill(__a._M_data, __i._M_data, __n, __t); }
  template<typename _Tp>
    inline void
    __valarray_copy(_Array<_Tp> __a, size_t __n, _Array<_Tp> __b)
    { std::__valarray_copy(__a._M_data, __n, __b._M_data); }
  template<typename _Tp>
    inline void
    __valarray_copy(_Array<_Tp> __a, size_t __n, size_t __s, _Array<_Tp> __b)
    { std::__valarray_copy(__a._M_data, __n, __s, __b._M_data); }
  template<typename _Tp>
    inline void
    __valarray_copy(_Array<_Tp> __a, _Array<_Tp> __b, size_t __n, size_t __s)
    { __valarray_copy(__a._M_data, __b._M_data, __n, __s); }
  template<typename _Tp>
    inline void
    __valarray_copy(_Array<_Tp> __a, size_t __n, size_t __s1,
                    _Array<_Tp> __b, size_t __s2)
    { std::__valarray_copy(__a._M_data, __n, __s1, __b._M_data, __s2); }
  template<typename _Tp>
    inline void
    __valarray_copy(_Array<_Tp> __a, _Array<size_t> __i,
      _Array<_Tp> __b, size_t __n)
    { std::__valarray_copy(__a._M_data, __i._M_data, __b._M_data, __n); }
  template<typename _Tp>
    inline void
    __valarray_copy(_Array<_Tp> __a, size_t __n, _Array<_Tp> __b,
      _Array<size_t> __i)
    { std::__valarray_copy(__a._M_data, __n, __b._M_data, __i._M_data); }
  template<typename _Tp>
    inline void
    __valarray_copy(_Array<_Tp> __src, size_t __n, _Array<size_t> __i,
                    _Array<_Tp> __dst, _Array<size_t> __j)
    {
      std::__valarray_copy(__src._M_data, __n, __i._M_data,
      __dst._M_data, __j._M_data);
    }
  template<typename _Tp>
    inline
    _Array<_Tp>::_Array(size_t __n)
    : _M_data(__valarray_get_storage<_Tp>(__n))
    { std::__valarray_default_construct(_M_data, _M_data + __n); }
  template<typename _Tp>
    inline
    _Array<_Tp>::_Array(_Tp* const __restrict__ __p)
    : _M_data (__p) {}
  template<typename _Tp>
    inline
    _Array<_Tp>::_Array(const valarray<_Tp>& __v)
    : _M_data (__v._M_data) {}
  template<typename _Tp>
    inline
    _Array<_Tp>::_Array(const _Tp* __restrict__ __b, size_t __s)
    : _M_data(__valarray_get_storage<_Tp>(__s))
    { std::__valarray_copy_construct(__b, __s, _M_data); }
  template<typename _Tp>
    inline _Tp*
    _Array<_Tp>::begin () const
    { return _M_data; }
   template<typename _Tp> inline void _Array_augmented___plus(_Array<_Tp> __a, size_t __n, const _Tp& __t) { for (_Tp* __p = __a._M_data; __p < __a._M_data + __n; ++__p) *__p += __t; } template<typename _Tp> inline void _Array_augmented___plus(_Array<_Tp> __a, size_t __n, _Array<_Tp> __b) { _Tp* __p = __a._M_data; for (_Tp* __q = __b._M_data; __q < __b._M_data + __n; ++__p, ++__q) *__p += *__q; } template<typename _Tp, class _Dom> void _Array_augmented___plus(_Array<_Tp> __a, const _Expr<_Dom, _Tp>& __e, size_t __n) { _Tp* __p(__a._M_data); for (size_t __i = 0; __i < __n; ++__i, ++__p) *__p += __e[__i]; } template<typename _Tp> inline void _Array_augmented___plus(_Array<_Tp> __a, size_t __n, size_t __s, _Array<_Tp> __b) { _Tp* __q(__b._M_data); for (_Tp* __p = __a._M_data; __p < __a._M_data + __s * __n; __p += __s, ++__q) *__p += *__q; } template<typename _Tp> inline void _Array_augmented___plus(_Array<_Tp> __a, _Array<_Tp> __b, size_t __n, size_t __s) { _Tp* __q(__b._M_data); for (_Tp* __p = __a._M_data; __p < __a._M_data + __n; ++__p, __q += __s) *__p += *__q; } template<typename _Tp, class _Dom> void _Array_augmented___plus(_Array<_Tp> __a, size_t __s, const _Expr<_Dom, _Tp>& __e, size_t __n) { _Tp* __p(__a._M_data); for (size_t __i = 0; __i < __n; ++__i, __p += __s) *__p += __e[__i]; } template<typename _Tp> inline void _Array_augmented___plus(_Array<_Tp> __a, _Array<size_t> __i, _Array<_Tp> __b, size_t __n) { _Tp* __q(__b._M_data); for (size_t* __j = __i._M_data; __j < __i._M_data + __n; ++__j, ++__q) __a._M_data[*__j] += *__q; } template<typename _Tp> inline void _Array_augmented___plus(_Array<_Tp> __a, size_t __n, _Array<_Tp> __b, _Array<size_t> __i) { _Tp* __p(__a._M_data); for (size_t* __j = __i._M_data; __j<__i._M_data + __n; ++__j, ++__p) *__p += __b._M_data[*__j]; } template<typename _Tp, class _Dom> void _Array_augmented___plus(_Array<_Tp> __a, _Array<size_t> __i, const _Expr<_Dom, _Tp>& __e, size_t __n) { size_t* __j(__i._M_data); for (size_t __k = 0; __k<__n; ++__k, ++__j) __a._M_data[*__j] += __e[__k]; } template<typename _Tp> void _Array_augmented___plus(_Array<_Tp> __a, _Array<bool> __m, _Array<_Tp> __b, size_t __n) { bool* __ok(__m._M_data); _Tp* __p(__a._M_data); for (_Tp* __q = __b._M_data; __q < __b._M_data + __n; ++__q, ++__ok, ++__p) { while (! *__ok) { ++__ok; ++__p; } *__p += *__q; } } template<typename _Tp> void _Array_augmented___plus(_Array<_Tp> __a, size_t __n, _Array<_Tp> __b, _Array<bool> __m) { bool* __ok(__m._M_data); _Tp* __q(__b._M_data); for (_Tp* __p = __a._M_data; __p < __a._M_data + __n; ++__p, ++__ok, ++__q) { while (! *__ok) { ++__ok; ++__q; } *__p += *__q; } } template<typename _Tp, class _Dom> void _Array_augmented___plus(_Array<_Tp> __a, _Array<bool> __m, const _Expr<_Dom, _Tp>& __e, size_t __n) { bool* __ok(__m._M_data); _Tp* __p(__a._M_data); for (size_t __i = 0; __i < __n; ++__i, ++__ok, ++__p) { while (! *__ok) { ++__ok; ++__p; } *__p += __e[__i]; } }
   template<typename _Tp> inline void _Array_augmented___minus(_Array<_Tp> __a, size_t __n, const _Tp& __t) { for (_Tp* __p = __a._M_data; __p < __a._M_data + __n; ++__p) *__p -= __t; } template<typename _Tp> inline void _Array_augmented___minus(_Array<_Tp> __a, size_t __n, _Array<_Tp> __b) { _Tp* __p = __a._M_data; for (_Tp* __q = __b._M_data; __q < __b._M_data + __n; ++__p, ++__q) *__p -= *__q; } template<typename _Tp, class _Dom> void _Array_augmented___minus(_Array<_Tp> __a, const _Expr<_Dom, _Tp>& __e, size_t __n) { _Tp* __p(__a._M_data); for (size_t __i = 0; __i < __n; ++__i, ++__p) *__p -= __e[__i]; } template<typename _Tp> inline void _Array_augmented___minus(_Array<_Tp> __a, size_t __n, size_t __s, _Array<_Tp> __b) { _Tp* __q(__b._M_data); for (_Tp* __p = __a._M_data; __p < __a._M_data + __s * __n; __p += __s, ++__q) *__p -= *__q; } template<typename _Tp> inline void _Array_augmented___minus(_Array<_Tp> __a, _Array<_Tp> __b, size_t __n, size_t __s) { _Tp* __q(__b._M_data); for (_Tp* __p = __a._M_data; __p < __a._M_data + __n; ++__p, __q += __s) *__p -= *__q; } template<typename _Tp, class _Dom> void _Array_augmented___minus(_Array<_Tp> __a, size_t __s, const _Expr<_Dom, _Tp>& __e, size_t __n) { _Tp* __p(__a._M_data); for (size_t __i = 0; __i < __n; ++__i, __p += __s) *__p -= __e[__i]; } template<typename _Tp> inline void _Array_augmented___minus(_Array<_Tp> __a, _Array<size_t> __i, _Array<_Tp> __b, size_t __n) { _Tp* __q(__b._M_data); for (size_t* __j = __i._M_data; __j < __i._M_data + __n; ++__j, ++__q) __a._M_data[*__j] -= *__q; } template<typename _Tp> inline void _Array_augmented___minus(_Array<_Tp> __a, size_t __n, _Array<_Tp> __b, _Array<size_t> __i) { _Tp* __p(__a._M_data); for (size_t* __j = __i._M_data; __j<__i._M_data + __n; ++__j, ++__p) *__p -= __b._M_data[*__j]; } template<typename _Tp, class _Dom> void _Array_augmented___minus(_Array<_Tp> __a, _Array<size_t> __i, const _Expr<_Dom, _Tp>& __e, size_t __n) { size_t* __j(__i._M_data); for (size_t __k = 0; __k<__n; ++__k, ++__j) __a._M_data[*__j] -= __e[__k]; } template<typename _Tp> void _Array_augmented___minus(_Array<_Tp> __a, _Array<bool> __m, _Array<_Tp> __b, size_t __n) { bool* __ok(__m._M_data); _Tp* __p(__a._M_data); for (_Tp* __q = __b._M_data; __q < __b._M_data + __n; ++__q, ++__ok, ++__p) { while (! *__ok) { ++__ok; ++__p; } *__p -= *__q; } } template<typename _Tp> void _Array_augmented___minus(_Array<_Tp> __a, size_t __n, _Array<_Tp> __b, _Array<bool> __m) { bool* __ok(__m._M_data); _Tp* __q(__b._M_data); for (_Tp* __p = __a._M_data; __p < __a._M_data + __n; ++__p, ++__ok, ++__q) { while (! *__ok) { ++__ok; ++__q; } *__p -= *__q; } } template<typename _Tp, class _Dom> void _Array_augmented___minus(_Array<_Tp> __a, _Array<bool> __m, const _Expr<_Dom, _Tp>& __e, size_t __n) { bool* __ok(__m._M_data); _Tp* __p(__a._M_data); for (size_t __i = 0; __i < __n; ++__i, ++__ok, ++__p) { while (! *__ok) { ++__ok; ++__p; } *__p -= __e[__i]; } }
   template<typename _Tp> inline void _Array_augmented___multiplies(_Array<_Tp> __a, size_t __n, const _Tp& __t) { for (_Tp* __p = __a._M_data; __p < __a._M_data + __n; ++__p) *__p *= __t; } template<typename _Tp> inline void _Array_augmented___multiplies(_Array<_Tp> __a, size_t __n, _Array<_Tp> __b) { _Tp* __p = __a._M_data; for (_Tp* __q = __b._M_data; __q < __b._M_data + __n; ++__p, ++__q) *__p *= *__q; } template<typename _Tp, class _Dom> void _Array_augmented___multiplies(_Array<_Tp> __a, const _Expr<_Dom, _Tp>& __e, size_t __n) { _Tp* __p(__a._M_data); for (size_t __i = 0; __i < __n; ++__i, ++__p) *__p *= __e[__i]; } template<typename _Tp> inline void _Array_augmented___multiplies(_Array<_Tp> __a, size_t __n, size_t __s, _Array<_Tp> __b) { _Tp* __q(__b._M_data); for (_Tp* __p = __a._M_data; __p < __a._M_data + __s * __n; __p += __s, ++__q) *__p *= *__q; } template<typename _Tp> inline void _Array_augmented___multiplies(_Array<_Tp> __a, _Array<_Tp> __b, size_t __n, size_t __s) { _Tp* __q(__b._M_data); for (_Tp* __p = __a._M_data; __p < __a._M_data + __n; ++__p, __q += __s) *__p *= *__q; } template<typename _Tp, class _Dom> void _Array_augmented___multiplies(_Array<_Tp> __a, size_t __s, const _Expr<_Dom, _Tp>& __e, size_t __n) { _Tp* __p(__a._M_data); for (size_t __i = 0; __i < __n; ++__i, __p += __s) *__p *= __e[__i]; } template<typename _Tp> inline void _Array_augmented___multiplies(_Array<_Tp> __a, _Array<size_t> __i, _Array<_Tp> __b, size_t __n) { _Tp* __q(__b._M_data); for (size_t* __j = __i._M_data; __j < __i._M_data + __n; ++__j, ++__q) __a._M_data[*__j] *= *__q; } template<typename _Tp> inline void _Array_augmented___multiplies(_Array<_Tp> __a, size_t __n, _Array<_Tp> __b, _Array<size_t> __i) { _Tp* __p(__a._M_data); for (size_t* __j = __i._M_data; __j<__i._M_data + __n; ++__j, ++__p) *__p *= __b._M_data[*__j]; } template<typename _Tp, class _Dom> void _Array_augmented___multiplies(_Array<_Tp> __a, _Array<size_t> __i, const _Expr<_Dom, _Tp>& __e, size_t __n) { size_t* __j(__i._M_data); for (size_t __k = 0; __k<__n; ++__k, ++__j) __a._M_data[*__j] *= __e[__k]; } template<typename _Tp> void _Array_augmented___multiplies(_Array<_Tp> __a, _Array<bool> __m, _Array<_Tp> __b, size_t __n) { bool* __ok(__m._M_data); _Tp* __p(__a._M_data); for (_Tp* __q = __b._M_data; __q < __b._M_data + __n; ++__q, ++__ok, ++__p) { while (! *__ok) { ++__ok; ++__p; } *__p *= *__q; } } template<typename _Tp> void _Array_augmented___multiplies(_Array<_Tp> __a, size_t __n, _Array<_Tp> __b, _Array<bool> __m) { bool* __ok(__m._M_data); _Tp* __q(__b._M_data); for (_Tp* __p = __a._M_data; __p < __a._M_data + __n; ++__p, ++__ok, ++__q) { while (! *__ok) { ++__ok; ++__q; } *__p *= *__q; } } template<typename _Tp, class _Dom> void _Array_augmented___multiplies(_Array<_Tp> __a, _Array<bool> __m, const _Expr<_Dom, _Tp>& __e, size_t __n) { bool* __ok(__m._M_data); _Tp* __p(__a._M_data); for (size_t __i = 0; __i < __n; ++__i, ++__ok, ++__p) { while (! *__ok) { ++__ok; ++__p; } *__p *= __e[__i]; } }
   template<typename _Tp> inline void _Array_augmented___divides(_Array<_Tp> __a, size_t __n, const _Tp& __t) { for (_Tp* __p = __a._M_data; __p < __a._M_data + __n; ++__p) *__p /= __t; } template<typename _Tp> inline void _Array_augmented___divides(_Array<_Tp> __a, size_t __n, _Array<_Tp> __b) { _Tp* __p = __a._M_data; for (_Tp* __q = __b._M_data; __q < __b._M_data + __n; ++__p, ++__q) *__p /= *__q; } template<typename _Tp, class _Dom> void _Array_augmented___divides(_Array<_Tp> __a, const _Expr<_Dom, _Tp>& __e, size_t __n) { _Tp* __p(__a._M_data); for (size_t __i = 0; __i < __n; ++__i, ++__p) *__p /= __e[__i]; } template<typename _Tp> inline void _Array_augmented___divides(_Array<_Tp> __a, size_t __n, size_t __s, _Array<_Tp> __b) { _Tp* __q(__b._M_data); for (_Tp* __p = __a._M_data; __p < __a._M_data + __s * __n; __p += __s, ++__q) *__p /= *__q; } template<typename _Tp> inline void _Array_augmented___divides(_Array<_Tp> __a, _Array<_Tp> __b, size_t __n, size_t __s) { _Tp* __q(__b._M_data); for (_Tp* __p = __a._M_data; __p < __a._M_data + __n; ++__p, __q += __s) *__p /= *__q; } template<typename _Tp, class _Dom> void _Array_augmented___divides(_Array<_Tp> __a, size_t __s, const _Expr<_Dom, _Tp>& __e, size_t __n) { _Tp* __p(__a._M_data); for (size_t __i = 0; __i < __n; ++__i, __p += __s) *__p /= __e[__i]; } template<typename _Tp> inline void _Array_augmented___divides(_Array<_Tp> __a, _Array<size_t> __i, _Array<_Tp> __b, size_t __n) { _Tp* __q(__b._M_data); for (size_t* __j = __i._M_data; __j < __i._M_data + __n; ++__j, ++__q) __a._M_data[*__j] /= *__q; } template<typename _Tp> inline void _Array_augmented___divides(_Array<_Tp> __a, size_t __n, _Array<_Tp> __b, _Array<size_t> __i) { _Tp* __p(__a._M_data); for (size_t* __j = __i._M_data; __j<__i._M_data + __n; ++__j, ++__p) *__p /= __b._M_data[*__j]; } template<typename _Tp, class _Dom> void _Array_augmented___divides(_Array<_Tp> __a, _Array<size_t> __i, const _Expr<_Dom, _Tp>& __e, size_t __n) { size_t* __j(__i._M_data); for (size_t __k = 0; __k<__n; ++__k, ++__j) __a._M_data[*__j] /= __e[__k]; } template<typename _Tp> void _Array_augmented___divides(_Array<_Tp> __a, _Array<bool> __m, _Array<_Tp> __b, size_t __n) { bool* __ok(__m._M_data); _Tp* __p(__a._M_data); for (_Tp* __q = __b._M_data; __q < __b._M_data + __n; ++__q, ++__ok, ++__p) { while (! *__ok) { ++__ok; ++__p; } *__p /= *__q; } } template<typename _Tp> void _Array_augmented___divides(_Array<_Tp> __a, size_t __n, _Array<_Tp> __b, _Array<bool> __m) { bool* __ok(__m._M_data); _Tp* __q(__b._M_data); for (_Tp* __p = __a._M_data; __p < __a._M_data + __n; ++__p, ++__ok, ++__q) { while (! *__ok) { ++__ok; ++__q; } *__p /= *__q; } } template<typename _Tp, class _Dom> void _Array_augmented___divides(_Array<_Tp> __a, _Array<bool> __m, const _Expr<_Dom, _Tp>& __e, size_t __n) { bool* __ok(__m._M_data); _Tp* __p(__a._M_data); for (size_t __i = 0; __i < __n; ++__i, ++__ok, ++__p) { while (! *__ok) { ++__ok; ++__p; } *__p /= __e[__i]; } }
   template<typename _Tp> inline void _Array_augmented___modulus(_Array<_Tp> __a, size_t __n, const _Tp& __t) { for (_Tp* __p = __a._M_data; __p < __a._M_data + __n; ++__p) *__p %= __t; } template<typename _Tp> inline void _Array_augmented___modulus(_Array<_Tp> __a, size_t __n, _Array<_Tp> __b) { _Tp* __p = __a._M_data; for (_Tp* __q = __b._M_data; __q < __b._M_data + __n; ++__p, ++__q) *__p %= *__q; } template<typename _Tp, class _Dom> void _Array_augmented___modulus(_Array<_Tp> __a, const _Expr<_Dom, _Tp>& __e, size_t __n) { _Tp* __p(__a._M_data); for (size_t __i = 0; __i < __n; ++__i, ++__p) *__p %= __e[__i]; } template<typename _Tp> inline void _Array_augmented___modulus(_Array<_Tp> __a, size_t __n, size_t __s, _Array<_Tp> __b) { _Tp* __q(__b._M_data); for (_Tp* __p = __a._M_data; __p < __a._M_data + __s * __n; __p += __s, ++__q) *__p %= *__q; } template<typename _Tp> inline void _Array_augmented___modulus(_Array<_Tp> __a, _Array<_Tp> __b, size_t __n, size_t __s) { _Tp* __q(__b._M_data); for (_Tp* __p = __a._M_data; __p < __a._M_data + __n; ++__p, __q += __s) *__p %= *__q; } template<typename _Tp, class _Dom> void _Array_augmented___modulus(_Array<_Tp> __a, size_t __s, const _Expr<_Dom, _Tp>& __e, size_t __n) { _Tp* __p(__a._M_data); for (size_t __i = 0; __i < __n; ++__i, __p += __s) *__p %= __e[__i]; } template<typename _Tp> inline void _Array_augmented___modulus(_Array<_Tp> __a, _Array<size_t> __i, _Array<_Tp> __b, size_t __n) { _Tp* __q(__b._M_data); for (size_t* __j = __i._M_data; __j < __i._M_data + __n; ++__j, ++__q) __a._M_data[*__j] %= *__q; } template<typename _Tp> inline void _Array_augmented___modulus(_Array<_Tp> __a, size_t __n, _Array<_Tp> __b, _Array<size_t> __i) { _Tp* __p(__a._M_data); for (size_t* __j = __i._M_data; __j<__i._M_data + __n; ++__j, ++__p) *__p %= __b._M_data[*__j]; } template<typename _Tp, class _Dom> void _Array_augmented___modulus(_Array<_Tp> __a, _Array<size_t> __i, const _Expr<_Dom, _Tp>& __e, size_t __n) { size_t* __j(__i._M_data); for (size_t __k = 0; __k<__n; ++__k, ++__j) __a._M_data[*__j] %= __e[__k]; } template<typename _Tp> void _Array_augmented___modulus(_Array<_Tp> __a, _Array<bool> __m, _Array<_Tp> __b, size_t __n) { bool* __ok(__m._M_data); _Tp* __p(__a._M_data); for (_Tp* __q = __b._M_data; __q < __b._M_data + __n; ++__q, ++__ok, ++__p) { while (! *__ok) { ++__ok; ++__p; } *__p %= *__q; } } template<typename _Tp> void _Array_augmented___modulus(_Array<_Tp> __a, size_t __n, _Array<_Tp> __b, _Array<bool> __m) { bool* __ok(__m._M_data); _Tp* __q(__b._M_data); for (_Tp* __p = __a._M_data; __p < __a._M_data + __n; ++__p, ++__ok, ++__q) { while (! *__ok) { ++__ok; ++__q; } *__p %= *__q; } } template<typename _Tp, class _Dom> void _Array_augmented___modulus(_Array<_Tp> __a, _Array<bool> __m, const _Expr<_Dom, _Tp>& __e, size_t __n) { bool* __ok(__m._M_data); _Tp* __p(__a._M_data); for (size_t __i = 0; __i < __n; ++__i, ++__ok, ++__p) { while (! *__ok) { ++__ok; ++__p; } *__p %= __e[__i]; } }
   template<typename _Tp> inline void _Array_augmented___bitwise_xor(_Array<_Tp> __a, size_t __n, const _Tp& __t) { for (_Tp* __p = __a._M_data; __p < __a._M_data + __n; ++__p) *__p ^= __t; } template<typename _Tp> inline void _Array_augmented___bitwise_xor(_Array<_Tp> __a, size_t __n, _Array<_Tp> __b) { _Tp* __p = __a._M_data; for (_Tp* __q = __b._M_data; __q < __b._M_data + __n; ++__p, ++__q) *__p ^= *__q; } template<typename _Tp, class _Dom> void _Array_augmented___bitwise_xor(_Array<_Tp> __a, const _Expr<_Dom, _Tp>& __e, size_t __n) { _Tp* __p(__a._M_data); for (size_t __i = 0; __i < __n; ++__i, ++__p) *__p ^= __e[__i]; } template<typename _Tp> inline void _Array_augmented___bitwise_xor(_Array<_Tp> __a, size_t __n, size_t __s, _Array<_Tp> __b) { _Tp* __q(__b._M_data); for (_Tp* __p = __a._M_data; __p < __a._M_data + __s * __n; __p += __s, ++__q) *__p ^= *__q; } template<typename _Tp> inline void _Array_augmented___bitwise_xor(_Array<_Tp> __a, _Array<_Tp> __b, size_t __n, size_t __s) { _Tp* __q(__b._M_data); for (_Tp* __p = __a._M_data; __p < __a._M_data + __n; ++__p, __q += __s) *__p ^= *__q; } template<typename _Tp, class _Dom> void _Array_augmented___bitwise_xor(_Array<_Tp> __a, size_t __s, const _Expr<_Dom, _Tp>& __e, size_t __n) { _Tp* __p(__a._M_data); for (size_t __i = 0; __i < __n; ++__i, __p += __s) *__p ^= __e[__i]; } template<typename _Tp> inline void _Array_augmented___bitwise_xor(_Array<_Tp> __a, _Array<size_t> __i, _Array<_Tp> __b, size_t __n) { _Tp* __q(__b._M_data); for (size_t* __j = __i._M_data; __j < __i._M_data + __n; ++__j, ++__q) __a._M_data[*__j] ^= *__q; } template<typename _Tp> inline void _Array_augmented___bitwise_xor(_Array<_Tp> __a, size_t __n, _Array<_Tp> __b, _Array<size_t> __i) { _Tp* __p(__a._M_data); for (size_t* __j = __i._M_data; __j<__i._M_data + __n; ++__j, ++__p) *__p ^= __b._M_data[*__j]; } template<typename _Tp, class _Dom> void _Array_augmented___bitwise_xor(_Array<_Tp> __a, _Array<size_t> __i, const _Expr<_Dom, _Tp>& __e, size_t __n) { size_t* __j(__i._M_data); for (size_t __k = 0; __k<__n; ++__k, ++__j) __a._M_data[*__j] ^= __e[__k]; } template<typename _Tp> void _Array_augmented___bitwise_xor(_Array<_Tp> __a, _Array<bool> __m, _Array<_Tp> __b, size_t __n) { bool* __ok(__m._M_data); _Tp* __p(__a._M_data); for (_Tp* __q = __b._M_data; __q < __b._M_data + __n; ++__q, ++__ok, ++__p) { while (! *__ok) { ++__ok; ++__p; } *__p ^= *__q; } } template<typename _Tp> void _Array_augmented___bitwise_xor(_Array<_Tp> __a, size_t __n, _Array<_Tp> __b, _Array<bool> __m) { bool* __ok(__m._M_data); _Tp* __q(__b._M_data); for (_Tp* __p = __a._M_data; __p < __a._M_data + __n; ++__p, ++__ok, ++__q) { while (! *__ok) { ++__ok; ++__q; } *__p ^= *__q; } } template<typename _Tp, class _Dom> void _Array_augmented___bitwise_xor(_Array<_Tp> __a, _Array<bool> __m, const _Expr<_Dom, _Tp>& __e, size_t __n) { bool* __ok(__m._M_data); _Tp* __p(__a._M_data); for (size_t __i = 0; __i < __n; ++__i, ++__ok, ++__p) { while (! *__ok) { ++__ok; ++__p; } *__p ^= __e[__i]; } }
   template<typename _Tp> inline void _Array_augmented___bitwise_or(_Array<_Tp> __a, size_t __n, const _Tp& __t) { for (_Tp* __p = __a._M_data; __p < __a._M_data + __n; ++__p) *__p |= __t; } template<typename _Tp> inline void _Array_augmented___bitwise_or(_Array<_Tp> __a, size_t __n, _Array<_Tp> __b) { _Tp* __p = __a._M_data; for (_Tp* __q = __b._M_data; __q < __b._M_data + __n; ++__p, ++__q) *__p |= *__q; } template<typename _Tp, class _Dom> void _Array_augmented___bitwise_or(_Array<_Tp> __a, const _Expr<_Dom, _Tp>& __e, size_t __n) { _Tp* __p(__a._M_data); for (size_t __i = 0; __i < __n; ++__i, ++__p) *__p |= __e[__i]; } template<typename _Tp> inline void _Array_augmented___bitwise_or(_Array<_Tp> __a, size_t __n, size_t __s, _Array<_Tp> __b) { _Tp* __q(__b._M_data); for (_Tp* __p = __a._M_data; __p < __a._M_data + __s * __n; __p += __s, ++__q) *__p |= *__q; } template<typename _Tp> inline void _Array_augmented___bitwise_or(_Array<_Tp> __a, _Array<_Tp> __b, size_t __n, size_t __s) { _Tp* __q(__b._M_data); for (_Tp* __p = __a._M_data; __p < __a._M_data + __n; ++__p, __q += __s) *__p |= *__q; } template<typename _Tp, class _Dom> void _Array_augmented___bitwise_or(_Array<_Tp> __a, size_t __s, const _Expr<_Dom, _Tp>& __e, size_t __n) { _Tp* __p(__a._M_data); for (size_t __i = 0; __i < __n; ++__i, __p += __s) *__p |= __e[__i]; } template<typename _Tp> inline void _Array_augmented___bitwise_or(_Array<_Tp> __a, _Array<size_t> __i, _Array<_Tp> __b, size_t __n) { _Tp* __q(__b._M_data); for (size_t* __j = __i._M_data; __j < __i._M_data + __n; ++__j, ++__q) __a._M_data[*__j] |= *__q; } template<typename _Tp> inline void _Array_augmented___bitwise_or(_Array<_Tp> __a, size_t __n, _Array<_Tp> __b, _Array<size_t> __i) { _Tp* __p(__a._M_data); for (size_t* __j = __i._M_data; __j<__i._M_data + __n; ++__j, ++__p) *__p |= __b._M_data[*__j]; } template<typename _Tp, class _Dom> void _Array_augmented___bitwise_or(_Array<_Tp> __a, _Array<size_t> __i, const _Expr<_Dom, _Tp>& __e, size_t __n) { size_t* __j(__i._M_data); for (size_t __k = 0; __k<__n; ++__k, ++__j) __a._M_data[*__j] |= __e[__k]; } template<typename _Tp> void _Array_augmented___bitwise_or(_Array<_Tp> __a, _Array<bool> __m, _Array<_Tp> __b, size_t __n) { bool* __ok(__m._M_data); _Tp* __p(__a._M_data); for (_Tp* __q = __b._M_data; __q < __b._M_data + __n; ++__q, ++__ok, ++__p) { while (! *__ok) { ++__ok; ++__p; } *__p |= *__q; } } template<typename _Tp> void _Array_augmented___bitwise_or(_Array<_Tp> __a, size_t __n, _Array<_Tp> __b, _Array<bool> __m) { bool* __ok(__m._M_data); _Tp* __q(__b._M_data); for (_Tp* __p = __a._M_data; __p < __a._M_data + __n; ++__p, ++__ok, ++__q) { while (! *__ok) { ++__ok; ++__q; } *__p |= *__q; } } template<typename _Tp, class _Dom> void _Array_augmented___bitwise_or(_Array<_Tp> __a, _Array<bool> __m, const _Expr<_Dom, _Tp>& __e, size_t __n) { bool* __ok(__m._M_data); _Tp* __p(__a._M_data); for (size_t __i = 0; __i < __n; ++__i, ++__ok, ++__p) { while (! *__ok) { ++__ok; ++__p; } *__p |= __e[__i]; } }
   template<typename _Tp> inline void _Array_augmented___bitwise_and(_Array<_Tp> __a, size_t __n, const _Tp& __t) { for (_Tp* __p = __a._M_data; __p < __a._M_data + __n; ++__p) *__p &= __t; } template<typename _Tp> inline void _Array_augmented___bitwise_and(_Array<_Tp> __a, size_t __n, _Array<_Tp> __b) { _Tp* __p = __a._M_data; for (_Tp* __q = __b._M_data; __q < __b._M_data + __n; ++__p, ++__q) *__p &= *__q; } template<typename _Tp, class _Dom> void _Array_augmented___bitwise_and(_Array<_Tp> __a, const _Expr<_Dom, _Tp>& __e, size_t __n) { _Tp* __p(__a._M_data); for (size_t __i = 0; __i < __n; ++__i, ++__p) *__p &= __e[__i]; } template<typename _Tp> inline void _Array_augmented___bitwise_and(_Array<_Tp> __a, size_t __n, size_t __s, _Array<_Tp> __b) { _Tp* __q(__b._M_data); for (_Tp* __p = __a._M_data; __p < __a._M_data + __s * __n; __p += __s, ++__q) *__p &= *__q; } template<typename _Tp> inline void _Array_augmented___bitwise_and(_Array<_Tp> __a, _Array<_Tp> __b, size_t __n, size_t __s) { _Tp* __q(__b._M_data); for (_Tp* __p = __a._M_data; __p < __a._M_data + __n; ++__p, __q += __s) *__p &= *__q; } template<typename _Tp, class _Dom> void _Array_augmented___bitwise_and(_Array<_Tp> __a, size_t __s, const _Expr<_Dom, _Tp>& __e, size_t __n) { _Tp* __p(__a._M_data); for (size_t __i = 0; __i < __n; ++__i, __p += __s) *__p &= __e[__i]; } template<typename _Tp> inline void _Array_augmented___bitwise_and(_Array<_Tp> __a, _Array<size_t> __i, _Array<_Tp> __b, size_t __n) { _Tp* __q(__b._M_data); for (size_t* __j = __i._M_data; __j < __i._M_data + __n; ++__j, ++__q) __a._M_data[*__j] &= *__q; } template<typename _Tp> inline void _Array_augmented___bitwise_and(_Array<_Tp> __a, size_t __n, _Array<_Tp> __b, _Array<size_t> __i) { _Tp* __p(__a._M_data); for (size_t* __j = __i._M_data; __j<__i._M_data + __n; ++__j, ++__p) *__p &= __b._M_data[*__j]; } template<typename _Tp, class _Dom> void _Array_augmented___bitwise_and(_Array<_Tp> __a, _Array<size_t> __i, const _Expr<_Dom, _Tp>& __e, size_t __n) { size_t* __j(__i._M_data); for (size_t __k = 0; __k<__n; ++__k, ++__j) __a._M_data[*__j] &= __e[__k]; } template<typename _Tp> void _Array_augmented___bitwise_and(_Array<_Tp> __a, _Array<bool> __m, _Array<_Tp> __b, size_t __n) { bool* __ok(__m._M_data); _Tp* __p(__a._M_data); for (_Tp* __q = __b._M_data; __q < __b._M_data + __n; ++__q, ++__ok, ++__p) { while (! *__ok) { ++__ok; ++__p; } *__p &= *__q; } } template<typename _Tp> void _Array_augmented___bitwise_and(_Array<_Tp> __a, size_t __n, _Array<_Tp> __b, _Array<bool> __m) { bool* __ok(__m._M_data); _Tp* __q(__b._M_data); for (_Tp* __p = __a._M_data; __p < __a._M_data + __n; ++__p, ++__ok, ++__q) { while (! *__ok) { ++__ok; ++__q; } *__p &= *__q; } } template<typename _Tp, class _Dom> void _Array_augmented___bitwise_and(_Array<_Tp> __a, _Array<bool> __m, const _Expr<_Dom, _Tp>& __e, size_t __n) { bool* __ok(__m._M_data); _Tp* __p(__a._M_data); for (size_t __i = 0; __i < __n; ++__i, ++__ok, ++__p) { while (! *__ok) { ++__ok; ++__p; } *__p &= __e[__i]; } }
   template<typename _Tp> inline void _Array_augmented___shift_left(_Array<_Tp> __a, size_t __n, const _Tp& __t) { for (_Tp* __p = __a._M_data; __p < __a._M_data + __n; ++__p) *__p <<= __t; } template<typename _Tp> inline void _Array_augmented___shift_left(_Array<_Tp> __a, size_t __n, _Array<_Tp> __b) { _Tp* __p = __a._M_data; for (_Tp* __q = __b._M_data; __q < __b._M_data + __n; ++__p, ++__q) *__p <<= *__q; } template<typename _Tp, class _Dom> void _Array_augmented___shift_left(_Array<_Tp> __a, const _Expr<_Dom, _Tp>& __e, size_t __n) { _Tp* __p(__a._M_data); for (size_t __i = 0; __i < __n; ++__i, ++__p) *__p <<= __e[__i]; } template<typename _Tp> inline void _Array_augmented___shift_left(_Array<_Tp> __a, size_t __n, size_t __s, _Array<_Tp> __b) { _Tp* __q(__b._M_data); for (_Tp* __p = __a._M_data; __p < __a._M_data + __s * __n; __p += __s, ++__q) *__p <<= *__q; } template<typename _Tp> inline void _Array_augmented___shift_left(_Array<_Tp> __a, _Array<_Tp> __b, size_t __n, size_t __s) { _Tp* __q(__b._M_data); for (_Tp* __p = __a._M_data; __p < __a._M_data + __n; ++__p, __q += __s) *__p <<= *__q; } template<typename _Tp, class _Dom> void _Array_augmented___shift_left(_Array<_Tp> __a, size_t __s, const _Expr<_Dom, _Tp>& __e, size_t __n) { _Tp* __p(__a._M_data); for (size_t __i = 0; __i < __n; ++__i, __p += __s) *__p <<= __e[__i]; } template<typename _Tp> inline void _Array_augmented___shift_left(_Array<_Tp> __a, _Array<size_t> __i, _Array<_Tp> __b, size_t __n) { _Tp* __q(__b._M_data); for (size_t* __j = __i._M_data; __j < __i._M_data + __n; ++__j, ++__q) __a._M_data[*__j] <<= *__q; } template<typename _Tp> inline void _Array_augmented___shift_left(_Array<_Tp> __a, size_t __n, _Array<_Tp> __b, _Array<size_t> __i) { _Tp* __p(__a._M_data); for (size_t* __j = __i._M_data; __j<__i._M_data + __n; ++__j, ++__p) *__p <<= __b._M_data[*__j]; } template<typename _Tp, class _Dom> void _Array_augmented___shift_left(_Array<_Tp> __a, _Array<size_t> __i, const _Expr<_Dom, _Tp>& __e, size_t __n) { size_t* __j(__i._M_data); for (size_t __k = 0; __k<__n; ++__k, ++__j) __a._M_data[*__j] <<= __e[__k]; } template<typename _Tp> void _Array_augmented___shift_left(_Array<_Tp> __a, _Array<bool> __m, _Array<_Tp> __b, size_t __n) { bool* __ok(__m._M_data); _Tp* __p(__a._M_data); for (_Tp* __q = __b._M_data; __q < __b._M_data + __n; ++__q, ++__ok, ++__p) { while (! *__ok) { ++__ok; ++__p; } *__p <<= *__q; } } template<typename _Tp> void _Array_augmented___shift_left(_Array<_Tp> __a, size_t __n, _Array<_Tp> __b, _Array<bool> __m) { bool* __ok(__m._M_data); _Tp* __q(__b._M_data); for (_Tp* __p = __a._M_data; __p < __a._M_data + __n; ++__p, ++__ok, ++__q) { while (! *__ok) { ++__ok; ++__q; } *__p <<= *__q; } } template<typename _Tp, class _Dom> void _Array_augmented___shift_left(_Array<_Tp> __a, _Array<bool> __m, const _Expr<_Dom, _Tp>& __e, size_t __n) { bool* __ok(__m._M_data); _Tp* __p(__a._M_data); for (size_t __i = 0; __i < __n; ++__i, ++__ok, ++__p) { while (! *__ok) { ++__ok; ++__p; } *__p <<= __e[__i]; } }
   template<typename _Tp> inline void _Array_augmented___shift_right(_Array<_Tp> __a, size_t __n, const _Tp& __t) { for (_Tp* __p = __a._M_data; __p < __a._M_data + __n; ++__p) *__p >>= __t; } template<typename _Tp> inline void _Array_augmented___shift_right(_Array<_Tp> __a, size_t __n, _Array<_Tp> __b) { _Tp* __p = __a._M_data; for (_Tp* __q = __b._M_data; __q < __b._M_data + __n; ++__p, ++__q) *__p >>= *__q; } template<typename _Tp, class _Dom> void _Array_augmented___shift_right(_Array<_Tp> __a, const _Expr<_Dom, _Tp>& __e, size_t __n) { _Tp* __p(__a._M_data); for (size_t __i = 0; __i < __n; ++__i, ++__p) *__p >>= __e[__i]; } template<typename _Tp> inline void _Array_augmented___shift_right(_Array<_Tp> __a, size_t __n, size_t __s, _Array<_Tp> __b) { _Tp* __q(__b._M_data); for (_Tp* __p = __a._M_data; __p < __a._M_data + __s * __n; __p += __s, ++__q) *__p >>= *__q; } template<typename _Tp> inline void _Array_augmented___shift_right(_Array<_Tp> __a, _Array<_Tp> __b, size_t __n, size_t __s) { _Tp* __q(__b._M_data); for (_Tp* __p = __a._M_data; __p < __a._M_data + __n; ++__p, __q += __s) *__p >>= *__q; } template<typename _Tp, class _Dom> void _Array_augmented___shift_right(_Array<_Tp> __a, size_t __s, const _Expr<_Dom, _Tp>& __e, size_t __n) { _Tp* __p(__a._M_data); for (size_t __i = 0; __i < __n; ++__i, __p += __s) *__p >>= __e[__i]; } template<typename _Tp> inline void _Array_augmented___shift_right(_Array<_Tp> __a, _Array<size_t> __i, _Array<_Tp> __b, size_t __n) { _Tp* __q(__b._M_data); for (size_t* __j = __i._M_data; __j < __i._M_data + __n; ++__j, ++__q) __a._M_data[*__j] >>= *__q; } template<typename _Tp> inline void _Array_augmented___shift_right(_Array<_Tp> __a, size_t __n, _Array<_Tp> __b, _Array<size_t> __i) { _Tp* __p(__a._M_data); for (size_t* __j = __i._M_data; __j<__i._M_data + __n; ++__j, ++__p) *__p >>= __b._M_data[*__j]; } template<typename _Tp, class _Dom> void _Array_augmented___shift_right(_Array<_Tp> __a, _Array<size_t> __i, const _Expr<_Dom, _Tp>& __e, size_t __n) { size_t* __j(__i._M_data); for (size_t __k = 0; __k<__n; ++__k, ++__j) __a._M_data[*__j] >>= __e[__k]; } template<typename _Tp> void _Array_augmented___shift_right(_Array<_Tp> __a, _Array<bool> __m, _Array<_Tp> __b, size_t __n) { bool* __ok(__m._M_data); _Tp* __p(__a._M_data); for (_Tp* __q = __b._M_data; __q < __b._M_data + __n; ++__q, ++__ok, ++__p) { while (! *__ok) { ++__ok; ++__p; } *__p >>= *__q; } } template<typename _Tp> void _Array_augmented___shift_right(_Array<_Tp> __a, size_t __n, _Array<_Tp> __b, _Array<bool> __m) { bool* __ok(__m._M_data); _Tp* __q(__b._M_data); for (_Tp* __p = __a._M_data; __p < __a._M_data + __n; ++__p, ++__ok, ++__q) { while (! *__ok) { ++__ok; ++__q; } *__p >>= *__q; } } template<typename _Tp, class _Dom> void _Array_augmented___shift_right(_Array<_Tp> __a, _Array<bool> __m, const _Expr<_Dom, _Tp>& __e, size_t __n) { bool* __ok(__m._M_data); _Tp* __p(__a._M_data); for (size_t __i = 0; __i < __n; ++__i, ++__ok, ++__p) { while (! *__ok) { ++__ok; ++__p; } *__p >>= __e[__i]; } }
}
namespace std
{
  template<typename _Tp>
    void
    __valarray_fill(_Array<_Tp> __a, size_t __n, _Array<bool> __m,
      const _Tp& __t)
    {
      _Tp* __p = __a._M_data;
      bool* __ok (__m._M_data);
      for (size_t __i=0; __i < __n; ++__i, ++__ok, ++__p)
 {
   while (!*__ok)
   {
     ++__ok;
     ++__p;
   }
   *__p = __t;
 }
    }
  template<typename _Tp>
    void
    __valarray_copy(_Array<_Tp> __a, _Array<bool> __m, _Array<_Tp> __b,
      size_t __n)
    {
      _Tp* __p (__a._M_data);
      bool* __ok (__m._M_data);
      for (_Tp* __q = __b._M_data; __q < __b._M_data + __n;
    ++__q, ++__ok, ++__p)
 {
   while (! *__ok)
     {
       ++__ok;
       ++__p;
     }
   *__q = *__p;
 }
    }
  template<typename _Tp>
    void
    __valarray_copy(_Array<_Tp> __a, size_t __n, _Array<_Tp> __b,
      _Array<bool> __m)
    {
      _Tp* __q (__b._M_data);
      bool* __ok (__m._M_data);
      for (_Tp* __p = __a._M_data; __p < __a._M_data+__n;
    ++__p, ++__ok, ++__q)
 {
   while (! *__ok)
     {
       ++__ok;
       ++__q;
     }
   *__q = *__p;
 }
    }
  template<typename _Tp>
    void
    __valarray_copy(_Array<_Tp> __a, _Array<bool> __m, size_t __n,
      _Array<_Tp> __b, _Array<bool> __k)
    {
      _Tp* __p (__a._M_data);
      _Tp* __q (__b._M_data);
      bool* __srcok (__m._M_data);
      bool* __dstok (__k._M_data);
      for (size_t __i = 0; __i < __n;
    ++__srcok, ++__p, ++__dstok, ++__q, ++__i)
 {
   while (! *__srcok)
     {
       ++__srcok;
       ++__p;
     }
   while (! *__dstok)
     {
       ++__dstok;
       ++__q;
     }
   *__q = *__p;
 }
    }
  template<typename _Tp, class _Dom>
    void
    __valarray_copy(const _Expr<_Dom, _Tp>& __e, size_t __n, _Array<_Tp> __a)
    {
      _Tp* __p (__a._M_data);
      for (size_t __i = 0; __i < __n; ++__i, ++__p)
 *__p = __e[__i];
    }
  template<typename _Tp, class _Dom>
    void
    __valarray_copy(const _Expr<_Dom, _Tp>& __e, size_t __n,
       _Array<_Tp> __a, size_t __s)
    {
      _Tp* __p (__a._M_data);
      for (size_t __i = 0; __i < __n; ++__i, __p += __s)
 *__p = __e[__i];
    }
  template<typename _Tp, class _Dom>
    void
    __valarray_copy(const _Expr<_Dom, _Tp>& __e, size_t __n,
      _Array<_Tp> __a, _Array<size_t> __i)
    {
      size_t* __j (__i._M_data);
      for (size_t __k = 0; __k < __n; ++__k, ++__j)
 __a._M_data[*__j] = __e[__k];
    }
  template<typename _Tp>
    void
    __valarray_copy(_Array<_Tp> __e, _Array<size_t> __f,
      size_t __n,
      _Array<_Tp> __a, _Array<size_t> __i)
    {
      size_t* __g (__f._M_data);
      size_t* __j (__i._M_data);
      for (size_t __k = 0; __k < __n; ++__k, ++__j, ++__g)
 __a._M_data[*__j] = __e._M_data[*__g];
    }
  template<typename _Tp, class _Dom>
    void
    __valarray_copy(const _Expr<_Dom, _Tp>& __e, size_t __n,
      _Array<_Tp> __a, _Array<bool> __m)
    {
      bool* __ok (__m._M_data);
      _Tp* __p (__a._M_data);
      for (size_t __i = 0; __i < __n; ++__i, ++__ok, ++__p)
 {
   while (! *__ok)
     {
       ++__ok;
       ++__p;
     }
   *__p = __e[__i];
 }
    }
  template<typename _Tp, class _Dom>
    void
    __valarray_copy_construct(const _Expr<_Dom, _Tp>& __e, size_t __n,
         _Array<_Tp> __a)
    {
      _Tp* __p (__a._M_data);
      for (size_t __i = 0; __i < __n; ++__i, ++__p)
 new (__p) _Tp(__e[__i]);
    }
  template<typename _Tp>
    void
    __valarray_copy_construct(_Array<_Tp> __a, _Array<bool> __m,
         _Array<_Tp> __b, size_t __n)
    {
      _Tp* __p (__a._M_data);
      bool* __ok (__m._M_data);
      for (_Tp* __q = __b._M_data; __q < __b._M_data+__n; ++__q, ++__ok, ++__p)
 {
   while (! *__ok)
     {
       ++__ok;
       ++__p;
     }
   new (__q) _Tp(*__p);
 }
    }
}
namespace std
{
  class slice
  {
  public:
    slice();
    slice(size_t, size_t, size_t);
    size_t start() const;
    size_t size() const;
    size_t stride() const;
  private:
    size_t _M_off;
    size_t _M_sz;
    size_t _M_st;
  };
  inline
  slice::slice() {}
  inline
  slice::slice(size_t __o, size_t __d, size_t __s)
  : _M_off(__o), _M_sz(__d), _M_st(__s) {}
  inline size_t
  slice::start() const
  { return _M_off; }
  inline size_t
  slice::size() const
  { return _M_sz; }
  inline size_t
  slice::stride() const
  { return _M_st; }
  template<typename _Tp>
    class slice_array
    {
    public:
      typedef _Tp value_type;
      slice_array(const slice_array&);
      slice_array& operator=(const slice_array&);
      void operator=(const valarray<_Tp>&) const;
      void operator*=(const valarray<_Tp>&) const;
      void operator/=(const valarray<_Tp>&) const;
      void operator%=(const valarray<_Tp>&) const;
      void operator+=(const valarray<_Tp>&) const;
      void operator-=(const valarray<_Tp>&) const;
      void operator^=(const valarray<_Tp>&) const;
      void operator&=(const valarray<_Tp>&) const;
      void operator|=(const valarray<_Tp>&) const;
      void operator<<=(const valarray<_Tp>&) const;
      void operator>>=(const valarray<_Tp>&) const;
      void operator=(const _Tp &) const;
      template<class _Dom>
        void operator=(const _Expr<_Dom, _Tp>&) const;
      template<class _Dom>
 void operator*=(const _Expr<_Dom, _Tp>&) const;
      template<class _Dom>
 void operator/=(const _Expr<_Dom, _Tp>&) const;
      template<class _Dom>
 void operator%=(const _Expr<_Dom, _Tp>&) const;
      template<class _Dom>
 void operator+=(const _Expr<_Dom, _Tp>&) const;
      template<class _Dom>
 void operator-=(const _Expr<_Dom, _Tp>&) const;
      template<class _Dom>
 void operator^=(const _Expr<_Dom, _Tp>&) const;
      template<class _Dom>
 void operator&=(const _Expr<_Dom, _Tp>&) const;
      template<class _Dom>
 void operator|=(const _Expr<_Dom, _Tp>&) const;
      template<class _Dom>
 void operator<<=(const _Expr<_Dom, _Tp>&) const;
      template<class _Dom>
 void operator>>=(const _Expr<_Dom, _Tp>&) const;
    private:
      friend class valarray<_Tp>;
      slice_array(_Array<_Tp>, const slice&);
      const size_t _M_sz;
      const size_t _M_stride;
      const _Array<_Tp> _M_array;
      slice_array();
    };
  template<typename _Tp>
    inline
    slice_array<_Tp>::slice_array(_Array<_Tp> __a, const slice& __s)
    : _M_sz(__s.size()), _M_stride(__s.stride()),
      _M_array(__a.begin() + __s.start()) {}
  template<typename _Tp>
    inline
    slice_array<_Tp>::slice_array(const slice_array<_Tp>& a)
    : _M_sz(a._M_sz), _M_stride(a._M_stride), _M_array(a._M_array) {}
  template<typename _Tp>
    inline slice_array<_Tp>&
    slice_array<_Tp>::operator=(const slice_array<_Tp>& __a)
    {
      std::__valarray_copy(__a._M_array, __a._M_sz, __a._M_stride,
      _M_array, _M_stride);
      return *this;
    }
  template<typename _Tp>
    inline void
    slice_array<_Tp>::operator=(const _Tp& __t) const
    { std::__valarray_fill(_M_array, _M_sz, _M_stride, __t); }
  template<typename _Tp>
    inline void
    slice_array<_Tp>::operator=(const valarray<_Tp>& __v) const
    { std::__valarray_copy(_Array<_Tp>(__v), _M_array, _M_sz, _M_stride); }
  template<typename _Tp>
  template<class _Dom>
    inline void
    slice_array<_Tp>::operator=(const _Expr<_Dom,_Tp>& __e) const
    { std::__valarray_copy(__e, _M_sz, _M_array, _M_stride); }
template<typename _Tp> inline void slice_array<_Tp>::operator *=(const valarray<_Tp>& __v) const { _Array_augmented___multiplies(_M_array, _M_sz, _M_stride, _Array<_Tp>(__v)); } template<typename _Tp> template<class _Dom> inline void slice_array<_Tp>::operator *=(const _Expr<_Dom,_Tp>& __e) const { _Array_augmented___multiplies(_M_array, _M_stride, __e, _M_sz); }
template<typename _Tp> inline void slice_array<_Tp>::operator /=(const valarray<_Tp>& __v) const { _Array_augmented___divides(_M_array, _M_sz, _M_stride, _Array<_Tp>(__v)); } template<typename _Tp> template<class _Dom> inline void slice_array<_Tp>::operator /=(const _Expr<_Dom,_Tp>& __e) const { _Array_augmented___divides(_M_array, _M_stride, __e, _M_sz); }
template<typename _Tp> inline void slice_array<_Tp>::operator %=(const valarray<_Tp>& __v) const { _Array_augmented___modulus(_M_array, _M_sz, _M_stride, _Array<_Tp>(__v)); } template<typename _Tp> template<class _Dom> inline void slice_array<_Tp>::operator %=(const _Expr<_Dom,_Tp>& __e) const { _Array_augmented___modulus(_M_array, _M_stride, __e, _M_sz); }
template<typename _Tp> inline void slice_array<_Tp>::operator +=(const valarray<_Tp>& __v) const { _Array_augmented___plus(_M_array, _M_sz, _M_stride, _Array<_Tp>(__v)); } template<typename _Tp> template<class _Dom> inline void slice_array<_Tp>::operator +=(const _Expr<_Dom,_Tp>& __e) const { _Array_augmented___plus(_M_array, _M_stride, __e, _M_sz); }
template<typename _Tp> inline void slice_array<_Tp>::operator -=(const valarray<_Tp>& __v) const { _Array_augmented___minus(_M_array, _M_sz, _M_stride, _Array<_Tp>(__v)); } template<typename _Tp> template<class _Dom> inline void slice_array<_Tp>::operator -=(const _Expr<_Dom,_Tp>& __e) const { _Array_augmented___minus(_M_array, _M_stride, __e, _M_sz); }
template<typename _Tp> inline void slice_array<_Tp>::operator ^=(const valarray<_Tp>& __v) const { _Array_augmented___bitwise_xor(_M_array, _M_sz, _M_stride, _Array<_Tp>(__v)); } template<typename _Tp> template<class _Dom> inline void slice_array<_Tp>::operator ^=(const _Expr<_Dom,_Tp>& __e) const { _Array_augmented___bitwise_xor(_M_array, _M_stride, __e, _M_sz); }
template<typename _Tp> inline void slice_array<_Tp>::operator &=(const valarray<_Tp>& __v) const { _Array_augmented___bitwise_and(_M_array, _M_sz, _M_stride, _Array<_Tp>(__v)); } template<typename _Tp> template<class _Dom> inline void slice_array<_Tp>::operator &=(const _Expr<_Dom,_Tp>& __e) const { _Array_augmented___bitwise_and(_M_array, _M_stride, __e, _M_sz); }
template<typename _Tp> inline void slice_array<_Tp>::operator |=(const valarray<_Tp>& __v) const { _Array_augmented___bitwise_or(_M_array, _M_sz, _M_stride, _Array<_Tp>(__v)); } template<typename _Tp> template<class _Dom> inline void slice_array<_Tp>::operator |=(const _Expr<_Dom,_Tp>& __e) const { _Array_augmented___bitwise_or(_M_array, _M_stride, __e, _M_sz); }
template<typename _Tp> inline void slice_array<_Tp>::operator <<=(const valarray<_Tp>& __v) const { _Array_augmented___shift_left(_M_array, _M_sz, _M_stride, _Array<_Tp>(__v)); } template<typename _Tp> template<class _Dom> inline void slice_array<_Tp>::operator <<=(const _Expr<_Dom,_Tp>& __e) const { _Array_augmented___shift_left(_M_array, _M_stride, __e, _M_sz); }
template<typename _Tp> inline void slice_array<_Tp>::operator >>=(const valarray<_Tp>& __v) const { _Array_augmented___shift_right(_M_array, _M_sz, _M_stride, _Array<_Tp>(__v)); } template<typename _Tp> template<class _Dom> inline void slice_array<_Tp>::operator >>=(const _Expr<_Dom,_Tp>& __e) const { _Array_augmented___shift_right(_M_array, _M_stride, __e, _M_sz); }
}
namespace std
{
  template<typename _Tp1, typename _Tp2> class _Constant;
  struct __abs
  {
    template<typename _Tp>
      _Tp operator()(const _Tp& __t) const
      { return abs(__t); }
  };
  struct __cos
  {
    template<typename _Tp>
      _Tp operator()(const _Tp& __t) const
      { return cos(__t); }
  };
  struct __acos
  {
    template<typename _Tp>
      _Tp operator()(const _Tp& __t) const
      { return acos(__t); }
  };
  struct __cosh
  {
    template<typename _Tp>
      _Tp operator()(const _Tp& __t) const
      { return cosh(__t); }
  };
  struct __sin
  {
    template<typename _Tp>
      _Tp operator()(const _Tp& __t) const
      { return sin(__t); }
  };
  struct __asin
  {
    template<typename _Tp>
      _Tp operator()(const _Tp& __t) const
      { return asin(__t); }
  };
  struct __sinh
  {
    template<typename _Tp>
      _Tp operator()(const _Tp& __t) const
      { return sinh(__t); }
  };
  struct __tan
  {
    template<typename _Tp>
      _Tp operator()(const _Tp& __t) const
      { return tan(__t); }
  };
  struct __atan
  {
    template<typename _Tp>
      _Tp operator()(const _Tp& __t) const
      { return atan(__t); }
  };
  struct __tanh
  {
    template<typename _Tp>
      _Tp operator()(const _Tp& __t) const
      { return tanh(__t); }
  };
  struct __exp
  {
    template<typename _Tp>
      _Tp operator()(const _Tp& __t) const
      { return exp(__t); }
  };
  struct __log
  {
    template<typename _Tp>
      _Tp operator()(const _Tp& __t) const
      { return log(__t); }
  };
  struct __log10
  {
    template<typename _Tp>
      _Tp operator()(const _Tp& __t) const
      { return log10(__t); }
  };
  struct __sqrt
  {
    template<typename _Tp>
      _Tp operator()(const _Tp& __t) const
      { return sqrt(__t); }
  };
  struct __unary_plus
  {
    template<typename _Tp>
      _Tp operator()(const _Tp& __t) const
      { return +__t; }
  };
  struct __negate
  {
    template<typename _Tp>
      _Tp operator()(const _Tp& __t) const
      { return -__t; }
  };
  struct __bitwise_not
  {
    template<typename _Tp>
      _Tp operator()(const _Tp& __t) const
      { return ~__t; }
  };
  struct __plus
  {
    template<typename _Tp>
      _Tp operator()(const _Tp& __x, const _Tp& __y) const
      { return __x + __y; }
  };
  struct __minus
  {
    template<typename _Tp>
      _Tp operator()(const _Tp& __x, const _Tp& __y) const
      { return __x - __y; }
  };
  struct __multiplies
  {
    template<typename _Tp>
      _Tp operator()(const _Tp& __x, const _Tp& __y) const
      { return __x * __y; }
  };
  struct __divides
  {
    template<typename _Tp>
      _Tp operator()(const _Tp& __x, const _Tp& __y) const
      { return __x / __y; }
  };
  struct __modulus
  {
    template<typename _Tp>
      _Tp operator()(const _Tp& __x, const _Tp& __y) const
      { return __x % __y; }
  };
  struct __bitwise_xor
  {
    template<typename _Tp>
      _Tp operator()(const _Tp& __x, const _Tp& __y) const
      { return __x ^ __y; }
  };
  struct __bitwise_and
  {
    template<typename _Tp>
      _Tp operator()(const _Tp& __x, const _Tp& __y) const
      { return __x & __y; }
  };
  struct __bitwise_or
  {
    template<typename _Tp>
      _Tp operator()(const _Tp& __x, const _Tp& __y) const
      { return __x | __y; }
  };
  struct __shift_left
  {
    template<typename _Tp>
      _Tp operator()(const _Tp& __x, const _Tp& __y) const
      { return __x << __y; }
  };
  struct __shift_right
  {
    template<typename _Tp>
      _Tp operator()(const _Tp& __x, const _Tp& __y) const
      { return __x >> __y; }
  };
  struct __logical_and
  {
    template<typename _Tp>
      bool operator()(const _Tp& __x, const _Tp& __y) const
      { return __x && __y; }
  };
  struct __logical_or
  {
    template<typename _Tp>
      bool operator()(const _Tp& __x, const _Tp& __y) const
      { return __x || __y; }
  };
  struct __logical_not
  {
    template<typename _Tp>
      bool operator()(const _Tp& __x) const { return !__x; }
  };
  struct __equal_to
  {
    template<typename _Tp>
      bool operator()(const _Tp& __x, const _Tp& __y) const
      { return __x == __y; }
  };
  struct __not_equal_to
  {
    template<typename _Tp>
      bool operator()(const _Tp& __x, const _Tp& __y) const
      { return __x != __y; }
  };
  struct __less
  {
    template<typename _Tp>
      bool operator()(const _Tp& __x, const _Tp& __y) const
      { return __x < __y; }
  };
  struct __greater
  {
    template<typename _Tp>
      bool operator()(const _Tp& __x, const _Tp& __y) const
      { return __x > __y; }
  };
  struct __less_equal
  {
    template<typename _Tp>
      bool operator()(const _Tp& __x, const _Tp& __y) const
      { return __x <= __y; }
  };
  struct __greater_equal
  {
    template<typename _Tp>
      bool operator()(const _Tp& __x, const _Tp& __y) const
      { return __x >= __y; }
  };
  struct __atan2
  {
    template<typename _Tp>
      _Tp operator()(const _Tp& __x, const _Tp& __y) const
      { return atan2(__x, __y); }
  };
  struct __pow
  {
    template<typename _Tp>
      _Tp operator()(const _Tp& __x, const _Tp& __y) const
      { return pow(__x, __y); }
  };
  template<typename, typename _Tp>
    struct __fun
    {
      typedef _Tp result_type;
    };
  template<typename _Tp>
    struct __fun<__logical_not, _Tp>
    {
      typedef bool result_type;
    };
  template<typename _Tp>
    struct __fun<__logical_and, _Tp>
    {
      typedef bool result_type;
    };
  template<typename _Tp>
    struct __fun<__logical_or, _Tp>
    {
      typedef bool result_type;
    };
  template<typename _Tp>
    struct __fun<__less, _Tp>
    {
      typedef bool result_type;
    };
  template<typename _Tp>
    struct __fun<__greater, _Tp>
    {
      typedef bool result_type;
    };
  template<typename _Tp>
    struct __fun<__less_equal, _Tp>
    {
      typedef bool result_type;
    };
  template<typename _Tp>
    struct __fun<__greater_equal, _Tp>
    {
      typedef bool result_type;
    };
  template<typename _Tp>
    struct __fun<__equal_to, _Tp>
    {
      typedef bool result_type;
    };
  template<typename _Tp>
    struct __fun<__not_equal_to, _Tp>
    {
      typedef bool result_type;
    };
  template<typename _Dom, typename _Arg>
    class _FunBase
    {
    public:
      typedef typename _Dom::value_type value_type;
      _FunBase(const _Dom& __e, value_type __f(_Arg))
      : _M_expr(__e), _M_func(__f) {}
      value_type operator[](size_t __i) const
      { return _M_func (_M_expr[__i]); }
      size_t size() const { return _M_expr.size ();}
    private:
      const _Dom& _M_expr;
      value_type (*_M_func)(_Arg);
    };
  template<class _Dom>
    struct _ValFunClos<_Expr,_Dom> : _FunBase<_Dom, typename _Dom::value_type>
    {
      typedef _FunBase<_Dom, typename _Dom::value_type> _Base;
      typedef typename _Base::value_type value_type;
      typedef value_type _Tp;
      _ValFunClos(const _Dom& __e, _Tp __f(_Tp)) : _Base(__e, __f) {}
    };
  template<typename _Tp>
    struct _ValFunClos<_ValArray,_Tp> : _FunBase<valarray<_Tp>, _Tp>
    {
      typedef _FunBase<valarray<_Tp>, _Tp> _Base;
      typedef _Tp value_type;
      _ValFunClos(const valarray<_Tp>& __v, _Tp __f(_Tp)) : _Base(__v, __f) {}
    };
  template<class _Dom>
    struct _RefFunClos<_Expr, _Dom>
    : _FunBase<_Dom, const typename _Dom::value_type&>
    {
      typedef _FunBase<_Dom, const typename _Dom::value_type&> _Base;
      typedef typename _Base::value_type value_type;
      typedef value_type _Tp;
      _RefFunClos(const _Dom& __e, _Tp __f(const _Tp&))
      : _Base(__e, __f) {}
    };
  template<typename _Tp>
    struct _RefFunClos<_ValArray, _Tp>
    : _FunBase<valarray<_Tp>, const _Tp&>
    {
      typedef _FunBase<valarray<_Tp>, const _Tp&> _Base;
      typedef _Tp value_type;
      _RefFunClos(const valarray<_Tp>& __v, _Tp __f(const _Tp&))
      : _Base(__v, __f) {}
    };
  template<class _Oper, class _Arg>
    class _UnBase
    {
    public:
      typedef typename _Arg::value_type _Vt;
      typedef typename __fun<_Oper, _Vt>::result_type value_type;
      _UnBase(const _Arg& __e) : _M_expr(__e) {}
      value_type operator[](size_t __i) const
      { return _Oper()(_M_expr[__i]); }
      size_t size() const { return _M_expr.size(); }
    private:
      const _Arg& _M_expr;
    };
  template<class _Oper, class _Dom>
    struct _UnClos<_Oper, _Expr, _Dom>
    : _UnBase<_Oper, _Dom>
    {
      typedef _Dom _Arg;
      typedef _UnBase<_Oper, _Dom> _Base;
      typedef typename _Base::value_type value_type;
      _UnClos(const _Arg& __e) : _Base(__e) {}
    };
  template<class _Oper, typename _Tp>
    struct _UnClos<_Oper, _ValArray, _Tp>
    : _UnBase<_Oper, valarray<_Tp> >
    {
      typedef valarray<_Tp> _Arg;
      typedef _UnBase<_Oper, valarray<_Tp> > _Base;
      typedef typename _Base::value_type value_type;
      _UnClos(const _Arg& __e) : _Base(__e) {}
    };
  template<class _Oper, class _FirstArg, class _SecondArg>
    class _BinBase
    {
    public:
      typedef typename _FirstArg::value_type _Vt;
      typedef typename __fun<_Oper, _Vt>::result_type value_type;
      _BinBase(const _FirstArg& __e1, const _SecondArg& __e2)
      : _M_expr1(__e1), _M_expr2(__e2) {}
      value_type operator[](size_t __i) const
      { return _Oper()(_M_expr1[__i], _M_expr2[__i]); }
      size_t size() const { return _M_expr1.size(); }
    private:
      const _FirstArg& _M_expr1;
      const _SecondArg& _M_expr2;
    };
  template<class _Oper, class _Clos>
    class _BinBase2
    {
    public:
      typedef typename _Clos::value_type _Vt;
      typedef typename __fun<_Oper, _Vt>::result_type value_type;
      _BinBase2(const _Clos& __e, const _Vt& __t)
      : _M_expr1(__e), _M_expr2(__t) {}
      value_type operator[](size_t __i) const
      { return _Oper()(_M_expr1[__i], _M_expr2); }
      size_t size() const { return _M_expr1.size(); }
    private:
      const _Clos& _M_expr1;
      const _Vt& _M_expr2;
    };
  template<class _Oper, class _Clos>
    class _BinBase1
    {
    public:
      typedef typename _Clos::value_type _Vt;
      typedef typename __fun<_Oper, _Vt>::result_type value_type;
      _BinBase1(const _Vt& __t, const _Clos& __e)
      : _M_expr1(__t), _M_expr2(__e) {}
      value_type operator[](size_t __i) const
      { return _Oper()(_M_expr1, _M_expr2[__i]); }
      size_t size() const { return _M_expr2.size(); }
    private:
      const _Vt& _M_expr1;
      const _Clos& _M_expr2;
    };
  template<class _Oper, class _Dom1, class _Dom2>
    struct _BinClos<_Oper, _Expr, _Expr, _Dom1, _Dom2>
    : _BinBase<_Oper, _Dom1, _Dom2>
    {
      typedef _BinBase<_Oper, _Dom1, _Dom2> _Base;
      typedef typename _Base::value_type value_type;
      _BinClos(const _Dom1& __e1, const _Dom2& __e2) : _Base(__e1, __e2) {}
    };
  template<class _Oper, typename _Tp>
    struct _BinClos<_Oper,_ValArray, _ValArray, _Tp, _Tp>
    : _BinBase<_Oper, valarray<_Tp>, valarray<_Tp> >
    {
      typedef _BinBase<_Oper, valarray<_Tp>, valarray<_Tp> > _Base;
      typedef _Tp value_type;
      _BinClos(const valarray<_Tp>& __v, const valarray<_Tp>& __w)
      : _Base(__v, __w) {}
    };
  template<class _Oper, class _Dom>
    struct _BinClos<_Oper, _Expr, _ValArray, _Dom, typename _Dom::value_type>
    : _BinBase<_Oper, _Dom, valarray<typename _Dom::value_type> >
    {
      typedef typename _Dom::value_type _Tp;
      typedef _BinBase<_Oper,_Dom,valarray<_Tp> > _Base;
      typedef typename _Base::value_type value_type;
      _BinClos(const _Dom& __e1, const valarray<_Tp>& __e2)
      : _Base(__e1, __e2) {}
    };
  template<class _Oper, class _Dom>
    struct _BinClos<_Oper, _ValArray, _Expr, typename _Dom::value_type, _Dom>
    : _BinBase<_Oper, valarray<typename _Dom::value_type>,_Dom>
    {
      typedef typename _Dom::value_type _Tp;
      typedef _BinBase<_Oper, valarray<_Tp>, _Dom> _Base;
      typedef typename _Base::value_type value_type;
      _BinClos(const valarray<_Tp>& __e1, const _Dom& __e2)
      : _Base(__e1, __e2) {}
    };
  template<class _Oper, class _Dom>
    struct _BinClos<_Oper, _Expr, _Constant, _Dom, typename _Dom::value_type>
    : _BinBase2<_Oper, _Dom>
    {
      typedef typename _Dom::value_type _Tp;
      typedef _BinBase2<_Oper,_Dom> _Base;
      typedef typename _Base::value_type value_type;
      _BinClos(const _Dom& __e1, const _Tp& __e2) : _Base(__e1, __e2) {}
    };
  template<class _Oper, class _Dom>
    struct _BinClos<_Oper, _Constant, _Expr, typename _Dom::value_type, _Dom>
    : _BinBase1<_Oper, _Dom>
    {
      typedef typename _Dom::value_type _Tp;
      typedef _BinBase1<_Oper, _Dom> _Base;
      typedef typename _Base::value_type value_type;
      _BinClos(const _Tp& __e1, const _Dom& __e2) : _Base(__e1, __e2) {}
    };
  template<class _Oper, typename _Tp>
    struct _BinClos<_Oper, _ValArray, _Constant, _Tp, _Tp>
    : _BinBase2<_Oper, valarray<_Tp> >
    {
      typedef _BinBase2<_Oper,valarray<_Tp> > _Base;
      typedef typename _Base::value_type value_type;
      _BinClos(const valarray<_Tp>& __v, const _Tp& __t) : _Base(__v, __t) {}
    };
  template<class _Oper, typename _Tp>
    struct _BinClos<_Oper, _Constant, _ValArray, _Tp, _Tp>
    : _BinBase1<_Oper, valarray<_Tp> >
    {
      typedef _BinBase1<_Oper, valarray<_Tp> > _Base;
      typedef typename _Base::value_type value_type;
      _BinClos(const _Tp& __t, const valarray<_Tp>& __v) : _Base(__t, __v) {}
    };
  template<typename _Dom>
    class _SBase
    {
    public:
      typedef typename _Dom::value_type value_type;
      _SBase (const _Dom& __e, const slice& __s)
      : _M_expr (__e), _M_slice (__s) {}
      value_type
      operator[] (size_t __i) const
      { return _M_expr[_M_slice.start () + __i * _M_slice.stride ()]; }
      size_t
      size() const
      { return _M_slice.size (); }
    private:
      const _Dom& _M_expr;
      const slice& _M_slice;
    };
  template<typename _Tp>
    class _SBase<_Array<_Tp> >
    {
    public:
      typedef _Tp value_type;
      _SBase (_Array<_Tp> __a, const slice& __s)
      : _M_array (__a._M_data+__s.start()), _M_size (__s.size()),
 _M_stride (__s.stride()) {}
      value_type
      operator[] (size_t __i) const
      { return _M_array._M_data[__i * _M_stride]; }
      size_t
      size() const
      { return _M_size; }
    private:
      const _Array<_Tp> _M_array;
      const size_t _M_size;
      const size_t _M_stride;
    };
  template<class _Dom>
    struct _SClos<_Expr, _Dom>
    : _SBase<_Dom>
    {
      typedef _SBase<_Dom> _Base;
      typedef typename _Base::value_type value_type;
      _SClos (const _Dom& __e, const slice& __s) : _Base (__e, __s) {}
    };
  template<typename _Tp>
    struct _SClos<_ValArray, _Tp>
    : _SBase<_Array<_Tp> >
    {
      typedef _SBase<_Array<_Tp> > _Base;
      typedef _Tp value_type;
      _SClos (_Array<_Tp> __a, const slice& __s) : _Base (__a, __s) {}
    };
}
namespace std
{
  template<class _Tp>
    class valarray
    {
      template<class _Op>
 struct _UnaryOp
 {
   typedef typename __fun<_Op, _Tp>::result_type __rt;
   typedef _Expr<_UnClos<_Op, _ValArray, _Tp>, __rt> _Rt;
 };
    public:
      typedef _Tp value_type;
      valarray();
      explicit valarray(size_t);
      valarray(const _Tp&, size_t);
      valarray(const _Tp* __restrict__, size_t);
      valarray(const valarray&);
      valarray(const slice_array<_Tp>&);
      valarray(const gslice_array<_Tp>&);
      valarray(const mask_array<_Tp>&);
      valarray(const indirect_array<_Tp>&);
      template<class _Dom>
 valarray(const _Expr<_Dom, _Tp>& __e);
      ~valarray();
      valarray<_Tp>& operator=(const valarray<_Tp>&);
      valarray<_Tp>& operator=(const _Tp&);
      valarray<_Tp>& operator=(const slice_array<_Tp>&);
      valarray<_Tp>& operator=(const gslice_array<_Tp>&);
      valarray<_Tp>& operator=(const mask_array<_Tp>&);
      valarray<_Tp>& operator=(const indirect_array<_Tp>&);
      template<class _Dom> valarray<_Tp>&
 operator= (const _Expr<_Dom, _Tp>&);
      _Tp& operator[](size_t);
      const _Tp& operator[](size_t) const;
      _Expr<_SClos<_ValArray, _Tp>, _Tp> operator[](slice) const;
      slice_array<_Tp> operator[](slice);
      _Expr<_GClos<_ValArray, _Tp>, _Tp> operator[](const gslice&) const;
      gslice_array<_Tp> operator[](const gslice&);
      valarray<_Tp> operator[](const valarray<bool>&) const;
      mask_array<_Tp> operator[](const valarray<bool>&);
      _Expr<_IClos<_ValArray, _Tp>, _Tp>
        operator[](const valarray<size_t>&) const;
      indirect_array<_Tp> operator[](const valarray<size_t>&);
      typename _UnaryOp<__unary_plus>::_Rt operator+() const;
      typename _UnaryOp<__negate>::_Rt operator-() const;
      typename _UnaryOp<__bitwise_not>::_Rt operator~() const;
      typename _UnaryOp<__logical_not>::_Rt operator!() const;
      valarray<_Tp>& operator*=(const _Tp&);
      valarray<_Tp>& operator/=(const _Tp&);
      valarray<_Tp>& operator%=(const _Tp&);
      valarray<_Tp>& operator+=(const _Tp&);
      valarray<_Tp>& operator-=(const _Tp&);
      valarray<_Tp>& operator^=(const _Tp&);
      valarray<_Tp>& operator&=(const _Tp&);
      valarray<_Tp>& operator|=(const _Tp&);
      valarray<_Tp>& operator<<=(const _Tp&);
      valarray<_Tp>& operator>>=(const _Tp&);
      valarray<_Tp>& operator*=(const valarray<_Tp>&);
      valarray<_Tp>& operator/=(const valarray<_Tp>&);
      valarray<_Tp>& operator%=(const valarray<_Tp>&);
      valarray<_Tp>& operator+=(const valarray<_Tp>&);
      valarray<_Tp>& operator-=(const valarray<_Tp>&);
      valarray<_Tp>& operator^=(const valarray<_Tp>&);
      valarray<_Tp>& operator|=(const valarray<_Tp>&);
      valarray<_Tp>& operator&=(const valarray<_Tp>&);
      valarray<_Tp>& operator<<=(const valarray<_Tp>&);
      valarray<_Tp>& operator>>=(const valarray<_Tp>&);
      template<class _Dom>
 valarray<_Tp>& operator*=(const _Expr<_Dom, _Tp>&);
      template<class _Dom>
 valarray<_Tp>& operator/=(const _Expr<_Dom, _Tp>&);
      template<class _Dom>
 valarray<_Tp>& operator%=(const _Expr<_Dom, _Tp>&);
      template<class _Dom>
 valarray<_Tp>& operator+=(const _Expr<_Dom, _Tp>&);
      template<class _Dom>
 valarray<_Tp>& operator-=(const _Expr<_Dom, _Tp>&);
      template<class _Dom>
 valarray<_Tp>& operator^=(const _Expr<_Dom, _Tp>&);
      template<class _Dom>
 valarray<_Tp>& operator|=(const _Expr<_Dom, _Tp>&);
      template<class _Dom>
 valarray<_Tp>& operator&=(const _Expr<_Dom, _Tp>&);
      template<class _Dom>
        valarray<_Tp>& operator<<=(const _Expr<_Dom, _Tp>&);
      template<class _Dom>
 valarray<_Tp>& operator>>=(const _Expr<_Dom, _Tp>&);
      size_t size() const;
      _Tp sum() const;
      _Tp min() const;
      _Tp max() const;
      valarray<_Tp> shift (int) const;
      valarray<_Tp> cshift(int) const;
      _Expr<_ValFunClos<_ValArray, _Tp>, _Tp> apply(_Tp func(_Tp)) const;
      _Expr<_RefFunClos<_ValArray, _Tp>, _Tp> apply(_Tp func(const _Tp&)) const;
      void resize(size_t __size, _Tp __c = _Tp());
    private:
      size_t _M_size;
      _Tp* __restrict__ _M_data;
      friend class _Array<_Tp>;
    };
  template<typename _Tp>
    inline const _Tp&
    valarray<_Tp>::operator[](size_t __i) const
    {
      ;
      return _M_data[__i];
    }
  template<typename _Tp>
    inline _Tp&
    valarray<_Tp>::operator[](size_t __i)
    {
      ;
      return _M_data[__i];
    }
}
namespace std
{
  template<class _Dom>
    class _GBase
    {
    public:
      typedef typename _Dom::value_type value_type;
      _GBase (const _Dom& __e, const valarray<size_t>& __i)
      : _M_expr (__e), _M_index(__i) {}
      value_type
      operator[] (size_t __i) const
      { return _M_expr[_M_index[__i]]; }
      size_t
      size () const
      { return _M_index.size(); }
    private:
      const _Dom& _M_expr;
      const valarray<size_t>& _M_index;
    };
  template<typename _Tp>
    class _GBase<_Array<_Tp> >
    {
    public:
      typedef _Tp value_type;
      _GBase (_Array<_Tp> __a, const valarray<size_t>& __i)
      : _M_array (__a), _M_index(__i) {}
      value_type
      operator[] (size_t __i) const
      { return _M_array._M_data[_M_index[__i]]; }
      size_t
      size () const
      { return _M_index.size(); }
    private:
      const _Array<_Tp> _M_array;
      const valarray<size_t>& _M_index;
    };
  template<class _Dom>
    struct _GClos<_Expr, _Dom>
    : _GBase<_Dom>
    {
      typedef _GBase<_Dom> _Base;
      typedef typename _Base::value_type value_type;
      _GClos (const _Dom& __e, const valarray<size_t>& __i)
      : _Base (__e, __i) {}
    };
  template<typename _Tp>
    struct _GClos<_ValArray, _Tp>
    : _GBase<_Array<_Tp> >
    {
      typedef _GBase<_Array<_Tp> > _Base;
      typedef typename _Base::value_type value_type;
      _GClos (_Array<_Tp> __a, const valarray<size_t>& __i)
      : _Base (__a, __i) {}
    };
  template<class _Dom>
    class _IBase
    {
    public:
      typedef typename _Dom::value_type value_type;
      _IBase (const _Dom& __e, const valarray<size_t>& __i)
      : _M_expr (__e), _M_index (__i) {}
      value_type
      operator[] (size_t __i) const
      { return _M_expr[_M_index[__i]]; }
      size_t
      size() const
      { return _M_index.size(); }
    private:
      const _Dom& _M_expr;
      const valarray<size_t>& _M_index;
    };
  template<class _Dom>
    struct _IClos<_Expr, _Dom>
    : _IBase<_Dom>
    {
      typedef _IBase<_Dom> _Base;
      typedef typename _Base::value_type value_type;
      _IClos (const _Dom& __e, const valarray<size_t>& __i)
      : _Base (__e, __i) {}
    };
  template<typename _Tp>
    struct _IClos<_ValArray, _Tp>
    : _IBase<valarray<_Tp> >
    {
      typedef _IBase<valarray<_Tp> > _Base;
      typedef _Tp value_type;
      _IClos (const valarray<_Tp>& __a, const valarray<size_t>& __i)
      : _Base (__a, __i) {}
    };
  template<class _Clos, typename _Tp>
    class _Expr
    {
    public:
      typedef _Tp value_type;
      _Expr(const _Clos&);
      const _Clos& operator()() const;
      value_type operator[](size_t) const;
      valarray<value_type> operator[](slice) const;
      valarray<value_type> operator[](const gslice&) const;
      valarray<value_type> operator[](const valarray<bool>&) const;
      valarray<value_type> operator[](const valarray<size_t>&) const;
      _Expr<_UnClos<__unary_plus, std::_Expr, _Clos>, value_type>
      operator+() const;
      _Expr<_UnClos<__negate, std::_Expr, _Clos>, value_type>
      operator-() const;
      _Expr<_UnClos<__bitwise_not, std::_Expr, _Clos>, value_type>
      operator~() const;
      _Expr<_UnClos<__logical_not, std::_Expr, _Clos>, bool>
      operator!() const;
      size_t size() const;
      value_type sum() const;
      valarray<value_type> shift(int) const;
      valarray<value_type> cshift(int) const;
      value_type min() const;
      value_type max() const;
      valarray<value_type> apply(value_type (*)(const value_type&)) const;
      valarray<value_type> apply(value_type (*)(value_type)) const;
    private:
      const _Clos _M_closure;
    };
  template<class _Clos, typename _Tp>
    inline
    _Expr<_Clos, _Tp>::_Expr(const _Clos& __c) : _M_closure(__c) {}
  template<class _Clos, typename _Tp>
    inline const _Clos&
    _Expr<_Clos, _Tp>::operator()() const
    { return _M_closure; }
  template<class _Clos, typename _Tp>
    inline _Tp
    _Expr<_Clos, _Tp>::operator[](size_t __i) const
    { return _M_closure[__i]; }
  template<class _Clos, typename _Tp>
    inline valarray<_Tp>
    _Expr<_Clos, _Tp>::operator[](slice __s) const
    {
      valarray<_Tp> __v = valarray<_Tp>(*this)[__s];
      return __v;
    }
  template<class _Clos, typename _Tp>
    inline valarray<_Tp>
    _Expr<_Clos, _Tp>::operator[](const gslice& __gs) const
    {
      valarray<_Tp> __v = valarray<_Tp>(*this)[__gs];
      return __v;
    }
  template<class _Clos, typename _Tp>
    inline valarray<_Tp>
    _Expr<_Clos, _Tp>::operator[](const valarray<bool>& __m) const
    {
      valarray<_Tp> __v = valarray<_Tp>(*this)[__m];
      return __v;
    }
  template<class _Clos, typename _Tp>
    inline valarray<_Tp>
    _Expr<_Clos, _Tp>::operator[](const valarray<size_t>& __i) const
    {
      valarray<_Tp> __v = valarray<_Tp>(*this)[__i];
      return __v;
    }
  template<class _Clos, typename _Tp>
    inline size_t
    _Expr<_Clos, _Tp>::size() const
    { return _M_closure.size(); }
  template<class _Clos, typename _Tp>
    inline valarray<_Tp>
    _Expr<_Clos, _Tp>::shift(int __n) const
    {
      valarray<_Tp> __v = valarray<_Tp>(*this).shift(__n);
      return __v;
    }
  template<class _Clos, typename _Tp>
    inline valarray<_Tp>
    _Expr<_Clos, _Tp>::cshift(int __n) const
    {
      valarray<_Tp> __v = valarray<_Tp>(*this).cshift(__n);
      return __v;
    }
  template<class _Clos, typename _Tp>
    inline valarray<_Tp>
    _Expr<_Clos, _Tp>::apply(_Tp __f(const _Tp&)) const
    {
      valarray<_Tp> __v = valarray<_Tp>(*this).apply(__f);
      return __v;
    }
  template<class _Clos, typename _Tp>
    inline valarray<_Tp>
    _Expr<_Clos, _Tp>::apply(_Tp __f(_Tp)) const
    {
      valarray<_Tp> __v = valarray<_Tp>(*this).apply(__f);
      return __v;
    }
  template<class _Clos, typename _Tp>
    inline _Tp
    _Expr<_Clos, _Tp>::sum() const
    {
      size_t __n = _M_closure.size();
      if (__n == 0)
 return _Tp();
      else
 {
   _Tp __s = _M_closure[--__n];
   while (__n != 0)
     __s += _M_closure[--__n];
   return __s;
        }
    }
  template<class _Clos, typename _Tp>
    inline _Tp
    _Expr<_Clos, _Tp>::min() const
    { return __valarray_min(_M_closure); }
  template<class _Clos, typename _Tp>
    inline _Tp
    _Expr<_Clos, _Tp>::max() const
    { return __valarray_max(_M_closure); }
  template<class _Dom, typename _Tp>
    inline _Expr<_UnClos<__logical_not, _Expr, _Dom>, bool>
    _Expr<_Dom, _Tp>::operator!() const
    {
      typedef _UnClos<__logical_not, std::_Expr, _Dom> _Closure;
      return _Expr<_Closure, _Tp>(_Closure(this->_M_closure));
    }
    template<class _Dom, typename _Tp> inline _Expr<_UnClos<__unary_plus, std::_Expr, _Dom>, _Tp> _Expr<_Dom, _Tp>::operator +() const { typedef _UnClos<__unary_plus, std::_Expr, _Dom> _Closure; return _Expr<_Closure, _Tp>(_Closure(this->_M_closure)); }
    template<class _Dom, typename _Tp> inline _Expr<_UnClos<__negate, std::_Expr, _Dom>, _Tp> _Expr<_Dom, _Tp>::operator -() const { typedef _UnClos<__negate, std::_Expr, _Dom> _Closure; return _Expr<_Closure, _Tp>(_Closure(this->_M_closure)); }
    template<class _Dom, typename _Tp> inline _Expr<_UnClos<__bitwise_not, std::_Expr, _Dom>, _Tp> _Expr<_Dom, _Tp>::operator ~() const { typedef _UnClos<__bitwise_not, std::_Expr, _Dom> _Closure; return _Expr<_Closure, _Tp>(_Closure(this->_M_closure)); }
    template<class _Dom1, class _Dom2> inline _Expr<_BinClos<__plus, _Expr, _Expr, _Dom1, _Dom2>, typename __fun<__plus, typename _Dom1::value_type>::result_type> operator +(const _Expr<_Dom1, typename _Dom1::value_type>& __v, const _Expr<_Dom2, typename _Dom2::value_type>& __w) { typedef typename _Dom1::value_type _Arg; typedef typename __fun<__plus, _Arg>::result_type _Value; typedef _BinClos<__plus, _Expr, _Expr, _Dom1, _Dom2> _Closure; return _Expr<_Closure, _Value>(_Closure(__v(), __w())); } template<class _Dom> inline _Expr<_BinClos<__plus, _Expr, _Constant, _Dom, typename _Dom::value_type>, typename __fun<__plus, typename _Dom::value_type>::result_type> operator +(const _Expr<_Dom, typename _Dom::value_type>& __v, const typename _Dom::value_type& __t) { typedef typename _Dom::value_type _Arg; typedef typename __fun<__plus, _Arg>::result_type _Value; typedef _BinClos<__plus, _Expr, _Constant, _Dom, _Arg> _Closure; return _Expr<_Closure, _Value>(_Closure(__v(), __t)); } template<class _Dom> inline _Expr<_BinClos<__plus, _Constant, _Expr, typename _Dom::value_type, _Dom>, typename __fun<__plus, typename _Dom::value_type>::result_type> operator +(const typename _Dom::value_type& __t, const _Expr<_Dom, typename _Dom::value_type>& __v) { typedef typename _Dom::value_type _Arg; typedef typename __fun<__plus, _Arg>::result_type _Value; typedef _BinClos<__plus, _Constant, _Expr, _Arg, _Dom> _Closure; return _Expr<_Closure, _Value>(_Closure(__t, __v())); } template<class _Dom> inline _Expr<_BinClos<__plus, _Expr, _ValArray, _Dom, typename _Dom::value_type>, typename __fun<__plus, typename _Dom::value_type>::result_type> operator +(const _Expr<_Dom,typename _Dom::value_type>& __e, const valarray<typename _Dom::value_type>& __v) { typedef typename _Dom::value_type _Arg; typedef typename __fun<__plus, _Arg>::result_type _Value; typedef _BinClos<__plus, _Expr, _ValArray, _Dom, _Arg> _Closure; return _Expr<_Closure, _Value>(_Closure(__e(), __v)); } template<class _Dom> inline _Expr<_BinClos<__plus, _ValArray, _Expr, typename _Dom::value_type, _Dom>, typename __fun<__plus, typename _Dom::value_type>::result_type> operator +(const valarray<typename _Dom::value_type>& __v, const _Expr<_Dom, typename _Dom::value_type>& __e) { typedef typename _Dom::value_type _Tp; typedef typename __fun<__plus, _Tp>::result_type _Value; typedef _BinClos<__plus, _ValArray, _Expr, _Tp, _Dom> _Closure; return _Expr<_Closure, _Value>(_Closure(__v, __e ())); }
    template<class _Dom1, class _Dom2> inline _Expr<_BinClos<__minus, _Expr, _Expr, _Dom1, _Dom2>, typename __fun<__minus, typename _Dom1::value_type>::result_type> operator -(const _Expr<_Dom1, typename _Dom1::value_type>& __v, const _Expr<_Dom2, typename _Dom2::value_type>& __w) { typedef typename _Dom1::value_type _Arg; typedef typename __fun<__minus, _Arg>::result_type _Value; typedef _BinClos<__minus, _Expr, _Expr, _Dom1, _Dom2> _Closure; return _Expr<_Closure, _Value>(_Closure(__v(), __w())); } template<class _Dom> inline _Expr<_BinClos<__minus, _Expr, _Constant, _Dom, typename _Dom::value_type>, typename __fun<__minus, typename _Dom::value_type>::result_type> operator -(const _Expr<_Dom, typename _Dom::value_type>& __v, const typename _Dom::value_type& __t) { typedef typename _Dom::value_type _Arg; typedef typename __fun<__minus, _Arg>::result_type _Value; typedef _BinClos<__minus, _Expr, _Constant, _Dom, _Arg> _Closure; return _Expr<_Closure, _Value>(_Closure(__v(), __t)); } template<class _Dom> inline _Expr<_BinClos<__minus, _Constant, _Expr, typename _Dom::value_type, _Dom>, typename __fun<__minus, typename _Dom::value_type>::result_type> operator -(const typename _Dom::value_type& __t, const _Expr<_Dom, typename _Dom::value_type>& __v) { typedef typename _Dom::value_type _Arg; typedef typename __fun<__minus, _Arg>::result_type _Value; typedef _BinClos<__minus, _Constant, _Expr, _Arg, _Dom> _Closure; return _Expr<_Closure, _Value>(_Closure(__t, __v())); } template<class _Dom> inline _Expr<_BinClos<__minus, _Expr, _ValArray, _Dom, typename _Dom::value_type>, typename __fun<__minus, typename _Dom::value_type>::result_type> operator -(const _Expr<_Dom,typename _Dom::value_type>& __e, const valarray<typename _Dom::value_type>& __v) { typedef typename _Dom::value_type _Arg; typedef typename __fun<__minus, _Arg>::result_type _Value; typedef _BinClos<__minus, _Expr, _ValArray, _Dom, _Arg> _Closure; return _Expr<_Closure, _Value>(_Closure(__e(), __v)); } template<class _Dom> inline _Expr<_BinClos<__minus, _ValArray, _Expr, typename _Dom::value_type, _Dom>, typename __fun<__minus, typename _Dom::value_type>::result_type> operator -(const valarray<typename _Dom::value_type>& __v, const _Expr<_Dom, typename _Dom::value_type>& __e) { typedef typename _Dom::value_type _Tp; typedef typename __fun<__minus, _Tp>::result_type _Value; typedef _BinClos<__minus, _ValArray, _Expr, _Tp, _Dom> _Closure; return _Expr<_Closure, _Value>(_Closure(__v, __e ())); }
    template<class _Dom1, class _Dom2> inline _Expr<_BinClos<__multiplies, _Expr, _Expr, _Dom1, _Dom2>, typename __fun<__multiplies, typename _Dom1::value_type>::result_type> operator *(const _Expr<_Dom1, typename _Dom1::value_type>& __v, const _Expr<_Dom2, typename _Dom2::value_type>& __w) { typedef typename _Dom1::value_type _Arg; typedef typename __fun<__multiplies, _Arg>::result_type _Value; typedef _BinClos<__multiplies, _Expr, _Expr, _Dom1, _Dom2> _Closure; return _Expr<_Closure, _Value>(_Closure(__v(), __w())); } template<class _Dom> inline _Expr<_BinClos<__multiplies, _Expr, _Constant, _Dom, typename _Dom::value_type>, typename __fun<__multiplies, typename _Dom::value_type>::result_type> operator *(const _Expr<_Dom, typename _Dom::value_type>& __v, const typename _Dom::value_type& __t) { typedef typename _Dom::value_type _Arg; typedef typename __fun<__multiplies, _Arg>::result_type _Value; typedef _BinClos<__multiplies, _Expr, _Constant, _Dom, _Arg> _Closure; return _Expr<_Closure, _Value>(_Closure(__v(), __t)); } template<class _Dom> inline _Expr<_BinClos<__multiplies, _Constant, _Expr, typename _Dom::value_type, _Dom>, typename __fun<__multiplies, typename _Dom::value_type>::result_type> operator *(const typename _Dom::value_type& __t, const _Expr<_Dom, typename _Dom::value_type>& __v) { typedef typename _Dom::value_type _Arg; typedef typename __fun<__multiplies, _Arg>::result_type _Value; typedef _BinClos<__multiplies, _Constant, _Expr, _Arg, _Dom> _Closure; return _Expr<_Closure, _Value>(_Closure(__t, __v())); } template<class _Dom> inline _Expr<_BinClos<__multiplies, _Expr, _ValArray, _Dom, typename _Dom::value_type>, typename __fun<__multiplies, typename _Dom::value_type>::result_type> operator *(const _Expr<_Dom,typename _Dom::value_type>& __e, const valarray<typename _Dom::value_type>& __v) { typedef typename _Dom::value_type _Arg; typedef typename __fun<__multiplies, _Arg>::result_type _Value; typedef _BinClos<__multiplies, _Expr, _ValArray, _Dom, _Arg> _Closure; return _Expr<_Closure, _Value>(_Closure(__e(), __v)); } template<class _Dom> inline _Expr<_BinClos<__multiplies, _ValArray, _Expr, typename _Dom::value_type, _Dom>, typename __fun<__multiplies, typename _Dom::value_type>::result_type> operator *(const valarray<typename _Dom::value_type>& __v, const _Expr<_Dom, typename _Dom::value_type>& __e) { typedef typename _Dom::value_type _Tp; typedef typename __fun<__multiplies, _Tp>::result_type _Value; typedef _BinClos<__multiplies, _ValArray, _Expr, _Tp, _Dom> _Closure; return _Expr<_Closure, _Value>(_Closure(__v, __e ())); }
    template<class _Dom1, class _Dom2> inline _Expr<_BinClos<__divides, _Expr, _Expr, _Dom1, _Dom2>, typename __fun<__divides, typename _Dom1::value_type>::result_type> operator /(const _Expr<_Dom1, typename _Dom1::value_type>& __v, const _Expr<_Dom2, typename _Dom2::value_type>& __w) { typedef typename _Dom1::value_type _Arg; typedef typename __fun<__divides, _Arg>::result_type _Value; typedef _BinClos<__divides, _Expr, _Expr, _Dom1, _Dom2> _Closure; return _Expr<_Closure, _Value>(_Closure(__v(), __w())); } template<class _Dom> inline _Expr<_BinClos<__divides, _Expr, _Constant, _Dom, typename _Dom::value_type>, typename __fun<__divides, typename _Dom::value_type>::result_type> operator /(const _Expr<_Dom, typename _Dom::value_type>& __v, const typename _Dom::value_type& __t) { typedef typename _Dom::value_type _Arg; typedef typename __fun<__divides, _Arg>::result_type _Value; typedef _BinClos<__divides, _Expr, _Constant, _Dom, _Arg> _Closure; return _Expr<_Closure, _Value>(_Closure(__v(), __t)); } template<class _Dom> inline _Expr<_BinClos<__divides, _Constant, _Expr, typename _Dom::value_type, _Dom>, typename __fun<__divides, typename _Dom::value_type>::result_type> operator /(const typename _Dom::value_type& __t, const _Expr<_Dom, typename _Dom::value_type>& __v) { typedef typename _Dom::value_type _Arg; typedef typename __fun<__divides, _Arg>::result_type _Value; typedef _BinClos<__divides, _Constant, _Expr, _Arg, _Dom> _Closure; return _Expr<_Closure, _Value>(_Closure(__t, __v())); } template<class _Dom> inline _Expr<_BinClos<__divides, _Expr, _ValArray, _Dom, typename _Dom::value_type>, typename __fun<__divides, typename _Dom::value_type>::result_type> operator /(const _Expr<_Dom,typename _Dom::value_type>& __e, const valarray<typename _Dom::value_type>& __v) { typedef typename _Dom::value_type _Arg; typedef typename __fun<__divides, _Arg>::result_type _Value; typedef _BinClos<__divides, _Expr, _ValArray, _Dom, _Arg> _Closure; return _Expr<_Closure, _Value>(_Closure(__e(), __v)); } template<class _Dom> inline _Expr<_BinClos<__divides, _ValArray, _Expr, typename _Dom::value_type, _Dom>, typename __fun<__divides, typename _Dom::value_type>::result_type> operator /(const valarray<typename _Dom::value_type>& __v, const _Expr<_Dom, typename _Dom::value_type>& __e) { typedef typename _Dom::value_type _Tp; typedef typename __fun<__divides, _Tp>::result_type _Value; typedef _BinClos<__divides, _ValArray, _Expr, _Tp, _Dom> _Closure; return _Expr<_Closure, _Value>(_Closure(__v, __e ())); }
    template<class _Dom1, class _Dom2> inline _Expr<_BinClos<__modulus, _Expr, _Expr, _Dom1, _Dom2>, typename __fun<__modulus, typename _Dom1::value_type>::result_type> operator %(const _Expr<_Dom1, typename _Dom1::value_type>& __v, const _Expr<_Dom2, typename _Dom2::value_type>& __w) { typedef typename _Dom1::value_type _Arg; typedef typename __fun<__modulus, _Arg>::result_type _Value; typedef _BinClos<__modulus, _Expr, _Expr, _Dom1, _Dom2> _Closure; return _Expr<_Closure, _Value>(_Closure(__v(), __w())); } template<class _Dom> inline _Expr<_BinClos<__modulus, _Expr, _Constant, _Dom, typename _Dom::value_type>, typename __fun<__modulus, typename _Dom::value_type>::result_type> operator %(const _Expr<_Dom, typename _Dom::value_type>& __v, const typename _Dom::value_type& __t) { typedef typename _Dom::value_type _Arg; typedef typename __fun<__modulus, _Arg>::result_type _Value; typedef _BinClos<__modulus, _Expr, _Constant, _Dom, _Arg> _Closure; return _Expr<_Closure, _Value>(_Closure(__v(), __t)); } template<class _Dom> inline _Expr<_BinClos<__modulus, _Constant, _Expr, typename _Dom::value_type, _Dom>, typename __fun<__modulus, typename _Dom::value_type>::result_type> operator %(const typename _Dom::value_type& __t, const _Expr<_Dom, typename _Dom::value_type>& __v) { typedef typename _Dom::value_type _Arg; typedef typename __fun<__modulus, _Arg>::result_type _Value; typedef _BinClos<__modulus, _Constant, _Expr, _Arg, _Dom> _Closure; return _Expr<_Closure, _Value>(_Closure(__t, __v())); } template<class _Dom> inline _Expr<_BinClos<__modulus, _Expr, _ValArray, _Dom, typename _Dom::value_type>, typename __fun<__modulus, typename _Dom::value_type>::result_type> operator %(const _Expr<_Dom,typename _Dom::value_type>& __e, const valarray<typename _Dom::value_type>& __v) { typedef typename _Dom::value_type _Arg; typedef typename __fun<__modulus, _Arg>::result_type _Value; typedef _BinClos<__modulus, _Expr, _ValArray, _Dom, _Arg> _Closure; return _Expr<_Closure, _Value>(_Closure(__e(), __v)); } template<class _Dom> inline _Expr<_BinClos<__modulus, _ValArray, _Expr, typename _Dom::value_type, _Dom>, typename __fun<__modulus, typename _Dom::value_type>::result_type> operator %(const valarray<typename _Dom::value_type>& __v, const _Expr<_Dom, typename _Dom::value_type>& __e) { typedef typename _Dom::value_type _Tp; typedef typename __fun<__modulus, _Tp>::result_type _Value; typedef _BinClos<__modulus, _ValArray, _Expr, _Tp, _Dom> _Closure; return _Expr<_Closure, _Value>(_Closure(__v, __e ())); }
    template<class _Dom1, class _Dom2> inline _Expr<_BinClos<__bitwise_xor, _Expr, _Expr, _Dom1, _Dom2>, typename __fun<__bitwise_xor, typename _Dom1::value_type>::result_type> operator ^(const _Expr<_Dom1, typename _Dom1::value_type>& __v, const _Expr<_Dom2, typename _Dom2::value_type>& __w) { typedef typename _Dom1::value_type _Arg; typedef typename __fun<__bitwise_xor, _Arg>::result_type _Value; typedef _BinClos<__bitwise_xor, _Expr, _Expr, _Dom1, _Dom2> _Closure; return _Expr<_Closure, _Value>(_Closure(__v(), __w())); } template<class _Dom> inline _Expr<_BinClos<__bitwise_xor, _Expr, _Constant, _Dom, typename _Dom::value_type>, typename __fun<__bitwise_xor, typename _Dom::value_type>::result_type> operator ^(const _Expr<_Dom, typename _Dom::value_type>& __v, const typename _Dom::value_type& __t) { typedef typename _Dom::value_type _Arg; typedef typename __fun<__bitwise_xor, _Arg>::result_type _Value; typedef _BinClos<__bitwise_xor, _Expr, _Constant, _Dom, _Arg> _Closure; return _Expr<_Closure, _Value>(_Closure(__v(), __t)); } template<class _Dom> inline _Expr<_BinClos<__bitwise_xor, _Constant, _Expr, typename _Dom::value_type, _Dom>, typename __fun<__bitwise_xor, typename _Dom::value_type>::result_type> operator ^(const typename _Dom::value_type& __t, const _Expr<_Dom, typename _Dom::value_type>& __v) { typedef typename _Dom::value_type _Arg; typedef typename __fun<__bitwise_xor, _Arg>::result_type _Value; typedef _BinClos<__bitwise_xor, _Constant, _Expr, _Arg, _Dom> _Closure; return _Expr<_Closure, _Value>(_Closure(__t, __v())); } template<class _Dom> inline _Expr<_BinClos<__bitwise_xor, _Expr, _ValArray, _Dom, typename _Dom::value_type>, typename __fun<__bitwise_xor, typename _Dom::value_type>::result_type> operator ^(const _Expr<_Dom,typename _Dom::value_type>& __e, const valarray<typename _Dom::value_type>& __v) { typedef typename _Dom::value_type _Arg; typedef typename __fun<__bitwise_xor, _Arg>::result_type _Value; typedef _BinClos<__bitwise_xor, _Expr, _ValArray, _Dom, _Arg> _Closure; return _Expr<_Closure, _Value>(_Closure(__e(), __v)); } template<class _Dom> inline _Expr<_BinClos<__bitwise_xor, _ValArray, _Expr, typename _Dom::value_type, _Dom>, typename __fun<__bitwise_xor, typename _Dom::value_type>::result_type> operator ^(const valarray<typename _Dom::value_type>& __v, const _Expr<_Dom, typename _Dom::value_type>& __e) { typedef typename _Dom::value_type _Tp; typedef typename __fun<__bitwise_xor, _Tp>::result_type _Value; typedef _BinClos<__bitwise_xor, _ValArray, _Expr, _Tp, _Dom> _Closure; return _Expr<_Closure, _Value>(_Closure(__v, __e ())); }
    template<class _Dom1, class _Dom2> inline _Expr<_BinClos<__bitwise_and, _Expr, _Expr, _Dom1, _Dom2>, typename __fun<__bitwise_and, typename _Dom1::value_type>::result_type> operator &(const _Expr<_Dom1, typename _Dom1::value_type>& __v, const _Expr<_Dom2, typename _Dom2::value_type>& __w) { typedef typename _Dom1::value_type _Arg; typedef typename __fun<__bitwise_and, _Arg>::result_type _Value; typedef _BinClos<__bitwise_and, _Expr, _Expr, _Dom1, _Dom2> _Closure; return _Expr<_Closure, _Value>(_Closure(__v(), __w())); } template<class _Dom> inline _Expr<_BinClos<__bitwise_and, _Expr, _Constant, _Dom, typename _Dom::value_type>, typename __fun<__bitwise_and, typename _Dom::value_type>::result_type> operator &(const _Expr<_Dom, typename _Dom::value_type>& __v, const typename _Dom::value_type& __t) { typedef typename _Dom::value_type _Arg; typedef typename __fun<__bitwise_and, _Arg>::result_type _Value; typedef _BinClos<__bitwise_and, _Expr, _Constant, _Dom, _Arg> _Closure; return _Expr<_Closure, _Value>(_Closure(__v(), __t)); } template<class _Dom> inline _Expr<_BinClos<__bitwise_and, _Constant, _Expr, typename _Dom::value_type, _Dom>, typename __fun<__bitwise_and, typename _Dom::value_type>::result_type> operator &(const typename _Dom::value_type& __t, const _Expr<_Dom, typename _Dom::value_type>& __v) { typedef typename _Dom::value_type _Arg; typedef typename __fun<__bitwise_and, _Arg>::result_type _Value; typedef _BinClos<__bitwise_and, _Constant, _Expr, _Arg, _Dom> _Closure; return _Expr<_Closure, _Value>(_Closure(__t, __v())); } template<class _Dom> inline _Expr<_BinClos<__bitwise_and, _Expr, _ValArray, _Dom, typename _Dom::value_type>, typename __fun<__bitwise_and, typename _Dom::value_type>::result_type> operator &(const _Expr<_Dom,typename _Dom::value_type>& __e, const valarray<typename _Dom::value_type>& __v) { typedef typename _Dom::value_type _Arg; typedef typename __fun<__bitwise_and, _Arg>::result_type _Value; typedef _BinClos<__bitwise_and, _Expr, _ValArray, _Dom, _Arg> _Closure; return _Expr<_Closure, _Value>(_Closure(__e(), __v)); } template<class _Dom> inline _Expr<_BinClos<__bitwise_and, _ValArray, _Expr, typename _Dom::value_type, _Dom>, typename __fun<__bitwise_and, typename _Dom::value_type>::result_type> operator &(const valarray<typename _Dom::value_type>& __v, const _Expr<_Dom, typename _Dom::value_type>& __e) { typedef typename _Dom::value_type _Tp; typedef typename __fun<__bitwise_and, _Tp>::result_type _Value; typedef _BinClos<__bitwise_and, _ValArray, _Expr, _Tp, _Dom> _Closure; return _Expr<_Closure, _Value>(_Closure(__v, __e ())); }
    template<class _Dom1, class _Dom2> inline _Expr<_BinClos<__bitwise_or, _Expr, _Expr, _Dom1, _Dom2>, typename __fun<__bitwise_or, typename _Dom1::value_type>::result_type> operator |(const _Expr<_Dom1, typename _Dom1::value_type>& __v, const _Expr<_Dom2, typename _Dom2::value_type>& __w) { typedef typename _Dom1::value_type _Arg; typedef typename __fun<__bitwise_or, _Arg>::result_type _Value; typedef _BinClos<__bitwise_or, _Expr, _Expr, _Dom1, _Dom2> _Closure; return _Expr<_Closure, _Value>(_Closure(__v(), __w())); } template<class _Dom> inline _Expr<_BinClos<__bitwise_or, _Expr, _Constant, _Dom, typename _Dom::value_type>, typename __fun<__bitwise_or, typename _Dom::value_type>::result_type> operator |(const _Expr<_Dom, typename _Dom::value_type>& __v, const typename _Dom::value_type& __t) { typedef typename _Dom::value_type _Arg; typedef typename __fun<__bitwise_or, _Arg>::result_type _Value; typedef _BinClos<__bitwise_or, _Expr, _Constant, _Dom, _Arg> _Closure; return _Expr<_Closure, _Value>(_Closure(__v(), __t)); } template<class _Dom> inline _Expr<_BinClos<__bitwise_or, _Constant, _Expr, typename _Dom::value_type, _Dom>, typename __fun<__bitwise_or, typename _Dom::value_type>::result_type> operator |(const typename _Dom::value_type& __t, const _Expr<_Dom, typename _Dom::value_type>& __v) { typedef typename _Dom::value_type _Arg; typedef typename __fun<__bitwise_or, _Arg>::result_type _Value; typedef _BinClos<__bitwise_or, _Constant, _Expr, _Arg, _Dom> _Closure; return _Expr<_Closure, _Value>(_Closure(__t, __v())); } template<class _Dom> inline _Expr<_BinClos<__bitwise_or, _Expr, _ValArray, _Dom, typename _Dom::value_type>, typename __fun<__bitwise_or, typename _Dom::value_type>::result_type> operator |(const _Expr<_Dom,typename _Dom::value_type>& __e, const valarray<typename _Dom::value_type>& __v) { typedef typename _Dom::value_type _Arg; typedef typename __fun<__bitwise_or, _Arg>::result_type _Value; typedef _BinClos<__bitwise_or, _Expr, _ValArray, _Dom, _Arg> _Closure; return _Expr<_Closure, _Value>(_Closure(__e(), __v)); } template<class _Dom> inline _Expr<_BinClos<__bitwise_or, _ValArray, _Expr, typename _Dom::value_type, _Dom>, typename __fun<__bitwise_or, typename _Dom::value_type>::result_type> operator |(const valarray<typename _Dom::value_type>& __v, const _Expr<_Dom, typename _Dom::value_type>& __e) { typedef typename _Dom::value_type _Tp; typedef typename __fun<__bitwise_or, _Tp>::result_type _Value; typedef _BinClos<__bitwise_or, _ValArray, _Expr, _Tp, _Dom> _Closure; return _Expr<_Closure, _Value>(_Closure(__v, __e ())); }
    template<class _Dom1, class _Dom2> inline _Expr<_BinClos<__shift_left, _Expr, _Expr, _Dom1, _Dom2>, typename __fun<__shift_left, typename _Dom1::value_type>::result_type> operator <<(const _Expr<_Dom1, typename _Dom1::value_type>& __v, const _Expr<_Dom2, typename _Dom2::value_type>& __w) { typedef typename _Dom1::value_type _Arg; typedef typename __fun<__shift_left, _Arg>::result_type _Value; typedef _BinClos<__shift_left, _Expr, _Expr, _Dom1, _Dom2> _Closure; return _Expr<_Closure, _Value>(_Closure(__v(), __w())); } template<class _Dom> inline _Expr<_BinClos<__shift_left, _Expr, _Constant, _Dom, typename _Dom::value_type>, typename __fun<__shift_left, typename _Dom::value_type>::result_type> operator <<(const _Expr<_Dom, typename _Dom::value_type>& __v, const typename _Dom::value_type& __t) { typedef typename _Dom::value_type _Arg; typedef typename __fun<__shift_left, _Arg>::result_type _Value; typedef _BinClos<__shift_left, _Expr, _Constant, _Dom, _Arg> _Closure; return _Expr<_Closure, _Value>(_Closure(__v(), __t)); } template<class _Dom> inline _Expr<_BinClos<__shift_left, _Constant, _Expr, typename _Dom::value_type, _Dom>, typename __fun<__shift_left, typename _Dom::value_type>::result_type> operator <<(const typename _Dom::value_type& __t, const _Expr<_Dom, typename _Dom::value_type>& __v) { typedef typename _Dom::value_type _Arg; typedef typename __fun<__shift_left, _Arg>::result_type _Value; typedef _BinClos<__shift_left, _Constant, _Expr, _Arg, _Dom> _Closure; return _Expr<_Closure, _Value>(_Closure(__t, __v())); } template<class _Dom> inline _Expr<_BinClos<__shift_left, _Expr, _ValArray, _Dom, typename _Dom::value_type>, typename __fun<__shift_left, typename _Dom::value_type>::result_type> operator <<(const _Expr<_Dom,typename _Dom::value_type>& __e, const valarray<typename _Dom::value_type>& __v) { typedef typename _Dom::value_type _Arg; typedef typename __fun<__shift_left, _Arg>::result_type _Value; typedef _BinClos<__shift_left, _Expr, _ValArray, _Dom, _Arg> _Closure; return _Expr<_Closure, _Value>(_Closure(__e(), __v)); } template<class _Dom> inline _Expr<_BinClos<__shift_left, _ValArray, _Expr, typename _Dom::value_type, _Dom>, typename __fun<__shift_left, typename _Dom::value_type>::result_type> operator <<(const valarray<typename _Dom::value_type>& __v, const _Expr<_Dom, typename _Dom::value_type>& __e) { typedef typename _Dom::value_type _Tp; typedef typename __fun<__shift_left, _Tp>::result_type _Value; typedef _BinClos<__shift_left, _ValArray, _Expr, _Tp, _Dom> _Closure; return _Expr<_Closure, _Value>(_Closure(__v, __e ())); }
    template<class _Dom1, class _Dom2> inline _Expr<_BinClos<__shift_right, _Expr, _Expr, _Dom1, _Dom2>, typename __fun<__shift_right, typename _Dom1::value_type>::result_type> operator >>(const _Expr<_Dom1, typename _Dom1::value_type>& __v, const _Expr<_Dom2, typename _Dom2::value_type>& __w) { typedef typename _Dom1::value_type _Arg; typedef typename __fun<__shift_right, _Arg>::result_type _Value; typedef _BinClos<__shift_right, _Expr, _Expr, _Dom1, _Dom2> _Closure; return _Expr<_Closure, _Value>(_Closure(__v(), __w())); } template<class _Dom> inline _Expr<_BinClos<__shift_right, _Expr, _Constant, _Dom, typename _Dom::value_type>, typename __fun<__shift_right, typename _Dom::value_type>::result_type> operator >>(const _Expr<_Dom, typename _Dom::value_type>& __v, const typename _Dom::value_type& __t) { typedef typename _Dom::value_type _Arg; typedef typename __fun<__shift_right, _Arg>::result_type _Value; typedef _BinClos<__shift_right, _Expr, _Constant, _Dom, _Arg> _Closure; return _Expr<_Closure, _Value>(_Closure(__v(), __t)); } template<class _Dom> inline _Expr<_BinClos<__shift_right, _Constant, _Expr, typename _Dom::value_type, _Dom>, typename __fun<__shift_right, typename _Dom::value_type>::result_type> operator >>(const typename _Dom::value_type& __t, const _Expr<_Dom, typename _Dom::value_type>& __v) { typedef typename _Dom::value_type _Arg; typedef typename __fun<__shift_right, _Arg>::result_type _Value; typedef _BinClos<__shift_right, _Constant, _Expr, _Arg, _Dom> _Closure; return _Expr<_Closure, _Value>(_Closure(__t, __v())); } template<class _Dom> inline _Expr<_BinClos<__shift_right, _Expr, _ValArray, _Dom, typename _Dom::value_type>, typename __fun<__shift_right, typename _Dom::value_type>::result_type> operator >>(const _Expr<_Dom,typename _Dom::value_type>& __e, const valarray<typename _Dom::value_type>& __v) { typedef typename _Dom::value_type _Arg; typedef typename __fun<__shift_right, _Arg>::result_type _Value; typedef _BinClos<__shift_right, _Expr, _ValArray, _Dom, _Arg> _Closure; return _Expr<_Closure, _Value>(_Closure(__e(), __v)); } template<class _Dom> inline _Expr<_BinClos<__shift_right, _ValArray, _Expr, typename _Dom::value_type, _Dom>, typename __fun<__shift_right, typename _Dom::value_type>::result_type> operator >>(const valarray<typename _Dom::value_type>& __v, const _Expr<_Dom, typename _Dom::value_type>& __e) { typedef typename _Dom::value_type _Tp; typedef typename __fun<__shift_right, _Tp>::result_type _Value; typedef _BinClos<__shift_right, _ValArray, _Expr, _Tp, _Dom> _Closure; return _Expr<_Closure, _Value>(_Closure(__v, __e ())); }
    template<class _Dom1, class _Dom2> inline _Expr<_BinClos<__logical_and, _Expr, _Expr, _Dom1, _Dom2>, typename __fun<__logical_and, typename _Dom1::value_type>::result_type> operator &&(const _Expr<_Dom1, typename _Dom1::value_type>& __v, const _Expr<_Dom2, typename _Dom2::value_type>& __w) { typedef typename _Dom1::value_type _Arg; typedef typename __fun<__logical_and, _Arg>::result_type _Value; typedef _BinClos<__logical_and, _Expr, _Expr, _Dom1, _Dom2> _Closure; return _Expr<_Closure, _Value>(_Closure(__v(), __w())); } template<class _Dom> inline _Expr<_BinClos<__logical_and, _Expr, _Constant, _Dom, typename _Dom::value_type>, typename __fun<__logical_and, typename _Dom::value_type>::result_type> operator &&(const _Expr<_Dom, typename _Dom::value_type>& __v, const typename _Dom::value_type& __t) { typedef typename _Dom::value_type _Arg; typedef typename __fun<__logical_and, _Arg>::result_type _Value; typedef _BinClos<__logical_and, _Expr, _Constant, _Dom, _Arg> _Closure; return _Expr<_Closure, _Value>(_Closure(__v(), __t)); } template<class _Dom> inline _Expr<_BinClos<__logical_and, _Constant, _Expr, typename _Dom::value_type, _Dom>, typename __fun<__logical_and, typename _Dom::value_type>::result_type> operator &&(const typename _Dom::value_type& __t, const _Expr<_Dom, typename _Dom::value_type>& __v) { typedef typename _Dom::value_type _Arg; typedef typename __fun<__logical_and, _Arg>::result_type _Value; typedef _BinClos<__logical_and, _Constant, _Expr, _Arg, _Dom> _Closure; return _Expr<_Closure, _Value>(_Closure(__t, __v())); } template<class _Dom> inline _Expr<_BinClos<__logical_and, _Expr, _ValArray, _Dom, typename _Dom::value_type>, typename __fun<__logical_and, typename _Dom::value_type>::result_type> operator &&(const _Expr<_Dom,typename _Dom::value_type>& __e, const valarray<typename _Dom::value_type>& __v) { typedef typename _Dom::value_type _Arg; typedef typename __fun<__logical_and, _Arg>::result_type _Value; typedef _BinClos<__logical_and, _Expr, _ValArray, _Dom, _Arg> _Closure; return _Expr<_Closure, _Value>(_Closure(__e(), __v)); } template<class _Dom> inline _Expr<_BinClos<__logical_and, _ValArray, _Expr, typename _Dom::value_type, _Dom>, typename __fun<__logical_and, typename _Dom::value_type>::result_type> operator &&(const valarray<typename _Dom::value_type>& __v, const _Expr<_Dom, typename _Dom::value_type>& __e) { typedef typename _Dom::value_type _Tp; typedef typename __fun<__logical_and, _Tp>::result_type _Value; typedef _BinClos<__logical_and, _ValArray, _Expr, _Tp, _Dom> _Closure; return _Expr<_Closure, _Value>(_Closure(__v, __e ())); }
    template<class _Dom1, class _Dom2> inline _Expr<_BinClos<__logical_or, _Expr, _Expr, _Dom1, _Dom2>, typename __fun<__logical_or, typename _Dom1::value_type>::result_type> operator ||(const _Expr<_Dom1, typename _Dom1::value_type>& __v, const _Expr<_Dom2, typename _Dom2::value_type>& __w) { typedef typename _Dom1::value_type _Arg; typedef typename __fun<__logical_or, _Arg>::result_type _Value; typedef _BinClos<__logical_or, _Expr, _Expr, _Dom1, _Dom2> _Closure; return _Expr<_Closure, _Value>(_Closure(__v(), __w())); } template<class _Dom> inline _Expr<_BinClos<__logical_or, _Expr, _Constant, _Dom, typename _Dom::value_type>, typename __fun<__logical_or, typename _Dom::value_type>::result_type> operator ||(const _Expr<_Dom, typename _Dom::value_type>& __v, const typename _Dom::value_type& __t) { typedef typename _Dom::value_type _Arg; typedef typename __fun<__logical_or, _Arg>::result_type _Value; typedef _BinClos<__logical_or, _Expr, _Constant, _Dom, _Arg> _Closure; return _Expr<_Closure, _Value>(_Closure(__v(), __t)); } template<class _Dom> inline _Expr<_BinClos<__logical_or, _Constant, _Expr, typename _Dom::value_type, _Dom>, typename __fun<__logical_or, typename _Dom::value_type>::result_type> operator ||(const typename _Dom::value_type& __t, const _Expr<_Dom, typename _Dom::value_type>& __v) { typedef typename _Dom::value_type _Arg; typedef typename __fun<__logical_or, _Arg>::result_type _Value; typedef _BinClos<__logical_or, _Constant, _Expr, _Arg, _Dom> _Closure; return _Expr<_Closure, _Value>(_Closure(__t, __v())); } template<class _Dom> inline _Expr<_BinClos<__logical_or, _Expr, _ValArray, _Dom, typename _Dom::value_type>, typename __fun<__logical_or, typename _Dom::value_type>::result_type> operator ||(const _Expr<_Dom,typename _Dom::value_type>& __e, const valarray<typename _Dom::value_type>& __v) { typedef typename _Dom::value_type _Arg; typedef typename __fun<__logical_or, _Arg>::result_type _Value; typedef _BinClos<__logical_or, _Expr, _ValArray, _Dom, _Arg> _Closure; return _Expr<_Closure, _Value>(_Closure(__e(), __v)); } template<class _Dom> inline _Expr<_BinClos<__logical_or, _ValArray, _Expr, typename _Dom::value_type, _Dom>, typename __fun<__logical_or, typename _Dom::value_type>::result_type> operator ||(const valarray<typename _Dom::value_type>& __v, const _Expr<_Dom, typename _Dom::value_type>& __e) { typedef typename _Dom::value_type _Tp; typedef typename __fun<__logical_or, _Tp>::result_type _Value; typedef _BinClos<__logical_or, _ValArray, _Expr, _Tp, _Dom> _Closure; return _Expr<_Closure, _Value>(_Closure(__v, __e ())); }
    template<class _Dom1, class _Dom2> inline _Expr<_BinClos<__equal_to, _Expr, _Expr, _Dom1, _Dom2>, typename __fun<__equal_to, typename _Dom1::value_type>::result_type> operator ==(const _Expr<_Dom1, typename _Dom1::value_type>& __v, const _Expr<_Dom2, typename _Dom2::value_type>& __w) { typedef typename _Dom1::value_type _Arg; typedef typename __fun<__equal_to, _Arg>::result_type _Value; typedef _BinClos<__equal_to, _Expr, _Expr, _Dom1, _Dom2> _Closure; return _Expr<_Closure, _Value>(_Closure(__v(), __w())); } template<class _Dom> inline _Expr<_BinClos<__equal_to, _Expr, _Constant, _Dom, typename _Dom::value_type>, typename __fun<__equal_to, typename _Dom::value_type>::result_type> operator ==(const _Expr<_Dom, typename _Dom::value_type>& __v, const typename _Dom::value_type& __t) { typedef typename _Dom::value_type _Arg; typedef typename __fun<__equal_to, _Arg>::result_type _Value; typedef _BinClos<__equal_to, _Expr, _Constant, _Dom, _Arg> _Closure; return _Expr<_Closure, _Value>(_Closure(__v(), __t)); } template<class _Dom> inline _Expr<_BinClos<__equal_to, _Constant, _Expr, typename _Dom::value_type, _Dom>, typename __fun<__equal_to, typename _Dom::value_type>::result_type> operator ==(const typename _Dom::value_type& __t, const _Expr<_Dom, typename _Dom::value_type>& __v) { typedef typename _Dom::value_type _Arg; typedef typename __fun<__equal_to, _Arg>::result_type _Value; typedef _BinClos<__equal_to, _Constant, _Expr, _Arg, _Dom> _Closure; return _Expr<_Closure, _Value>(_Closure(__t, __v())); } template<class _Dom> inline _Expr<_BinClos<__equal_to, _Expr, _ValArray, _Dom, typename _Dom::value_type>, typename __fun<__equal_to, typename _Dom::value_type>::result_type> operator ==(const _Expr<_Dom,typename _Dom::value_type>& __e, const valarray<typename _Dom::value_type>& __v) { typedef typename _Dom::value_type _Arg; typedef typename __fun<__equal_to, _Arg>::result_type _Value; typedef _BinClos<__equal_to, _Expr, _ValArray, _Dom, _Arg> _Closure; return _Expr<_Closure, _Value>(_Closure(__e(), __v)); } template<class _Dom> inline _Expr<_BinClos<__equal_to, _ValArray, _Expr, typename _Dom::value_type, _Dom>, typename __fun<__equal_to, typename _Dom::value_type>::result_type> operator ==(const valarray<typename _Dom::value_type>& __v, const _Expr<_Dom, typename _Dom::value_type>& __e) { typedef typename _Dom::value_type _Tp; typedef typename __fun<__equal_to, _Tp>::result_type _Value; typedef _BinClos<__equal_to, _ValArray, _Expr, _Tp, _Dom> _Closure; return _Expr<_Closure, _Value>(_Closure(__v, __e ())); }
    template<class _Dom1, class _Dom2> inline _Expr<_BinClos<__not_equal_to, _Expr, _Expr, _Dom1, _Dom2>, typename __fun<__not_equal_to, typename _Dom1::value_type>::result_type> operator !=(const _Expr<_Dom1, typename _Dom1::value_type>& __v, const _Expr<_Dom2, typename _Dom2::value_type>& __w) { typedef typename _Dom1::value_type _Arg; typedef typename __fun<__not_equal_to, _Arg>::result_type _Value; typedef _BinClos<__not_equal_to, _Expr, _Expr, _Dom1, _Dom2> _Closure; return _Expr<_Closure, _Value>(_Closure(__v(), __w())); } template<class _Dom> inline _Expr<_BinClos<__not_equal_to, _Expr, _Constant, _Dom, typename _Dom::value_type>, typename __fun<__not_equal_to, typename _Dom::value_type>::result_type> operator !=(const _Expr<_Dom, typename _Dom::value_type>& __v, const typename _Dom::value_type& __t) { typedef typename _Dom::value_type _Arg; typedef typename __fun<__not_equal_to, _Arg>::result_type _Value; typedef _BinClos<__not_equal_to, _Expr, _Constant, _Dom, _Arg> _Closure; return _Expr<_Closure, _Value>(_Closure(__v(), __t)); } template<class _Dom> inline _Expr<_BinClos<__not_equal_to, _Constant, _Expr, typename _Dom::value_type, _Dom>, typename __fun<__not_equal_to, typename _Dom::value_type>::result_type> operator !=(const typename _Dom::value_type& __t, const _Expr<_Dom, typename _Dom::value_type>& __v) { typedef typename _Dom::value_type _Arg; typedef typename __fun<__not_equal_to, _Arg>::result_type _Value; typedef _BinClos<__not_equal_to, _Constant, _Expr, _Arg, _Dom> _Closure; return _Expr<_Closure, _Value>(_Closure(__t, __v())); } template<class _Dom> inline _Expr<_BinClos<__not_equal_to, _Expr, _ValArray, _Dom, typename _Dom::value_type>, typename __fun<__not_equal_to, typename _Dom::value_type>::result_type> operator !=(const _Expr<_Dom,typename _Dom::value_type>& __e, const valarray<typename _Dom::value_type>& __v) { typedef typename _Dom::value_type _Arg; typedef typename __fun<__not_equal_to, _Arg>::result_type _Value; typedef _BinClos<__not_equal_to, _Expr, _ValArray, _Dom, _Arg> _Closure; return _Expr<_Closure, _Value>(_Closure(__e(), __v)); } template<class _Dom> inline _Expr<_BinClos<__not_equal_to, _ValArray, _Expr, typename _Dom::value_type, _Dom>, typename __fun<__not_equal_to, typename _Dom::value_type>::result_type> operator !=(const valarray<typename _Dom::value_type>& __v, const _Expr<_Dom, typename _Dom::value_type>& __e) { typedef typename _Dom::value_type _Tp; typedef typename __fun<__not_equal_to, _Tp>::result_type _Value; typedef _BinClos<__not_equal_to, _ValArray, _Expr, _Tp, _Dom> _Closure; return _Expr<_Closure, _Value>(_Closure(__v, __e ())); }
    template<class _Dom1, class _Dom2> inline _Expr<_BinClos<__less, _Expr, _Expr, _Dom1, _Dom2>, typename __fun<__less, typename _Dom1::value_type>::result_type> operator <(const _Expr<_Dom1, typename _Dom1::value_type>& __v, const _Expr<_Dom2, typename _Dom2::value_type>& __w) { typedef typename _Dom1::value_type _Arg; typedef typename __fun<__less, _Arg>::result_type _Value; typedef _BinClos<__less, _Expr, _Expr, _Dom1, _Dom2> _Closure; return _Expr<_Closure, _Value>(_Closure(__v(), __w())); } template<class _Dom> inline _Expr<_BinClos<__less, _Expr, _Constant, _Dom, typename _Dom::value_type>, typename __fun<__less, typename _Dom::value_type>::result_type> operator <(const _Expr<_Dom, typename _Dom::value_type>& __v, const typename _Dom::value_type& __t) { typedef typename _Dom::value_type _Arg; typedef typename __fun<__less, _Arg>::result_type _Value; typedef _BinClos<__less, _Expr, _Constant, _Dom, _Arg> _Closure; return _Expr<_Closure, _Value>(_Closure(__v(), __t)); } template<class _Dom> inline _Expr<_BinClos<__less, _Constant, _Expr, typename _Dom::value_type, _Dom>, typename __fun<__less, typename _Dom::value_type>::result_type> operator <(const typename _Dom::value_type& __t, const _Expr<_Dom, typename _Dom::value_type>& __v) { typedef typename _Dom::value_type _Arg; typedef typename __fun<__less, _Arg>::result_type _Value; typedef _BinClos<__less, _Constant, _Expr, _Arg, _Dom> _Closure; return _Expr<_Closure, _Value>(_Closure(__t, __v())); } template<class _Dom> inline _Expr<_BinClos<__less, _Expr, _ValArray, _Dom, typename _Dom::value_type>, typename __fun<__less, typename _Dom::value_type>::result_type> operator <(const _Expr<_Dom,typename _Dom::value_type>& __e, const valarray<typename _Dom::value_type>& __v) { typedef typename _Dom::value_type _Arg; typedef typename __fun<__less, _Arg>::result_type _Value; typedef _BinClos<__less, _Expr, _ValArray, _Dom, _Arg> _Closure; return _Expr<_Closure, _Value>(_Closure(__e(), __v)); } template<class _Dom> inline _Expr<_BinClos<__less, _ValArray, _Expr, typename _Dom::value_type, _Dom>, typename __fun<__less, typename _Dom::value_type>::result_type> operator <(const valarray<typename _Dom::value_type>& __v, const _Expr<_Dom, typename _Dom::value_type>& __e) { typedef typename _Dom::value_type _Tp; typedef typename __fun<__less, _Tp>::result_type _Value; typedef _BinClos<__less, _ValArray, _Expr, _Tp, _Dom> _Closure; return _Expr<_Closure, _Value>(_Closure(__v, __e ())); }
    template<class _Dom1, class _Dom2> inline _Expr<_BinClos<__greater, _Expr, _Expr, _Dom1, _Dom2>, typename __fun<__greater, typename _Dom1::value_type>::result_type> operator >(const _Expr<_Dom1, typename _Dom1::value_type>& __v, const _Expr<_Dom2, typename _Dom2::value_type>& __w) { typedef typename _Dom1::value_type _Arg; typedef typename __fun<__greater, _Arg>::result_type _Value; typedef _BinClos<__greater, _Expr, _Expr, _Dom1, _Dom2> _Closure; return _Expr<_Closure, _Value>(_Closure(__v(), __w())); } template<class _Dom> inline _Expr<_BinClos<__greater, _Expr, _Constant, _Dom, typename _Dom::value_type>, typename __fun<__greater, typename _Dom::value_type>::result_type> operator >(const _Expr<_Dom, typename _Dom::value_type>& __v, const typename _Dom::value_type& __t) { typedef typename _Dom::value_type _Arg; typedef typename __fun<__greater, _Arg>::result_type _Value; typedef _BinClos<__greater, _Expr, _Constant, _Dom, _Arg> _Closure; return _Expr<_Closure, _Value>(_Closure(__v(), __t)); } template<class _Dom> inline _Expr<_BinClos<__greater, _Constant, _Expr, typename _Dom::value_type, _Dom>, typename __fun<__greater, typename _Dom::value_type>::result_type> operator >(const typename _Dom::value_type& __t, const _Expr<_Dom, typename _Dom::value_type>& __v) { typedef typename _Dom::value_type _Arg; typedef typename __fun<__greater, _Arg>::result_type _Value; typedef _BinClos<__greater, _Constant, _Expr, _Arg, _Dom> _Closure; return _Expr<_Closure, _Value>(_Closure(__t, __v())); } template<class _Dom> inline _Expr<_BinClos<__greater, _Expr, _ValArray, _Dom, typename _Dom::value_type>, typename __fun<__greater, typename _Dom::value_type>::result_type> operator >(const _Expr<_Dom,typename _Dom::value_type>& __e, const valarray<typename _Dom::value_type>& __v) { typedef typename _Dom::value_type _Arg; typedef typename __fun<__greater, _Arg>::result_type _Value; typedef _BinClos<__greater, _Expr, _ValArray, _Dom, _Arg> _Closure; return _Expr<_Closure, _Value>(_Closure(__e(), __v)); } template<class _Dom> inline _Expr<_BinClos<__greater, _ValArray, _Expr, typename _Dom::value_type, _Dom>, typename __fun<__greater, typename _Dom::value_type>::result_type> operator >(const valarray<typename _Dom::value_type>& __v, const _Expr<_Dom, typename _Dom::value_type>& __e) { typedef typename _Dom::value_type _Tp; typedef typename __fun<__greater, _Tp>::result_type _Value; typedef _BinClos<__greater, _ValArray, _Expr, _Tp, _Dom> _Closure; return _Expr<_Closure, _Value>(_Closure(__v, __e ())); }
    template<class _Dom1, class _Dom2> inline _Expr<_BinClos<__less_equal, _Expr, _Expr, _Dom1, _Dom2>, typename __fun<__less_equal, typename _Dom1::value_type>::result_type> operator <=(const _Expr<_Dom1, typename _Dom1::value_type>& __v, const _Expr<_Dom2, typename _Dom2::value_type>& __w) { typedef typename _Dom1::value_type _Arg; typedef typename __fun<__less_equal, _Arg>::result_type _Value; typedef _BinClos<__less_equal, _Expr, _Expr, _Dom1, _Dom2> _Closure; return _Expr<_Closure, _Value>(_Closure(__v(), __w())); } template<class _Dom> inline _Expr<_BinClos<__less_equal, _Expr, _Constant, _Dom, typename _Dom::value_type>, typename __fun<__less_equal, typename _Dom::value_type>::result_type> operator <=(const _Expr<_Dom, typename _Dom::value_type>& __v, const typename _Dom::value_type& __t) { typedef typename _Dom::value_type _Arg; typedef typename __fun<__less_equal, _Arg>::result_type _Value; typedef _BinClos<__less_equal, _Expr, _Constant, _Dom, _Arg> _Closure; return _Expr<_Closure, _Value>(_Closure(__v(), __t)); } template<class _Dom> inline _Expr<_BinClos<__less_equal, _Constant, _Expr, typename _Dom::value_type, _Dom>, typename __fun<__less_equal, typename _Dom::value_type>::result_type> operator <=(const typename _Dom::value_type& __t, const _Expr<_Dom, typename _Dom::value_type>& __v) { typedef typename _Dom::value_type _Arg; typedef typename __fun<__less_equal, _Arg>::result_type _Value; typedef _BinClos<__less_equal, _Constant, _Expr, _Arg, _Dom> _Closure; return _Expr<_Closure, _Value>(_Closure(__t, __v())); } template<class _Dom> inline _Expr<_BinClos<__less_equal, _Expr, _ValArray, _Dom, typename _Dom::value_type>, typename __fun<__less_equal, typename _Dom::value_type>::result_type> operator <=(const _Expr<_Dom,typename _Dom::value_type>& __e, const valarray<typename _Dom::value_type>& __v) { typedef typename _Dom::value_type _Arg; typedef typename __fun<__less_equal, _Arg>::result_type _Value; typedef _BinClos<__less_equal, _Expr, _ValArray, _Dom, _Arg> _Closure; return _Expr<_Closure, _Value>(_Closure(__e(), __v)); } template<class _Dom> inline _Expr<_BinClos<__less_equal, _ValArray, _Expr, typename _Dom::value_type, _Dom>, typename __fun<__less_equal, typename _Dom::value_type>::result_type> operator <=(const valarray<typename _Dom::value_type>& __v, const _Expr<_Dom, typename _Dom::value_type>& __e) { typedef typename _Dom::value_type _Tp; typedef typename __fun<__less_equal, _Tp>::result_type _Value; typedef _BinClos<__less_equal, _ValArray, _Expr, _Tp, _Dom> _Closure; return _Expr<_Closure, _Value>(_Closure(__v, __e ())); }
    template<class _Dom1, class _Dom2> inline _Expr<_BinClos<__greater_equal, _Expr, _Expr, _Dom1, _Dom2>, typename __fun<__greater_equal, typename _Dom1::value_type>::result_type> operator >=(const _Expr<_Dom1, typename _Dom1::value_type>& __v, const _Expr<_Dom2, typename _Dom2::value_type>& __w) { typedef typename _Dom1::value_type _Arg; typedef typename __fun<__greater_equal, _Arg>::result_type _Value; typedef _BinClos<__greater_equal, _Expr, _Expr, _Dom1, _Dom2> _Closure; return _Expr<_Closure, _Value>(_Closure(__v(), __w())); } template<class _Dom> inline _Expr<_BinClos<__greater_equal, _Expr, _Constant, _Dom, typename _Dom::value_type>, typename __fun<__greater_equal, typename _Dom::value_type>::result_type> operator >=(const _Expr<_Dom, typename _Dom::value_type>& __v, const typename _Dom::value_type& __t) { typedef typename _Dom::value_type _Arg; typedef typename __fun<__greater_equal, _Arg>::result_type _Value; typedef _BinClos<__greater_equal, _Expr, _Constant, _Dom, _Arg> _Closure; return _Expr<_Closure, _Value>(_Closure(__v(), __t)); } template<class _Dom> inline _Expr<_BinClos<__greater_equal, _Constant, _Expr, typename _Dom::value_type, _Dom>, typename __fun<__greater_equal, typename _Dom::value_type>::result_type> operator >=(const typename _Dom::value_type& __t, const _Expr<_Dom, typename _Dom::value_type>& __v) { typedef typename _Dom::value_type _Arg; typedef typename __fun<__greater_equal, _Arg>::result_type _Value; typedef _BinClos<__greater_equal, _Constant, _Expr, _Arg, _Dom> _Closure; return _Expr<_Closure, _Value>(_Closure(__t, __v())); } template<class _Dom> inline _Expr<_BinClos<__greater_equal, _Expr, _ValArray, _Dom, typename _Dom::value_type>, typename __fun<__greater_equal, typename _Dom::value_type>::result_type> operator >=(const _Expr<_Dom,typename _Dom::value_type>& __e, const valarray<typename _Dom::value_type>& __v) { typedef typename _Dom::value_type _Arg; typedef typename __fun<__greater_equal, _Arg>::result_type _Value; typedef _BinClos<__greater_equal, _Expr, _ValArray, _Dom, _Arg> _Closure; return _Expr<_Closure, _Value>(_Closure(__e(), __v)); } template<class _Dom> inline _Expr<_BinClos<__greater_equal, _ValArray, _Expr, typename _Dom::value_type, _Dom>, typename __fun<__greater_equal, typename _Dom::value_type>::result_type> operator >=(const valarray<typename _Dom::value_type>& __v, const _Expr<_Dom, typename _Dom::value_type>& __e) { typedef typename _Dom::value_type _Tp; typedef typename __fun<__greater_equal, _Tp>::result_type _Value; typedef _BinClos<__greater_equal, _ValArray, _Expr, _Tp, _Dom> _Closure; return _Expr<_Closure, _Value>(_Closure(__v, __e ())); }
    template<class _Dom> inline _Expr<_UnClos<__abs, _Expr, _Dom>, typename _Dom::value_type> abs(const _Expr<_Dom, typename _Dom::value_type>& __e) { typedef typename _Dom::value_type _Tp; typedef _UnClos<__abs, _Expr, _Dom> _Closure; return _Expr<_Closure, _Tp>(_Closure(__e())); } template<typename _Tp> inline _Expr<_UnClos<__abs, _ValArray, _Tp>, _Tp> abs(const valarray<_Tp>& __v) { typedef _UnClos<__abs, _ValArray, _Tp> _Closure; return _Expr<_Closure, _Tp>(_Closure(__v)); }
    template<class _Dom> inline _Expr<_UnClos<__cos, _Expr, _Dom>, typename _Dom::value_type> cos(const _Expr<_Dom, typename _Dom::value_type>& __e) { typedef typename _Dom::value_type _Tp; typedef _UnClos<__cos, _Expr, _Dom> _Closure; return _Expr<_Closure, _Tp>(_Closure(__e())); } template<typename _Tp> inline _Expr<_UnClos<__cos, _ValArray, _Tp>, _Tp> cos(const valarray<_Tp>& __v) { typedef _UnClos<__cos, _ValArray, _Tp> _Closure; return _Expr<_Closure, _Tp>(_Closure(__v)); }
    template<class _Dom> inline _Expr<_UnClos<__acos, _Expr, _Dom>, typename _Dom::value_type> acos(const _Expr<_Dom, typename _Dom::value_type>& __e) { typedef typename _Dom::value_type _Tp; typedef _UnClos<__acos, _Expr, _Dom> _Closure; return _Expr<_Closure, _Tp>(_Closure(__e())); } template<typename _Tp> inline _Expr<_UnClos<__acos, _ValArray, _Tp>, _Tp> acos(const valarray<_Tp>& __v) { typedef _UnClos<__acos, _ValArray, _Tp> _Closure; return _Expr<_Closure, _Tp>(_Closure(__v)); }
    template<class _Dom> inline _Expr<_UnClos<__cosh, _Expr, _Dom>, typename _Dom::value_type> cosh(const _Expr<_Dom, typename _Dom::value_type>& __e) { typedef typename _Dom::value_type _Tp; typedef _UnClos<__cosh, _Expr, _Dom> _Closure; return _Expr<_Closure, _Tp>(_Closure(__e())); } template<typename _Tp> inline _Expr<_UnClos<__cosh, _ValArray, _Tp>, _Tp> cosh(const valarray<_Tp>& __v) { typedef _UnClos<__cosh, _ValArray, _Tp> _Closure; return _Expr<_Closure, _Tp>(_Closure(__v)); }
    template<class _Dom> inline _Expr<_UnClos<__sin, _Expr, _Dom>, typename _Dom::value_type> sin(const _Expr<_Dom, typename _Dom::value_type>& __e) { typedef typename _Dom::value_type _Tp; typedef _UnClos<__sin, _Expr, _Dom> _Closure; return _Expr<_Closure, _Tp>(_Closure(__e())); } template<typename _Tp> inline _Expr<_UnClos<__sin, _ValArray, _Tp>, _Tp> sin(const valarray<_Tp>& __v) { typedef _UnClos<__sin, _ValArray, _Tp> _Closure; return _Expr<_Closure, _Tp>(_Closure(__v)); }
    template<class _Dom> inline _Expr<_UnClos<__asin, _Expr, _Dom>, typename _Dom::value_type> asin(const _Expr<_Dom, typename _Dom::value_type>& __e) { typedef typename _Dom::value_type _Tp; typedef _UnClos<__asin, _Expr, _Dom> _Closure; return _Expr<_Closure, _Tp>(_Closure(__e())); } template<typename _Tp> inline _Expr<_UnClos<__asin, _ValArray, _Tp>, _Tp> asin(const valarray<_Tp>& __v) { typedef _UnClos<__asin, _ValArray, _Tp> _Closure; return _Expr<_Closure, _Tp>(_Closure(__v)); }
    template<class _Dom> inline _Expr<_UnClos<__sinh, _Expr, _Dom>, typename _Dom::value_type> sinh(const _Expr<_Dom, typename _Dom::value_type>& __e) { typedef typename _Dom::value_type _Tp; typedef _UnClos<__sinh, _Expr, _Dom> _Closure; return _Expr<_Closure, _Tp>(_Closure(__e())); } template<typename _Tp> inline _Expr<_UnClos<__sinh, _ValArray, _Tp>, _Tp> sinh(const valarray<_Tp>& __v) { typedef _UnClos<__sinh, _ValArray, _Tp> _Closure; return _Expr<_Closure, _Tp>(_Closure(__v)); }
    template<class _Dom> inline _Expr<_UnClos<__tan, _Expr, _Dom>, typename _Dom::value_type> tan(const _Expr<_Dom, typename _Dom::value_type>& __e) { typedef typename _Dom::value_type _Tp; typedef _UnClos<__tan, _Expr, _Dom> _Closure; return _Expr<_Closure, _Tp>(_Closure(__e())); } template<typename _Tp> inline _Expr<_UnClos<__tan, _ValArray, _Tp>, _Tp> tan(const valarray<_Tp>& __v) { typedef _UnClos<__tan, _ValArray, _Tp> _Closure; return _Expr<_Closure, _Tp>(_Closure(__v)); }
    template<class _Dom> inline _Expr<_UnClos<__tanh, _Expr, _Dom>, typename _Dom::value_type> tanh(const _Expr<_Dom, typename _Dom::value_type>& __e) { typedef typename _Dom::value_type _Tp; typedef _UnClos<__tanh, _Expr, _Dom> _Closure; return _Expr<_Closure, _Tp>(_Closure(__e())); } template<typename _Tp> inline _Expr<_UnClos<__tanh, _ValArray, _Tp>, _Tp> tanh(const valarray<_Tp>& __v) { typedef _UnClos<__tanh, _ValArray, _Tp> _Closure; return _Expr<_Closure, _Tp>(_Closure(__v)); }
    template<class _Dom> inline _Expr<_UnClos<__atan, _Expr, _Dom>, typename _Dom::value_type> atan(const _Expr<_Dom, typename _Dom::value_type>& __e) { typedef typename _Dom::value_type _Tp; typedef _UnClos<__atan, _Expr, _Dom> _Closure; return _Expr<_Closure, _Tp>(_Closure(__e())); } template<typename _Tp> inline _Expr<_UnClos<__atan, _ValArray, _Tp>, _Tp> atan(const valarray<_Tp>& __v) { typedef _UnClos<__atan, _ValArray, _Tp> _Closure; return _Expr<_Closure, _Tp>(_Closure(__v)); }
    template<class _Dom> inline _Expr<_UnClos<__exp, _Expr, _Dom>, typename _Dom::value_type> exp(const _Expr<_Dom, typename _Dom::value_type>& __e) { typedef typename _Dom::value_type _Tp; typedef _UnClos<__exp, _Expr, _Dom> _Closure; return _Expr<_Closure, _Tp>(_Closure(__e())); } template<typename _Tp> inline _Expr<_UnClos<__exp, _ValArray, _Tp>, _Tp> exp(const valarray<_Tp>& __v) { typedef _UnClos<__exp, _ValArray, _Tp> _Closure; return _Expr<_Closure, _Tp>(_Closure(__v)); }
    template<class _Dom> inline _Expr<_UnClos<__log, _Expr, _Dom>, typename _Dom::value_type> log(const _Expr<_Dom, typename _Dom::value_type>& __e) { typedef typename _Dom::value_type _Tp; typedef _UnClos<__log, _Expr, _Dom> _Closure; return _Expr<_Closure, _Tp>(_Closure(__e())); } template<typename _Tp> inline _Expr<_UnClos<__log, _ValArray, _Tp>, _Tp> log(const valarray<_Tp>& __v) { typedef _UnClos<__log, _ValArray, _Tp> _Closure; return _Expr<_Closure, _Tp>(_Closure(__v)); }
    template<class _Dom> inline _Expr<_UnClos<__log10, _Expr, _Dom>, typename _Dom::value_type> log10(const _Expr<_Dom, typename _Dom::value_type>& __e) { typedef typename _Dom::value_type _Tp; typedef _UnClos<__log10, _Expr, _Dom> _Closure; return _Expr<_Closure, _Tp>(_Closure(__e())); } template<typename _Tp> inline _Expr<_UnClos<__log10, _ValArray, _Tp>, _Tp> log10(const valarray<_Tp>& __v) { typedef _UnClos<__log10, _ValArray, _Tp> _Closure; return _Expr<_Closure, _Tp>(_Closure(__v)); }
    template<class _Dom> inline _Expr<_UnClos<__sqrt, _Expr, _Dom>, typename _Dom::value_type> sqrt(const _Expr<_Dom, typename _Dom::value_type>& __e) { typedef typename _Dom::value_type _Tp; typedef _UnClos<__sqrt, _Expr, _Dom> _Closure; return _Expr<_Closure, _Tp>(_Closure(__e())); } template<typename _Tp> inline _Expr<_UnClos<__sqrt, _ValArray, _Tp>, _Tp> sqrt(const valarray<_Tp>& __v) { typedef _UnClos<__sqrt, _ValArray, _Tp> _Closure; return _Expr<_Closure, _Tp>(_Closure(__v)); }
template<class _Dom1, class _Dom2> inline _Expr<_BinClos<__atan2, _Expr, _Expr, _Dom1, _Dom2>, typename _Dom1::value_type> atan2(const _Expr<_Dom1, typename _Dom1::value_type>& __e1, const _Expr<_Dom2, typename _Dom2::value_type>& __e2) { typedef typename _Dom1::value_type _Tp; typedef _BinClos<__atan2, _Expr, _Expr, _Dom1, _Dom2> _Closure; return _Expr<_Closure, _Tp>(_Closure(__e1(), __e2())); } template<class _Dom> inline _Expr<_BinClos<__atan2, _Expr, _ValArray, _Dom, typename _Dom::value_type>, typename _Dom::value_type> atan2(const _Expr<_Dom, typename _Dom::value_type>& __e, const valarray<typename _Dom::value_type>& __v) { typedef typename _Dom::value_type _Tp; typedef _BinClos<__atan2, _Expr, _ValArray, _Dom, _Tp> _Closure; return _Expr<_Closure, _Tp>(_Closure(__e(), __v)); } template<class _Dom> inline _Expr<_BinClos<__atan2, _ValArray, _Expr, typename _Dom::value_type, _Dom>, typename _Dom::value_type> atan2(const valarray<typename _Dom::valarray>& __v, const _Expr<_Dom, typename _Dom::value_type>& __e) { typedef typename _Dom::value_type _Tp; typedef _BinClos<__atan2, _ValArray, _Expr, _Tp, _Dom> _Closure; return _Expr<_Closure, _Tp>(_Closure(__v, __e())); } template<class _Dom> inline _Expr<_BinClos<__atan2, _Expr, _Constant, _Dom, typename _Dom::value_type>, typename _Dom::value_type> atan2(const _Expr<_Dom, typename _Dom::value_type>& __e, const typename _Dom::value_type& __t) { typedef typename _Dom::value_type _Tp; typedef _BinClos<__atan2, _Expr, _Constant, _Dom, _Tp> _Closure; return _Expr<_Closure, _Tp>(_Closure(__e(), __t)); } template<class _Dom> inline _Expr<_BinClos<__atan2, _Constant, _Expr, typename _Dom::value_type, _Dom>, typename _Dom::value_type> atan2(const typename _Dom::value_type& __t, const _Expr<_Dom, typename _Dom::value_type>& __e) { typedef typename _Dom::value_type _Tp; typedef _BinClos<__atan2, _Constant, _Expr, _Tp, _Dom> _Closure; return _Expr<_Closure, _Tp>(_Closure(__t, __e())); } template<typename _Tp> inline _Expr<_BinClos<__atan2, _ValArray, _ValArray, _Tp, _Tp>, _Tp> atan2(const valarray<_Tp>& __v, const valarray<_Tp>& __w) { typedef _BinClos<__atan2, _ValArray, _ValArray, _Tp, _Tp> _Closure; return _Expr<_Closure, _Tp>(_Closure(__v, __w)); } template<typename _Tp> inline _Expr<_BinClos<__atan2, _ValArray, _Constant, _Tp, _Tp>, _Tp> atan2(const valarray<_Tp>& __v, const _Tp& __t) { typedef _BinClos<__atan2, _ValArray, _Constant, _Tp, _Tp> _Closure; return _Expr<_Closure, _Tp>(_Closure(__v, __t)); } template<typename _Tp> inline _Expr<_BinClos<__atan2, _Constant, _ValArray, _Tp, _Tp>, _Tp> atan2(const _Tp& __t, const valarray<_Tp>& __v) { typedef _BinClos<__atan2, _Constant, _ValArray, _Tp, _Tp> _Closure; return _Expr<_Closure, _Tp>(_Closure(__t, __v)); }
template<class _Dom1, class _Dom2> inline _Expr<_BinClos<__pow, _Expr, _Expr, _Dom1, _Dom2>, typename _Dom1::value_type> pow(const _Expr<_Dom1, typename _Dom1::value_type>& __e1, const _Expr<_Dom2, typename _Dom2::value_type>& __e2) { typedef typename _Dom1::value_type _Tp; typedef _BinClos<__pow, _Expr, _Expr, _Dom1, _Dom2> _Closure; return _Expr<_Closure, _Tp>(_Closure(__e1(), __e2())); } template<class _Dom> inline _Expr<_BinClos<__pow, _Expr, _ValArray, _Dom, typename _Dom::value_type>, typename _Dom::value_type> pow(const _Expr<_Dom, typename _Dom::value_type>& __e, const valarray<typename _Dom::value_type>& __v) { typedef typename _Dom::value_type _Tp; typedef _BinClos<__pow, _Expr, _ValArray, _Dom, _Tp> _Closure; return _Expr<_Closure, _Tp>(_Closure(__e(), __v)); } template<class _Dom> inline _Expr<_BinClos<__pow, _ValArray, _Expr, typename _Dom::value_type, _Dom>, typename _Dom::value_type> pow(const valarray<typename _Dom::valarray>& __v, const _Expr<_Dom, typename _Dom::value_type>& __e) { typedef typename _Dom::value_type _Tp; typedef _BinClos<__pow, _ValArray, _Expr, _Tp, _Dom> _Closure; return _Expr<_Closure, _Tp>(_Closure(__v, __e())); } template<class _Dom> inline _Expr<_BinClos<__pow, _Expr, _Constant, _Dom, typename _Dom::value_type>, typename _Dom::value_type> pow(const _Expr<_Dom, typename _Dom::value_type>& __e, const typename _Dom::value_type& __t) { typedef typename _Dom::value_type _Tp; typedef _BinClos<__pow, _Expr, _Constant, _Dom, _Tp> _Closure; return _Expr<_Closure, _Tp>(_Closure(__e(), __t)); } template<class _Dom> inline _Expr<_BinClos<__pow, _Constant, _Expr, typename _Dom::value_type, _Dom>, typename _Dom::value_type> pow(const typename _Dom::value_type& __t, const _Expr<_Dom, typename _Dom::value_type>& __e) { typedef typename _Dom::value_type _Tp; typedef _BinClos<__pow, _Constant, _Expr, _Tp, _Dom> _Closure; return _Expr<_Closure, _Tp>(_Closure(__t, __e())); } template<typename _Tp> inline _Expr<_BinClos<__pow, _ValArray, _ValArray, _Tp, _Tp>, _Tp> pow(const valarray<_Tp>& __v, const valarray<_Tp>& __w) { typedef _BinClos<__pow, _ValArray, _ValArray, _Tp, _Tp> _Closure; return _Expr<_Closure, _Tp>(_Closure(__v, __w)); } template<typename _Tp> inline _Expr<_BinClos<__pow, _ValArray, _Constant, _Tp, _Tp>, _Tp> pow(const valarray<_Tp>& __v, const _Tp& __t) { typedef _BinClos<__pow, _ValArray, _Constant, _Tp, _Tp> _Closure; return _Expr<_Closure, _Tp>(_Closure(__v, __t)); } template<typename _Tp> inline _Expr<_BinClos<__pow, _Constant, _ValArray, _Tp, _Tp>, _Tp> pow(const _Tp& __t, const valarray<_Tp>& __v) { typedef _BinClos<__pow, _Constant, _ValArray, _Tp, _Tp> _Closure; return _Expr<_Closure, _Tp>(_Closure(__t, __v)); }
}
namespace std
{
  class gslice
  {
  public:
    gslice ();
    gslice(size_t, const valarray<size_t>&, const valarray<size_t>&);
    gslice(const gslice&);
    ~gslice();
    gslice& operator=(const gslice&);
    size_t start() const;
    valarray<size_t> size() const;
    valarray<size_t> stride() const;
  private:
    struct _Indexer
    {
      size_t _M_count;
      size_t _M_start;
      valarray<size_t> _M_size;
      valarray<size_t> _M_stride;
      valarray<size_t> _M_index;
      _Indexer(size_t, const valarray<size_t>&,
        const valarray<size_t>&);
      void
      _M_increment_use()
      { ++_M_count; }
      size_t
      _M_decrement_use()
      { return --_M_count; }
    };
    _Indexer* _M_index;
    template<typename _Tp> friend class valarray;
  };
  inline size_t
  gslice::start () const
  { return _M_index ? _M_index->_M_start : 0; }
  inline valarray<size_t>
  gslice::size () const
  { return _M_index ? _M_index->_M_size : valarray<size_t>(); }
  inline valarray<size_t>
  gslice::stride () const
  { return _M_index ? _M_index->_M_stride : valarray<size_t>(); }
  inline gslice::gslice () : _M_index(0) {}
  inline
  gslice::gslice(size_t __o, const valarray<size_t>& __l,
   const valarray<size_t>& __s)
  : _M_index(new gslice::_Indexer(__o, __l, __s)) {}
  inline
  gslice::gslice(const gslice& __g) : _M_index(__g._M_index)
  { if (_M_index) _M_index->_M_increment_use(); }
  inline
  gslice::~gslice()
  {
    if (_M_index && _M_index->_M_decrement_use() == 0)
      delete _M_index;
  }
  inline gslice&
  gslice::operator= (const gslice& __g)
  {
    if (__g._M_index)
      __g._M_index->_M_increment_use();
    if (_M_index && _M_index->_M_decrement_use() == 0)
      delete _M_index;
    _M_index = __g._M_index;
    return *this;
  }
}
namespace std
{
  template<typename _Tp>
    class gslice_array
    {
    public:
      typedef _Tp value_type;
      gslice_array(const gslice_array&);
      gslice_array& operator=(const gslice_array&);
      void operator=(const valarray<_Tp>&) const;
      void operator*=(const valarray<_Tp>&) const;
      void operator/=(const valarray<_Tp>&) const;
      void operator%=(const valarray<_Tp>&) const;
      void operator+=(const valarray<_Tp>&) const;
      void operator-=(const valarray<_Tp>&) const;
      void operator^=(const valarray<_Tp>&) const;
      void operator&=(const valarray<_Tp>&) const;
      void operator|=(const valarray<_Tp>&) const;
      void operator<<=(const valarray<_Tp>&) const;
      void operator>>=(const valarray<_Tp>&) const;
      void operator=(const _Tp&) const;
      template<class _Dom>
        void operator=(const _Expr<_Dom, _Tp>&) const;
      template<class _Dom>
        void operator*=(const _Expr<_Dom, _Tp>&) const;
      template<class _Dom>
        void operator/=(const _Expr<_Dom, _Tp>&) const;
      template<class _Dom>
        void operator%=(const _Expr<_Dom, _Tp>&) const;
      template<class _Dom>
        void operator+=(const _Expr<_Dom, _Tp>&) const;
      template<class _Dom>
        void operator-=(const _Expr<_Dom, _Tp>&) const;
      template<class _Dom>
        void operator^=(const _Expr<_Dom, _Tp>&) const;
      template<class _Dom>
        void operator&=(const _Expr<_Dom, _Tp>&) const;
      template<class _Dom>
        void operator|=(const _Expr<_Dom, _Tp>&) const;
      template<class _Dom>
        void operator<<=(const _Expr<_Dom, _Tp>&) const;
      template<class _Dom>
        void operator>>=(const _Expr<_Dom, _Tp>&) const;
    private:
      _Array<_Tp> _M_array;
      const valarray<size_t>& _M_index;
      friend class valarray<_Tp>;
      gslice_array(_Array<_Tp>, const valarray<size_t>&);
      gslice_array();
    };
  template<typename _Tp>
    inline
    gslice_array<_Tp>::gslice_array(_Array<_Tp> __a,
        const valarray<size_t>& __i)
    : _M_array(__a), _M_index(__i) {}
  template<typename _Tp>
    inline
    gslice_array<_Tp>::gslice_array(const gslice_array<_Tp>& __a)
    : _M_array(__a._M_array), _M_index(__a._M_index) {}
  template<typename _Tp>
    inline gslice_array<_Tp>&
    gslice_array<_Tp>::operator=(const gslice_array<_Tp>& __a)
    {
      std::__valarray_copy(_Array<_Tp>(__a._M_array),
      _Array<size_t>(__a._M_index), _M_index.size(),
      _M_array, _Array<size_t>(_M_index));
      return *this;
    }
  template<typename _Tp>
    inline void
    gslice_array<_Tp>::operator=(const _Tp& __t) const
    {
      std::__valarray_fill(_M_array, _Array<size_t>(_M_index),
      _M_index.size(), __t);
    }
  template<typename _Tp>
    inline void
    gslice_array<_Tp>::operator=(const valarray<_Tp>& __v) const
    {
      std::__valarray_copy(_Array<_Tp>(__v), __v.size(),
      _M_array, _Array<size_t>(_M_index));
    }
  template<typename _Tp>
    template<class _Dom>
      inline void
      gslice_array<_Tp>::operator=(const _Expr<_Dom, _Tp>& __e) const
      {
 std::__valarray_copy (__e, _M_index.size(), _M_array,
         _Array<size_t>(_M_index));
      }
template<typename _Tp> inline void gslice_array<_Tp>::operator *=(const valarray<_Tp>& __v) const { _Array_augmented___multiplies(_M_array, _Array<size_t>(_M_index), _Array<_Tp>(__v), __v.size()); } template<typename _Tp> template<class _Dom> inline void gslice_array<_Tp>::operator *= (const _Expr<_Dom, _Tp>& __e) const { _Array_augmented___multiplies(_M_array, _Array<size_t>(_M_index), __e, _M_index.size()); }
template<typename _Tp> inline void gslice_array<_Tp>::operator /=(const valarray<_Tp>& __v) const { _Array_augmented___divides(_M_array, _Array<size_t>(_M_index), _Array<_Tp>(__v), __v.size()); } template<typename _Tp> template<class _Dom> inline void gslice_array<_Tp>::operator /= (const _Expr<_Dom, _Tp>& __e) const { _Array_augmented___divides(_M_array, _Array<size_t>(_M_index), __e, _M_index.size()); }
template<typename _Tp> inline void gslice_array<_Tp>::operator %=(const valarray<_Tp>& __v) const { _Array_augmented___modulus(_M_array, _Array<size_t>(_M_index), _Array<_Tp>(__v), __v.size()); } template<typename _Tp> template<class _Dom> inline void gslice_array<_Tp>::operator %= (const _Expr<_Dom, _Tp>& __e) const { _Array_augmented___modulus(_M_array, _Array<size_t>(_M_index), __e, _M_index.size()); }
template<typename _Tp> inline void gslice_array<_Tp>::operator +=(const valarray<_Tp>& __v) const { _Array_augmented___plus(_M_array, _Array<size_t>(_M_index), _Array<_Tp>(__v), __v.size()); } template<typename _Tp> template<class _Dom> inline void gslice_array<_Tp>::operator += (const _Expr<_Dom, _Tp>& __e) const { _Array_augmented___plus(_M_array, _Array<size_t>(_M_index), __e, _M_index.size()); }
template<typename _Tp> inline void gslice_array<_Tp>::operator -=(const valarray<_Tp>& __v) const { _Array_augmented___minus(_M_array, _Array<size_t>(_M_index), _Array<_Tp>(__v), __v.size()); } template<typename _Tp> template<class _Dom> inline void gslice_array<_Tp>::operator -= (const _Expr<_Dom, _Tp>& __e) const { _Array_augmented___minus(_M_array, _Array<size_t>(_M_index), __e, _M_index.size()); }
template<typename _Tp> inline void gslice_array<_Tp>::operator ^=(const valarray<_Tp>& __v) const { _Array_augmented___bitwise_xor(_M_array, _Array<size_t>(_M_index), _Array<_Tp>(__v), __v.size()); } template<typename _Tp> template<class _Dom> inline void gslice_array<_Tp>::operator ^= (const _Expr<_Dom, _Tp>& __e) const { _Array_augmented___bitwise_xor(_M_array, _Array<size_t>(_M_index), __e, _M_index.size()); }
template<typename _Tp> inline void gslice_array<_Tp>::operator &=(const valarray<_Tp>& __v) const { _Array_augmented___bitwise_and(_M_array, _Array<size_t>(_M_index), _Array<_Tp>(__v), __v.size()); } template<typename _Tp> template<class _Dom> inline void gslice_array<_Tp>::operator &= (const _Expr<_Dom, _Tp>& __e) const { _Array_augmented___bitwise_and(_M_array, _Array<size_t>(_M_index), __e, _M_index.size()); }
template<typename _Tp> inline void gslice_array<_Tp>::operator |=(const valarray<_Tp>& __v) const { _Array_augmented___bitwise_or(_M_array, _Array<size_t>(_M_index), _Array<_Tp>(__v), __v.size()); } template<typename _Tp> template<class _Dom> inline void gslice_array<_Tp>::operator |= (const _Expr<_Dom, _Tp>& __e) const { _Array_augmented___bitwise_or(_M_array, _Array<size_t>(_M_index), __e, _M_index.size()); }
template<typename _Tp> inline void gslice_array<_Tp>::operator <<=(const valarray<_Tp>& __v) const { _Array_augmented___shift_left(_M_array, _Array<size_t>(_M_index), _Array<_Tp>(__v), __v.size()); } template<typename _Tp> template<class _Dom> inline void gslice_array<_Tp>::operator <<= (const _Expr<_Dom, _Tp>& __e) const { _Array_augmented___shift_left(_M_array, _Array<size_t>(_M_index), __e, _M_index.size()); }
template<typename _Tp> inline void gslice_array<_Tp>::operator >>=(const valarray<_Tp>& __v) const { _Array_augmented___shift_right(_M_array, _Array<size_t>(_M_index), _Array<_Tp>(__v), __v.size()); } template<typename _Tp> template<class _Dom> inline void gslice_array<_Tp>::operator >>= (const _Expr<_Dom, _Tp>& __e) const { _Array_augmented___shift_right(_M_array, _Array<size_t>(_M_index), __e, _M_index.size()); }
}
namespace std
{
  template <class _Tp>
    class mask_array
    {
    public:
      typedef _Tp value_type;
      mask_array (const mask_array&);
      mask_array& operator=(const mask_array&);
      void operator=(const valarray<_Tp>&) const;
      void operator*=(const valarray<_Tp>&) const;
      void operator/=(const valarray<_Tp>&) const;
      void operator%=(const valarray<_Tp>&) const;
      void operator+=(const valarray<_Tp>&) const;
      void operator-=(const valarray<_Tp>&) const;
      void operator^=(const valarray<_Tp>&) const;
      void operator&=(const valarray<_Tp>&) const;
      void operator|=(const valarray<_Tp>&) const;
      void operator<<=(const valarray<_Tp>&) const;
      void operator>>=(const valarray<_Tp>&) const;
      void operator=(const _Tp&) const;
      template<class _Dom>
        void operator=(const _Expr<_Dom,_Tp>&) const;
      template<class _Dom>
        void operator*=(const _Expr<_Dom,_Tp>&) const;
      template<class _Dom>
        void operator/=(const _Expr<_Dom,_Tp>&) const;
      template<class _Dom>
        void operator%=(const _Expr<_Dom,_Tp>&) const;
      template<class _Dom>
        void operator+=(const _Expr<_Dom,_Tp>&) const;
      template<class _Dom>
        void operator-=(const _Expr<_Dom,_Tp>&) const;
      template<class _Dom>
        void operator^=(const _Expr<_Dom,_Tp>&) const;
      template<class _Dom>
        void operator&=(const _Expr<_Dom,_Tp>&) const;
      template<class _Dom>
        void operator|=(const _Expr<_Dom,_Tp>&) const;
      template<class _Dom>
        void operator<<=(const _Expr<_Dom,_Tp>&) const;
      template<class _Dom>
        void operator>>=(const _Expr<_Dom,_Tp>&) const;
    private:
      mask_array(_Array<_Tp>, size_t, _Array<bool>);
      friend class valarray<_Tp>;
      const size_t _M_sz;
      const _Array<bool> _M_mask;
      const _Array<_Tp> _M_array;
      mask_array();
    };
  template<typename _Tp>
    inline mask_array<_Tp>::mask_array(const mask_array<_Tp>& a)
    : _M_sz(a._M_sz), _M_mask(a._M_mask), _M_array(a._M_array) {}
  template<typename _Tp>
    inline
    mask_array<_Tp>::mask_array(_Array<_Tp> __a, size_t __s, _Array<bool> __m)
    : _M_sz(__s), _M_mask(__m), _M_array(__a) {}
  template<typename _Tp>
    inline mask_array<_Tp>&
    mask_array<_Tp>::operator=(const mask_array<_Tp>& __a)
    {
      std::__valarray_copy(__a._M_array, __a._M_mask,
      _M_sz, _M_array, _M_mask);
      return *this;
    }
  template<typename _Tp>
    inline void
    mask_array<_Tp>::operator=(const _Tp& __t) const
    { std::__valarray_fill(_M_array, _M_sz, _M_mask, __t); }
  template<typename _Tp>
    inline void
    mask_array<_Tp>::operator=(const valarray<_Tp>& __v) const
    { std::__valarray_copy(_Array<_Tp>(__v), __v.size(), _M_array, _M_mask); }
  template<typename _Tp>
    template<class _Ex>
      inline void
      mask_array<_Tp>::operator=(const _Expr<_Ex, _Tp>& __e) const
      { std::__valarray_copy(__e, __e.size(), _M_array, _M_mask); }
template<typename _Tp> inline void mask_array<_Tp>::operator *=(const valarray<_Tp>& __v) const { _Array_augmented___multiplies(_M_array, _M_mask, _Array<_Tp>(__v), __v.size()); } template<typename _Tp> template<class _Dom> inline void mask_array<_Tp>::operator *=(const _Expr<_Dom, _Tp>& __e) const { _Array_augmented___multiplies(_M_array, _M_mask, __e, __e.size()); }
template<typename _Tp> inline void mask_array<_Tp>::operator /=(const valarray<_Tp>& __v) const { _Array_augmented___divides(_M_array, _M_mask, _Array<_Tp>(__v), __v.size()); } template<typename _Tp> template<class _Dom> inline void mask_array<_Tp>::operator /=(const _Expr<_Dom, _Tp>& __e) const { _Array_augmented___divides(_M_array, _M_mask, __e, __e.size()); }
template<typename _Tp> inline void mask_array<_Tp>::operator %=(const valarray<_Tp>& __v) const { _Array_augmented___modulus(_M_array, _M_mask, _Array<_Tp>(__v), __v.size()); } template<typename _Tp> template<class _Dom> inline void mask_array<_Tp>::operator %=(const _Expr<_Dom, _Tp>& __e) const { _Array_augmented___modulus(_M_array, _M_mask, __e, __e.size()); }
template<typename _Tp> inline void mask_array<_Tp>::operator +=(const valarray<_Tp>& __v) const { _Array_augmented___plus(_M_array, _M_mask, _Array<_Tp>(__v), __v.size()); } template<typename _Tp> template<class _Dom> inline void mask_array<_Tp>::operator +=(const _Expr<_Dom, _Tp>& __e) const { _Array_augmented___plus(_M_array, _M_mask, __e, __e.size()); }
template<typename _Tp> inline void mask_array<_Tp>::operator -=(const valarray<_Tp>& __v) const { _Array_augmented___minus(_M_array, _M_mask, _Array<_Tp>(__v), __v.size()); } template<typename _Tp> template<class _Dom> inline void mask_array<_Tp>::operator -=(const _Expr<_Dom, _Tp>& __e) const { _Array_augmented___minus(_M_array, _M_mask, __e, __e.size()); }
template<typename _Tp> inline void mask_array<_Tp>::operator ^=(const valarray<_Tp>& __v) const { _Array_augmented___bitwise_xor(_M_array, _M_mask, _Array<_Tp>(__v), __v.size()); } template<typename _Tp> template<class _Dom> inline void mask_array<_Tp>::operator ^=(const _Expr<_Dom, _Tp>& __e) const { _Array_augmented___bitwise_xor(_M_array, _M_mask, __e, __e.size()); }
template<typename _Tp> inline void mask_array<_Tp>::operator &=(const valarray<_Tp>& __v) const { _Array_augmented___bitwise_and(_M_array, _M_mask, _Array<_Tp>(__v), __v.size()); } template<typename _Tp> template<class _Dom> inline void mask_array<_Tp>::operator &=(const _Expr<_Dom, _Tp>& __e) const { _Array_augmented___bitwise_and(_M_array, _M_mask, __e, __e.size()); }
template<typename _Tp> inline void mask_array<_Tp>::operator |=(const valarray<_Tp>& __v) const { _Array_augmented___bitwise_or(_M_array, _M_mask, _Array<_Tp>(__v), __v.size()); } template<typename _Tp> template<class _Dom> inline void mask_array<_Tp>::operator |=(const _Expr<_Dom, _Tp>& __e) const { _Array_augmented___bitwise_or(_M_array, _M_mask, __e, __e.size()); }
template<typename _Tp> inline void mask_array<_Tp>::operator <<=(const valarray<_Tp>& __v) const { _Array_augmented___shift_left(_M_array, _M_mask, _Array<_Tp>(__v), __v.size()); } template<typename _Tp> template<class _Dom> inline void mask_array<_Tp>::operator <<=(const _Expr<_Dom, _Tp>& __e) const { _Array_augmented___shift_left(_M_array, _M_mask, __e, __e.size()); }
template<typename _Tp> inline void mask_array<_Tp>::operator >>=(const valarray<_Tp>& __v) const { _Array_augmented___shift_right(_M_array, _M_mask, _Array<_Tp>(__v), __v.size()); } template<typename _Tp> template<class _Dom> inline void mask_array<_Tp>::operator >>=(const _Expr<_Dom, _Tp>& __e) const { _Array_augmented___shift_right(_M_array, _M_mask, __e, __e.size()); }
}
namespace std
{
  template <class _Tp>
    class indirect_array
    {
    public:
      typedef _Tp value_type;
      indirect_array(const indirect_array&);
      indirect_array& operator=(const indirect_array&);
      void operator=(const valarray<_Tp>&) const;
      void operator*=(const valarray<_Tp>&) const;
      void operator/=(const valarray<_Tp>&) const;
      void operator%=(const valarray<_Tp>&) const;
      void operator+=(const valarray<_Tp>&) const;
      void operator-=(const valarray<_Tp>&) const;
      void operator^=(const valarray<_Tp>&) const;
      void operator&=(const valarray<_Tp>&) const;
      void operator|=(const valarray<_Tp>&) const;
      void operator<<=(const valarray<_Tp>&) const;
      void operator>>=(const valarray<_Tp>&) const;
      void operator= (const _Tp&) const;
      template<class _Dom>
      void operator=(const _Expr<_Dom, _Tp>&) const;
      template<class _Dom>
      void operator*=(const _Expr<_Dom, _Tp>&) const;
      template<class _Dom>
      void operator/=(const _Expr<_Dom, _Tp>&) const;
      template<class _Dom>
      void operator%=(const _Expr<_Dom, _Tp>&) const;
      template<class _Dom>
      void operator+=(const _Expr<_Dom, _Tp>&) const;
      template<class _Dom>
      void operator-=(const _Expr<_Dom, _Tp>&) const;
      template<class _Dom>
      void operator^=(const _Expr<_Dom, _Tp>&) const;
      template<class _Dom>
      void operator&=(const _Expr<_Dom, _Tp>&) const;
      template<class _Dom>
      void operator|=(const _Expr<_Dom, _Tp>&) const;
      template<class _Dom>
      void operator<<=(const _Expr<_Dom, _Tp>&) const;
      template<class _Dom>
      void operator>>=(const _Expr<_Dom, _Tp>&) const;
    private:
      indirect_array(_Array<_Tp>, size_t, _Array<size_t>);
      friend class valarray<_Tp>;
      friend class gslice_array<_Tp>;
      const size_t _M_sz;
      const _Array<size_t> _M_index;
      const _Array<_Tp> _M_array;
      indirect_array();
    };
  template<typename _Tp>
    inline
    indirect_array<_Tp>::indirect_array(const indirect_array<_Tp>& __a)
    : _M_sz(__a._M_sz), _M_index(__a._M_index), _M_array(__a._M_array) {}
  template<typename _Tp>
    inline
    indirect_array<_Tp>::indirect_array(_Array<_Tp> __a, size_t __s,
     _Array<size_t> __i)
    : _M_sz(__s), _M_index(__i), _M_array(__a) {}
  template<typename _Tp>
    inline indirect_array<_Tp>&
    indirect_array<_Tp>::operator=(const indirect_array<_Tp>& __a)
    {
      std::__valarray_copy(__a._M_array, _M_sz, __a._M_index, _M_array,
      _M_index);
      return *this;
    }
  template<typename _Tp>
    inline void
    indirect_array<_Tp>::operator=(const _Tp& __t) const
    { std::__valarray_fill(_M_array, _M_index, _M_sz, __t); }
  template<typename _Tp>
    inline void
    indirect_array<_Tp>::operator=(const valarray<_Tp>& __v) const
    { std::__valarray_copy(_Array<_Tp>(__v), _M_sz, _M_array, _M_index); }
  template<typename _Tp>
    template<class _Dom>
      inline void
      indirect_array<_Tp>::operator=(const _Expr<_Dom, _Tp>& __e) const
      { std::__valarray_copy(__e, _M_sz, _M_array, _M_index); }
template<typename _Tp> inline void indirect_array<_Tp>::operator *=(const valarray<_Tp>& __v) const { _Array_augmented___multiplies(_M_array, _M_index, _Array<_Tp>(__v), _M_sz); } template<typename _Tp> template<class _Dom> inline void indirect_array<_Tp>::operator *=(const _Expr<_Dom,_Tp>& __e) const { _Array_augmented___multiplies(_M_array, _M_index, __e, _M_sz); }
template<typename _Tp> inline void indirect_array<_Tp>::operator /=(const valarray<_Tp>& __v) const { _Array_augmented___divides(_M_array, _M_index, _Array<_Tp>(__v), _M_sz); } template<typename _Tp> template<class _Dom> inline void indirect_array<_Tp>::operator /=(const _Expr<_Dom,_Tp>& __e) const { _Array_augmented___divides(_M_array, _M_index, __e, _M_sz); }
template<typename _Tp> inline void indirect_array<_Tp>::operator %=(const valarray<_Tp>& __v) const { _Array_augmented___modulus(_M_array, _M_index, _Array<_Tp>(__v), _M_sz); } template<typename _Tp> template<class _Dom> inline void indirect_array<_Tp>::operator %=(const _Expr<_Dom,_Tp>& __e) const { _Array_augmented___modulus(_M_array, _M_index, __e, _M_sz); }
template<typename _Tp> inline void indirect_array<_Tp>::operator +=(const valarray<_Tp>& __v) const { _Array_augmented___plus(_M_array, _M_index, _Array<_Tp>(__v), _M_sz); } template<typename _Tp> template<class _Dom> inline void indirect_array<_Tp>::operator +=(const _Expr<_Dom,_Tp>& __e) const { _Array_augmented___plus(_M_array, _M_index, __e, _M_sz); }
template<typename _Tp> inline void indirect_array<_Tp>::operator -=(const valarray<_Tp>& __v) const { _Array_augmented___minus(_M_array, _M_index, _Array<_Tp>(__v), _M_sz); } template<typename _Tp> template<class _Dom> inline void indirect_array<_Tp>::operator -=(const _Expr<_Dom,_Tp>& __e) const { _Array_augmented___minus(_M_array, _M_index, __e, _M_sz); }
template<typename _Tp> inline void indirect_array<_Tp>::operator ^=(const valarray<_Tp>& __v) const { _Array_augmented___bitwise_xor(_M_array, _M_index, _Array<_Tp>(__v), _M_sz); } template<typename _Tp> template<class _Dom> inline void indirect_array<_Tp>::operator ^=(const _Expr<_Dom,_Tp>& __e) const { _Array_augmented___bitwise_xor(_M_array, _M_index, __e, _M_sz); }
template<typename _Tp> inline void indirect_array<_Tp>::operator &=(const valarray<_Tp>& __v) const { _Array_augmented___bitwise_and(_M_array, _M_index, _Array<_Tp>(__v), _M_sz); } template<typename _Tp> template<class _Dom> inline void indirect_array<_Tp>::operator &=(const _Expr<_Dom,_Tp>& __e) const { _Array_augmented___bitwise_and(_M_array, _M_index, __e, _M_sz); }
template<typename _Tp> inline void indirect_array<_Tp>::operator |=(const valarray<_Tp>& __v) const { _Array_augmented___bitwise_or(_M_array, _M_index, _Array<_Tp>(__v), _M_sz); } template<typename _Tp> template<class _Dom> inline void indirect_array<_Tp>::operator |=(const _Expr<_Dom,_Tp>& __e) const { _Array_augmented___bitwise_or(_M_array, _M_index, __e, _M_sz); }
template<typename _Tp> inline void indirect_array<_Tp>::operator <<=(const valarray<_Tp>& __v) const { _Array_augmented___shift_left(_M_array, _M_index, _Array<_Tp>(__v), _M_sz); } template<typename _Tp> template<class _Dom> inline void indirect_array<_Tp>::operator <<=(const _Expr<_Dom,_Tp>& __e) const { _Array_augmented___shift_left(_M_array, _M_index, __e, _M_sz); }
template<typename _Tp> inline void indirect_array<_Tp>::operator >>=(const valarray<_Tp>& __v) const { _Array_augmented___shift_right(_M_array, _M_index, _Array<_Tp>(__v), _M_sz); } template<typename _Tp> template<class _Dom> inline void indirect_array<_Tp>::operator >>=(const _Expr<_Dom,_Tp>& __e) const { _Array_augmented___shift_right(_M_array, _M_index, __e, _M_sz); }
}
namespace std
{
  template<typename _Tp>
    inline
    valarray<_Tp>::valarray() : _M_size(0), _M_data(0) {}
  template<typename _Tp>
    inline
    valarray<_Tp>::valarray(size_t __n)
    : _M_size(__n), _M_data(__valarray_get_storage<_Tp>(__n))
    { std::__valarray_default_construct(_M_data, _M_data + __n); }
  template<typename _Tp>
    inline
    valarray<_Tp>::valarray(const _Tp& __t, size_t __n)
    : _M_size(__n), _M_data(__valarray_get_storage<_Tp>(__n))
    { std::__valarray_fill_construct(_M_data, _M_data + __n, __t); }
  template<typename _Tp>
    inline
    valarray<_Tp>::valarray(const _Tp* __restrict__ __p, size_t __n)
    : _M_size(__n), _M_data(__valarray_get_storage<_Tp>(__n))
    {
      ;
      std::__valarray_copy_construct(__p, __p + __n, _M_data);
    }
  template<typename _Tp>
    inline
    valarray<_Tp>::valarray(const valarray<_Tp>& __v)
    : _M_size(__v._M_size), _M_data(__valarray_get_storage<_Tp>(__v._M_size))
    { std::__valarray_copy_construct(__v._M_data, __v._M_data + _M_size,
         _M_data); }
  template<typename _Tp>
    inline
    valarray<_Tp>::valarray(const slice_array<_Tp>& __sa)
    : _M_size(__sa._M_sz), _M_data(__valarray_get_storage<_Tp>(__sa._M_sz))
    {
      std::__valarray_copy
 (__sa._M_array, __sa._M_sz, __sa._M_stride, _Array<_Tp>(_M_data));
    }
  template<typename _Tp>
    inline
    valarray<_Tp>::valarray(const gslice_array<_Tp>& __ga)
    : _M_size(__ga._M_index.size()),
      _M_data(__valarray_get_storage<_Tp>(_M_size))
    {
      std::__valarray_copy
 (__ga._M_array, _Array<size_t>(__ga._M_index),
  _Array<_Tp>(_M_data), _M_size);
    }
  template<typename _Tp>
    inline
    valarray<_Tp>::valarray(const mask_array<_Tp>& __ma)
    : _M_size(__ma._M_sz), _M_data(__valarray_get_storage<_Tp>(__ma._M_sz))
    {
      std::__valarray_copy
 (__ma._M_array, __ma._M_mask, _Array<_Tp>(_M_data), _M_size);
    }
  template<typename _Tp>
    inline
    valarray<_Tp>::valarray(const indirect_array<_Tp>& __ia)
    : _M_size(__ia._M_sz), _M_data(__valarray_get_storage<_Tp>(__ia._M_sz))
    {
      std::__valarray_copy
 (__ia._M_array, __ia._M_index, _Array<_Tp>(_M_data), _M_size);
    }
  template<typename _Tp> template<class _Dom>
    inline
    valarray<_Tp>::valarray(const _Expr<_Dom, _Tp>& __e)
    : _M_size(__e.size()), _M_data(__valarray_get_storage<_Tp>(_M_size))
    { std::__valarray_copy(__e, _M_size, _Array<_Tp>(_M_data)); }
  template<typename _Tp>
    inline
    valarray<_Tp>::~valarray()
    {
      std::__valarray_destroy_elements(_M_data, _M_data + _M_size);
      std::__valarray_release_memory(_M_data);
    }
  template<typename _Tp>
    inline valarray<_Tp>&
    valarray<_Tp>::operator=(const valarray<_Tp>& __v)
    {
      ;
      std::__valarray_copy(__v._M_data, _M_size, _M_data);
      return *this;
    }
  template<typename _Tp>
    inline valarray<_Tp>&
    valarray<_Tp>::operator=(const _Tp& __t)
    {
      std::__valarray_fill(_M_data, _M_size, __t);
      return *this;
    }
  template<typename _Tp>
    inline valarray<_Tp>&
    valarray<_Tp>::operator=(const slice_array<_Tp>& __sa)
    {
      ;
      std::__valarray_copy(__sa._M_array, __sa._M_sz,
      __sa._M_stride, _Array<_Tp>(_M_data));
      return *this;
    }
  template<typename _Tp>
    inline valarray<_Tp>&
    valarray<_Tp>::operator=(const gslice_array<_Tp>& __ga)
    {
      ;
      std::__valarray_copy(__ga._M_array, _Array<size_t>(__ga._M_index),
      _Array<_Tp>(_M_data), _M_size);
      return *this;
    }
  template<typename _Tp>
    inline valarray<_Tp>&
    valarray<_Tp>::operator=(const mask_array<_Tp>& __ma)
    {
      ;
      std::__valarray_copy(__ma._M_array, __ma._M_mask,
      _Array<_Tp>(_M_data), _M_size);
      return *this;
    }
  template<typename _Tp>
    inline valarray<_Tp>&
    valarray<_Tp>::operator=(const indirect_array<_Tp>& __ia)
    {
      ;
      std::__valarray_copy(__ia._M_array, __ia._M_index,
      _Array<_Tp>(_M_data), _M_size);
      return *this;
    }
  template<typename _Tp> template<class _Dom>
    inline valarray<_Tp>&
    valarray<_Tp>::operator=(const _Expr<_Dom, _Tp>& __e)
    {
      ;
      std::__valarray_copy(__e, _M_size, _Array<_Tp>(_M_data));
      return *this;
    }
  template<typename _Tp>
    inline _Expr<_SClos<_ValArray,_Tp>, _Tp>
    valarray<_Tp>::operator[](slice __s) const
    {
      typedef _SClos<_ValArray,_Tp> _Closure;
      return _Expr<_Closure, _Tp>(_Closure (_Array<_Tp>(_M_data), __s));
    }
  template<typename _Tp>
    inline slice_array<_Tp>
    valarray<_Tp>::operator[](slice __s)
    { return slice_array<_Tp>(_Array<_Tp>(_M_data), __s); }
  template<typename _Tp>
    inline _Expr<_GClos<_ValArray,_Tp>, _Tp>
    valarray<_Tp>::operator[](const gslice& __gs) const
    {
      typedef _GClos<_ValArray,_Tp> _Closure;
      return _Expr<_Closure, _Tp>
 (_Closure(_Array<_Tp>(_M_data), __gs._M_index->_M_index));
    }
  template<typename _Tp>
    inline gslice_array<_Tp>
    valarray<_Tp>::operator[](const gslice& __gs)
    {
      return gslice_array<_Tp>
 (_Array<_Tp>(_M_data), __gs._M_index->_M_index);
    }
  template<typename _Tp>
    inline valarray<_Tp>
    valarray<_Tp>::operator[](const valarray<bool>& __m) const
    {
      size_t __s = 0;
      size_t __e = __m.size();
      for (size_t __i=0; __i<__e; ++__i)
 if (__m[__i]) ++__s;
      return valarray<_Tp>(mask_array<_Tp>(_Array<_Tp>(_M_data), __s,
        _Array<bool> (__m)));
    }
  template<typename _Tp>
    inline mask_array<_Tp>
    valarray<_Tp>::operator[](const valarray<bool>& __m)
    {
      size_t __s = 0;
      size_t __e = __m.size();
      for (size_t __i=0; __i<__e; ++__i)
 if (__m[__i]) ++__s;
      return mask_array<_Tp>(_Array<_Tp>(_M_data), __s, _Array<bool>(__m));
    }
  template<typename _Tp>
    inline _Expr<_IClos<_ValArray,_Tp>, _Tp>
    valarray<_Tp>::operator[](const valarray<size_t>& __i) const
    {
      typedef _IClos<_ValArray,_Tp> _Closure;
      return _Expr<_Closure, _Tp>(_Closure(*this, __i));
    }
  template<typename _Tp>
    inline indirect_array<_Tp>
    valarray<_Tp>::operator[](const valarray<size_t>& __i)
    {
      return indirect_array<_Tp>(_Array<_Tp>(_M_data), __i.size(),
     _Array<size_t>(__i));
    }
  template<class _Tp>
    inline size_t
    valarray<_Tp>::size() const
    { return _M_size; }
  template<class _Tp>
    inline _Tp
    valarray<_Tp>::sum() const
    {
      ;
      return std::__valarray_sum(_M_data, _M_data + _M_size);
    }
  template <class _Tp>
     inline valarray<_Tp>
     valarray<_Tp>::shift(int __n) const
     {
       _Tp* const __a = static_cast<_Tp*>
         (__builtin_alloca(sizeof(_Tp) * _M_size));
       if (__n == 0)
         std::__valarray_copy_construct(_M_data, _M_data + _M_size, __a);
       else if (__n > 0)
         {
           if (size_t(__n) > _M_size)
             std::__valarray_default_construct(__a, __a + __n);
           else
             {
               std::__valarray_copy_construct(_M_data + __n,
           _M_data + _M_size, __a);
               std::__valarray_default_construct(__a + _M_size -__n,
       __a + _M_size);
             }
         }
       else
         {
           std::__valarray_copy_construct (_M_data, _M_data + _M_size + __n,
        __a - __n);
           std::__valarray_default_construct(__a, __a - __n);
         }
       return valarray<_Tp>(__a, _M_size);
     }
  template <class _Tp>
     inline valarray<_Tp>
     valarray<_Tp>::cshift (int __n) const
     {
       _Tp* const __a = static_cast<_Tp*>
         (__builtin_alloca (sizeof(_Tp) * _M_size));
       if (__n == 0)
         std::__valarray_copy_construct(_M_data, _M_data + _M_size, __a);
       else if (__n > 0)
         {
           std::__valarray_copy_construct(_M_data, _M_data + __n,
       __a + _M_size - __n);
           std::__valarray_copy_construct(_M_data + __n, _M_data + _M_size,
       __a);
         }
       else
         {
           std::__valarray_copy_construct
             (_M_data + _M_size + __n, _M_data + _M_size, __a);
           std::__valarray_copy_construct
             (_M_data, _M_data + _M_size+__n, __a - __n);
         }
       return valarray<_Tp>(__a, _M_size);
     }
  template <class _Tp>
    inline void
    valarray<_Tp>::resize (size_t __n, _Tp __c)
    {
      std::__valarray_destroy_elements(_M_data, _M_data + _M_size);
      if (_M_size != __n)
 {
   std::__valarray_release_memory(_M_data);
   _M_size = __n;
   _M_data = __valarray_get_storage<_Tp>(__n);
 }
      std::__valarray_fill_construct(_M_data, _M_data + __n, __c);
    }
  template<typename _Tp>
    inline _Tp
    valarray<_Tp>::min() const
    {
      ;
      return *std::min_element(_M_data, _M_data+_M_size);
    }
  template<typename _Tp>
    inline _Tp
    valarray<_Tp>::max() const
    {
      ;
      return *std::max_element(_M_data, _M_data+_M_size);
    }
  template<class _Tp>
    inline _Expr<_ValFunClos<_ValArray, _Tp>, _Tp>
    valarray<_Tp>::apply(_Tp func(_Tp)) const
    {
      typedef _ValFunClos<_ValArray, _Tp> _Closure;
      return _Expr<_Closure, _Tp>(_Closure(*this, func));
    }
  template<class _Tp>
    inline _Expr<_RefFunClos<_ValArray, _Tp>, _Tp>
    valarray<_Tp>::apply(_Tp func(const _Tp &)) const
    {
      typedef _RefFunClos<_ValArray, _Tp> _Closure;
      return _Expr<_Closure, _Tp>(_Closure(*this, func));
    }
    template<typename _Tp> inline typename valarray<_Tp>::template _UnaryOp<__unary_plus>::_Rt valarray<_Tp>::operator +() const { typedef _UnClos<__unary_plus, _ValArray, _Tp> _Closure; typedef typename __fun<__unary_plus, _Tp>::result_type _Rt; return _Expr<_Closure, _Rt>(_Closure(*this)); }
    template<typename _Tp> inline typename valarray<_Tp>::template _UnaryOp<__negate>::_Rt valarray<_Tp>::operator -() const { typedef _UnClos<__negate, _ValArray, _Tp> _Closure; typedef typename __fun<__negate, _Tp>::result_type _Rt; return _Expr<_Closure, _Rt>(_Closure(*this)); }
    template<typename _Tp> inline typename valarray<_Tp>::template _UnaryOp<__bitwise_not>::_Rt valarray<_Tp>::operator ~() const { typedef _UnClos<__bitwise_not, _ValArray, _Tp> _Closure; typedef typename __fun<__bitwise_not, _Tp>::result_type _Rt; return _Expr<_Closure, _Rt>(_Closure(*this)); }
    template<typename _Tp> inline typename valarray<_Tp>::template _UnaryOp<__logical_not>::_Rt valarray<_Tp>::operator !() const { typedef _UnClos<__logical_not, _ValArray, _Tp> _Closure; typedef typename __fun<__logical_not, _Tp>::result_type _Rt; return _Expr<_Closure, _Rt>(_Closure(*this)); }
template<class _Tp> inline valarray<_Tp>& valarray<_Tp>::operator +=(const _Tp &__t) { _Array_augmented___plus(_Array<_Tp>(_M_data), _M_size, __t); return *this; } template<class _Tp> inline valarray<_Tp>& valarray<_Tp>::operator +=(const valarray<_Tp> &__v) { ; _Array_augmented___plus(_Array<_Tp>(_M_data), _M_size, _Array<_Tp>(__v._M_data)); return *this; }
template<class _Tp> inline valarray<_Tp>& valarray<_Tp>::operator -=(const _Tp &__t) { _Array_augmented___minus(_Array<_Tp>(_M_data), _M_size, __t); return *this; } template<class _Tp> inline valarray<_Tp>& valarray<_Tp>::operator -=(const valarray<_Tp> &__v) { ; _Array_augmented___minus(_Array<_Tp>(_M_data), _M_size, _Array<_Tp>(__v._M_data)); return *this; }
template<class _Tp> inline valarray<_Tp>& valarray<_Tp>::operator *=(const _Tp &__t) { _Array_augmented___multiplies(_Array<_Tp>(_M_data), _M_size, __t); return *this; } template<class _Tp> inline valarray<_Tp>& valarray<_Tp>::operator *=(const valarray<_Tp> &__v) { ; _Array_augmented___multiplies(_Array<_Tp>(_M_data), _M_size, _Array<_Tp>(__v._M_data)); return *this; }
template<class _Tp> inline valarray<_Tp>& valarray<_Tp>::operator /=(const _Tp &__t) { _Array_augmented___divides(_Array<_Tp>(_M_data), _M_size, __t); return *this; } template<class _Tp> inline valarray<_Tp>& valarray<_Tp>::operator /=(const valarray<_Tp> &__v) { ; _Array_augmented___divides(_Array<_Tp>(_M_data), _M_size, _Array<_Tp>(__v._M_data)); return *this; }
template<class _Tp> inline valarray<_Tp>& valarray<_Tp>::operator %=(const _Tp &__t) { _Array_augmented___modulus(_Array<_Tp>(_M_data), _M_size, __t); return *this; } template<class _Tp> inline valarray<_Tp>& valarray<_Tp>::operator %=(const valarray<_Tp> &__v) { ; _Array_augmented___modulus(_Array<_Tp>(_M_data), _M_size, _Array<_Tp>(__v._M_data)); return *this; }
template<class _Tp> inline valarray<_Tp>& valarray<_Tp>::operator ^=(const _Tp &__t) { _Array_augmented___bitwise_xor(_Array<_Tp>(_M_data), _M_size, __t); return *this; } template<class _Tp> inline valarray<_Tp>& valarray<_Tp>::operator ^=(const valarray<_Tp> &__v) { ; _Array_augmented___bitwise_xor(_Array<_Tp>(_M_data), _M_size, _Array<_Tp>(__v._M_data)); return *this; }
template<class _Tp> inline valarray<_Tp>& valarray<_Tp>::operator &=(const _Tp &__t) { _Array_augmented___bitwise_and(_Array<_Tp>(_M_data), _M_size, __t); return *this; } template<class _Tp> inline valarray<_Tp>& valarray<_Tp>::operator &=(const valarray<_Tp> &__v) { ; _Array_augmented___bitwise_and(_Array<_Tp>(_M_data), _M_size, _Array<_Tp>(__v._M_data)); return *this; }
template<class _Tp> inline valarray<_Tp>& valarray<_Tp>::operator |=(const _Tp &__t) { _Array_augmented___bitwise_or(_Array<_Tp>(_M_data), _M_size, __t); return *this; } template<class _Tp> inline valarray<_Tp>& valarray<_Tp>::operator |=(const valarray<_Tp> &__v) { ; _Array_augmented___bitwise_or(_Array<_Tp>(_M_data), _M_size, _Array<_Tp>(__v._M_data)); return *this; }
template<class _Tp> inline valarray<_Tp>& valarray<_Tp>::operator <<=(const _Tp &__t) { _Array_augmented___shift_left(_Array<_Tp>(_M_data), _M_size, __t); return *this; } template<class _Tp> inline valarray<_Tp>& valarray<_Tp>::operator <<=(const valarray<_Tp> &__v) { ; _Array_augmented___shift_left(_Array<_Tp>(_M_data), _M_size, _Array<_Tp>(__v._M_data)); return *this; }
template<class _Tp> inline valarray<_Tp>& valarray<_Tp>::operator >>=(const _Tp &__t) { _Array_augmented___shift_right(_Array<_Tp>(_M_data), _M_size, __t); return *this; } template<class _Tp> inline valarray<_Tp>& valarray<_Tp>::operator >>=(const valarray<_Tp> &__v) { ; _Array_augmented___shift_right(_Array<_Tp>(_M_data), _M_size, _Array<_Tp>(__v._M_data)); return *this; }
template<class _Tp> template<class _Dom> inline valarray<_Tp>& valarray<_Tp>::operator +=(const _Expr<_Dom, _Tp>& __e) { _Array_augmented___plus(_Array<_Tp>(_M_data), __e, _M_size); return *this; }
template<class _Tp> template<class _Dom> inline valarray<_Tp>& valarray<_Tp>::operator -=(const _Expr<_Dom, _Tp>& __e) { _Array_augmented___minus(_Array<_Tp>(_M_data), __e, _M_size); return *this; }
template<class _Tp> template<class _Dom> inline valarray<_Tp>& valarray<_Tp>::operator *=(const _Expr<_Dom, _Tp>& __e) { _Array_augmented___multiplies(_Array<_Tp>(_M_data), __e, _M_size); return *this; }
template<class _Tp> template<class _Dom> inline valarray<_Tp>& valarray<_Tp>::operator /=(const _Expr<_Dom, _Tp>& __e) { _Array_augmented___divides(_Array<_Tp>(_M_data), __e, _M_size); return *this; }
template<class _Tp> template<class _Dom> inline valarray<_Tp>& valarray<_Tp>::operator %=(const _Expr<_Dom, _Tp>& __e) { _Array_augmented___modulus(_Array<_Tp>(_M_data), __e, _M_size); return *this; }
template<class _Tp> template<class _Dom> inline valarray<_Tp>& valarray<_Tp>::operator ^=(const _Expr<_Dom, _Tp>& __e) { _Array_augmented___bitwise_xor(_Array<_Tp>(_M_data), __e, _M_size); return *this; }
template<class _Tp> template<class _Dom> inline valarray<_Tp>& valarray<_Tp>::operator &=(const _Expr<_Dom, _Tp>& __e) { _Array_augmented___bitwise_and(_Array<_Tp>(_M_data), __e, _M_size); return *this; }
template<class _Tp> template<class _Dom> inline valarray<_Tp>& valarray<_Tp>::operator |=(const _Expr<_Dom, _Tp>& __e) { _Array_augmented___bitwise_or(_Array<_Tp>(_M_data), __e, _M_size); return *this; }
template<class _Tp> template<class _Dom> inline valarray<_Tp>& valarray<_Tp>::operator <<=(const _Expr<_Dom, _Tp>& __e) { _Array_augmented___shift_left(_Array<_Tp>(_M_data), __e, _M_size); return *this; }
template<class _Tp> template<class _Dom> inline valarray<_Tp>& valarray<_Tp>::operator >>=(const _Expr<_Dom, _Tp>& __e) { _Array_augmented___shift_right(_Array<_Tp>(_M_data), __e, _M_size); return *this; }
template<typename _Tp> inline _Expr<_BinClos<__plus, _ValArray, _ValArray, _Tp, _Tp>, typename __fun<__plus, _Tp>::result_type> operator +(const valarray<_Tp>& __v, const valarray<_Tp>& __w) { ; typedef _BinClos<__plus, _ValArray, _ValArray, _Tp, _Tp> _Closure; typedef typename __fun<__plus, _Tp>::result_type _Rt; return _Expr<_Closure, _Rt>(_Closure(__v, __w)); } template<typename _Tp> inline _Expr<_BinClos<__plus, _ValArray,_Constant, _Tp, _Tp>, typename __fun<__plus, _Tp>::result_type> operator +(const valarray<_Tp>& __v, const _Tp& __t) { typedef _BinClos<__plus, _ValArray, _Constant, _Tp, _Tp> _Closure; typedef typename __fun<__plus, _Tp>::result_type _Rt; return _Expr<_Closure, _Rt>(_Closure(__v, __t)); } template<typename _Tp> inline _Expr<_BinClos<__plus, _Constant, _ValArray, _Tp, _Tp>, typename __fun<__plus, _Tp>::result_type> operator +(const _Tp& __t, const valarray<_Tp>& __v) { typedef _BinClos<__plus, _Constant, _ValArray, _Tp, _Tp> _Closure; typedef typename __fun<__plus, _Tp>::result_type _Rt; return _Expr<_Closure, _Tp>(_Closure(__t, __v)); }
template<typename _Tp> inline _Expr<_BinClos<__minus, _ValArray, _ValArray, _Tp, _Tp>, typename __fun<__minus, _Tp>::result_type> operator -(const valarray<_Tp>& __v, const valarray<_Tp>& __w) { ; typedef _BinClos<__minus, _ValArray, _ValArray, _Tp, _Tp> _Closure; typedef typename __fun<__minus, _Tp>::result_type _Rt; return _Expr<_Closure, _Rt>(_Closure(__v, __w)); } template<typename _Tp> inline _Expr<_BinClos<__minus, _ValArray,_Constant, _Tp, _Tp>, typename __fun<__minus, _Tp>::result_type> operator -(const valarray<_Tp>& __v, const _Tp& __t) { typedef _BinClos<__minus, _ValArray, _Constant, _Tp, _Tp> _Closure; typedef typename __fun<__minus, _Tp>::result_type _Rt; return _Expr<_Closure, _Rt>(_Closure(__v, __t)); } template<typename _Tp> inline _Expr<_BinClos<__minus, _Constant, _ValArray, _Tp, _Tp>, typename __fun<__minus, _Tp>::result_type> operator -(const _Tp& __t, const valarray<_Tp>& __v) { typedef _BinClos<__minus, _Constant, _ValArray, _Tp, _Tp> _Closure; typedef typename __fun<__minus, _Tp>::result_type _Rt; return _Expr<_Closure, _Tp>(_Closure(__t, __v)); }
template<typename _Tp> inline _Expr<_BinClos<__multiplies, _ValArray, _ValArray, _Tp, _Tp>, typename __fun<__multiplies, _Tp>::result_type> operator *(const valarray<_Tp>& __v, const valarray<_Tp>& __w) { ; typedef _BinClos<__multiplies, _ValArray, _ValArray, _Tp, _Tp> _Closure; typedef typename __fun<__multiplies, _Tp>::result_type _Rt; return _Expr<_Closure, _Rt>(_Closure(__v, __w)); } template<typename _Tp> inline _Expr<_BinClos<__multiplies, _ValArray,_Constant, _Tp, _Tp>, typename __fun<__multiplies, _Tp>::result_type> operator *(const valarray<_Tp>& __v, const _Tp& __t) { typedef _BinClos<__multiplies, _ValArray, _Constant, _Tp, _Tp> _Closure; typedef typename __fun<__multiplies, _Tp>::result_type _Rt; return _Expr<_Closure, _Rt>(_Closure(__v, __t)); } template<typename _Tp> inline _Expr<_BinClos<__multiplies, _Constant, _ValArray, _Tp, _Tp>, typename __fun<__multiplies, _Tp>::result_type> operator *(const _Tp& __t, const valarray<_Tp>& __v) { typedef _BinClos<__multiplies, _Constant, _ValArray, _Tp, _Tp> _Closure; typedef typename __fun<__multiplies, _Tp>::result_type _Rt; return _Expr<_Closure, _Tp>(_Closure(__t, __v)); }
template<typename _Tp> inline _Expr<_BinClos<__divides, _ValArray, _ValArray, _Tp, _Tp>, typename __fun<__divides, _Tp>::result_type> operator /(const valarray<_Tp>& __v, const valarray<_Tp>& __w) { ; typedef _BinClos<__divides, _ValArray, _ValArray, _Tp, _Tp> _Closure; typedef typename __fun<__divides, _Tp>::result_type _Rt; return _Expr<_Closure, _Rt>(_Closure(__v, __w)); } template<typename _Tp> inline _Expr<_BinClos<__divides, _ValArray,_Constant, _Tp, _Tp>, typename __fun<__divides, _Tp>::result_type> operator /(const valarray<_Tp>& __v, const _Tp& __t) { typedef _BinClos<__divides, _ValArray, _Constant, _Tp, _Tp> _Closure; typedef typename __fun<__divides, _Tp>::result_type _Rt; return _Expr<_Closure, _Rt>(_Closure(__v, __t)); } template<typename _Tp> inline _Expr<_BinClos<__divides, _Constant, _ValArray, _Tp, _Tp>, typename __fun<__divides, _Tp>::result_type> operator /(const _Tp& __t, const valarray<_Tp>& __v) { typedef _BinClos<__divides, _Constant, _ValArray, _Tp, _Tp> _Closure; typedef typename __fun<__divides, _Tp>::result_type _Rt; return _Expr<_Closure, _Tp>(_Closure(__t, __v)); }
template<typename _Tp> inline _Expr<_BinClos<__modulus, _ValArray, _ValArray, _Tp, _Tp>, typename __fun<__modulus, _Tp>::result_type> operator %(const valarray<_Tp>& __v, const valarray<_Tp>& __w) { ; typedef _BinClos<__modulus, _ValArray, _ValArray, _Tp, _Tp> _Closure; typedef typename __fun<__modulus, _Tp>::result_type _Rt; return _Expr<_Closure, _Rt>(_Closure(__v, __w)); } template<typename _Tp> inline _Expr<_BinClos<__modulus, _ValArray,_Constant, _Tp, _Tp>, typename __fun<__modulus, _Tp>::result_type> operator %(const valarray<_Tp>& __v, const _Tp& __t) { typedef _BinClos<__modulus, _ValArray, _Constant, _Tp, _Tp> _Closure; typedef typename __fun<__modulus, _Tp>::result_type _Rt; return _Expr<_Closure, _Rt>(_Closure(__v, __t)); } template<typename _Tp> inline _Expr<_BinClos<__modulus, _Constant, _ValArray, _Tp, _Tp>, typename __fun<__modulus, _Tp>::result_type> operator %(const _Tp& __t, const valarray<_Tp>& __v) { typedef _BinClos<__modulus, _Constant, _ValArray, _Tp, _Tp> _Closure; typedef typename __fun<__modulus, _Tp>::result_type _Rt; return _Expr<_Closure, _Tp>(_Closure(__t, __v)); }
template<typename _Tp> inline _Expr<_BinClos<__bitwise_xor, _ValArray, _ValArray, _Tp, _Tp>, typename __fun<__bitwise_xor, _Tp>::result_type> operator ^(const valarray<_Tp>& __v, const valarray<_Tp>& __w) { ; typedef _BinClos<__bitwise_xor, _ValArray, _ValArray, _Tp, _Tp> _Closure; typedef typename __fun<__bitwise_xor, _Tp>::result_type _Rt; return _Expr<_Closure, _Rt>(_Closure(__v, __w)); } template<typename _Tp> inline _Expr<_BinClos<__bitwise_xor, _ValArray,_Constant, _Tp, _Tp>, typename __fun<__bitwise_xor, _Tp>::result_type> operator ^(const valarray<_Tp>& __v, const _Tp& __t) { typedef _BinClos<__bitwise_xor, _ValArray, _Constant, _Tp, _Tp> _Closure; typedef typename __fun<__bitwise_xor, _Tp>::result_type _Rt; return _Expr<_Closure, _Rt>(_Closure(__v, __t)); } template<typename _Tp> inline _Expr<_BinClos<__bitwise_xor, _Constant, _ValArray, _Tp, _Tp>, typename __fun<__bitwise_xor, _Tp>::result_type> operator ^(const _Tp& __t, const valarray<_Tp>& __v) { typedef _BinClos<__bitwise_xor, _Constant, _ValArray, _Tp, _Tp> _Closure; typedef typename __fun<__bitwise_xor, _Tp>::result_type _Rt; return _Expr<_Closure, _Tp>(_Closure(__t, __v)); }
template<typename _Tp> inline _Expr<_BinClos<__bitwise_and, _ValArray, _ValArray, _Tp, _Tp>, typename __fun<__bitwise_and, _Tp>::result_type> operator &(const valarray<_Tp>& __v, const valarray<_Tp>& __w) { ; typedef _BinClos<__bitwise_and, _ValArray, _ValArray, _Tp, _Tp> _Closure; typedef typename __fun<__bitwise_and, _Tp>::result_type _Rt; return _Expr<_Closure, _Rt>(_Closure(__v, __w)); } template<typename _Tp> inline _Expr<_BinClos<__bitwise_and, _ValArray,_Constant, _Tp, _Tp>, typename __fun<__bitwise_and, _Tp>::result_type> operator &(const valarray<_Tp>& __v, const _Tp& __t) { typedef _BinClos<__bitwise_and, _ValArray, _Constant, _Tp, _Tp> _Closure; typedef typename __fun<__bitwise_and, _Tp>::result_type _Rt; return _Expr<_Closure, _Rt>(_Closure(__v, __t)); } template<typename _Tp> inline _Expr<_BinClos<__bitwise_and, _Constant, _ValArray, _Tp, _Tp>, typename __fun<__bitwise_and, _Tp>::result_type> operator &(const _Tp& __t, const valarray<_Tp>& __v) { typedef _BinClos<__bitwise_and, _Constant, _ValArray, _Tp, _Tp> _Closure; typedef typename __fun<__bitwise_and, _Tp>::result_type _Rt; return _Expr<_Closure, _Tp>(_Closure(__t, __v)); }
template<typename _Tp> inline _Expr<_BinClos<__bitwise_or, _ValArray, _ValArray, _Tp, _Tp>, typename __fun<__bitwise_or, _Tp>::result_type> operator |(const valarray<_Tp>& __v, const valarray<_Tp>& __w) { ; typedef _BinClos<__bitwise_or, _ValArray, _ValArray, _Tp, _Tp> _Closure; typedef typename __fun<__bitwise_or, _Tp>::result_type _Rt; return _Expr<_Closure, _Rt>(_Closure(__v, __w)); } template<typename _Tp> inline _Expr<_BinClos<__bitwise_or, _ValArray,_Constant, _Tp, _Tp>, typename __fun<__bitwise_or, _Tp>::result_type> operator |(const valarray<_Tp>& __v, const _Tp& __t) { typedef _BinClos<__bitwise_or, _ValArray, _Constant, _Tp, _Tp> _Closure; typedef typename __fun<__bitwise_or, _Tp>::result_type _Rt; return _Expr<_Closure, _Rt>(_Closure(__v, __t)); } template<typename _Tp> inline _Expr<_BinClos<__bitwise_or, _Constant, _ValArray, _Tp, _Tp>, typename __fun<__bitwise_or, _Tp>::result_type> operator |(const _Tp& __t, const valarray<_Tp>& __v) { typedef _BinClos<__bitwise_or, _Constant, _ValArray, _Tp, _Tp> _Closure; typedef typename __fun<__bitwise_or, _Tp>::result_type _Rt; return _Expr<_Closure, _Tp>(_Closure(__t, __v)); }
template<typename _Tp> inline _Expr<_BinClos<__shift_left, _ValArray, _ValArray, _Tp, _Tp>, typename __fun<__shift_left, _Tp>::result_type> operator <<(const valarray<_Tp>& __v, const valarray<_Tp>& __w) { ; typedef _BinClos<__shift_left, _ValArray, _ValArray, _Tp, _Tp> _Closure; typedef typename __fun<__shift_left, _Tp>::result_type _Rt; return _Expr<_Closure, _Rt>(_Closure(__v, __w)); } template<typename _Tp> inline _Expr<_BinClos<__shift_left, _ValArray,_Constant, _Tp, _Tp>, typename __fun<__shift_left, _Tp>::result_type> operator <<(const valarray<_Tp>& __v, const _Tp& __t) { typedef _BinClos<__shift_left, _ValArray, _Constant, _Tp, _Tp> _Closure; typedef typename __fun<__shift_left, _Tp>::result_type _Rt; return _Expr<_Closure, _Rt>(_Closure(__v, __t)); } template<typename _Tp> inline _Expr<_BinClos<__shift_left, _Constant, _ValArray, _Tp, _Tp>, typename __fun<__shift_left, _Tp>::result_type> operator <<(const _Tp& __t, const valarray<_Tp>& __v) { typedef _BinClos<__shift_left, _Constant, _ValArray, _Tp, _Tp> _Closure; typedef typename __fun<__shift_left, _Tp>::result_type _Rt; return _Expr<_Closure, _Tp>(_Closure(__t, __v)); }
template<typename _Tp> inline _Expr<_BinClos<__shift_right, _ValArray, _ValArray, _Tp, _Tp>, typename __fun<__shift_right, _Tp>::result_type> operator >>(const valarray<_Tp>& __v, const valarray<_Tp>& __w) { ; typedef _BinClos<__shift_right, _ValArray, _ValArray, _Tp, _Tp> _Closure; typedef typename __fun<__shift_right, _Tp>::result_type _Rt; return _Expr<_Closure, _Rt>(_Closure(__v, __w)); } template<typename _Tp> inline _Expr<_BinClos<__shift_right, _ValArray,_Constant, _Tp, _Tp>, typename __fun<__shift_right, _Tp>::result_type> operator >>(const valarray<_Tp>& __v, const _Tp& __t) { typedef _BinClos<__shift_right, _ValArray, _Constant, _Tp, _Tp> _Closure; typedef typename __fun<__shift_right, _Tp>::result_type _Rt; return _Expr<_Closure, _Rt>(_Closure(__v, __t)); } template<typename _Tp> inline _Expr<_BinClos<__shift_right, _Constant, _ValArray, _Tp, _Tp>, typename __fun<__shift_right, _Tp>::result_type> operator >>(const _Tp& __t, const valarray<_Tp>& __v) { typedef _BinClos<__shift_right, _Constant, _ValArray, _Tp, _Tp> _Closure; typedef typename __fun<__shift_right, _Tp>::result_type _Rt; return _Expr<_Closure, _Tp>(_Closure(__t, __v)); }
template<typename _Tp> inline _Expr<_BinClos<__logical_and, _ValArray, _ValArray, _Tp, _Tp>, typename __fun<__logical_and, _Tp>::result_type> operator &&(const valarray<_Tp>& __v, const valarray<_Tp>& __w) { ; typedef _BinClos<__logical_and, _ValArray, _ValArray, _Tp, _Tp> _Closure; typedef typename __fun<__logical_and, _Tp>::result_type _Rt; return _Expr<_Closure, _Rt>(_Closure(__v, __w)); } template<typename _Tp> inline _Expr<_BinClos<__logical_and, _ValArray,_Constant, _Tp, _Tp>, typename __fun<__logical_and, _Tp>::result_type> operator &&(const valarray<_Tp>& __v, const _Tp& __t) { typedef _BinClos<__logical_and, _ValArray, _Constant, _Tp, _Tp> _Closure; typedef typename __fun<__logical_and, _Tp>::result_type _Rt; return _Expr<_Closure, _Rt>(_Closure(__v, __t)); } template<typename _Tp> inline _Expr<_BinClos<__logical_and, _Constant, _ValArray, _Tp, _Tp>, typename __fun<__logical_and, _Tp>::result_type> operator &&(const _Tp& __t, const valarray<_Tp>& __v) { typedef _BinClos<__logical_and, _Constant, _ValArray, _Tp, _Tp> _Closure; typedef typename __fun<__logical_and, _Tp>::result_type _Rt; return _Expr<_Closure, _Tp>(_Closure(__t, __v)); }
template<typename _Tp> inline _Expr<_BinClos<__logical_or, _ValArray, _ValArray, _Tp, _Tp>, typename __fun<__logical_or, _Tp>::result_type> operator ||(const valarray<_Tp>& __v, const valarray<_Tp>& __w) { ; typedef _BinClos<__logical_or, _ValArray, _ValArray, _Tp, _Tp> _Closure; typedef typename __fun<__logical_or, _Tp>::result_type _Rt; return _Expr<_Closure, _Rt>(_Closure(__v, __w)); } template<typename _Tp> inline _Expr<_BinClos<__logical_or, _ValArray,_Constant, _Tp, _Tp>, typename __fun<__logical_or, _Tp>::result_type> operator ||(const valarray<_Tp>& __v, const _Tp& __t) { typedef _BinClos<__logical_or, _ValArray, _Constant, _Tp, _Tp> _Closure; typedef typename __fun<__logical_or, _Tp>::result_type _Rt; return _Expr<_Closure, _Rt>(_Closure(__v, __t)); } template<typename _Tp> inline _Expr<_BinClos<__logical_or, _Constant, _ValArray, _Tp, _Tp>, typename __fun<__logical_or, _Tp>::result_type> operator ||(const _Tp& __t, const valarray<_Tp>& __v) { typedef _BinClos<__logical_or, _Constant, _ValArray, _Tp, _Tp> _Closure; typedef typename __fun<__logical_or, _Tp>::result_type _Rt; return _Expr<_Closure, _Tp>(_Closure(__t, __v)); }
template<typename _Tp> inline _Expr<_BinClos<__equal_to, _ValArray, _ValArray, _Tp, _Tp>, typename __fun<__equal_to, _Tp>::result_type> operator ==(const valarray<_Tp>& __v, const valarray<_Tp>& __w) { ; typedef _BinClos<__equal_to, _ValArray, _ValArray, _Tp, _Tp> _Closure; typedef typename __fun<__equal_to, _Tp>::result_type _Rt; return _Expr<_Closure, _Rt>(_Closure(__v, __w)); } template<typename _Tp> inline _Expr<_BinClos<__equal_to, _ValArray,_Constant, _Tp, _Tp>, typename __fun<__equal_to, _Tp>::result_type> operator ==(const valarray<_Tp>& __v, const _Tp& __t) { typedef _BinClos<__equal_to, _ValArray, _Constant, _Tp, _Tp> _Closure; typedef typename __fun<__equal_to, _Tp>::result_type _Rt; return _Expr<_Closure, _Rt>(_Closure(__v, __t)); } template<typename _Tp> inline _Expr<_BinClos<__equal_to, _Constant, _ValArray, _Tp, _Tp>, typename __fun<__equal_to, _Tp>::result_type> operator ==(const _Tp& __t, const valarray<_Tp>& __v) { typedef _BinClos<__equal_to, _Constant, _ValArray, _Tp, _Tp> _Closure; typedef typename __fun<__equal_to, _Tp>::result_type _Rt; return _Expr<_Closure, _Tp>(_Closure(__t, __v)); }
template<typename _Tp> inline _Expr<_BinClos<__not_equal_to, _ValArray, _ValArray, _Tp, _Tp>, typename __fun<__not_equal_to, _Tp>::result_type> operator !=(const valarray<_Tp>& __v, const valarray<_Tp>& __w) { ; typedef _BinClos<__not_equal_to, _ValArray, _ValArray, _Tp, _Tp> _Closure; typedef typename __fun<__not_equal_to, _Tp>::result_type _Rt; return _Expr<_Closure, _Rt>(_Closure(__v, __w)); } template<typename _Tp> inline _Expr<_BinClos<__not_equal_to, _ValArray,_Constant, _Tp, _Tp>, typename __fun<__not_equal_to, _Tp>::result_type> operator !=(const valarray<_Tp>& __v, const _Tp& __t) { typedef _BinClos<__not_equal_to, _ValArray, _Constant, _Tp, _Tp> _Closure; typedef typename __fun<__not_equal_to, _Tp>::result_type _Rt; return _Expr<_Closure, _Rt>(_Closure(__v, __t)); } template<typename _Tp> inline _Expr<_BinClos<__not_equal_to, _Constant, _ValArray, _Tp, _Tp>, typename __fun<__not_equal_to, _Tp>::result_type> operator !=(const _Tp& __t, const valarray<_Tp>& __v) { typedef _BinClos<__not_equal_to, _Constant, _ValArray, _Tp, _Tp> _Closure; typedef typename __fun<__not_equal_to, _Tp>::result_type _Rt; return _Expr<_Closure, _Tp>(_Closure(__t, __v)); }
template<typename _Tp> inline _Expr<_BinClos<__less, _ValArray, _ValArray, _Tp, _Tp>, typename __fun<__less, _Tp>::result_type> operator <(const valarray<_Tp>& __v, const valarray<_Tp>& __w) { ; typedef _BinClos<__less, _ValArray, _ValArray, _Tp, _Tp> _Closure; typedef typename __fun<__less, _Tp>::result_type _Rt; return _Expr<_Closure, _Rt>(_Closure(__v, __w)); } template<typename _Tp> inline _Expr<_BinClos<__less, _ValArray,_Constant, _Tp, _Tp>, typename __fun<__less, _Tp>::result_type> operator <(const valarray<_Tp>& __v, const _Tp& __t) { typedef _BinClos<__less, _ValArray, _Constant, _Tp, _Tp> _Closure; typedef typename __fun<__less, _Tp>::result_type _Rt; return _Expr<_Closure, _Rt>(_Closure(__v, __t)); } template<typename _Tp> inline _Expr<_BinClos<__less, _Constant, _ValArray, _Tp, _Tp>, typename __fun<__less, _Tp>::result_type> operator <(const _Tp& __t, const valarray<_Tp>& __v) { typedef _BinClos<__less, _Constant, _ValArray, _Tp, _Tp> _Closure; typedef typename __fun<__less, _Tp>::result_type _Rt; return _Expr<_Closure, _Tp>(_Closure(__t, __v)); }
template<typename _Tp> inline _Expr<_BinClos<__greater, _ValArray, _ValArray, _Tp, _Tp>, typename __fun<__greater, _Tp>::result_type> operator >(const valarray<_Tp>& __v, const valarray<_Tp>& __w) { ; typedef _BinClos<__greater, _ValArray, _ValArray, _Tp, _Tp> _Closure; typedef typename __fun<__greater, _Tp>::result_type _Rt; return _Expr<_Closure, _Rt>(_Closure(__v, __w)); } template<typename _Tp> inline _Expr<_BinClos<__greater, _ValArray,_Constant, _Tp, _Tp>, typename __fun<__greater, _Tp>::result_type> operator >(const valarray<_Tp>& __v, const _Tp& __t) { typedef _BinClos<__greater, _ValArray, _Constant, _Tp, _Tp> _Closure; typedef typename __fun<__greater, _Tp>::result_type _Rt; return _Expr<_Closure, _Rt>(_Closure(__v, __t)); } template<typename _Tp> inline _Expr<_BinClos<__greater, _Constant, _ValArray, _Tp, _Tp>, typename __fun<__greater, _Tp>::result_type> operator >(const _Tp& __t, const valarray<_Tp>& __v) { typedef _BinClos<__greater, _Constant, _ValArray, _Tp, _Tp> _Closure; typedef typename __fun<__greater, _Tp>::result_type _Rt; return _Expr<_Closure, _Tp>(_Closure(__t, __v)); }
template<typename _Tp> inline _Expr<_BinClos<__less_equal, _ValArray, _ValArray, _Tp, _Tp>, typename __fun<__less_equal, _Tp>::result_type> operator <=(const valarray<_Tp>& __v, const valarray<_Tp>& __w) { ; typedef _BinClos<__less_equal, _ValArray, _ValArray, _Tp, _Tp> _Closure; typedef typename __fun<__less_equal, _Tp>::result_type _Rt; return _Expr<_Closure, _Rt>(_Closure(__v, __w)); } template<typename _Tp> inline _Expr<_BinClos<__less_equal, _ValArray,_Constant, _Tp, _Tp>, typename __fun<__less_equal, _Tp>::result_type> operator <=(const valarray<_Tp>& __v, const _Tp& __t) { typedef _BinClos<__less_equal, _ValArray, _Constant, _Tp, _Tp> _Closure; typedef typename __fun<__less_equal, _Tp>::result_type _Rt; return _Expr<_Closure, _Rt>(_Closure(__v, __t)); } template<typename _Tp> inline _Expr<_BinClos<__less_equal, _Constant, _ValArray, _Tp, _Tp>, typename __fun<__less_equal, _Tp>::result_type> operator <=(const _Tp& __t, const valarray<_Tp>& __v) { typedef _BinClos<__less_equal, _Constant, _ValArray, _Tp, _Tp> _Closure; typedef typename __fun<__less_equal, _Tp>::result_type _Rt; return _Expr<_Closure, _Tp>(_Closure(__t, __v)); }
template<typename _Tp> inline _Expr<_BinClos<__greater_equal, _ValArray, _ValArray, _Tp, _Tp>, typename __fun<__greater_equal, _Tp>::result_type> operator >=(const valarray<_Tp>& __v, const valarray<_Tp>& __w) { ; typedef _BinClos<__greater_equal, _ValArray, _ValArray, _Tp, _Tp> _Closure; typedef typename __fun<__greater_equal, _Tp>::result_type _Rt; return _Expr<_Closure, _Rt>(_Closure(__v, __w)); } template<typename _Tp> inline _Expr<_BinClos<__greater_equal, _ValArray,_Constant, _Tp, _Tp>, typename __fun<__greater_equal, _Tp>::result_type> operator >=(const valarray<_Tp>& __v, const _Tp& __t) { typedef _BinClos<__greater_equal, _ValArray, _Constant, _Tp, _Tp> _Closure; typedef typename __fun<__greater_equal, _Tp>::result_type _Rt; return _Expr<_Closure, _Rt>(_Closure(__v, __t)); } template<typename _Tp> inline _Expr<_BinClos<__greater_equal, _Constant, _ValArray, _Tp, _Tp>, typename __fun<__greater_equal, _Tp>::result_type> operator >=(const _Tp& __t, const valarray<_Tp>& __v) { typedef _BinClos<__greater_equal, _Constant, _ValArray, _Tp, _Tp> _Closure; typedef typename __fun<__greater_equal, _Tp>::result_type _Rt; return _Expr<_Closure, _Tp>(_Closure(__t, __v)); }
}
namespace Cairo
{
typedef cairo_glyph_t Glyph;
typedef cairo_font_extents_t FontExtents;
typedef cairo_text_extents_t TextExtents;
typedef cairo_matrix_t Matrix;
typedef cairo_rectangle_t Rectangle;
class Context
{
protected:
  explicit Context(const RefPtr<Surface>& target);
public:
  explicit Context(cairo_t* cobject, bool has_reference = false);
  static RefPtr<Context> create(const RefPtr<Surface>& target);
  virtual ~Context();
  void save();
  void restore();
  void set_operator(Operator op);
  void set_source(const RefPtr<const Pattern>& source);
  void set_source_rgb(double red, double green, double blue);
  void set_source_rgba(double red, double green, double blue, double alpha);
  void set_source(const RefPtr<Surface>& surface, double x, double y);
  void set_tolerance(double tolerance);
  void set_antialias(Antialias antialias);
  void set_fill_rule(FillRule fill_rule);
  void set_line_width(double width);
  void set_line_cap(LineCap line_cap);
  void set_line_join(LineJoin line_join);
  void set_dash(std::valarray<double>& dashes, double offset);
  void set_dash(std::vector<double>& dashes, double offset);
  void unset_dash();
  void set_miter_limit(double limit);
  void translate(double tx, double ty);
  void scale(double sx, double sy);
  void rotate(double angle_radians);
  void rotate_degrees(double angle_degres);
  void transform(const Matrix& matrix);
  void set_matrix(const Matrix& matrix);
  void set_identity_matrix();
  void user_to_device(double& x, double& y);
  void user_to_device_distance(double& dx, double& dy);
  void device_to_user(double& x, double& y);
  void device_to_user_distance(double& dx, double& dy);
  void begin_new_path();
  void begin_new_sub_path();
  void move_to(double x, double y);
  void line_to(double x, double y);
  void curve_to(double x1, double y1, double x2, double y2, double x3, double y3);
  void arc(double xc, double yc, double radius, double angle1, double angle2);
  void arc_negative(double xc, double yc, double radius, double angle1, double angle2);
  void rel_move_to(double dx, double dy);
  void rel_line_to(double dx, double dy);
  void rel_curve_to(double dx1, double dy1, double dx2, double dy2, double dx3, double dy3);
  void rectangle(double x, double y, double width, double height);
  void close_path();
  void paint();
  void paint_with_alpha(double alpha);
  void mask(const RefPtr<const Pattern>& pattern);
  void mask(const RefPtr<const Surface>& surface, double surface_x, double surface_y);
  void stroke();
  void stroke_preserve();
  void fill();
  void fill_preserve();
  void copy_page();
  void show_page();
  bool in_stroke(double x, double y) const;
  bool in_fill(double x, double y) const;
  void get_stroke_extents(double& x1, double& y1, double& x2, double& y2) const;
  void get_fill_extents(double& x1, double& y1, double& x2, double& y2) const;
  void reset_clip();
  void clip();
  void clip_preserve();
  void get_clip_extents(double& x1, double& y1, double& x2, double& y2) const;
   void copy_clip_rectangle_list(std::vector<Rectangle>& rectangles) const;
  void select_font_face(const std::string& family, FontSlant slant, FontWeight weight);
  void set_font_size(double size);
  void set_font_matrix(const Matrix& matrix);
  void get_font_matrix(Matrix& matrix) const;
  void set_font_options(const FontOptions& options);
  void show_text(const std::string& utf8);
  void show_glyphs(const std::vector<Glyph>& glyphs);
  RefPtr<FontFace> get_font_face();
  RefPtr<const FontFace> get_font_face() const;
  void get_font_extents(FontExtents& extents) const;
  void set_font_face(const RefPtr<const FontFace>& font_face);
  void get_text_extents(const std::string& utf8, TextExtents& extents) const;
  void get_glyph_extents(const std::vector<Glyph>& glyphs, TextExtents& extents) const;
  void text_path(const std::string& utf8);
  void glyph_path(const std::vector<Glyph>& glyphs);
  Operator get_operator() const;
  RefPtr<Pattern> get_source();
  RefPtr<const Pattern> get_source() const;
  double get_tolerance() const;
  Antialias get_antialias() const;
  void get_current_point (double& x, double& y) const;
  FillRule get_fill_rule() const;
  double get_line_width() const;
  LineCap get_line_cap() const;
  LineJoin get_line_join() const;
  double get_miter_limit() const;
  void get_dash(std::vector<double>& dashes, double& offset) const;
  void get_matrix(Matrix& matrix);
  RefPtr<Surface> get_target();
  RefPtr<const Surface> get_target() const;
  Path* copy_path() const;
  Path* copy_path_flat() const;
  void append_path(const Path& path);
  void push_group();
  void push_group_with_content(Content content);
  RefPtr<Pattern> pop_group();
  void pop_group_to_source();
  RefPtr<Surface> get_group_target();
  RefPtr<const Surface> get_group_target() const;
  typedef cairo_t cobject;
  inline cobject* cobj() { return m_cobject; }
  inline const cobject* cobj() const { return m_cobject; }
  inline ErrorStatus get_status() const
  { return cairo_status(const_cast<cairo_t*>(cobj())); }
  void reference() const;
  void unreference() const;
protected:
  cobject* m_cobject;
};
}
typedef struct _PangoContext PangoContext;
typedef struct _PangoContextClass PangoContextClass;
namespace Pango
{ class Context_Class; }
namespace Pango
{
enum Direction
{
  DIRECTION_LTR,
  DIRECTION_RTL,
  DIRECTION_TTB_LTR,
  DIRECTION_TTB_RTL,
  DIRECTION_WEAK_LTR,
  DIRECTION_WEAK_RTL,
  DIRECTION_NEUTRAL
};
}
namespace Glib
{
template <>
class Value<Pango::Direction> : public Glib::Value_Enum<Pango::Direction>
{
public:
  static GType value_type() __attribute__((__const__));
};
}
namespace Pango
{
enum GravityHint
{
  GRAVITY_HINT_NATURAL,
  GRAVITY_HINT_STRONG,
  GRAVITY_HINT_LINE
};
}
namespace Glib
{
template <>
class Value<Pango::GravityHint> : public Glib::Value_Enum<Pango::GravityHint>
{
public:
  static GType value_type() __attribute__((__const__));
};
}
namespace Pango
{
class Context : public Glib::Object
{
public:
  typedef Context CppObjectType;
  typedef Context_Class CppClassType;
  typedef PangoContext BaseObjectType;
  typedef PangoContextClass BaseClassType;
private: friend class Context_Class;
  static CppClassType context_class_;
private:
  Context(const Context&);
  Context& operator=(const Context&);
protected:
  explicit Context(const Glib::ConstructParams& construct_params);
  explicit Context(PangoContext* castitem);
public:
  virtual ~Context();
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  PangoContext* gobj() { return reinterpret_cast<PangoContext*>(gobject_); }
  const PangoContext* gobj() const { return reinterpret_cast<PangoContext*>(gobject_); }
  PangoContext* gobj_copy();
private:
protected:
  Context();
public:
  Glib::ArrayHandle< Glib::RefPtr<FontFamily> > list_families() const;
  Glib::RefPtr<FontMap> get_font_map();
  Glib::RefPtr<const FontMap> get_font_map() const;
  Glib::RefPtr<Font> load_font(const FontDescription& desc) const;
  Glib::RefPtr<Fontset> load_fontset(const FontDescription& desc, const Language& language) const;
  FontMetrics get_metrics(const FontDescription& desc) const;
  FontMetrics get_metrics(const FontDescription& desc, const Language& language) const;
  void set_font_description(const FontDescription& desc);
  FontDescription get_font_description() const;
  Language get_language() const;
  void set_language(const Language& language);
  void set_base_dir(Direction direction);
  Direction get_base_dir() const;
  void set_base_gravity(Gravity gravity);
  Gravity get_base_gravity() const;
  Gravity get_gravity() const;
  void set_gravity_hint(GravityHint hint);
  GravityHint get_gravity_hint() const;
  void set_matrix(const Matrix& matrix);
  Matrix get_matrix() const;
  ListHandle_Item itemize(const Glib::ustring& text, const AttrList& attrs) const;
  ListHandle_Item itemize(const Glib::ustring& text, int start_index, int length,
                          const AttrList& attrs, AttrIter& cached_iter) const;
  void update_from_cairo_context(const Cairo::RefPtr<Cairo::Context>& context);
  void set_cairo_font_options(const Cairo::FontOptions& options);
  Cairo::FontOptions get_font_options() const;
  void set_resolution(double dpi);
  double get_resolution() const;
public:
public:
protected:
};
}
namespace Glib
{
  Glib::RefPtr<Pango::Context> wrap(PangoContext* object, bool take_copy = false);
}
extern "C" { typedef struct _PangoTabArray PangoTabArray; }
namespace Pango
{
enum TabAlign
{
  TAB_LEFT
};
}
namespace Glib
{
template <>
class Value<Pango::TabAlign> : public Glib::Value_Enum<Pango::TabAlign>
{
public:
  static GType value_type() __attribute__((__const__));
};
}
namespace Pango
{
class TabArray
{
  public:
  typedef TabArray CppObjectType;
  typedef PangoTabArray BaseObjectType;
  static GType get_type() __attribute__((__const__));
  TabArray();
  explicit TabArray(PangoTabArray* gobject, bool make_a_copy = true);
  TabArray(const TabArray& other);
  TabArray& operator=(const TabArray& other);
  ~TabArray();
  void swap(TabArray& other);
  PangoTabArray* gobj() { return gobject_; }
  const PangoTabArray* gobj() const { return gobject_; }
  PangoTabArray* gobj_copy() const;
protected:
  PangoTabArray* gobject_;
private:
public:
  explicit TabArray(int initial_size, bool positions_in_pixels = true);
  int get_size() const;
  void resize(int new_size);
  void set_tab(int tab_index, TabAlign alignment, int location);
  std::pair<TabAlign,int> get_tab(int tab_index) const;
  Glib::ArrayHandle< std::pair<TabAlign,int> > get_tabs() const;
  bool get_positions_in_pixels() const;
};
}
namespace Pango
{
inline void swap(TabArray& lhs, TabArray& rhs)
  { lhs.swap(rhs); }
}
namespace Glib
{
Pango::TabArray wrap(PangoTabArray* object, bool take_copy = false);
template <>
class Value<Pango::TabArray> : public Glib::Value_Boxed<Pango::TabArray>
{};
}
namespace Pango
{
class Layout;
class LayoutLine
{
  public:
  typedef LayoutLine CppObjectType;
  typedef PangoLayoutLine BaseObjectType;
  void reference() const;
  void unreference() const;
  PangoLayoutLine* gobj();
  const PangoLayoutLine* gobj() const;
  PangoLayoutLine* gobj_copy() const;
protected:
  LayoutLine();
  void operator delete(void*, size_t);
private:
  LayoutLine(const LayoutLine&);
  LayoutLine& operator=(const LayoutLine&);
public:
  bool x_to_index(int x_pos, int& index, int& trailing) const;
  int index_to_x(int index, bool trailing) const;
  Glib::ArrayHandle<std::pair<int,int> > get_x_ranges(int start_index, int end_index) const;
  void get_extents(Rectangle& ink_rect, Rectangle& logical_rect) const;
  Rectangle get_ink_extents() const;
  Rectangle get_logical_extents() const;
  void get_pixel_extents(Rectangle& ink_rect, Rectangle& logical_rect) const;
  Rectangle get_pixel_ink_extents() const;
  Rectangle get_pixel_logical_extents() const;
  void show_in_cairo_context(const Cairo::RefPtr<Cairo::Context>& context);
  void add_to_cairo_context(const Cairo::RefPtr<Cairo::Context>& context);
   Glib::RefPtr<Pango::Layout> get_layout();
  Glib::RefPtr<const Pango::Layout> get_layout() const;
   int get_length() const;
    int get_start_index() const;
};
}
namespace Glib
{
Glib::RefPtr<Pango::LayoutLine> wrap(PangoLayoutLine* object, bool take_copy );
}
namespace Pango
{
struct LayoutLineTraits
{
  typedef Glib::RefPtr<LayoutLine> CppType;
  typedef PangoLayoutLine * CType;
  typedef PangoLayoutLine * CTypeNonConst;
  static CType to_c_type (const CppType& ptr) { return Glib::unwrap(ptr); }
  static CType to_c_type (CType ptr) { return ptr; }
  static CppType to_cpp_type (CType ptr) { return Glib::wrap(ptr, true); }
  static void release_c_type (CType ptr) { pango_layout_line_unref(ptr); }
};
typedef Glib::SListHandle< Glib::RefPtr<LayoutLine>, LayoutLineTraits > SListHandle_LayoutLine;
typedef Glib::SListHandle< Glib::RefPtr<const LayoutLine>, LayoutLineTraits > SListHandle_ConstLayoutLine;
}
namespace Glib
{
  Glib::RefPtr<Pango::LayoutLine> wrap(PangoLayoutLine* object, bool take_copy = false);
}
namespace Pango
{
class Item;
class GlyphString;
class LayoutRun
{
  public:
  typedef LayoutRun CppObjectType;
  typedef PangoLayoutRun BaseObjectType;
private:
protected:
  LayoutRun();
public:
  explicit LayoutRun(const PangoLayoutRun* src);
   Item get_item() const;
   GlyphString get_glyphs() const;
  PangoLayoutRun* gobj() { return &gobject_; }
  const PangoLayoutRun* gobj() const { return &gobject_; }
protected:
  PangoLayoutRun gobject_;
};
}
namespace Glib
{
Pango::LayoutRun& wrap(PangoLayoutRun* object);
const Pango::LayoutRun& wrap(const PangoLayoutRun* object);
}
namespace Pango
{
class LayoutIter
{
  public:
  typedef LayoutIter CppObjectType;
  typedef PangoLayoutIter BaseObjectType;
private:
public:
  LayoutIter();
  ~LayoutIter();
  int get_index() const;
  LayoutRun get_run() const;
  Glib::RefPtr<LayoutLine> get_line() const;
  bool at_last_line() const;
  bool next_char();
  bool next_cluster();
  bool next_run();
  bool next_line();
  Rectangle get_char_extents() const;
  void get_cluster_extents(Rectangle& ink_rect, Rectangle& logical_rect) const;
  Rectangle get_cluster_ink_extents() const;
  Rectangle get_cluster_logical_extents() const;
  void get_run_extents(Rectangle& ink_rect, Rectangle& logical_rect) const;
  Rectangle get_run_ink_extents() const;
  Rectangle get_run_logical_extents() const;
  void get_line_extents(Rectangle& ink_rect, Rectangle& logical_rect) const;
  Rectangle get_line_ink_extents() const;
  Rectangle get_line_logical_extents() const;
  void get_line_yrange(int& y0, int& y1) const;
  void get_layout_extents(Rectangle& ink_rect, Rectangle& logical_rect) const;
  Rectangle get_layout_ink_extents() const;
  Rectangle get_layout_logical_extents() const;
  int get_baseline() const;
  PangoLayoutIter* gobj() { return gobject_; }
  const PangoLayoutIter* gobj() const { return gobject_; }
  void assign_gobj(PangoLayoutIter* src);
protected:
  PangoLayoutIter* gobject_;
private:
  LayoutIter(const LayoutIter&);
  LayoutIter& operator=(const LayoutIter&);
};
}
typedef struct _PangoLayout PangoLayout;
typedef struct _PangoLayoutClass PangoLayoutClass;
namespace Pango
{ class Layout_Class; }
namespace Pango
{
enum Alignment
{
  ALIGN_LEFT,
  ALIGN_CENTER,
  ALIGN_RIGHT
};
}
namespace Glib
{
template <>
class Value<Pango::Alignment> : public Glib::Value_Enum<Pango::Alignment>
{
public:
  static GType value_type() __attribute__((__const__));
};
}
namespace Pango
{
enum WrapMode
{
  WRAP_WORD,
  WRAP_CHAR,
  WRAP_WORD_CHAR
};
}
namespace Glib
{
template <>
class Value<Pango::WrapMode> : public Glib::Value_Enum<Pango::WrapMode>
{
public:
  static GType value_type() __attribute__((__const__));
};
}
namespace Pango
{
enum EllipsizeMode
{
  ELLIPSIZE_NONE,
  ELLIPSIZE_START,
  ELLIPSIZE_MIDDLE,
  ELLIPSIZE_END
};
}
namespace Glib
{
template <>
class Value<Pango::EllipsizeMode> : public Glib::Value_Enum<Pango::EllipsizeMode>
{
public:
  static GType value_type() __attribute__((__const__));
};
}
namespace Pango
{
class Layout : public Glib::Object
{
public:
  typedef Layout CppObjectType;
  typedef Layout_Class CppClassType;
  typedef PangoLayout BaseObjectType;
  typedef PangoLayoutClass BaseClassType;
private: friend class Layout_Class;
  static CppClassType layout_class_;
private:
  Layout(const Layout&);
  Layout& operator=(const Layout&);
protected:
  explicit Layout(const Glib::ConstructParams& construct_params);
  explicit Layout(PangoLayout* castitem);
public:
  virtual ~Layout();
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  PangoLayout* gobj() { return reinterpret_cast<PangoLayout*>(gobject_); }
  const PangoLayout* gobj() const { return reinterpret_cast<PangoLayout*>(gobject_); }
  PangoLayout* gobj_copy();
private:
protected:
  explicit Layout(const Glib::RefPtr<Context>& context);
public:
  static Glib::RefPtr<Layout> create(const Glib::RefPtr<Context>& context);
  static Glib::RefPtr<Layout> create(const Cairo::RefPtr<Cairo::Context>& context);
  void update_from_cairo_context(const Cairo::RefPtr<Cairo::Context>& context);
  Glib::RefPtr<Layout> copy();
  Glib::RefPtr<Context> get_context() const;
  void set_attributes(AttrList& attrs);
  AttrList get_attributes() const;
  void set_text(const Glib::ustring& text);
  Glib::ustring get_text() const;
  void set_markup(const Glib::ustring& markup);
  void set_markup(const Glib::ustring& markup, gunichar accel_marker, gunichar& accel_char);
  void set_font_description(const FontDescription& desc);
  void unset_font_description();
  FontDescription get_font_description() const;
  void set_width(int width);
  int get_width() const;
  void set_wrap(WrapMode wrap);
  WrapMode get_wrap() const;
  bool is_wrapped() const;
  void set_indent(int indent);
  int get_indent() const;
  void set_spacing(int spacing);
  int get_spacing() const;
  void set_justify(bool justify = true);
  bool get_justify() const;
  bool get_auto_dir() const;
  void set_auto_dir(bool auto_dir = true);
  void set_alignment(Alignment alignment);
  Alignment get_alignment() const;
  void set_tabs(TabArray& tabs);
  TabArray get_tabs() const;
  void set_single_paragraph_mode(bool setting = true);
  bool get_single_paragraph_mode() const;
  void set_ellipsize(EllipsizeMode ellipsize);
  EllipsizeMode get_ellipsize() const;
  bool is_ellipsized() const;
  int get_unknown_glyphs_count() const;
  void context_changed();
  Glib::ArrayHandle<LogAttr> get_log_attrs() const;
  Rectangle index_to_pos(int index) const;
  void index_to_line_x(int index_, bool trailing, int& line, int& x_pos) const;
  void get_cursor_pos(int index, Rectangle& strong_pos, Rectangle& weak_pos) const;
  Rectangle get_cursor_strong_pos(int index) const;
  Rectangle get_cursor_weak_pos(int index) const;
  void move_cursor_visually(bool strong,
     int old_index, int old_trailing, int direction,
     int& new_index, int& new_trailing) const;
  bool xy_to_index(int x, int y, int& index, int& trailing) const;
  void get_extents(Rectangle& ink_rect, Rectangle& logical_rect) const;
  Rectangle get_ink_extents() const;
  Rectangle get_logical_extents() const;
  void get_pixel_extents(Rectangle& ink_rect, Rectangle& logical_rect) const;
  Rectangle get_pixel_ink_extents() const;
  Rectangle get_pixel_logical_extents() const;
  void get_size(int& width, int& height) const;
  void get_pixel_size(int& width, int& height) const;
  int get_line_count() const;
  Glib::RefPtr<LayoutLine> get_line(int line);
  Glib::RefPtr<const LayoutLine> get_line(int line) const;
  SListHandle_LayoutLine get_lines();
  SListHandle_ConstLayoutLine get_lines() const;
  void get_iter(LayoutIter& iter);
  void add_to_cairo_context(const Cairo::RefPtr<Cairo::Context>& context);
public:
public:
protected:
};
}
namespace Glib
{
  Glib::RefPtr<Pango::Layout> wrap(PangoLayout* object, bool take_copy = false);
}
extern "C" { typedef struct _PangoGlyphString PangoGlyphString; }
namespace Pango
{
class GlyphString
{
  public:
  typedef GlyphString CppObjectType;
  typedef PangoGlyphString BaseObjectType;
  static GType get_type() __attribute__((__const__));
  GlyphString();
  explicit GlyphString(PangoGlyphString* gobject, bool make_a_copy = true);
  GlyphString(const GlyphString& other);
  GlyphString& operator=(const GlyphString& other);
  ~GlyphString();
  void swap(GlyphString& other);
  PangoGlyphString* gobj() { return gobject_; }
  const PangoGlyphString* gobj() const { return gobject_; }
  PangoGlyphString* gobj_copy() const;
protected:
  PangoGlyphString* gobject_;
private:
public:
  GlyphString(const Glib::ustring& text, const Analysis& analysis);
  void set_size (int new_len);
  void get_extents(const Glib::RefPtr<const Font>& font, Rectangle& ink_rect, Rectangle& logical_rect) const;
  void get_extents(int start, int end, const Glib::RefPtr<const Font>& font, Rectangle& ink_rect, Rectangle& logical_rect) const;
  int get_width() const;
  Rectangle get_ink_extents(const Glib::RefPtr<const Font>& font) const;
  Rectangle get_ink_extents(int start, int end, const Glib::RefPtr<const Font>& font) const;
  Rectangle get_logical_extents(const Glib::RefPtr<const Font>& font) const;
  Rectangle get_logical_extents(int start, int end, const Glib::RefPtr<const Font>& font) const;
  Glib::ArrayHandle<int> get_logical_widths(const Glib::ustring& text, int embedding_level) const;
  int index_to_x(const Glib::ustring& text, const Analysis& analysis, int index, bool trailing) const;
  void x_to_index(const Glib::ustring& text, const Analysis& analysis, int x_pos, int& index, bool& trailing) const;
  Glib::ArrayHandle<GlyphInfo> get_glyphs() const;
};
}
namespace Pango
{
inline void swap(GlyphString& lhs, GlyphString& rhs)
  { lhs.swap(rhs); }
}
namespace Glib
{
Pango::GlyphString wrap(PangoGlyphString* object, bool take_copy = false);
template <>
class Value<Pango::GlyphString> : public Glib::Value_Boxed<Pango::GlyphString>
{};
}
extern "C" { typedef struct _GdkColor GdkColor; }
namespace Gdk
{
class Colormap;
class Color
{
  public:
  typedef Color CppObjectType;
  typedef GdkColor BaseObjectType;
  static GType get_type() __attribute__((__const__));
  explicit Color(GdkColor* gobject, bool make_a_copy = true);
  Color(const Color& other);
  Color& operator=(const Color& other);
  ~Color();
  void swap(Color& other);
  GdkColor* gobj() { return gobject_; }
  const GdkColor* gobj() const { return gobject_; }
  GdkColor* gobj_copy() const;
protected:
  GdkColor* gobject_;
private:
public:
  Color();
  explicit Color(const Glib::ustring& value);
  void set_grey(gushort value);
  void set_grey_p(double g);
  void set_rgb(gushort red_, gushort green_, gushort blue_);
  void set_rgb_p(double red_, double green_, double blue_);
  void set_hsv(double h, double s, double v);
  void set_hsl(double h, double s, double l);
  bool set(const Glib::ustring& value);
  bool parse(const Glib::ustring& spec);
  gushort get_red() const;
  gushort get_green() const;
  gushort get_blue() const;
  void set_red(gushort value);
  void set_green(gushort value);
  void set_blue(gushort value);
  void rgb_find_color(const Glib::RefPtr<Gdk::Colormap>& map);
  guint get_pixel() const;
  double get_red_p() const;
  double get_green_p() const;
  double get_blue_p() const;
};
struct ColorTraits
{
  typedef Gdk::Color CppType;
  typedef GdkColor CType;
  typedef GdkColor CTypeNonConst;
  static CType to_c_type (const CppType& obj) { return *obj.gobj(); }
  static CType to_c_type (const CType& obj) { return obj; }
  static CppType to_cpp_type (const CType& obj) { return CppType(const_cast<CType*>(&obj), true); }
  static void release_c_type (const CType&) {}
};
typedef Glib::ArrayHandle<Color,ColorTraits> ArrayHandle_Color;
}
namespace Gdk
{
bool operator==(const Color& lhs, const Color& rhs);
bool operator!=(const Color& lhs, const Color& rhs);
}
namespace Gdk
{
inline void swap(Color& lhs, Color& rhs)
  { lhs.swap(rhs); }
}
namespace Glib
{
Gdk::Color wrap(GdkColor* object, bool take_copy = false);
template <>
class Value<Gdk::Color> : public Glib::Value_Boxed<Gdk::Color>
{};
}
typedef struct _GdkColormap GdkColormap;
typedef struct _GdkColormapClass GdkColormapClass;
namespace Gdk
{ class Colormap_Class; }
namespace Gdk
{
class Colormap : public Glib::Object
{
public:
  typedef Colormap CppObjectType;
  typedef Colormap_Class CppClassType;
  typedef GdkColormap BaseObjectType;
  typedef GdkColormapClass BaseClassType;
private: friend class Colormap_Class;
  static CppClassType colormap_class_;
private:
  Colormap(const Colormap&);
  Colormap& operator=(const Colormap&);
protected:
  explicit Colormap(const Glib::ConstructParams& construct_params);
  explicit Colormap(GdkColormap* castitem);
public:
  virtual ~Colormap();
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GdkColormap* gobj() { return reinterpret_cast<GdkColormap*>(gobject_); }
  const GdkColormap* gobj() const { return reinterpret_cast<GdkColormap*>(gobject_); }
  GdkColormap* gobj_copy();
private:
protected:
  explicit Colormap(const Glib::RefPtr<Visual>& visual, bool allocate);
public:
  static Glib::RefPtr<Colormap> create(const Glib::RefPtr<Visual>& visual, bool allocate);
  static Glib::RefPtr<Colormap> get_system();
  int alloc_colors(ArrayHandle_Color& colors, int ncolors, bool writeable, bool best_match, Glib::ArrayHandle<bool>& success);
  void free_colors(Color& colors, int ncolors);
  bool alloc_color(Color& color, bool writeable = false, bool best_match = true);
  void free_color(Color& color);
  void query_color (gulong pixel, Color& result);
  Glib::RefPtr<Visual> get_visual();
  Glib::RefPtr<const Visual> get_visual() const;
  Glib::RefPtr<Screen> get_screen();
  Glib::RefPtr<const Screen> get_screen() const;
public:
public:
protected:
};
}
namespace Glib
{
  Glib::RefPtr<Gdk::Colormap> wrap(GdkColormap* object, bool take_copy = false);
}
typedef struct _GdkImage GdkImage;
typedef struct _GdkImageClass GdkImageClass;
namespace Gdk
{ class Image_Class; }
namespace Gdk
{
enum ImageType
{
  IMAGE_NORMAL,
  IMAGE_SHARED,
  IMAGE_FASTEST
};
}
namespace Glib
{
template <>
class Value<Gdk::ImageType> : public Glib::Value_Enum<Gdk::ImageType>
{
public:
  static GType value_type() __attribute__((__const__));
};
}
namespace Gdk
{
class Image : public Glib::Object
{
public:
  typedef Image CppObjectType;
  typedef Image_Class CppClassType;
  typedef GdkImage BaseObjectType;
  typedef GdkImageClass BaseClassType;
private: friend class Image_Class;
  static CppClassType image_class_;
private:
  Image(const Image&);
  Image& operator=(const Image&);
protected:
  explicit Image(const Glib::ConstructParams& construct_params);
  explicit Image(GdkImage* castitem);
public:
  virtual ~Image();
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GdkImage* gobj() { return reinterpret_cast<GdkImage*>(gobject_); }
  const GdkImage* gobj() const { return reinterpret_cast<GdkImage*>(gobject_); }
  GdkImage* gobj_copy();
private:
protected:
  Image(ImageType type, const Glib::RefPtr<Visual>& visual, int width, int height);
public:
  static Glib::RefPtr<Image> create(ImageType type, const Glib::RefPtr<Visual>& visual, int width, int height);
  void put_pixel(int x, int y, guint32 pixel);
  guint32 get_pixel(int x, int y) const;
  void set_colormap(const Glib::RefPtr<Colormap>& colormap);
  Glib::RefPtr<Colormap> get_colormap();
  Glib::RefPtr<const Colormap> get_colormap() const;
   ImageType get_image_type() const;
    Glib::RefPtr<Visual> get_visual();
  Glib::RefPtr<const Visual> get_visual() const;
    ByteOrder get_byte_order() const;
    int get_width() const;
    int get_height() const;
    guint16 get_bpp() const;
    guint16 get_bpl() const;
    guint16 get_bits_per_pixel() const;
   void* get_mem();
  const void* get_mem() const;
   void* get_windowing_data() const;
public:
public:
protected:
};
}
namespace Glib
{
  Glib::RefPtr<Gdk::Image> wrap(GdkImage* object, bool take_copy = false);
}
extern "C" { typedef struct _GdkRegion GdkRegion; }
namespace Gdk
{
enum FillRule
{
  EVEN_ODD_RULE,
  WINDING_RULE
};
}
namespace Glib
{
template <>
class Value<Gdk::FillRule> : public Glib::Value_Enum<Gdk::FillRule>
{
public:
  static GType value_type() __attribute__((__const__));
};
}
namespace Gdk
{
enum OverlapType
{
  OVERLAP_RECTANGLE_IN,
  OVERLAP_RECTANGLE_OUT,
  OVERLAP_RECTANGLE_PART
};
}
namespace Glib
{
template <>
class Value<Gdk::OverlapType> : public Glib::Value_Enum<Gdk::OverlapType>
{
public:
  static GType value_type() __attribute__((__const__));
};
}
namespace Gdk
{
class Region
{
  public:
  typedef Region CppObjectType;
  typedef GdkRegion BaseObjectType;
  Region();
  explicit Region(GdkRegion* castitem, bool make_a_copy = false);
  Region(const Region& src);
  Region& operator=(const Region& src);
  ~Region();
  GdkRegion* gobj() { return gobject_; }
  const GdkRegion* gobj() const { return gobject_; }
  GdkRegion* gobj_copy() const;
protected:
  GdkRegion* gobject_;
private:
public:
  Region(const Glib::ArrayHandle<Gdk::Point>& points, FillRule fill_rule);
  explicit Region(const Rectangle& rectangle);
  void get_clipbox(const Rectangle& rectangle);
  Glib::ArrayHandle<Rectangle> get_rectangles() const;
  bool empty();
  bool point_in(int x, int y);
  OverlapType rect_in(const Rectangle& rect);
  void offset(int dx, int dy);
  void shrink(int dx, int dy);
  void union_with_rect(const Rectangle& rect);
  void intersect(const Region& source2);
  void union_(const Region& source2);
  void subtract(const Region& source2);
  void xor_(const Region& source2);
  void spans_intersect_foreach(GdkSpan* spans, int n_spans, bool sorted, GdkSpanFunc function, gpointer data);
};
}
namespace Gdk
{
bool operator==(const Region& lhs, const Region& rhs);
bool operator!=(const Region& lhs, const Region& rhs);
}
namespace Glib
{
Gdk::Region wrap(GdkRegion* object, bool take_copy = false);
}
extern "C" { typedef struct _GdkRgbCmap GdkRgbCmap; }
namespace Gdk
{
class RgbCmap
{
  public:
  typedef RgbCmap CppObjectType;
  typedef GdkRgbCmap BaseObjectType;
private:
public:
  explicit RgbCmap(const Glib::ArrayHandle<guint32>& colors);
  virtual ~RgbCmap();
  unsigned long size() const;
  guint32& operator[](unsigned long index);
  const guint32& operator[](unsigned long index) const;
  GdkRgbCmap* gobj() { return gobject_; }
  const GdkRgbCmap* gobj() const { return gobject_; }
protected:
  GdkRgbCmap* gobject_;
private:
  RgbCmap(const RgbCmap&);
  RgbCmap& operator=(const RgbCmap&);
};
}
typedef struct _GdkDrawable GdkDrawable;
typedef struct _GdkDrawableClass GdkDrawableClass;
namespace Gdk
{ class Drawable_Class; }
namespace Gdk
{
enum RgbDither
{
  RGB_DITHER_NONE,
  RGB_DITHER_NORMAL,
  RGB_DITHER_MAX
};
}
namespace Glib
{
template <>
class Value<Gdk::RgbDither> : public Glib::Value_Enum<Gdk::RgbDither>
{
public:
  static GType value_type() __attribute__((__const__));
};
}
namespace Gdk
{
class GC;
class Pixbuf;
class Drawable : public Glib::Object
{
public:
  typedef Drawable CppObjectType;
  typedef Drawable_Class CppClassType;
  typedef GdkDrawable BaseObjectType;
  typedef GdkDrawableClass BaseClassType;
private: friend class Drawable_Class;
  static CppClassType drawable_class_;
private:
  Drawable(const Drawable&);
  Drawable& operator=(const Drawable&);
protected:
  explicit Drawable(const Glib::ConstructParams& construct_params);
  explicit Drawable(GdkDrawable* castitem);
public:
  virtual ~Drawable();
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GdkDrawable* gobj() { return reinterpret_cast<GdkDrawable*>(gobject_); }
  const GdkDrawable* gobj() const { return reinterpret_cast<GdkDrawable*>(gobject_); }
  GdkDrawable* gobj_copy();
private:
protected:
  Drawable();
public:
  static Glib::RefPtr<Drawable> create();
  void get_size(int& width, int& height);
  int get_depth() const;
  void set_colormap(const Glib::RefPtr<Colormap>& colormap);
  Glib::RefPtr<Colormap> get_colormap();
  Glib::RefPtr<Visual> get_visual();
  void draw_point(const Glib::RefPtr<const GC>& gc, int x, int y);
  void draw_points(const Glib::RefPtr<const GC>& gc, const Glib::ArrayHandle<Point>& points);
  void draw_line(const Glib::RefPtr<const GC>& gc, int x1, int y1, int x2, int y2);
  void draw_lines(const Glib::RefPtr<const GC>& gc, const Glib::ArrayHandle<Point>& points);
  void draw_rectangle(const Glib::RefPtr<const GC>& gc, bool filled, int x, int y, int width, int height);
  void draw_arc(const Glib::RefPtr<const GC>& gc, bool filled, int x, int y, int width, int height, int angle1, int angle2);
  void draw_polygon(const Glib::RefPtr<const GC>& gc, bool filled, const Glib::ArrayHandle<Point>& points);
  void draw_drawable(const Glib::RefPtr<const GC>& gc, const Glib::RefPtr<const Drawable>& src, int xsrc, int ysrc, int xdest, int ydest, int width = -1, int height = -1);
  void draw_image(const Glib::RefPtr<const GC>& gc, const Glib::RefPtr<const Image>& image, int xsrc, int ysrc, int xdest, int ydest, int width = -1, int height = -1);
  void draw_segments(const Glib::RefPtr<const GC>& gc, GdkSegment* segs, int nsegs);
  void draw_glyphs(const Glib::RefPtr<const GC>& gc, const Glib::RefPtr<const Pango::Font>& font, int x, int y, const Pango::GlyphString& glyphs);
  void draw_layout_line(const Glib::RefPtr<const GC>& gc, int x, int y, const Glib::RefPtr<const Pango::LayoutLine>& line);
  void draw_layout_line(const Glib::RefPtr<const GC>& gc, int x, int y, const Glib::RefPtr<const Pango::LayoutLine>& line, const Color& foreground, const Color& background);
  void draw_layout(const Glib::RefPtr<const GC>& gc, int x, int y, const Glib::RefPtr<const Pango::Layout>& layout);
  void draw_layout(const Glib::RefPtr<const GC>& gc, int x, int y, const Glib::RefPtr<const Pango::Layout>& layout, const Color& foreground, const Color& background);
  void draw_pixbuf(const Glib::RefPtr<const GC>& gc, const Glib::RefPtr<Pixbuf>& pixbuf,
    int src_x, int src_y, int dest_x, int dest_y,
    int width, int height,
    RgbDither dither, int x_dither, int y_dither);
  Glib::RefPtr<Image> get_image(int x, int y, int width, int height) const;
  void copy_to_image(const Glib::RefPtr<Image>& image, int src_x, int src_y, int dest_x, int dest_y, int width, int height) const;
  Region get_clip_region() const;
  Region get_visible_region() const;
  void draw_rgb_image(
                   const Glib::RefPtr<const GC>& gc,
                   int x, int y, int width, int height,
                   RgbDither dith, const guchar* rgb_buf, int rowstride);
  void draw_rgb_image_dithalign(
                   const Glib::RefPtr<const GC>& gc,
                   int x, int y, int width, int height,
                   RgbDither dith, const guchar* rgb_buf, int rowstride,
                   int xdith, int ydith);
  void draw_rgb_32_image(
                   const Glib::RefPtr<const GC>& gc,
                   int x, int y, int width, int height,
                   RgbDither dith, const guchar* rgb_buf, int rowstride);
  void draw_rgb_32_image_dithalign(
                   const Glib::RefPtr<const GC>& gc,
                   int x, int y, int width, int height,
                   RgbDither dith, const guchar* buf, int rowstride,
                   int xdith, int ydith);
  void draw_gray_image(
                   const Glib::RefPtr<const GC>& gc,
                   int x, int y, int width, int height,
                   RgbDither dith, const guchar* rgb_buf, int rowstride);
  void draw_indexed_image(
                   const Glib::RefPtr<const GC>& gc,
                   int x, int y, int width, int height,
                   RgbDither dith, const guchar* rgb_buf, int rowstride,
                   const RgbCmap& cmap);
  Glib::RefPtr<Screen> get_screen();
  Glib::RefPtr<const Screen> get_screen() const;
  Glib::RefPtr<Display> get_display();
  Glib::RefPtr<const Display> get_display() const;
  Cairo::RefPtr<Cairo::Context> create_cairo_context();
public:
public:
protected:
};
}
namespace Glib
{
  Glib::RefPtr<Gdk::Drawable> wrap(GdkDrawable* object, bool take_copy = false);
}
typedef struct _GdkGC GdkGC;
typedef struct _GdkGCClass GdkGCClass;
namespace Gdk
{ class GC_Class; }
namespace Gdk
{
enum LineStyle
{
  LINE_SOLID,
  LINE_ON_OFF_DASH,
  LINE_DOUBLE_DASH
};
}
namespace Glib
{
template <>
class Value<Gdk::LineStyle> : public Glib::Value_Enum<Gdk::LineStyle>
{
public:
  static GType value_type() __attribute__((__const__));
};
}
namespace Gdk
{
enum CapStyle
{
  CAP_NOT_LAST,
  CAP_BUTT,
  CAP_ROUND,
  CAP_PROJECTING
};
}
namespace Glib
{
template <>
class Value<Gdk::CapStyle> : public Glib::Value_Enum<Gdk::CapStyle>
{
public:
  static GType value_type() __attribute__((__const__));
};
}
namespace Gdk
{
enum JoinStyle
{
  JOIN_MITER,
  JOIN_ROUND,
  JOIN_BEVEL
};
}
namespace Glib
{
template <>
class Value<Gdk::JoinStyle> : public Glib::Value_Enum<Gdk::JoinStyle>
{
public:
  static GType value_type() __attribute__((__const__));
};
}
namespace Gdk
{
enum Fill
{
  SOLID,
  TILED,
  STIPPLED,
  OPAQUE_STIPPLED
};
}
namespace Glib
{
template <>
class Value<Gdk::Fill> : public Glib::Value_Enum<Gdk::Fill>
{
public:
  static GType value_type() __attribute__((__const__));
};
}
namespace Gdk
{
enum Function
{
  COPY,
  INVERT,
  XOR,
  CLEAR,
  AND,
  AND_REVERSE,
  AND_INVERT,
  NOOP,
  OR,
  EQUIV,
  OR_REVERSE,
  COPY_INVERT,
  OR_INVERT,
  NAND,
  NOR,
  SET
};
}
namespace Glib
{
template <>
class Value<Gdk::Function> : public Glib::Value_Enum<Gdk::Function>
{
public:
  static GType value_type() __attribute__((__const__));
};
}
namespace Gdk
{
enum SubwindowMode
{
  CLIP_BY_CHILDREN,
  INCLUDE_INFERIORS
};
}
namespace Glib
{
template <>
class Value<Gdk::SubwindowMode> : public Glib::Value_Enum<Gdk::SubwindowMode>
{
public:
  static GType value_type() __attribute__((__const__));
};
}
namespace Gdk
{
enum GCValuesMask
{
  GC_FOREGROUND = 1 << 0,
  GC_BACKGROUND = 1 << 1,
  GC_FONT = 1 << 2,
  GC_FUNCTION = 1 << 3,
  GC_FILL = 1 << 4,
  GC_TILE = 1 << 5,
  GC_STIPPLE = 1 << 6,
  GC_CLIP_MASK = 1 << 7,
  GC_SUBWINDOW = 1 << 8,
  GC_TS_X_ORIGIN = 1 << 9,
  GC_TS_Y_ORIGIN = 1 << 10,
  GC_CLIP_X_ORIGIN = 1 << 11,
  GC_CLIP_Y_ORIGIN = 1 << 12,
  GC_EXPOSURES = 1 << 13,
  GC_LINE_WIDTH = 1 << 14,
  GC_LINE_STYLE = 1 << 15,
  GC_CAP_STYLE = 1 << 16,
  GC_JOIN_STYLE = 1 << 17
};
inline GCValuesMask operator|(GCValuesMask lhs, GCValuesMask rhs)
  { return static_cast<GCValuesMask>(static_cast<unsigned>(lhs) | static_cast<unsigned>(rhs)); }
inline GCValuesMask operator&(GCValuesMask lhs, GCValuesMask rhs)
  { return static_cast<GCValuesMask>(static_cast<unsigned>(lhs) & static_cast<unsigned>(rhs)); }
inline GCValuesMask operator^(GCValuesMask lhs, GCValuesMask rhs)
  { return static_cast<GCValuesMask>(static_cast<unsigned>(lhs) ^ static_cast<unsigned>(rhs)); }
inline GCValuesMask operator~(GCValuesMask flags)
  { return static_cast<GCValuesMask>(~static_cast<unsigned>(flags)); }
inline GCValuesMask& operator|=(GCValuesMask& lhs, GCValuesMask rhs)
  { return (lhs = static_cast<GCValuesMask>(static_cast<unsigned>(lhs) | static_cast<unsigned>(rhs))); }
inline GCValuesMask& operator&=(GCValuesMask& lhs, GCValuesMask rhs)
  { return (lhs = static_cast<GCValuesMask>(static_cast<unsigned>(lhs) & static_cast<unsigned>(rhs))); }
inline GCValuesMask& operator^=(GCValuesMask& lhs, GCValuesMask rhs)
  { return (lhs = static_cast<GCValuesMask>(static_cast<unsigned>(lhs) ^ static_cast<unsigned>(rhs))); }
}
namespace Glib
{
template <>
class Value<Gdk::GCValuesMask> : public Glib::Value_Flags<Gdk::GCValuesMask>
{
public:
  static GType value_type() __attribute__((__const__));
};
}
namespace Gdk
{
class Drawable;
class GC : public Glib::Object
{
public:
  typedef GC CppObjectType;
  typedef GC_Class CppClassType;
  typedef GdkGC BaseObjectType;
  typedef GdkGCClass BaseClassType;
private: friend class GC_Class;
  static CppClassType gc_class_;
private:
  GC(const GC&);
  GC& operator=(const GC&);
protected:
  explicit GC(const Glib::ConstructParams& construct_params);
  explicit GC(GdkGC* castitem);
public:
  virtual ~GC();
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GdkGC* gobj() { return reinterpret_cast<GdkGC*>(gobject_); }
  const GdkGC* gobj() const { return reinterpret_cast<GdkGC*>(gobject_); }
  GdkGC* gobj_copy();
private:
protected:
  GC();
  explicit GC(const Glib::RefPtr<Drawable>& drawable);
public:
  static Glib::RefPtr<GC> create();
  static Glib::RefPtr<GC> create(const Glib::RefPtr<Drawable>& drawable);
  void set_foreground(const Color& color);
  void set_background(const Color& color);
  void set_function(Function function);
  void set_fill(Fill fill);
  void set_tile(const Glib::RefPtr<Pixmap>& tile);
  void set_stipple(const Glib::RefPtr<Pixmap>& stipple);
  void set_ts_origin(int x, int y);
  void set_clip_origin(int x, int y);
  void set_clip_mask(const Glib::RefPtr<Bitmap>& mask);
  void set_clip_rectangle(Rectangle& rectangle);
  void set_clip_rectangle(const Rectangle& rectangle);
  void set_clip_region(const Region& region);
  void set_subwindow(SubwindowMode mode);
  void set_exposures(bool exposures);
  void set_line_attributes(int line_width, LineStyle line_style, CapStyle cap_style, JoinStyle join_style);
  void set_dashes(int dash_offset, gint8* dash_list, int n);
  void offset(int x_offset, int y_offset);
  void set_colormap(const Glib::RefPtr<Colormap>& colormap);
  Glib::RefPtr<Colormap> get_colormap();
  void set_rgb_fg_color(const Color& color);
  void set_rgb_bg_color(const Color& color);
  Glib::RefPtr<Screen> get_screen();
  Glib::RefPtr<const Screen> get_screen() const;
public:
public:
protected:
};
}
namespace Glib
{
  Glib::RefPtr<Gdk::GC> wrap(GdkGC* object, bool take_copy = false);
}
extern "C" {
typedef struct _GdkDrawable GdkPixmap;
typedef struct _GdkPixmapClass GdkPixmapClass;
}
namespace Gdk
{ class Pixmap_Class; }
namespace Gdk
{
class Window;
class Pixmap : public Gdk::Drawable
{
public:
  typedef Pixmap CppObjectType;
  typedef Pixmap_Class CppClassType;
  typedef GdkPixmap BaseObjectType;
  typedef GdkPixmapObjectClass BaseClassType;
private: friend class Pixmap_Class;
  static CppClassType pixmap_class_;
private:
  Pixmap(const Pixmap&);
  Pixmap& operator=(const Pixmap&);
protected:
  explicit Pixmap(const Glib::ConstructParams& construct_params);
  explicit Pixmap(GdkPixmap* castitem);
public:
  virtual ~Pixmap();
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GdkPixmap* gobj() { return reinterpret_cast<GdkPixmap*>(gobject_); }
  const GdkPixmap* gobj() const { return reinterpret_cast<GdkPixmap*>(gobject_); }
  GdkPixmap* gobj_copy();
private:
protected:
  Pixmap();
  Pixmap(const Glib::RefPtr<Drawable>& drawable, int width, int height, int depth = -1);
  Pixmap(const Glib::RefPtr<Drawable>& drawable,
         const char* data, int width, int height, int depth,
         const Color& fg, const Color& bg);
  Pixmap(const Glib::RefPtr<Display>& display, NativeWindow anid);
public:
  static Glib::RefPtr<Pixmap> create(const Glib::RefPtr<Drawable>& drawable, int width, int height, int depth = -1);
  static Glib::RefPtr<Pixmap> create(const Glib::RefPtr<Drawable>& drawable, const char* data, int width, int height, int depth, const Color& fg, const Color& bg);
  static Glib::RefPtr<Pixmap> create(const Glib::RefPtr<Display>& display, NativeWindow anid);
  static Glib::RefPtr<Pixmap> create_from_data(const Glib::RefPtr<const Drawable>& drawable,
                                               const char* data, int width, int height, int depth,
                                               const Color& fg, const Color& bg);
  static Glib::RefPtr<Pixmap> create_from_xpm(const Glib::RefPtr<const Drawable>& drawable,
                                              const Color& transparent_color,
                                              const std::string& filename);
  static Glib::RefPtr<Pixmap> create_from_xpm(const Glib::RefPtr<const Drawable>& drawable,
                                              Glib::RefPtr<Bitmap>& mask,
                                              const Color& transparent_color,
                                              const std::string& filename);
  static Glib::RefPtr<Pixmap> create_from_xpm(const Glib::RefPtr<const Drawable>& drawable,
                                              const Glib::RefPtr<Colormap>& colormap,
                                              Glib::RefPtr<Bitmap>& mask,
                                              const Color& transparent_color,
                                              const std::string& filename);
  static Glib::RefPtr<Pixmap> create_from_xpm(const Glib::RefPtr<const Drawable>& drawable,
                                              Glib::RefPtr<Bitmap>& mask,
                                              const Color& transparent_color,
                                              const char* const* data);
  static Glib::RefPtr<Pixmap> create_from_xpm(const Glib::RefPtr<const Drawable>& drawable,
                                              const Glib::RefPtr<Colormap>& colormap,
                                              Glib::RefPtr<Bitmap>& mask,
                                              const Color& transparent_color,
                                              const char* const* data);
  static Glib::RefPtr<Pixmap> create_from_xpm(const Glib::RefPtr<Colormap>& colormap,
                                              Glib::RefPtr<Bitmap>& mask,
                                              const Color& transparent_color,
                                              const char* const* data);
  static Glib::RefPtr<Pixmap> create_from_xpm(const Glib::RefPtr<Colormap>& colormap,
                                              Glib::RefPtr<Bitmap>& mask,
                                              const char* const* data);
public:
public:
protected:
};
}
namespace Glib
{
  Glib::RefPtr<Gdk::Pixmap> wrap(GdkPixmapObject* object, bool take_copy = false);
}
namespace Gdk
{
class Window;
class Bitmap : public Gdk::Pixmap
{
  public:
  typedef Bitmap CppObjectType;
  typedef GdkBitmap BaseObjectType;
private:
protected:
  explicit Bitmap(GdkBitmap* castitem);
  friend class Gdk::Pixmap_Class;
  Bitmap(const char* data, int width, int height);
  Bitmap(const Glib::RefPtr<Gdk::Drawable>& drawable, const char* data, int width, int height);
public:
  static Glib::RefPtr<Bitmap> create(const char* data, int width, int height);
  static Glib::RefPtr<Bitmap> create(const Glib::RefPtr<Gdk::Drawable>& drawable, const char* data, int width, int height);
};
}
extern "C" {
typedef struct _GdkDrawable GdkWindow;
}
namespace Gdk
{ class Window_Class; }
namespace Gdk
{
enum EventMask
{
  EXPOSURE_MASK = 1 << 1,
  POINTER_MOTION_MASK = 1 << 2,
  POINTER_MOTION_HINT_MASK = 1 << 3,
  BUTTON_MOTION_MASK = 1 << 4,
  BUTTON1_MOTION_MASK = 1 << 5,
  BUTTON2_MOTION_MASK = 1 << 6,
  BUTTON3_MOTION_MASK = 1 << 7,
  BUTTON_PRESS_MASK = 1 << 8,
  BUTTON_RELEASE_MASK = 1 << 9,
  KEY_PRESS_MASK = 1 << 10,
  KEY_RELEASE_MASK = 1 << 11,
  ENTER_NOTIFY_MASK = 1 << 12,
  LEAVE_NOTIFY_MASK = 1 << 13,
  FOCUS_CHANGE_MASK = 1 << 14,
  STRUCTURE_MASK = 1 << 15,
  PROPERTY_CHANGE_MASK = 1 << 16,
  VISIBILITY_NOTIFY_MASK = 1 << 17,
  PROXIMITY_IN_MASK = 1 << 18,
  PROXIMITY_OUT_MASK = 1 << 19,
  SUBSTRUCTURE_MASK = 1 << 20,
  SCROLL_MASK = 1 << 21,
  ALL_EVENTS_MASK = 0x3FFFFE
};
inline EventMask operator|(EventMask lhs, EventMask rhs)
  { return static_cast<EventMask>(static_cast<unsigned>(lhs) | static_cast<unsigned>(rhs)); }
inline EventMask operator&(EventMask lhs, EventMask rhs)
  { return static_cast<EventMask>(static_cast<unsigned>(lhs) & static_cast<unsigned>(rhs)); }
inline EventMask operator^(EventMask lhs, EventMask rhs)
  { return static_cast<EventMask>(static_cast<unsigned>(lhs) ^ static_cast<unsigned>(rhs)); }
inline EventMask operator~(EventMask flags)
  { return static_cast<EventMask>(~static_cast<unsigned>(flags)); }
inline EventMask& operator|=(EventMask& lhs, EventMask rhs)
  { return (lhs = static_cast<EventMask>(static_cast<unsigned>(lhs) | static_cast<unsigned>(rhs))); }
inline EventMask& operator&=(EventMask& lhs, EventMask rhs)
  { return (lhs = static_cast<EventMask>(static_cast<unsigned>(lhs) & static_cast<unsigned>(rhs))); }
inline EventMask& operator^=(EventMask& lhs, EventMask rhs)
  { return (lhs = static_cast<EventMask>(static_cast<unsigned>(lhs) ^ static_cast<unsigned>(rhs))); }
}
namespace Glib
{
template <>
class Value<Gdk::EventMask> : public Glib::Value_Flags<Gdk::EventMask>
{
public:
  static GType value_type() __attribute__((__const__));
};
}
namespace Gdk
{
enum WindowState
{
  WINDOW_STATE_WITHDRAWN = 1 << 0,
  WINDOW_STATE_ICONIFIED = 1 << 1,
  WINDOW_STATE_MAXIMIZED = 1 << 2,
  WINDOW_STATE_STICKY = 1 << 3,
  WINDOW_STATE_FULLSCREEN = 1 << 4,
  WINDOW_STATE_ABOVE = 1 << 5,
  WINDOW_STATE_BELOW = 1 << 6
};
inline WindowState operator|(WindowState lhs, WindowState rhs)
  { return static_cast<WindowState>(static_cast<unsigned>(lhs) | static_cast<unsigned>(rhs)); }
inline WindowState operator&(WindowState lhs, WindowState rhs)
  { return static_cast<WindowState>(static_cast<unsigned>(lhs) & static_cast<unsigned>(rhs)); }
inline WindowState operator^(WindowState lhs, WindowState rhs)
  { return static_cast<WindowState>(static_cast<unsigned>(lhs) ^ static_cast<unsigned>(rhs)); }
inline WindowState operator~(WindowState flags)
  { return static_cast<WindowState>(~static_cast<unsigned>(flags)); }
inline WindowState& operator|=(WindowState& lhs, WindowState rhs)
  { return (lhs = static_cast<WindowState>(static_cast<unsigned>(lhs) | static_cast<unsigned>(rhs))); }
inline WindowState& operator&=(WindowState& lhs, WindowState rhs)
  { return (lhs = static_cast<WindowState>(static_cast<unsigned>(lhs) & static_cast<unsigned>(rhs))); }
inline WindowState& operator^=(WindowState& lhs, WindowState rhs)
  { return (lhs = static_cast<WindowState>(static_cast<unsigned>(lhs) ^ static_cast<unsigned>(rhs))); }
}
namespace Glib
{
template <>
class Value<Gdk::WindowState> : public Glib::Value_Flags<Gdk::WindowState>
{
public:
  static GType value_type() __attribute__((__const__));
};
}
namespace Gdk
{
enum WindowType
{
  WINDOW_ROOT,
  WINDOW_TOPLEVEL,
  WINDOW_CHILD,
  WINDOW_DIALOG,
  WINDOW_TEMP,
  WINDOW_FOREIGN
};
}
namespace Glib
{
template <>
class Value<Gdk::WindowType> : public Glib::Value_Enum<Gdk::WindowType>
{
public:
  static GType value_type() __attribute__((__const__));
};
}
namespace Gdk
{
enum WindowAttributesType
{
  WA_TITLE = 1 << 1,
  WA_X = 1 << 2,
  WA_Y = 1 << 3,
  WA_CURSOR = 1 << 4,
  WA_COLORMAP = 1 << 5,
  WA_VISUAL = 1 << 6,
  WA_WMCLASS = 1 << 7,
  WA_NOREDIR = 1 << 8,
  WA_TYPE_HINT = 1 << 9
};
inline WindowAttributesType operator|(WindowAttributesType lhs, WindowAttributesType rhs)
  { return static_cast<WindowAttributesType>(static_cast<unsigned>(lhs) | static_cast<unsigned>(rhs)); }
inline WindowAttributesType operator&(WindowAttributesType lhs, WindowAttributesType rhs)
  { return static_cast<WindowAttributesType>(static_cast<unsigned>(lhs) & static_cast<unsigned>(rhs)); }
inline WindowAttributesType operator^(WindowAttributesType lhs, WindowAttributesType rhs)
  { return static_cast<WindowAttributesType>(static_cast<unsigned>(lhs) ^ static_cast<unsigned>(rhs)); }
inline WindowAttributesType operator~(WindowAttributesType flags)
  { return static_cast<WindowAttributesType>(~static_cast<unsigned>(flags)); }
inline WindowAttributesType& operator|=(WindowAttributesType& lhs, WindowAttributesType rhs)
  { return (lhs = static_cast<WindowAttributesType>(static_cast<unsigned>(lhs) | static_cast<unsigned>(rhs))); }
inline WindowAttributesType& operator&=(WindowAttributesType& lhs, WindowAttributesType rhs)
  { return (lhs = static_cast<WindowAttributesType>(static_cast<unsigned>(lhs) & static_cast<unsigned>(rhs))); }
inline WindowAttributesType& operator^=(WindowAttributesType& lhs, WindowAttributesType rhs)
  { return (lhs = static_cast<WindowAttributesType>(static_cast<unsigned>(lhs) ^ static_cast<unsigned>(rhs))); }
}
namespace Glib
{
template <>
class Value<Gdk::WindowAttributesType> : public Glib::Value_Flags<Gdk::WindowAttributesType>
{
public:
  static GType value_type() __attribute__((__const__));
};
}
namespace Gdk
{
enum WindowHints
{
  HINT_POS = 1 << 0,
  HINT_MIN_SIZE = 1 << 1,
  HINT_MAX_SIZE = 1 << 2,
  HINT_BASE_SIZE = 1 << 3,
  HINT_ASPECT = 1 << 4,
  HINT_RESIZE_INC = 1 << 5,
  HINT_WIN_GRAVITY = 1 << 6,
  HINT_USER_POS = 1 << 7,
  HINT_USER_SIZE = 1 << 8
};
inline WindowHints operator|(WindowHints lhs, WindowHints rhs)
  { return static_cast<WindowHints>(static_cast<unsigned>(lhs) | static_cast<unsigned>(rhs)); }
inline WindowHints operator&(WindowHints lhs, WindowHints rhs)
  { return static_cast<WindowHints>(static_cast<unsigned>(lhs) & static_cast<unsigned>(rhs)); }
inline WindowHints operator^(WindowHints lhs, WindowHints rhs)
  { return static_cast<WindowHints>(static_cast<unsigned>(lhs) ^ static_cast<unsigned>(rhs)); }
inline WindowHints operator~(WindowHints flags)
  { return static_cast<WindowHints>(~static_cast<unsigned>(flags)); }
inline WindowHints& operator|=(WindowHints& lhs, WindowHints rhs)
  { return (lhs = static_cast<WindowHints>(static_cast<unsigned>(lhs) | static_cast<unsigned>(rhs))); }
inline WindowHints& operator&=(WindowHints& lhs, WindowHints rhs)
  { return (lhs = static_cast<WindowHints>(static_cast<unsigned>(lhs) & static_cast<unsigned>(rhs))); }
inline WindowHints& operator^=(WindowHints& lhs, WindowHints rhs)
  { return (lhs = static_cast<WindowHints>(static_cast<unsigned>(lhs) ^ static_cast<unsigned>(rhs))); }
}
namespace Glib
{
template <>
class Value<Gdk::WindowHints> : public Glib::Value_Flags<Gdk::WindowHints>
{
public:
  static GType value_type() __attribute__((__const__));
};
}
namespace Gdk
{
enum WindowTypeHint
{
  WINDOW_TYPE_HINT_NORMAL,
  WINDOW_TYPE_HINT_DIALOG,
  WINDOW_TYPE_HINT_MENU,
  WINDOW_TYPE_HINT_TOOLBAR,
  WINDOW_TYPE_HINT_SPLASHSCREEN,
  WINDOW_TYPE_HINT_UTILITY,
  WINDOW_TYPE_HINT_DOCK,
  WINDOW_TYPE_HINT_DESKTOP,
  WINDOW_TYPE_HINT_DROPDOWN_MENU,
  WINDOW_TYPE_HINT_POPUP_MENU,
  WINDOW_TYPE_HINT_TOOLTIP,
  WINDOW_TYPE_HINT_NOTIFICATION,
  WINDOW_TYPE_HINT_COMBO,
  WINDOW_TYPE_HINT_DND
};
}
namespace Glib
{
template <>
class Value<Gdk::WindowTypeHint> : public Glib::Value_Enum<Gdk::WindowTypeHint>
{
public:
  static GType value_type() __attribute__((__const__));
};
}
namespace Gdk
{
enum WMDecoration
{
  DECOR_ALL = 1 << 0,
  DECOR_BORDER = 1 << 1,
  DECOR_RESIZEH = 1 << 2,
  DECOR_TITLE = 1 << 3,
  DECOR_MENU = 1 << 4,
  DECOR_MINIMIZE = 1 << 5,
  DECOR_MAXIMIZE = 1 << 6
};
inline WMDecoration operator|(WMDecoration lhs, WMDecoration rhs)
  { return static_cast<WMDecoration>(static_cast<unsigned>(lhs) | static_cast<unsigned>(rhs)); }
inline WMDecoration operator&(WMDecoration lhs, WMDecoration rhs)
  { return static_cast<WMDecoration>(static_cast<unsigned>(lhs) & static_cast<unsigned>(rhs)); }
inline WMDecoration operator^(WMDecoration lhs, WMDecoration rhs)
  { return static_cast<WMDecoration>(static_cast<unsigned>(lhs) ^ static_cast<unsigned>(rhs)); }
inline WMDecoration operator~(WMDecoration flags)
  { return static_cast<WMDecoration>(~static_cast<unsigned>(flags)); }
inline WMDecoration& operator|=(WMDecoration& lhs, WMDecoration rhs)
  { return (lhs = static_cast<WMDecoration>(static_cast<unsigned>(lhs) | static_cast<unsigned>(rhs))); }
inline WMDecoration& operator&=(WMDecoration& lhs, WMDecoration rhs)
  { return (lhs = static_cast<WMDecoration>(static_cast<unsigned>(lhs) & static_cast<unsigned>(rhs))); }
inline WMDecoration& operator^=(WMDecoration& lhs, WMDecoration rhs)
  { return (lhs = static_cast<WMDecoration>(static_cast<unsigned>(lhs) ^ static_cast<unsigned>(rhs))); }
}
namespace Glib
{
template <>
class Value<Gdk::WMDecoration> : public Glib::Value_Flags<Gdk::WMDecoration>
{
public:
  static GType value_type() __attribute__((__const__));
};
}
namespace Gdk
{
enum WMFunction
{
  FUNC_ALL = 1 << 0,
  FUNC_RESIZE = 1 << 1,
  FUNC_MOVE = 1 << 2,
  FUNC_MINIMIZE = 1 << 3,
  FUNC_MAXIMIZE = 1 << 4,
  FUNC_CLOSE = 1 << 5
};
inline WMFunction operator|(WMFunction lhs, WMFunction rhs)
  { return static_cast<WMFunction>(static_cast<unsigned>(lhs) | static_cast<unsigned>(rhs)); }
inline WMFunction operator&(WMFunction lhs, WMFunction rhs)
  { return static_cast<WMFunction>(static_cast<unsigned>(lhs) & static_cast<unsigned>(rhs)); }
inline WMFunction operator^(WMFunction lhs, WMFunction rhs)
  { return static_cast<WMFunction>(static_cast<unsigned>(lhs) ^ static_cast<unsigned>(rhs)); }
inline WMFunction operator~(WMFunction flags)
  { return static_cast<WMFunction>(~static_cast<unsigned>(flags)); }
inline WMFunction& operator|=(WMFunction& lhs, WMFunction rhs)
  { return (lhs = static_cast<WMFunction>(static_cast<unsigned>(lhs) | static_cast<unsigned>(rhs))); }
inline WMFunction& operator&=(WMFunction& lhs, WMFunction rhs)
  { return (lhs = static_cast<WMFunction>(static_cast<unsigned>(lhs) & static_cast<unsigned>(rhs))); }
inline WMFunction& operator^=(WMFunction& lhs, WMFunction rhs)
  { return (lhs = static_cast<WMFunction>(static_cast<unsigned>(lhs) ^ static_cast<unsigned>(rhs))); }
}
namespace Glib
{
template <>
class Value<Gdk::WMFunction> : public Glib::Value_Flags<Gdk::WMFunction>
{
public:
  static GType value_type() __attribute__((__const__));
};
}
namespace Gdk
{
enum WindowEdge
{
  WINDOW_EDGE_NORTH_WEST,
  WINDOW_EDGE_NORTH,
  WINDOW_EDGE_NORTH_EAST,
  WINDOW_EDGE_WEST,
  WINDOW_EDGE_EAST,
  WINDOW_EDGE_SOUTH_WEST,
  WINDOW_EDGE_SOUTH,
  WINDOW_EDGE_SOUTH_EAST
};
}
namespace Glib
{
template <>
class Value<Gdk::WindowEdge> : public Glib::Value_Enum<Gdk::WindowEdge>
{
public:
  static GType value_type() __attribute__((__const__));
};
}
namespace Gdk
{
enum Gravity
{
  GRAVITY_NORTH_WEST = 1,
  GRAVITY_NORTH,
  GRAVITY_NORTH_EAST,
  GRAVITY_WEST,
  GRAVITY_CENTER,
  GRAVITY_EAST,
  GRAVITY_SOUTH_WEST,
  GRAVITY_SOUTH,
  GRAVITY_SOUTH_EAST,
  GRAVITY_STATIC
};
}
namespace Glib
{
template <>
class Value<Gdk::Gravity> : public Glib::Value_Enum<Gdk::Gravity>
{
public:
  static GType value_type() __attribute__((__const__));
};
}
namespace Gdk
{
enum GrabStatus
{
  GRAB_SUCCESS,
  GRAB_ALREADY_GRABBED,
  GRAB_INVALID_TIME,
  GRAB_NOT_VIEWABLE,
  GRAB_FROZEN
};
}
namespace Glib
{
template <>
class Value<Gdk::GrabStatus> : public Glib::Value_Enum<Gdk::GrabStatus>
{
public:
  static GType value_type() __attribute__((__const__));
};
}
namespace Gdk
{
class Cursor;
class Window : public Gdk::Drawable
{
public:
  typedef Window CppObjectType;
  typedef Window_Class CppClassType;
  typedef GdkWindow BaseObjectType;
  typedef GdkWindowObjectClass BaseClassType;
private: friend class Window_Class;
  static CppClassType window_class_;
private:
  Window(const Window&);
  Window& operator=(const Window&);
protected:
  explicit Window(const Glib::ConstructParams& construct_params);
  explicit Window(GdkWindow* castitem);
public:
  virtual ~Window();
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GdkWindow* gobj() { return reinterpret_cast<GdkWindow*>(gobject_); }
  const GdkWindow* gobj() const { return reinterpret_cast<GdkWindow*>(gobject_); }
  GdkWindow* gobj_copy();
private:
protected:
  Window(const Glib::RefPtr<Window>& parent, GdkWindowAttr* attributes, int attributes_mask);
public:
  static Glib::RefPtr<Window> create(const Glib::RefPtr<Window>& parent, GdkWindowAttr* attributes, int attributes_mask);
  WindowType get_window_type() const;
  void show();
  void hide();
  void withdraw();
  void show_unraised();
  void move(int x, int y);
  void resize(int width, int height);
  void move_resize(int x, int y, int width, int height);
  void reparent(const Glib::RefPtr<Window>& new_parent, int x, int y);
  void clear();
  void clear_area(int x, int y, int width, int height);
  void clear_area_e(int x, int y, int width, int height);
  void raise();
  void lower();
  void focus(guint32 timestamp);
  void set_user_data(gpointer user_data);
  void set_override_redirect(bool override_redirect = true);
  void add_filter(GdkFilterFunc function, gpointer data);
  void remove_filter(GdkFilterFunc function, gpointer data);
  void scroll(int dx, int dy);
  void move_region(const Region& region, int dx, int dy);
  void shape_combine_mask(const Glib::RefPtr<Bitmap>& mask, int x, int y);
  void unset_shape_combine_mask();
  void shape_combine_region(const Region& shape_region, int offset_x, int offset_y);
  void set_child_shapes();
  void set_composited(bool composited = (!(0)));
  void merge_child_shapes();
  void input_shape_combine_mask(const Glib::RefPtr<Bitmap>& mask, int x, int y);
  void input_shape_combine_region (const Region& shape_region, int offset_x, int offset_y);
  void set_child_input_shapes();
  void merge_child_input_shapes();
  bool is_visible() const;
  bool is_viewable() const;
  WindowState get_state() const;
  bool set_static_gravities(bool use_static = true);
  void set_type_hint(WindowTypeHint hint);
  WindowTypeHint get_type_hint();
  void set_modal_hint(bool modal = true);
  void set_geometry_hints(const Geometry& geometry, WindowHints geom_mask);
  static void set_sm_client_id(const Glib::ustring& sm_client_id);
  static void unset_sm_client_id();
  void begin_paint_rect(Rectangle&rectangle);
  void begin_paint_region(const Region& region);
  void end_paint();
  void set_title(const Glib::ustring& title);
  void set_role(const Glib::ustring& role);
  void set_startup_id(const Glib::ustring& startup_id);
  void set_transient_for(const Glib::RefPtr<Window>& parent);
  void set_background(const Color& color);
  void set_back_pixmap(const Glib::RefPtr<Pixmap>&pixmap, bool parent_relative);
  void set_cursor(const Cursor& cursor);
  void set_cursor();
  void get_user_data(gpointer* data);
  void get_geometry(int& x, int& y, int& width, int& height, int& depth) const;
  void get_position(int& x, int& y) const;
  int get_origin(int& x, int& y) const;
  void get_root_origin(int& x, int& y) const;
  void get_frame_extents(Rectangle& rect);
  Glib::RefPtr<Window> get_pointer(int& x, int& y, ModifierType& mask);
  Glib::RefPtr<Window> get_parent();
  Glib::RefPtr<const Window> get_parent() const;
  Glib::RefPtr<Window> get_toplevel();
  Glib::RefPtr<const Window> get_toplevel() const;
  Glib::ListHandle< Glib::RefPtr<Window> > get_children();
  Glib::ListHandle< Glib::RefPtr<const Window> > get_children() const;
  EventMask get_events() const;
  void set_events(EventMask event_mask);
  void set_icon_list(const Glib::ListHandle< Glib::RefPtr<Gdk::Pixbuf> >& pixbufs);
  void set_icon(const Glib::RefPtr<Window>& icon_window, const Glib::RefPtr<Pixmap>& pixmap, const Glib::RefPtr<Bitmap>& mask);
  void set_icon(const Glib::RefPtr<Window>& icon_window, const Glib::RefPtr<Pixmap>& pixmap);
  void unset_icon();
  void set_icon_name(const Glib::ustring& name);
  void set_group(const Glib::RefPtr<Window>& leader);
  Glib::RefPtr<Window> get_group();
  Glib::RefPtr<const Window> get_group() const;
  void set_decorations(WMDecoration decorations);
  bool get_decorations(WMDecoration& decorations) const;
  void set_functions(WMFunction functions);
  static Glib::ListHandle< Glib::RefPtr<Window> > get_toplevels();
  void beep();
  void iconify();
  void deiconify();
  void stick();
  void unstick();
  void maximize();
  void unmaximize();
  void register_dnd();
  void begin_resize_drag(WindowEdge edge, int button, int root_x, int root_y, guint32 timestamp);
  void begin_move_drag(int button, int root_x, int root_y, guint32 timestamp);
  void invalidate_rect(const Rectangle& rect, bool invalidate_children);
  void invalidate_region(const Region& region, bool invalidate_children = true);
  Region get_update_area();
  void freeze_updates();
  void thaw_updates();
  static void process_all_updates();
  void process_updates(bool update_children);
  static void set_debug_updates(bool setting = true);
  static void constrain_size(const Geometry& geometry, guint flags, int width, int height, int& new_width, int& new_height);
  void get_internal_paint_info(Glib::RefPtr<Drawable>& real_drawable, int& x_offset, int& y_offset) const;
  void enable_synchronized_configure();
  void configure_finished();
  void set_skip_taskbar_hint(bool skips_taskbar = true);
  void set_skip_pager_hint(bool skips_pager = true);
  void set_urgency_hint(bool urgent = true);
  void fullscreen();
  void unfullscreen();
  GrabStatus pointer_grab(bool owner_events, EventMask event_mask, const Glib::RefPtr<const Window>& confine_to, const Cursor& cursor, guint32 time_);
  GrabStatus pointer_grab(bool owner_events, EventMask event_mask, const Cursor& cursor, guint32 timestamp);
  GrabStatus pointer_grab(bool owner_events, EventMask event_mask, guint32 timestamp);
  static void pointer_ungrab(guint32 timestamp);
  GrabStatus keyboard_grab(bool owner_events, guint32 timestamp);
  static void keyboard_ungrab(guint32 timestamp);
  void set_keep_above(bool setting = true);
  void set_keep_below(bool setting = true);
  void set_opacity(double opacity);
  void set_accept_focus(bool accept_focus = true);
  void set_focus_on_map(bool focus_on_map);
public:
public:
protected:
};
}
namespace Glib
{
  Glib::RefPtr<Gdk::Window> wrap(GdkWindowObject* object, bool take_copy = false);
}
extern "C" { typedef struct _GdkPixbufFormat GdkPixbufFormat; }
namespace Gdk
{
class PixbufFormat
{
  public:
  typedef PixbufFormat CppObjectType;
  typedef GdkPixbufFormat BaseObjectType;
private:
public:
  PixbufFormat();
  explicit PixbufFormat(const GdkPixbufFormat* gobject);
  virtual ~PixbufFormat();
  PixbufFormat(const PixbufFormat& src);
  PixbufFormat& operator=(const PixbufFormat& src);
  Glib::ustring get_name() const;
  Glib::ustring get_description() const;
  Glib::StringArrayHandle get_mime_types() const;
  Glib::StringArrayHandle get_extensions() const;
  bool is_writable() const;
  bool is_scalable() const;
  bool is_disabled() const;
  void set_disabled(bool disabled = true);
  Glib::ustring get_license() const;
  GdkPixbufFormat* gobj() { return const_cast<GdkPixbufFormat*>(gobject_); }
  const GdkPixbufFormat* gobj() const { return gobject_; }
protected:
  const GdkPixbufFormat* gobject_;
};
}
typedef struct _GdkPixbuf GdkPixbuf;
typedef struct _GdkPixbufClass GdkPixbufClass;
namespace Gdk
{ class Pixbuf_Class; }
namespace Gdk
{
enum Colorspace
{
  COLORSPACE_RGB
};
}
namespace Glib
{
template <>
class Value<Gdk::Colorspace> : public Glib::Value_Enum<Gdk::Colorspace>
{
public:
  static GType value_type() __attribute__((__const__));
};
}
namespace Gdk
{
enum InterpType
{
  INTERP_NEAREST,
  INTERP_TILES,
  INTERP_BILINEAR,
  INTERP_HYPER
};
}
namespace Glib
{
template <>
class Value<Gdk::InterpType> : public Glib::Value_Enum<Gdk::InterpType>
{
public:
  static GType value_type() __attribute__((__const__));
};
}
namespace Gdk
{
enum PixbufAlphaMode
{
  PIXBUF_ALPHA_BILEVEL,
  PIXBUF_ALPHA_FULL
};
}
namespace Glib
{
template <>
class Value<Gdk::PixbufAlphaMode> : public Glib::Value_Enum<Gdk::PixbufAlphaMode>
{
public:
  static GType value_type() __attribute__((__const__));
};
}
namespace Gdk
{
enum PixbufRotation
{
  PIXBUF_ROTATE_NONE = 0,
  PIXBUF_ROTATE_COUNTERCLOCKWISE = 90,
  PIXBUF_ROTATE_UPSIDEDOWN = 180,
  PIXBUF_ROTATE_CLOCKWISE = 270
};
}
namespace Glib
{
template <>
class Value<Gdk::PixbufRotation> : public Glib::Value_Enum<Gdk::PixbufRotation>
{
public:
  static GType value_type() __attribute__((__const__));
};
}
namespace Gdk
{
class PixbufError : public Glib::Error
{
public:
  enum Code
  {
    CORRUPT_IMAGE,
    INSUFFICIENT_MEMORY,
    BAD_OPTION,
    UNKNOWN_TYPE,
    UNSUPPORTED_OPERATION,
    FAILED
  };
  PixbufError(Code error_code, const Glib::ustring& error_message);
  explicit PixbufError(GError* gobject);
  Code code() const;
private:
  static void throw_func(GError* gobject);
  friend void wrap_init();
};
}
namespace Glib
{
template <>
class Value<Gdk::PixbufError::Code> : public Glib::Value_Enum<Gdk::PixbufError::Code>
{
public:
  static GType value_type() __attribute__((__const__));
};
}
namespace Gdk
{
struct PixbufFormatTraits
{
  typedef PixbufFormat CppType;
  typedef const GdkPixbufFormat* CType;
  typedef GdkPixbufFormat* CTypeNonConst;
  static CType to_c_type (const CppType& obj) { return obj.gobj(); }
  static CType to_c_type (CType ptr) { return ptr; }
  static CppType to_cpp_type (CType ptr) { return PixbufFormat(ptr); }
  static void release_c_type (CType ) { }
};
class Pixbuf : public Glib::Object
{
public:
  typedef Pixbuf CppObjectType;
  typedef Pixbuf_Class CppClassType;
  typedef GdkPixbuf BaseObjectType;
  typedef GdkPixbufClass BaseClassType;
private: friend class Pixbuf_Class;
  static CppClassType pixbuf_class_;
private:
  Pixbuf(const Pixbuf&);
  Pixbuf& operator=(const Pixbuf&);
protected:
  explicit Pixbuf(const Glib::ConstructParams& construct_params);
  explicit Pixbuf(GdkPixbuf* castitem);
public:
  virtual ~Pixbuf();
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GdkPixbuf* gobj() { return reinterpret_cast<GdkPixbuf*>(gobject_); }
  const GdkPixbuf* gobj() const { return reinterpret_cast<GdkPixbuf*>(gobject_); }
  GdkPixbuf* gobj_copy();
private:
protected:
   Pixbuf(const Glib::RefPtr<Drawable>& src, const Glib::RefPtr<Colormap>& cmap,
         int src_x, int src_y, int width, int height);
   Pixbuf(const Glib::RefPtr<Drawable>& src,
         int src_x, int src_y, int width, int height);
   Pixbuf(const Glib::RefPtr<Drawable>& src, const Glib::RefPtr<Colormap>& cmap,
         int src_x, int src_y, int dest_x, int dest_y, int width, int height);
  Pixbuf(const Glib::RefPtr<Image>& src, const Glib::RefPtr<Colormap>& cmap,
         int src_x, int src_y, int width, int height);
  Pixbuf(const Glib::RefPtr<Image>& src,
         int src_x, int src_y, int width, int height);
  Pixbuf(const Glib::RefPtr<Image>& src, const Glib::RefPtr<Colormap>& cmap,
         int src_x, int src_y, int dest_x, int dest_y, int width, int height);
public:
  typedef sigc::slot<void, const guint8*> SlotDestroyData;
  static Glib::RefPtr<Pixbuf> create(const Glib::RefPtr<Drawable>& src, const Glib::RefPtr<Colormap>& cmap, int src_x, int src_y, int dest_x, int dest_y, int width, int height);
  static Glib::RefPtr<Pixbuf> create(const Glib::RefPtr<Image>& src, const Glib::RefPtr<Colormap>& cmap, int src_x, int src_y, int dest_x, int dest_y, int width, int height);
  static Glib::RefPtr<Pixbuf> create(const Glib::RefPtr<Drawable>& src, const Glib::RefPtr<Colormap>& cmap, int src_x, int src_y, int width, int height);
  static Glib::RefPtr<Pixbuf> create(const Glib::RefPtr<Drawable>& src, int src_x, int src_y, int width, int height);
  static Glib::RefPtr<Pixbuf> create(const Glib::RefPtr<Image>& src, const Glib::RefPtr<Colormap>& cmap, int src_x, int src_y, int width, int height);
  static Glib::RefPtr<Pixbuf> create(const Glib::RefPtr<Image>& src, int src_x, int src_y, int width, int height);
  Glib::RefPtr<Pixbuf> copy() const;
  static Glib::RefPtr<Pixbuf> create(
                   Colorspace colorspace, bool has_alpha,
                   int bits_per_sample, int width, int height);
  static Glib::RefPtr<Pixbuf> create_subpixbuf(
                  const Glib::RefPtr<Pixbuf>& src_pixbuf,
                  int src_x, int src_y, int width, int height);
  static Glib::RefPtr<Pixbuf> create_from_file(const std::string& filename);
  static Glib::RefPtr<Pixbuf> create_from_file(const std::string& filename, int width, int height, bool preserve_aspect_ratio = true);
  static Glib::RefPtr<Pixbuf> create_from_data(const guint8* data, Colorspace colorspace,
                                               bool has_alpha, int bits_per_sample,
                                               int width, int height, int rowstride);
  static Glib::RefPtr<Pixbuf> create_from_data(const guint8* data, Colorspace colorspace,
                                               bool has_alpha, int bits_per_sample,
                                               int width, int height, int rowstride,
                                               const SlotDestroyData& destroy_slot);
  static Glib::RefPtr<Pixbuf> create_from_xpm_data(const char *const * data);
  static Glib::RefPtr<Pixbuf> create_from_inline(int data_length, const guint8* data,
                                                 bool copy_pixels = false);
  Colorspace get_colorspace() const;
  int get_n_channels() const;
  bool get_has_alpha() const;
  int get_bits_per_sample() const;
  guint8* get_pixels() const;
  int get_width() const;
  int get_height() const;
  int get_rowstride() const;
  void fill(guint32 pixel);
  void save(const std::string& filename, const Glib::ustring& type);
  void save(const std::string& filename, const Glib::ustring& type,
            const Glib::StringArrayHandle& option_keys,
            const Glib::StringArrayHandle& option_values);
  void save_to_buffer(gchar*& buffer, gsize& buffer_size,
                      const Glib::ustring& type = "png");
  void save_to_buffer(gchar*& buffer, gsize& buffer_size,
                      const Glib::ustring& type,
                      const Glib::StringArrayHandle& option_keys,
                      const Glib::StringArrayHandle& option_values);
  Glib::RefPtr<Gdk::Pixbuf> add_alpha(
                   bool substitute_color, guint8 r, guint8 g, guint8 b) const;
  void copy_area(
                   int src_x, int src_y, int width, int height,
                   const Glib::RefPtr<Gdk::Pixbuf>& dest_pixbuf,
                   int dest_x, int dest_y) const;
  void saturate_and_pixelate(
                   const Glib::RefPtr<Gdk::Pixbuf>& dest,
                   float saturation, bool pixelate) const;
  void scale(const Glib::RefPtr<Gdk::Pixbuf>& dest,
                          int dest_x, int dest_y,
                          int dest_width, int dest_height,
                          double offset_x, double offset_y,
                          double scale_x, double scale_y,
                          InterpType interp_type) const;
  void composite(const Glib::RefPtr<Gdk::Pixbuf>& dest,
                              int dest_x, int dest_y,
                              int dest_width, int dest_height,
                              double offset_x, double offset_y,
                              double scale_x, double scale_y,
                              InterpType interp_type,
                              int overall_alpha) const;
  void composite_color(const Glib::RefPtr<Gdk::Pixbuf>& dest,
                                    int dest_x, int dest_y,
                                    int dest_width, int dest_height,
                                    double offset_x, double offset_y,
                                    double scale_x, double scale_y,
                                    InterpType interp_type,
                                    int overall_alpha,
                                    int check_x, int check_y,
                                    int check_size,
                                    guint32 color1, guint32 color2) const;
  Glib::RefPtr<Gdk::Pixbuf> scale_simple(
                   int dest_width, int dest_height,
                   InterpType interp_type) const;
  Glib::RefPtr<Gdk::Pixbuf> composite_color_simple(
                   int dest_width, int dest_height,
                   InterpType interp_type,
                   int overall_alpha, int check_size,
                   guint32 color1, guint32 color2) const;
  Glib::RefPtr<Gdk::Pixbuf> rotate_simple(PixbufRotation angle) const;
  Glib::RefPtr<Gdk::Pixbuf> flip(bool horizontal = true) const;
  void render_threshold_alpha(const Glib::RefPtr<Gdk::Bitmap>& bitmap,
                                          int src_x, int src_y,
                                          int dest_x, int dest_y,
                                          int width, int height,
                                          int alpha_threshold);
  void render_to_drawable(const Glib::RefPtr<Drawable>& drawable,
                                          const Glib::RefPtr<Gdk::GC>& gc,
                                          int src_x, int src_y,
                                          int dest_x, int dest_y,
                                          int width, int height,
                                          RgbDither dither,
                                          int x_dither, int y_dither);
  void render_to_drawable_alpha(const Glib::RefPtr<Drawable>& drawable,
                                          int src_x, int src_y,
                                          int dest_x, int dest_y,
                                          int width, int height,
                                          PixbufAlphaMode alpha_mode,
                                          int alpha_threshold,
                                          RgbDither dither,
                                          int x_dither, int y_dither);
  void render_pixmap_and_mask_for_colormap(const Glib::RefPtr<Colormap>& colormap,
                                           Glib::RefPtr<Pixmap>& pixmap_return,
                                           Glib::RefPtr<Bitmap>& mask_return,
                                           int alpha_threshold);
  void render_pixmap_and_mask(Glib::RefPtr<Pixmap>& pixmap_return,
                              Glib::RefPtr<Bitmap>& mask_return, int alpha_threshold);
  Glib::ustring get_option(const Glib::ustring& key) const;
  typedef Glib::SListHandle< Glib::RefPtr<PixbufFormat>, PixbufFormatTraits > SListHandle_PixbufFormat;
  static SListHandle_PixbufFormat get_formats();
public:
public:
protected:
};
}
namespace Glib
{
  Glib::RefPtr<Gdk::Pixbuf> wrap(GdkPixbuf* object, bool take_copy = false);
}
typedef struct _GdkPixbufAnimationIter GdkPixbufAnimationIter;
typedef struct _GdkPixbufAnimationIterClass GdkPixbufAnimationIterClass;
namespace Gdk
{ class PixbufAnimationIter_Class; }
namespace Gdk
{
class PixbufAnimationIter : public Glib::Object
{
public:
  typedef PixbufAnimationIter CppObjectType;
  typedef PixbufAnimationIter_Class CppClassType;
  typedef GdkPixbufAnimationIter BaseObjectType;
  typedef GdkPixbufAnimationIterClass BaseClassType;
private: friend class PixbufAnimationIter_Class;
  static CppClassType pixbufanimationiter_class_;
private:
  PixbufAnimationIter(const PixbufAnimationIter&);
  PixbufAnimationIter& operator=(const PixbufAnimationIter&);
protected:
  explicit PixbufAnimationIter(const Glib::ConstructParams& construct_params);
  explicit PixbufAnimationIter(GdkPixbufAnimationIter* castitem);
public:
  virtual ~PixbufAnimationIter();
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GdkPixbufAnimationIter* gobj() { return reinterpret_cast<GdkPixbufAnimationIter*>(gobject_); }
  const GdkPixbufAnimationIter* gobj() const { return reinterpret_cast<GdkPixbufAnimationIter*>(gobject_); }
  GdkPixbufAnimationIter* gobj_copy();
private:
protected:
public:
public:
protected:
};
}
namespace Glib
{
  Glib::RefPtr<Gdk::PixbufAnimationIter> wrap(GdkPixbufAnimationIter* object, bool take_copy = false);
}
typedef struct _GdkPixbufAnimation GdkPixbufAnimation;
typedef struct _GdkPixbufAnimationClass GdkPixbufAnimationClass;
namespace Gdk
{ class PixbufAnimation_Class; }
namespace Gdk
{
class PixbufAnimation : public Glib::Object
{
public:
  typedef PixbufAnimation CppObjectType;
  typedef PixbufAnimation_Class CppClassType;
  typedef GdkPixbufAnimation BaseObjectType;
  typedef GdkPixbufAnimationClass BaseClassType;
private: friend class PixbufAnimation_Class;
  static CppClassType pixbufanimation_class_;
private:
  PixbufAnimation(const PixbufAnimation&);
  PixbufAnimation& operator=(const PixbufAnimation&);
protected:
  explicit PixbufAnimation(const Glib::ConstructParams& construct_params);
  explicit PixbufAnimation(GdkPixbufAnimation* castitem);
public:
  virtual ~PixbufAnimation();
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GdkPixbufAnimation* gobj() { return reinterpret_cast<GdkPixbufAnimation*>(gobject_); }
  const GdkPixbufAnimation* gobj() const { return reinterpret_cast<GdkPixbufAnimation*>(gobject_); }
  GdkPixbufAnimation* gobj_copy();
private:
protected:
public:
  static Glib::RefPtr<PixbufAnimation> create_from_file(const Glib::ustring& filename);
  int get_width() const;
  int get_height() const;
  bool is_static_image() const;
  Glib::RefPtr<Pixbuf> get_static_image();
  Glib::RefPtr<PixbufAnimationIter> get_iter(const GTimeVal* start_time);
public:
public:
protected:
};
}
namespace Glib
{
  Glib::RefPtr<Gdk::PixbufAnimation> wrap(GdkPixbufAnimation* object, bool take_copy = false);
}
typedef struct _GdkPixbufLoader GdkPixbufLoader;
typedef struct _GdkPixbufLoaderClass GdkPixbufLoaderClass;
namespace Gdk
{ class PixbufLoader_Class; }
namespace Gdk
{
class PixbufLoader : public Glib::Object
{
public:
  typedef PixbufLoader CppObjectType;
  typedef PixbufLoader_Class CppClassType;
  typedef GdkPixbufLoader BaseObjectType;
  typedef GdkPixbufLoaderClass BaseClassType;
private: friend class PixbufLoader_Class;
  static CppClassType pixbufloader_class_;
private:
  PixbufLoader(const PixbufLoader&);
  PixbufLoader& operator=(const PixbufLoader&);
protected:
  explicit PixbufLoader(const Glib::ConstructParams& construct_params);
  explicit PixbufLoader(GdkPixbufLoader* castitem);
public:
  virtual ~PixbufLoader();
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GdkPixbufLoader* gobj() { return reinterpret_cast<GdkPixbufLoader*>(gobject_); }
  const GdkPixbufLoader* gobj() const { return reinterpret_cast<GdkPixbufLoader*>(gobject_); }
  GdkPixbufLoader* gobj_copy();
private:
protected:
  PixbufLoader();
  explicit PixbufLoader(const Glib::ustring& image_type, bool mime_type = false);
public:
  static Glib::RefPtr<PixbufLoader> create();
  static Glib::RefPtr<PixbufLoader> create(const Glib::ustring& image_type, bool mime_type = false);
  void set_size(int width, int height);
  void write(const guint8* buf, gsize count);
  void close();
  Glib::RefPtr<Gdk::Pixbuf> get_pixbuf();
  Glib::RefPtr<Gdk::PixbufAnimation> get_animation();
  PixbufFormat get_format() const;
  Glib::SignalProxy0< void > signal_area_prepared();
  Glib::SignalProxy4< void,int,int,int,int > signal_area_updated();
  Glib::SignalProxy0< void > signal_closed();
  Glib::SignalProxy2< void,int,int > signal_size_prepared();
public:
public:
protected:
  virtual void on_area_prepared();
  virtual void on_area_updated(int x, int y, int width, int height);
  virtual void on_closed();
};
}
namespace Glib
{
  Glib::RefPtr<Gdk::PixbufLoader> wrap(GdkPixbufLoader* object, bool take_copy = false);
}
extern "C" { typedef union _GdkEvent GdkEvent; }
namespace Gdk
{
enum EventType
{
  NOTHING = -1,
  DELETE,
  DESTROY,
  EXPOSE,
  MOTION_NOTIFY,
  BUTTON_PRESS,
  DOUBLE_BUTTON_PRESS,
  TRIPLE_BUTTON_PRESS,
  BUTTON_RELEASE,
  KEY_PRESS,
  KEY_RELEASE,
  ENTER_NOTIFY,
  LEAVE_NOTIFY,
  FOCUS_CHANGE,
  CONFIGURE,
  MAP,
  UNMAP,
  PROPERTY_NOTIFY,
  SELECTION_CLEAR,
  SELECTION_REQUEST,
  SELECTION_NOTIFY,
  PROXIMITY_IN,
  PROXIMITY_OUT,
  DRAG_ENTER,
  DRAG_LEAVE,
  DRAG_MOTION,
  DRAG_STATUS,
  DROP_START,
  DROP_FINISHED,
  CLIENT_EVENT,
  VISIBILITY_NOTIFY,
  NO_EXPOSE,
  SCROLL,
  WINDOW_STATE,
  SETTING,
  OWNER_CHANGE,
  GRAB_BROKEN
};
}
namespace Glib
{
template <>
class Value<Gdk::EventType> : public Glib::Value_Enum<Gdk::EventType>
{
public:
  static GType value_type() __attribute__((__const__));
};
}
namespace Gdk
{
enum ExtensionMode
{
  EXTENSION_EVENTS_NONE,
  EXTENSION_EVENTS_ALL,
  EXTENSION_EVENTS_CURSOR
};
}
namespace Glib
{
template <>
class Value<Gdk::ExtensionMode> : public Glib::Value_Enum<Gdk::ExtensionMode>
{
public:
  static GType value_type() __attribute__((__const__));
};
}
namespace Gdk
{
enum AxisUse
{
  AXIS_IGNORE,
  AXIS_X,
  AXIS_Y,
  AXIS_PRESSURE,
  AXIS_XTILT,
  AXIS_YTILT,
  AXIS_WHEEL,
  AXIS_LAST
};
}
namespace Glib
{
template <>
class Value<Gdk::AxisUse> : public Glib::Value_Enum<Gdk::AxisUse>
{
public:
  static GType value_type() __attribute__((__const__));
};
}
namespace Gdk
{
class Event
{
  public:
  typedef Event CppObjectType;
  typedef GdkEvent BaseObjectType;
  static GType get_type() __attribute__((__const__));
  Event();
  explicit Event(GdkEvent* gobject, bool make_a_copy = true);
  Event(const Event& other);
  Event& operator=(const Event& other);
  ~Event();
  void swap(Event& other);
  GdkEvent* gobj() { return gobject_; }
  const GdkEvent* gobj() const { return gobject_; }
  GdkEvent* gobj_copy() const;
protected:
  GdkEvent* gobject_;
private:
public:
  static Event get();
  static Event peek();
  static Event get_graphics_expose(const Glib::RefPtr<Window>& window);
  void put();
  static bool events_pending();
  guint32 get_time() const;
  bool get_state(ModifierType& state) const;
  bool get_coords(double& x_win, double& y_win) const;
  bool get_root_coords(double& x_root, double& y_root) const;
  bool get_axis(AxisUse axis_use, double& value) const;
  static void set_show_events(bool show_events);
  static bool get_show_events();
  void set_screen(const Glib::RefPtr<Screen>& screen);
  Glib::RefPtr<Screen> get_screen();
  Glib::RefPtr<const Screen> get_screen() const;
  bool send_client_message(NativeWindow winid);
  bool send_client_message(const Glib::RefPtr<Display>& display, NativeWindow winid);
};
}
namespace Gdk
{
inline void swap(Event& lhs, Event& rhs)
  { lhs.swap(rhs); }
}
namespace Glib
{
Gdk::Event wrap(GdkEvent* object, bool take_copy = false);
template <>
class Value<Gdk::Event> : public Glib::Value_Boxed<Gdk::Event>
{};
}
typedef struct _GdkDevice GdkDevice;
typedef struct _GdkDeviceClass GdkDeviceClass;
namespace Gdk
{ class Device_Class; }
namespace Gdk
{
enum InputMode
{
  MODE_DISABLED,
  MODE_SCREEN,
  MODE_WINDOW
};
}
namespace Glib
{
template <>
class Value<Gdk::InputMode> : public Glib::Value_Enum<Gdk::InputMode>
{
public:
  static GType value_type() __attribute__((__const__));
};
}
namespace Gdk
{
enum InputSource
{
  SOURCE_MOUSE,
  SOURCE_PEN,
  SOURCE_ERASER,
  SOURCE_CURSOR
};
}
namespace Glib
{
template <>
class Value<Gdk::InputSource> : public Glib::Value_Enum<Gdk::InputSource>
{
public:
  static GType value_type() __attribute__((__const__));
};
}
namespace Gdk
{
class Device : public Glib::Object
{
public:
  typedef Device CppObjectType;
  typedef Device_Class CppClassType;
  typedef GdkDevice BaseObjectType;
  typedef GdkDeviceClass BaseClassType;
private: friend class Device_Class;
  static CppClassType device_class_;
private:
  Device(const Device&);
  Device& operator=(const Device&);
protected:
  explicit Device(const Glib::ConstructParams& construct_params);
  explicit Device(GdkDevice* castitem);
public:
  virtual ~Device();
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GdkDevice* gobj() { return reinterpret_cast<GdkDevice*>(gobject_); }
  const GdkDevice* gobj() const { return reinterpret_cast<GdkDevice*>(gobject_); }
  GdkDevice* gobj_copy();
private:
protected:
  Device();
public:
  void set_source(InputSource source);
  bool set_mode(InputMode mode);
  void set_key(guint index_, guint keyval, ModifierType modifiers);
  void set_axis_use(guint index_, AxisUse use);
  void get_state(const Glib::RefPtr<Window>& window, double& axes, ModifierType& mask);
  bool get_history(const Glib::RefPtr<Window>& window, guint32 start, guint32 stop, GdkTimeCoord**& events, int& n_events);
  bool get_axis(double& axes, AxisUse use, double& value) const;
   Glib::ustring get_name() const;
   InputSource get_source() const;
   InputMode get_mode() const;
   bool get_has_cursor() const;
public:
public:
protected:
};
}
namespace Glib
{
  Glib::RefPtr<Gdk::Device> wrap(GdkDevice* object, bool take_copy = false);
}
typedef struct _GdkDisplay GdkDisplay;
typedef struct _GdkDisplayClass GdkDisplayClass;
namespace Gdk
{ class Display_Class; }
namespace Gdk
{
class Drawable;
class Display : public Glib::Object
{
public:
  typedef Display CppObjectType;
  typedef Display_Class CppClassType;
  typedef GdkDisplay BaseObjectType;
  typedef GdkDisplayClass BaseClassType;
private: friend class Display_Class;
  static CppClassType display_class_;
private:
  Display(const Display&);
  Display& operator=(const Display&);
protected:
  explicit Display(const Glib::ConstructParams& construct_params);
  explicit Display(GdkDisplay* castitem);
public:
  virtual ~Display();
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GdkDisplay* gobj() { return reinterpret_cast<GdkDisplay*>(gobject_); }
  const GdkDisplay* gobj() const { return reinterpret_cast<GdkDisplay*>(gobject_); }
  GdkDisplay* gobj_copy();
private:
protected:
  Display();
public:
  static Glib::RefPtr<Display> open(const Glib::ustring& display_name);
  Glib::ustring get_name() const;
  int get_n_screens() const;
  Glib::RefPtr<Screen> get_screen(int screen_num);
  Glib::RefPtr<const Screen> get_screen(int screen_num) const;
  Glib::RefPtr<Screen> get_default_screen();
  Glib::RefPtr<const Screen> get_default_screen() const;
  void pointer_ungrab(guint32 timestamp);
  void keyboard_ungrab(guint32 timestamp);
  bool pointer_is_grabbed() const;
  void beep();
  void sync();
  void close();
  Glib::ListHandle< Glib::RefPtr<Device> > list_devices();
  Glib::ListHandle< Glib::RefPtr<const Device> > list_devices() const;
  GdkEvent* get_event();
  const GdkEvent* get_event() const;
  GdkEvent* peek_event();
  GdkEvent* peek_event() const;
  void put_event(GdkEvent* event);
  void add_client_message_filter(Glib::ustring& message_type, GdkFilterFunc func, gpointer data);
  void set_double_click_time(guint msec);
  void set_double_click_distance(guint distance);
  static Glib::RefPtr<Display> get_default();
  Glib::RefPtr<Device> get_core_pointer();
  Glib::RefPtr<const Device> get_core_pointer() const;
  void get_pointer(Glib::RefPtr<Screen>& screen, int& x, int& y, ModifierType& mask);
  void get_pointer(int& x, int& y, ModifierType& mask);
  Glib::RefPtr<Window> get_window_at_pointer(int& win_x, int& win_y);
  Glib::RefPtr<const Window> get_window_at_pointer(int& win_x, int& win_y) const;
  Glib::RefPtr<Window> get_window_at_pointer();
  Glib::RefPtr<const Window> get_window_at_pointer() const;
  void warp_pointer(const Glib::RefPtr<Screen>& screen, int x, int y);
  GdkDisplayPointerHooks* set_pointer_hooks(const GdkDisplayPointerHooks* new_hooks);
  GdkDisplayPointerHooks* unset_pointer_hooks();
  static Glib::RefPtr<Display> open_default_libgtk_only();
  guint32 get_drag_protocol(guint32 xid, GdkDragProtocol& protocol);
  GdkKeymap* get_keymap();
  const GdkKeymap* get_keymap() const;
  bool set_selection_owner(const Glib::RefPtr<Window>& owner, Glib::ustring& selection, guint32 time_, bool send_event);
  Glib::RefPtr<Window> get_selection_owner(const Glib::ustring& selection);
  void selection_send_notify(guint32 requestor, Glib::ustring& selection, Glib::ustring& target, Glib::ustring& property, guint32 time_);
  Glib::RefPtr<Pixmap> lookup_pixmap(NativeWindow anid);
  Glib::RefPtr<const Pixmap> lookup_pixmap(NativeWindow anid) const;
  void flush();
  bool supports_cursor_alpha() const;
  bool supports_cursor_color() const;
  guint get_default_cursor_size() const;
  void get_maximal_cursor_size(guint& width, guint& height);
  Glib::RefPtr<Window> get_default_group();
  Glib::RefPtr<const Window> get_default_group() const;
  bool supports_selection_notification() const;
  bool request_selection_notification(const Glib::ustring& selection);
  bool supports_clipboard_persistence() const;
  void store_clipboard(const Glib::RefPtr<Gdk::Window>& clipboard_window, guint32 time_);
  void store_clipboard(const Glib::RefPtr<Gdk::Window>& clipboard_window, guint32 time_, const Glib::StringArrayHandle& targets);
  bool supports_shapes() const;
  bool supports_input_shapes() const;
  bool supports_composite() const;
  Glib::SignalProxy1< void,bool > signal_closed();
public:
public:
protected:
  virtual void on_closed(bool is_error);
};
}
namespace Glib
{
  Glib::RefPtr<Gdk::Display> wrap(GdkDisplay* object, bool take_copy = false);
}
extern "C" { typedef struct _GdkCursor GdkCursor; }
namespace Gdk
{
enum CursorType
{
  X_CURSOR = 0,
  ARROW = 2,
  BASED_ARROW_DOWN = 4,
  BASED_ARROW_UP = 6,
  BOAT = 8,
  BOGOSITY = 10,
  BOTTOM_LEFT_CORNER = 12,
  BOTTOM_RIGHT_CORNER = 14,
  BOTTOM_SIDE = 16,
  BOTTOM_TEE = 18,
  BOX_SPIRAL = 20,
  CENTER_PTR = 22,
  CIRCLE = 24,
  CLOCK = 26,
  COFFEE_MUG = 28,
  CROSS = 30,
  CROSS_REVERSE = 32,
  CROSSHAIR = 34,
  DIAMOND_CROSS = 36,
  DOT = 38,
  DOTBOX = 40,
  DOUBLE_ARROW = 42,
  DRAFT_LARGE = 44,
  DRAFT_SMALL = 46,
  DRAPED_BOX = 48,
  EXCHANGE = 50,
  FLEUR = 52,
  GOBBLER = 54,
  GUMBY = 56,
  HAND1 = 58,
  HAND2 = 60,
  HEART = 62,
  ICON = 64,
  IRON_CROSS = 66,
  LEFT_PTR = 68,
  LEFT_SIDE = 70,
  LEFT_TEE = 72,
  LEFTBUTTON = 74,
  LL_ANGLE = 76,
  LR_ANGLE = 78,
  MAN = 80,
  MIDDLEBUTTON = 82,
  MOUSE = 84,
  PENCIL = 86,
  PIRATE = 88,
  PLUS = 90,
  QUESTION_ARROW = 92,
  RIGHT_PTR = 94,
  RIGHT_SIDE = 96,
  RIGHT_TEE = 98,
  RIGHTBUTTON = 100,
  RTL_LOGO = 102,
  SAILBOAT = 104,
  SB_DOWN_ARROW = 106,
  SB_H_DOUBLE_ARROW = 108,
  SB_LEFT_ARROW = 110,
  SB_RIGHT_ARROW = 112,
  SB_UP_ARROW = 114,
  SB_V_DOUBLE_ARROW = 116,
  SHUTTLE = 118,
  SIZING = 120,
  SPIDER = 122,
  SPRAYCAN = 124,
  STAR = 126,
  TARGET = 128,
  TCROSS = 130,
  TOP_LEFT_ARROW = 132,
  TOP_LEFT_CORNER = 134,
  TOP_RIGHT_CORNER = 136,
  TOP_SIDE = 138,
  TOP_TEE = 140,
  TREK = 142,
  UL_ANGLE = 144,
  UMBRELLA = 146,
  UR_ANGLE = 148,
  WATCH = 150,
  XTERM = 152,
  LAST_CURSOR = 153,
  CURSOR_IS_PIXMAP = -1
};
}
namespace Glib
{
template <>
class Value<Gdk::CursorType> : public Glib::Value_Enum<Gdk::CursorType>
{
public:
  static GType value_type() __attribute__((__const__));
};
}
namespace Gdk
{
class Cursor
{
  public:
  typedef Cursor CppObjectType;
  typedef GdkCursor BaseObjectType;
  static GType get_type() __attribute__((__const__));
  Cursor();
  explicit Cursor(GdkCursor* gobject, bool make_a_copy = true);
  Cursor(const Cursor& other);
  Cursor& operator=(const Cursor& other);
  ~Cursor();
  void swap(Cursor& other);
  GdkCursor* gobj() { return gobject_; }
  const GdkCursor* gobj() const { return gobject_; }
  GdkCursor* gobj_copy() const;
protected:
  GdkCursor* gobject_;
private:
public:
  explicit Cursor(CursorType cursor_type);
  Cursor(const Glib::RefPtr<Pixmap>& source, const Glib::RefPtr<Pixmap>& mask,
         const Color& fg, const Color& bg,
         int x, int y);
  explicit Cursor(const Glib::RefPtr<Display>& display, CursorType cursor_type);
  Cursor(const Glib::RefPtr<Display>& display, const Glib::RefPtr<Pixbuf>& pixbuf, int x, int y);
  explicit Cursor(const Glib::RefPtr<Display>& display, const Glib::ustring& name);
  Glib::RefPtr<Display> get_display();
  Glib::RefPtr<const Display> get_display() const;
  Glib::RefPtr<Gdk::Pixbuf> get_image();
  Glib::RefPtr<const Gdk::Pixbuf> get_image() const;
};
}
namespace Gdk
{
inline void swap(Cursor& lhs, Cursor& rhs)
  { lhs.swap(rhs); }
}
namespace Glib
{
Gdk::Cursor wrap(GdkCursor* object, bool take_copy = false);
template <>
class Value<Gdk::Cursor> : public Glib::Value_Boxed<Gdk::Cursor>
{};
}
typedef struct _GdkDisplayManager GdkDisplayManager;
typedef struct _GdkDisplayManagerClass GdkDisplayManagerClass;
namespace Gdk
{ class DisplayManager_Class; }
namespace Gdk
{
class DisplayManager : public Glib::Object
{
public:
  typedef DisplayManager CppObjectType;
  typedef DisplayManager_Class CppClassType;
  typedef GdkDisplayManager BaseObjectType;
  typedef GdkDisplayManagerClass BaseClassType;
private: friend class DisplayManager_Class;
  static CppClassType displaymanager_class_;
private:
  DisplayManager(const DisplayManager&);
  DisplayManager& operator=(const DisplayManager&);
protected:
  explicit DisplayManager(const Glib::ConstructParams& construct_params);
  explicit DisplayManager(GdkDisplayManager* castitem);
public:
  virtual ~DisplayManager();
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GdkDisplayManager* gobj() { return reinterpret_cast<GdkDisplayManager*>(gobject_); }
  const GdkDisplayManager* gobj() const { return reinterpret_cast<GdkDisplayManager*>(gobject_); }
  GdkDisplayManager* gobj_copy();
private:
protected:
public:
  static Glib::RefPtr<DisplayManager> get();
  Glib::RefPtr<Display> get_default_display();
  Glib::RefPtr<const Display> get_default_display() const;
  void set_default_display(const Glib::RefPtr<Display>& display);
  Glib::SListHandle< Glib::RefPtr<Display> > list_displays();
  Glib::PropertyProxy< Glib::RefPtr<Display> > property_default_display() ;
  Glib::PropertyProxy_ReadOnly< Glib::RefPtr<Display> > property_default_display() const;
  Glib::SignalProxy1< void,const Glib::RefPtr<Display>& > signal_display_opened();
public:
public:
protected:
  virtual void on_display_opened(const Glib::RefPtr<Display>& display);
};
}
namespace Glib
{
  Glib::RefPtr<Gdk::DisplayManager> wrap(GdkDisplayManager* object, bool take_copy = false);
}
namespace Gdk
{
int screen_width();
int screen_height();
int screen_width_mm();
int screen_height_mm();
void flush();
namespace Cairo
{
void set_source_color(::Cairo::RefPtr< ::Cairo::Context >& context, const Gdk::Color& color);
void set_source_color(const ::Cairo::RefPtr< ::Cairo::Context >& context, const Gdk::Color& color);
void set_source_pixbuf(::Cairo::RefPtr< ::Cairo::Context >& context, const Glib::RefPtr<Gdk::Pixbuf>& pixbuf, double pixbuf_x, double pixbuf_y);
void set_source_pixbuf(const ::Cairo::RefPtr< ::Cairo::Context >& context, const Glib::RefPtr<Gdk::Pixbuf>& pixbuf, double pixbuf_x, double pixbuf_y);
void set_source_pixmap(::Cairo::RefPtr< ::Cairo::Context >& context, const Glib::RefPtr<Gdk::Pixmap>& pixmap, double pixmap_x, double pixmap_y);
void set_source_pixmap(const ::Cairo::RefPtr< ::Cairo::Context >& context, const Glib::RefPtr<Gdk::Pixmap>& pixmap, double pixmap_x, double pixmap_y);
void rectangle(::Cairo::RefPtr< ::Cairo::Context >& context, const Gdk::Rectangle& rectangle);
void add_rectangle_to_path(const ::Cairo::RefPtr< ::Cairo::Context >& context, const Gdk::Rectangle& rectangle);
void region(::Cairo::RefPtr< ::Cairo::Context >& context, const Gdk::Region& region);
void add_region_to_path(const ::Cairo::RefPtr< ::Cairo::Context >& context, const Gdk::Region& region);
}
}
namespace Gdk
{
Glib::RefPtr<Colormap> rgb_get_colormap();
Glib::RefPtr<Visual> rgb_get_visual();
bool rgb_ditherable();
}
namespace Gtk
{
  using Glib::unconst;
}
typedef struct _GtkObject GtkObject;
typedef struct _GtkObjectClass GtkObjectClass;
namespace Gtk
{ class Object_Class; }
namespace Gtk
{
class Object;
template<class T>
T* manage(T* obj)
{
  obj->set_manage();
  return obj;
}
class Object : public Glib::Object
{
  public:
  typedef Object CppObjectType;
  typedef Object_Class CppClassType;
  typedef GtkObject BaseObjectType;
  typedef GtkObjectClass BaseClassType;
  virtual ~Object();
private:
  friend class Object_Class;
  static CppClassType object_class_;
  Object(const Object&);
  Object& operator=(const Object&);
protected:
  explicit Object(const Glib::ConstructParams& construct_params);
  explicit Object(GtkObject* castitem);
public:
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkObject* gobj() { return reinterpret_cast<GtkObject*>(gobject_); }
  const GtkObject* gobj() const { return reinterpret_cast<GtkObject*>(gobject_); }
public:
protected:
private:
public:
  virtual void set_manage();
  Glib::PropertyProxy<void*> property_user_data() ;
  Glib::PropertyProxy_ReadOnly<void*> property_user_data() const;
  bool is_managed_() const;
protected:
  void destroy_();
  void _init_unmanage(bool is_toplevel = false);
  virtual void destroy_notify_();
  void disconnect_cpp_wrapper();
  void _destroy_c_instance();
  static void callback_destroy_(GObject* gobject, void* data);
  bool referenced_;
  bool gobject_disposed_;
};
}
namespace Glib
{
  Gtk::Object* wrap(GtkObject* object, bool take_copy = false);
}
namespace Gtk
{
struct BuiltinStockID;
class StockID
{
public:
  StockID();
  StockID(const BuiltinStockID& id);
  explicit StockID(const Glib::ustring& id);
  explicit StockID(const char* id);
  ~StockID();
  StockID(const StockID& other);
  StockID& operator=(const StockID& other);
  bool equal(const StockID& rhs) const;
  Glib::ustring get_string() const;
  const char* get_c_str() const;
protected:
  Glib::ustring id_;
};
inline bool operator==(const StockID& lhs, const StockID& rhs)
  { return lhs.equal(rhs); }
inline bool operator!=(const StockID& lhs, const StockID& rhs)
  { return !lhs.equal(rhs); }
struct StockID_Traits : public Glib::Container_Helpers::TypeTraits<Glib::ustring>
{
  typedef Gtk::StockID CppType;
  static const char* to_c_type(const StockID& id) { return id.get_c_str(); }
  static StockID to_cpp_type(const char* str) { return StockID(str); }
};
}
namespace Glib
{
template <>
class Value<Gtk::StockID> : public Glib::ValueBase_String
{
public:
  typedef Gtk::StockID CppType;
  void set(const Gtk::StockID& data) { set_cstring(data.get_c_str()); }
  Gtk::StockID get() const { return Gtk::StockID(get_cstring()); }
};
}
typedef struct _GdkDragContext GdkDragContext;
typedef struct _GdkDragContextClass GdkDragContextClass;
namespace Gdk
{ class DragContext_Class; }
namespace Gtk
{
  class Widget;
}
namespace Gdk
{
enum DragAction
{
  ACTION_DEFAULT = 1 << 0,
  ACTION_COPY = 1 << 1,
  ACTION_MOVE = 1 << 2,
  ACTION_LINK = 1 << 3,
  ACTION_PRIVATE = 1 << 4,
  ACTION_ASK = 1 << 5
};
inline DragAction operator|(DragAction lhs, DragAction rhs)
  { return static_cast<DragAction>(static_cast<unsigned>(lhs) | static_cast<unsigned>(rhs)); }
inline DragAction operator&(DragAction lhs, DragAction rhs)
  { return static_cast<DragAction>(static_cast<unsigned>(lhs) & static_cast<unsigned>(rhs)); }
inline DragAction operator^(DragAction lhs, DragAction rhs)
  { return static_cast<DragAction>(static_cast<unsigned>(lhs) ^ static_cast<unsigned>(rhs)); }
inline DragAction operator~(DragAction flags)
  { return static_cast<DragAction>(~static_cast<unsigned>(flags)); }
inline DragAction& operator|=(DragAction& lhs, DragAction rhs)
  { return (lhs = static_cast<DragAction>(static_cast<unsigned>(lhs) | static_cast<unsigned>(rhs))); }
inline DragAction& operator&=(DragAction& lhs, DragAction rhs)
  { return (lhs = static_cast<DragAction>(static_cast<unsigned>(lhs) & static_cast<unsigned>(rhs))); }
inline DragAction& operator^=(DragAction& lhs, DragAction rhs)
  { return (lhs = static_cast<DragAction>(static_cast<unsigned>(lhs) ^ static_cast<unsigned>(rhs))); }
}
namespace Glib
{
template <>
class Value<Gdk::DragAction> : public Glib::Value_Flags<Gdk::DragAction>
{
public:
  static GType value_type() __attribute__((__const__));
};
}
namespace Gdk
{
enum DragProtocol
{
  DRAG_PROTO_MOTIF,
  DRAG_PROTO_XDND,
  DRAG_PROTO_NONE,
  DRAG_PROTO_WIN32_DROPFILES,
  DRAG_PROTO_OLE2,
  DRAG_PROTO_LOCAL
};
}
namespace Glib
{
template <>
class Value<Gdk::DragProtocol> : public Glib::Value_Enum<Gdk::DragProtocol>
{
public:
  static GType value_type() __attribute__((__const__));
};
}
namespace Gdk
{
class DragContext : public Glib::Object
{
public:
  typedef DragContext CppObjectType;
  typedef DragContext_Class CppClassType;
  typedef GdkDragContext BaseObjectType;
  typedef GdkDragContextClass BaseClassType;
private: friend class DragContext_Class;
  static CppClassType dragcontext_class_;
private:
  DragContext(const DragContext&);
  DragContext& operator=(const DragContext&);
protected:
  explicit DragContext(const Glib::ConstructParams& construct_params);
  explicit DragContext(GdkDragContext* castitem);
public:
  virtual ~DragContext();
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GdkDragContext* gobj() { return reinterpret_cast<GdkDragContext*>(gobject_); }
  const GdkDragContext* gobj() const { return reinterpret_cast<GdkDragContext*>(gobject_); }
  GdkDragContext* gobj_copy();
private:
protected:
  DragContext();
public:
  static Glib::RefPtr<DragContext> create();
  void drag_status(DragAction action, guint32 time);
  void drag_refuse(guint32 time);
  void drop_reply(bool ok, guint32 time);
  void drop_finish(bool success, guint32 time);
  Glib::ustring get_selection() const;
  void drag_finish(bool success, bool del, guint32 time);
  void set_icon(const Glib::RefPtr<Gdk::Colormap>& colormap, const Glib::RefPtr<Gdk::Pixmap>& pixmap, const Glib::RefPtr<Gdk::Bitmap>& mask, int hot_x, int hot_y);
  void set_icon(const Glib::RefPtr<Gdk::Pixbuf>& pixbuf, int hot_x, int hot_y);
  void set_icon(const Glib::ustring& stock_id, int hot_x, int hot_y);
  void set_icon_name(const Glib::ustring& name, int hot_x, int hot_y);
  void set_icon();
   Glib::RefPtr<Window> get_source_window();
  Glib::RefPtr<const Window> get_source_window() const;
   Glib::RefPtr<Window> get_destination_window();
  Glib::RefPtr<const Window> get_destination_window() const;
  Gdk::ListHandle_AtomString get_targets() const;
   DragProtocol get_protocol() const;
   bool get_is_source() const;
   DragAction get_actions() const;
   DragAction get_suggested_action() const;
   DragAction get_action() const;
   guint32 get_start_time() const;
  void find_window_for_screen(const Glib::RefPtr<Window>& drag_window, const Glib::RefPtr<Screen>& screen, int x_root, int y_root, Glib::RefPtr<Window>& dest_window, DragProtocol* protocol) const;
public:
public:
protected:
};
}
namespace Glib
{
  Glib::RefPtr<Gdk::DragContext> wrap(GdkDragContext* object, bool take_copy = false);
}
namespace Gtk
{
enum AccelFlags
{
  ACCEL_VISIBLE = 1 << 0,
  ACCEL_LOCKED = 1 << 1,
  ACCEL_MASK = 0x07
};
inline AccelFlags operator|(AccelFlags lhs, AccelFlags rhs)
  { return static_cast<AccelFlags>(static_cast<unsigned>(lhs) | static_cast<unsigned>(rhs)); }
inline AccelFlags operator&(AccelFlags lhs, AccelFlags rhs)
  { return static_cast<AccelFlags>(static_cast<unsigned>(lhs) & static_cast<unsigned>(rhs)); }
inline AccelFlags operator^(AccelFlags lhs, AccelFlags rhs)
  { return static_cast<AccelFlags>(static_cast<unsigned>(lhs) ^ static_cast<unsigned>(rhs)); }
inline AccelFlags operator~(AccelFlags flags)
  { return static_cast<AccelFlags>(~static_cast<unsigned>(flags)); }
inline AccelFlags& operator|=(AccelFlags& lhs, AccelFlags rhs)
  { return (lhs = static_cast<AccelFlags>(static_cast<unsigned>(lhs) | static_cast<unsigned>(rhs))); }
inline AccelFlags& operator&=(AccelFlags& lhs, AccelFlags rhs)
  { return (lhs = static_cast<AccelFlags>(static_cast<unsigned>(lhs) & static_cast<unsigned>(rhs))); }
inline AccelFlags& operator^=(AccelFlags& lhs, AccelFlags rhs)
  { return (lhs = static_cast<AccelFlags>(static_cast<unsigned>(lhs) ^ static_cast<unsigned>(rhs))); }
}
namespace Glib
{
template <>
class Value<Gtk::AccelFlags> : public Glib::Value_Flags<Gtk::AccelFlags>
{
public:
  static GType value_type() __attribute__((__const__));
};
}
namespace Gtk
{
enum AnchorType
{
  ANCHOR_CENTER,
  ANCHOR_NORTH,
  ANCHOR_NORTH_WEST,
  ANCHOR_NORTH_EAST,
  ANCHOR_SOUTH,
  ANCHOR_SOUTH_WEST,
  ANCHOR_SOUTH_EAST,
  ANCHOR_WEST,
  ANCHOR_EAST,
  ANCHOR_N = ANCHOR_NORTH,
  ANCHOR_NW = ANCHOR_NORTH_WEST,
  ANCHOR_NE = ANCHOR_NORTH_EAST,
  ANCHOR_S = ANCHOR_SOUTH,
  ANCHOR_SW = ANCHOR_SOUTH_WEST,
  ANCHOR_SE = ANCHOR_SOUTH_EAST,
  ANCHOR_W = ANCHOR_WEST,
  ANCHOR_E = ANCHOR_EAST
};
}
namespace Glib
{
template <>
class Value<Gtk::AnchorType> : public Glib::Value_Enum<Gtk::AnchorType>
{
public:
  static GType value_type() __attribute__((__const__));
};
}
namespace Gtk
{
enum ArrowType
{
  ARROW_UP,
  ARROW_DOWN,
  ARROW_LEFT,
  ARROW_RIGHT,
  ARROW_NONE
};
}
namespace Glib
{
template <>
class Value<Gtk::ArrowType> : public Glib::Value_Enum<Gtk::ArrowType>
{
public:
  static GType value_type() __attribute__((__const__));
};
}
namespace Gtk
{
enum AttachOptions
{
  EXPAND = 1 << 0,
  SHRINK = 1 << 1,
  FILL = 1 << 2
};
inline AttachOptions operator|(AttachOptions lhs, AttachOptions rhs)
  { return static_cast<AttachOptions>(static_cast<unsigned>(lhs) | static_cast<unsigned>(rhs)); }
inline AttachOptions operator&(AttachOptions lhs, AttachOptions rhs)
  { return static_cast<AttachOptions>(static_cast<unsigned>(lhs) & static_cast<unsigned>(rhs)); }
inline AttachOptions operator^(AttachOptions lhs, AttachOptions rhs)
  { return static_cast<AttachOptions>(static_cast<unsigned>(lhs) ^ static_cast<unsigned>(rhs)); }
inline AttachOptions operator~(AttachOptions flags)
  { return static_cast<AttachOptions>(~static_cast<unsigned>(flags)); }
inline AttachOptions& operator|=(AttachOptions& lhs, AttachOptions rhs)
  { return (lhs = static_cast<AttachOptions>(static_cast<unsigned>(lhs) | static_cast<unsigned>(rhs))); }
inline AttachOptions& operator&=(AttachOptions& lhs, AttachOptions rhs)
  { return (lhs = static_cast<AttachOptions>(static_cast<unsigned>(lhs) & static_cast<unsigned>(rhs))); }
inline AttachOptions& operator^=(AttachOptions& lhs, AttachOptions rhs)
  { return (lhs = static_cast<AttachOptions>(static_cast<unsigned>(lhs) ^ static_cast<unsigned>(rhs))); }
}
namespace Glib
{
template <>
class Value<Gtk::AttachOptions> : public Glib::Value_Flags<Gtk::AttachOptions>
{
public:
  static GType value_type() __attribute__((__const__));
};
}
namespace Gtk
{
enum ButtonBoxStyle
{
  BUTTONBOX_DEFAULT_STYLE,
  BUTTONBOX_SPREAD,
  BUTTONBOX_EDGE,
  BUTTONBOX_START,
  BUTTONBOX_END,
  BUTTONBOX_CENTER
};
}
namespace Glib
{
template <>
class Value<Gtk::ButtonBoxStyle> : public Glib::Value_Enum<Gtk::ButtonBoxStyle>
{
public:
  static GType value_type() __attribute__((__const__));
};
}
namespace Gtk
{
enum CurveType
{
  CURVE_TYPE_LINEAR,
  CURVE_TYPE_SPLINE,
  CURVE_TYPE_FREE
};
}
namespace Glib
{
template <>
class Value<Gtk::CurveType> : public Glib::Value_Enum<Gtk::CurveType>
{
public:
  static GType value_type() __attribute__((__const__));
};
}
namespace Gtk
{
enum DeleteType
{
  DELETE_CHARS,
  DELETE_WORDS,
  DELETE_DISPLAY_LINES,
  DELETE_DISPLAY_LINE_ENDS,
  DELETE_PARAGRAPH_ENDS,
  DELETE_PARAGRAPHS,
  DELETE_WHITESPACE
};
}
namespace Glib
{
template <>
class Value<Gtk::DeleteType> : public Glib::Value_Enum<Gtk::DeleteType>
{
public:
  static GType value_type() __attribute__((__const__));
};
}
namespace Gtk
{
enum DirectionType
{
  DIR_TAB_FORWARD,
  DIR_TAB_BACKWARD,
  DIR_UP,
  DIR_DOWN,
  DIR_LEFT,
  DIR_RIGHT
};
}
namespace Glib
{
template <>
class Value<Gtk::DirectionType> : public Glib::Value_Enum<Gtk::DirectionType>
{
public:
  static GType value_type() __attribute__((__const__));
};
}
namespace Gtk
{
enum ExpanderStyle
{
  EXPANDER_COLLAPSED,
  EXPANDER_SEMI_COLLAPSED,
  EXPANDER_SEMI_EXPANDED,
  EXPANDER_EXPANDED
};
}
namespace Glib
{
template <>
class Value<Gtk::ExpanderStyle> : public Glib::Value_Enum<Gtk::ExpanderStyle>
{
public:
  static GType value_type() __attribute__((__const__));
};
}
namespace Gtk
{
enum BuiltinIconSize
{
  ICON_SIZE_INVALID,
  ICON_SIZE_MENU,
  ICON_SIZE_SMALL_TOOLBAR,
  ICON_SIZE_LARGE_TOOLBAR,
  ICON_SIZE_BUTTON,
  ICON_SIZE_DND,
  ICON_SIZE_DIALOG
};
}
namespace Glib
{
template <>
class Value<Gtk::BuiltinIconSize> : public Glib::Value_Enum<Gtk::BuiltinIconSize>
{
public:
  static GType value_type() __attribute__((__const__));
};
}
namespace Gtk
{
enum TextDirection
{
  TEXT_DIR_NONE,
  TEXT_DIR_LTR,
  TEXT_DIR_RTL
};
}
namespace Glib
{
template <>
class Value<Gtk::TextDirection> : public Glib::Value_Enum<Gtk::TextDirection>
{
public:
  static GType value_type() __attribute__((__const__));
};
}
namespace Gtk
{
enum Justification
{
  JUSTIFY_LEFT,
  JUSTIFY_RIGHT,
  JUSTIFY_CENTER,
  JUSTIFY_FILL
};
}
namespace Glib
{
template <>
class Value<Gtk::Justification> : public Glib::Value_Enum<Gtk::Justification>
{
public:
  static GType value_type() __attribute__((__const__));
};
}
namespace Gtk
{
enum MenuDirectionType
{
  MENU_DIR_PARENT,
  MENU_DIR_CHILD,
  MENU_DIR_NEXT,
  MENU_DIR_PREV
};
}
namespace Glib
{
template <>
class Value<Gtk::MenuDirectionType> : public Glib::Value_Enum<Gtk::MenuDirectionType>
{
public:
  static GType value_type() __attribute__((__const__));
};
}
namespace Gtk
{
enum MetricType
{
  PIXELS,
  INCHES,
  CENTIMETERS
};
}
namespace Glib
{
template <>
class Value<Gtk::MetricType> : public Glib::Value_Enum<Gtk::MetricType>
{
public:
  static GType value_type() __attribute__((__const__));
};
}
namespace Gtk
{
enum MovementStep
{
  MOVEMENT_LOGICAL_POSITIONS,
  MOVEMENT_VISUAL_POSITIONS,
  MOVEMENT_WORDS,
  MOVEMENT_DISPLAY_LINES,
  MOVEMENT_DISPLAY_LINE_ENDS,
  MOVEMENT_PARAGRAPHS,
  MOVEMENT_PARAGRAPH_ENDS,
  MOVEMENT_PAGES,
  MOVEMENT_BUFFER_ENDS,
  MOVEMENT_HORIZONTAL_PAGES
};
}
namespace Glib
{
template <>
class Value<Gtk::MovementStep> : public Glib::Value_Enum<Gtk::MovementStep>
{
public:
  static GType value_type() __attribute__((__const__));
};
}
namespace Gtk
{
enum Orientation
{
  ORIENTATION_HORIZONTAL,
  ORIENTATION_VERTICAL
};
}
namespace Glib
{
template <>
class Value<Gtk::Orientation> : public Glib::Value_Enum<Gtk::Orientation>
{
public:
  static GType value_type() __attribute__((__const__));
};
}
namespace Gtk
{
enum CornerType
{
  CORNER_TOP_LEFT,
  CORNER_BOTTOM_LEFT,
  CORNER_TOP_RIGHT,
  CORNER_BOTTOM_RIGHT
};
}
namespace Glib
{
template <>
class Value<Gtk::CornerType> : public Glib::Value_Enum<Gtk::CornerType>
{
public:
  static GType value_type() __attribute__((__const__));
};
}
namespace Gtk
{
enum PackType
{
  PACK_START,
  PACK_END
};
}
namespace Glib
{
template <>
class Value<Gtk::PackType> : public Glib::Value_Enum<Gtk::PackType>
{
public:
  static GType value_type() __attribute__((__const__));
};
}
namespace Gtk
{
enum PathPriorityType
{
  PATH_PRIO_LOWEST = 0,
  PATH_PRIO_GTK = 4,
  PATH_PRIO_APPLICATION = 8,
  PATH_PRIO_THEME = 10,
  PATH_PRIO_RC = 12,
  PATH_PRIO_HIGHEST = 15
};
}
namespace Glib
{
template <>
class Value<Gtk::PathPriorityType> : public Glib::Value_Enum<Gtk::PathPriorityType>
{
public:
  static GType value_type() __attribute__((__const__));
};
}
namespace Gtk
{
enum PathType
{
  PATH_WIDGET,
  PATH_WIDGET_CLASS,
  PATH_CLASS
};
}
namespace Glib
{
template <>
class Value<Gtk::PathType> : public Glib::Value_Enum<Gtk::PathType>
{
public:
  static GType value_type() __attribute__((__const__));
};
}
namespace Gtk
{
enum PolicyType
{
  POLICY_ALWAYS,
  POLICY_AUTOMATIC,
  POLICY_NEVER
};
}
namespace Glib
{
template <>
class Value<Gtk::PolicyType> : public Glib::Value_Enum<Gtk::PolicyType>
{
public:
  static GType value_type() __attribute__((__const__));
};
}
namespace Gtk
{
enum PositionType
{
  POS_LEFT,
  POS_RIGHT,
  POS_TOP,
  POS_BOTTOM
};
}
namespace Glib
{
template <>
class Value<Gtk::PositionType> : public Glib::Value_Enum<Gtk::PositionType>
{
public:
  static GType value_type() __attribute__((__const__));
};
}
namespace Gtk
{
enum ReliefStyle
{
  RELIEF_NORMAL,
  RELIEF_HALF,
  RELIEF_NONE
};
}
namespace Glib
{
template <>
class Value<Gtk::ReliefStyle> : public Glib::Value_Enum<Gtk::ReliefStyle>
{
public:
  static GType value_type() __attribute__((__const__));
};
}
namespace Gtk
{
enum ResizeMode
{
  RESIZE_PARENT,
  RESIZE_QUEUE,
  RESIZE_IMMEDIATE
};
}
namespace Glib
{
template <>
class Value<Gtk::ResizeMode> : public Glib::Value_Enum<Gtk::ResizeMode>
{
public:
  static GType value_type() __attribute__((__const__));
};
}
namespace Gtk
{
enum ScrollType
{
  SCROLL_NONE,
  SCROLL_JUMP,
  SCROLL_STEP_BACKWARD,
  SCROLL_STEP_FORWARD,
  SCROLL_PAGE_BACKWARD,
  SCROLL_PAGE_FORWARD,
  SCROLL_STEP_UP,
  SCROLL_STEP_DOWN,
  SCROLL_PAGE_UP,
  SCROLL_PAGE_DOWN,
  SCROLL_STEP_LEFT,
  SCROLL_STEP_RIGHT,
  SCROLL_PAGE_LEFT,
  SCROLL_PAGE_RIGHT,
  SCROLL_START,
  SCROLL_END
};
}
namespace Glib
{
template <>
class Value<Gtk::ScrollType> : public Glib::Value_Enum<Gtk::ScrollType>
{
public:
  static GType value_type() __attribute__((__const__));
};
}
namespace Gtk
{
enum SelectionMode
{
  SELECTION_NONE,
  SELECTION_SINGLE,
  SELECTION_BROWSE,
  SELECTION_MULTIPLE,
  SELECTION_EXTENDED = SELECTION_MULTIPLE
};
}
namespace Glib
{
template <>
class Value<Gtk::SelectionMode> : public Glib::Value_Enum<Gtk::SelectionMode>
{
public:
  static GType value_type() __attribute__((__const__));
};
}
namespace Gtk
{
enum ShadowType
{
  SHADOW_NONE,
  SHADOW_IN,
  SHADOW_OUT,
  SHADOW_ETCHED_IN,
  SHADOW_ETCHED_OUT
};
}
namespace Glib
{
template <>
class Value<Gtk::ShadowType> : public Glib::Value_Enum<Gtk::ShadowType>
{
public:
  static GType value_type() __attribute__((__const__));
};
}
namespace Gtk
{
enum StateType
{
  STATE_NORMAL,
  STATE_ACTIVE,
  STATE_PRELIGHT,
  STATE_SELECTED,
  STATE_INSENSITIVE
};
}
namespace Glib
{
template <>
class Value<Gtk::StateType> : public Glib::Value_Enum<Gtk::StateType>
{
public:
  static GType value_type() __attribute__((__const__));
};
}
namespace Gtk
{
enum TargetFlags
{
  TARGET_SAME_APP = 1 << 0,
  TARGET_SAME_WIDGET = 1 << 1,
  TARGET_OTHER_APP = 1 << 2,
  TARGET_OTHER_WIDGET = 1 << 3
};
inline TargetFlags operator|(TargetFlags lhs, TargetFlags rhs)
  { return static_cast<TargetFlags>(static_cast<unsigned>(lhs) | static_cast<unsigned>(rhs)); }
inline TargetFlags operator&(TargetFlags lhs, TargetFlags rhs)
  { return static_cast<TargetFlags>(static_cast<unsigned>(lhs) & static_cast<unsigned>(rhs)); }
inline TargetFlags operator^(TargetFlags lhs, TargetFlags rhs)
  { return static_cast<TargetFlags>(static_cast<unsigned>(lhs) ^ static_cast<unsigned>(rhs)); }
inline TargetFlags operator~(TargetFlags flags)
  { return static_cast<TargetFlags>(~static_cast<unsigned>(flags)); }
inline TargetFlags& operator|=(TargetFlags& lhs, TargetFlags rhs)
  { return (lhs = static_cast<TargetFlags>(static_cast<unsigned>(lhs) | static_cast<unsigned>(rhs))); }
inline TargetFlags& operator&=(TargetFlags& lhs, TargetFlags rhs)
  { return (lhs = static_cast<TargetFlags>(static_cast<unsigned>(lhs) & static_cast<unsigned>(rhs))); }
inline TargetFlags& operator^=(TargetFlags& lhs, TargetFlags rhs)
  { return (lhs = static_cast<TargetFlags>(static_cast<unsigned>(lhs) ^ static_cast<unsigned>(rhs))); }
}
namespace Glib
{
template <>
class Value<Gtk::TargetFlags> : public Glib::Value_Flags<Gtk::TargetFlags>
{
public:
  static GType value_type() __attribute__((__const__));
};
}
namespace Gtk
{
enum ToolbarStyle
{
  TOOLBAR_ICONS,
  TOOLBAR_TEXT,
  TOOLBAR_BOTH,
  TOOLBAR_BOTH_HORIZ
};
}
namespace Glib
{
template <>
class Value<Gtk::ToolbarStyle> : public Glib::Value_Enum<Gtk::ToolbarStyle>
{
public:
  static GType value_type() __attribute__((__const__));
};
}
namespace Gtk
{
enum UpdateType
{
  UPDATE_CONTINUOUS,
  UPDATE_DISCONTINUOUS,
  UPDATE_DELAYED
};
}
namespace Glib
{
template <>
class Value<Gtk::UpdateType> : public Glib::Value_Enum<Gtk::UpdateType>
{
public:
  static GType value_type() __attribute__((__const__));
};
}
namespace Gtk
{
enum Visibility
{
  VISIBILITY_NONE,
  VISIBILITY_PARTIAL,
  VISIBILITY_FULL
};
}
namespace Glib
{
template <>
class Value<Gtk::Visibility> : public Glib::Value_Enum<Gtk::Visibility>
{
public:
  static GType value_type() __attribute__((__const__));
};
}
namespace Gtk
{
enum WindowPosition
{
  WIN_POS_NONE,
  WIN_POS_CENTER,
  WIN_POS_MOUSE,
  WIN_POS_CENTER_ALWAYS,
  WIN_POS_CENTER_ON_PARENT
};
}
namespace Glib
{
template <>
class Value<Gtk::WindowPosition> : public Glib::Value_Enum<Gtk::WindowPosition>
{
public:
  static GType value_type() __attribute__((__const__));
};
}
namespace Gtk
{
enum WindowType
{
  WINDOW_TOPLEVEL,
  WINDOW_POPUP
};
}
namespace Glib
{
template <>
class Value<Gtk::WindowType> : public Glib::Value_Enum<Gtk::WindowType>
{
public:
  static GType value_type() __attribute__((__const__));
};
}
namespace Gtk
{
enum WrapMode
{
  WRAP_NONE,
  WRAP_CHAR,
  WRAP_WORD,
  WRAP_WORD_CHAR
};
}
namespace Glib
{
template <>
class Value<Gtk::WrapMode> : public Glib::Value_Enum<Gtk::WrapMode>
{
public:
  static GType value_type() __attribute__((__const__));
};
}
namespace Gtk
{
enum SortType
{
  SORT_ASCENDING,
  SORT_DESCENDING
};
}
namespace Glib
{
template <>
class Value<Gtk::SortType> : public Glib::Value_Enum<Gtk::SortType>
{
public:
  static GType value_type() __attribute__((__const__));
};
}
namespace Gtk
{
enum PageOrientation
{
  PAGE_ORIENTATION_PORTRAIT,
  PAGE_ORIENTATION_LANDSCAPE,
  PAGE_ORIENTATION_REVERSE_PORTRAIT,
  PAGE_ORIENTATION_REVERSE_LANDSCAPE
};
}
namespace Glib
{
template <>
class Value<Gtk::PageOrientation> : public Glib::Value_Enum<Gtk::PageOrientation>
{
public:
  static GType value_type() __attribute__((__const__));
};
}
namespace Gtk
{
class IconSize
{
private:
  int size_;
public:
  IconSize() : size_ (0) {}
  IconSize(BuiltinIconSize size) : size_ (size) {}
  explicit IconSize(int size) : size_ (size) {}
  operator int() const { return size_; }
  static bool lookup(IconSize size, int& width, int& height);
  static IconSize register_new(const Glib::ustring& name, int width, int height);
  static void register_alias(const Glib::ustring& alias, IconSize target);
  static IconSize from_name(const Glib::ustring& name);
  static Glib::ustring get_name(IconSize size);
};
}
namespace Glib
{
template <>
class Value<Gtk::IconSize> : public Glib::Value_Enum<Gtk::IconSize>
{
public:
  static GType value_type() __attribute__((__const__));
};
}
namespace Gtk
{
  enum AlignmentEnum
  {
    ALIGN_LEFT,
    ALIGN_CENTER,
    ALIGN_RIGHT,
    ALIGN_TOP,
    ALIGN_BOTTOM
  };
float _gtkmm_align_float_from_enum(AlignmentEnum value);
}
extern "C" {
typedef enum
{
  GTK_ANCHOR_CENTER,
  GTK_ANCHOR_NORTH,
  GTK_ANCHOR_NORTH_WEST,
  GTK_ANCHOR_NORTH_EAST,
  GTK_ANCHOR_SOUTH,
  GTK_ANCHOR_SOUTH_WEST,
  GTK_ANCHOR_SOUTH_EAST,
  GTK_ANCHOR_WEST,
  GTK_ANCHOR_EAST,
  GTK_ANCHOR_N = GTK_ANCHOR_NORTH,
  GTK_ANCHOR_NW = GTK_ANCHOR_NORTH_WEST,
  GTK_ANCHOR_NE = GTK_ANCHOR_NORTH_EAST,
  GTK_ANCHOR_S = GTK_ANCHOR_SOUTH,
  GTK_ANCHOR_SW = GTK_ANCHOR_SOUTH_WEST,
  GTK_ANCHOR_SE = GTK_ANCHOR_SOUTH_EAST,
  GTK_ANCHOR_W = GTK_ANCHOR_WEST,
  GTK_ANCHOR_E = GTK_ANCHOR_EAST
} GtkAnchorType;
typedef enum
{
  GTK_ARROW_UP,
  GTK_ARROW_DOWN,
  GTK_ARROW_LEFT,
  GTK_ARROW_RIGHT,
  GTK_ARROW_NONE
} GtkArrowType;
typedef enum
{
  GTK_EXPAND = 1 << 0,
  GTK_SHRINK = 1 << 1,
  GTK_FILL = 1 << 2
} GtkAttachOptions;
typedef enum
{
  GTK_BUTTONBOX_DEFAULT_STYLE,
  GTK_BUTTONBOX_SPREAD,
  GTK_BUTTONBOX_EDGE,
  GTK_BUTTONBOX_START,
  GTK_BUTTONBOX_END,
  GTK_BUTTONBOX_CENTER
} GtkButtonBoxStyle;
typedef enum
{
  GTK_CURVE_TYPE_LINEAR,
  GTK_CURVE_TYPE_SPLINE,
  GTK_CURVE_TYPE_FREE
} GtkCurveType;
typedef enum {
  GTK_DELETE_CHARS,
  GTK_DELETE_WORD_ENDS,
  GTK_DELETE_WORDS,
  GTK_DELETE_DISPLAY_LINES,
  GTK_DELETE_DISPLAY_LINE_ENDS,
  GTK_DELETE_PARAGRAPH_ENDS,
  GTK_DELETE_PARAGRAPHS,
  GTK_DELETE_WHITESPACE
} GtkDeleteType;
typedef enum
{
  GTK_DIR_TAB_FORWARD,
  GTK_DIR_TAB_BACKWARD,
  GTK_DIR_UP,
  GTK_DIR_DOWN,
  GTK_DIR_LEFT,
  GTK_DIR_RIGHT
} GtkDirectionType;
typedef enum
{
  GTK_EXPANDER_COLLAPSED,
  GTK_EXPANDER_SEMI_COLLAPSED,
  GTK_EXPANDER_SEMI_EXPANDED,
  GTK_EXPANDER_EXPANDED
} GtkExpanderStyle;
typedef enum
{
  GTK_ICON_SIZE_INVALID,
  GTK_ICON_SIZE_MENU,
  GTK_ICON_SIZE_SMALL_TOOLBAR,
  GTK_ICON_SIZE_LARGE_TOOLBAR,
  GTK_ICON_SIZE_BUTTON,
  GTK_ICON_SIZE_DND,
  GTK_ICON_SIZE_DIALOG
} GtkIconSize;
typedef enum
{
  GTK_SENSITIVITY_AUTO,
  GTK_SENSITIVITY_ON,
  GTK_SENSITIVITY_OFF
} GtkSensitivityType;
typedef enum
{
  GTK_SIDE_TOP,
  GTK_SIDE_BOTTOM,
  GTK_SIDE_LEFT,
  GTK_SIDE_RIGHT
} GtkSideType;
typedef enum
{
  GTK_TEXT_DIR_NONE,
  GTK_TEXT_DIR_LTR,
  GTK_TEXT_DIR_RTL
} GtkTextDirection;
typedef enum
{
  GTK_JUSTIFY_LEFT,
  GTK_JUSTIFY_RIGHT,
  GTK_JUSTIFY_CENTER,
  GTK_JUSTIFY_FILL
} GtkJustification;
typedef enum
{
  GTK_MATCH_ALL,
  GTK_MATCH_ALL_TAIL,
  GTK_MATCH_HEAD,
  GTK_MATCH_TAIL,
  GTK_MATCH_EXACT,
  GTK_MATCH_LAST
} GtkMatchType;
typedef enum
{
  GTK_MENU_DIR_PARENT,
  GTK_MENU_DIR_CHILD,
  GTK_MENU_DIR_NEXT,
  GTK_MENU_DIR_PREV
} GtkMenuDirectionType;
typedef enum
{
  GTK_PIXELS,
  GTK_INCHES,
  GTK_CENTIMETERS
} GtkMetricType;
typedef enum
{
  GTK_MOVEMENT_LOGICAL_POSITIONS,
  GTK_MOVEMENT_VISUAL_POSITIONS,
  GTK_MOVEMENT_WORDS,
  GTK_MOVEMENT_DISPLAY_LINES,
  GTK_MOVEMENT_DISPLAY_LINE_ENDS,
  GTK_MOVEMENT_PARAGRAPHS,
  GTK_MOVEMENT_PARAGRAPH_ENDS,
  GTK_MOVEMENT_PAGES,
  GTK_MOVEMENT_BUFFER_ENDS,
  GTK_MOVEMENT_HORIZONTAL_PAGES
} GtkMovementStep;
typedef enum
{
  GTK_SCROLL_STEPS,
  GTK_SCROLL_PAGES,
  GTK_SCROLL_ENDS,
  GTK_SCROLL_HORIZONTAL_STEPS,
  GTK_SCROLL_HORIZONTAL_PAGES,
  GTK_SCROLL_HORIZONTAL_ENDS
} GtkScrollStep;
typedef enum
{
  GTK_ORIENTATION_HORIZONTAL,
  GTK_ORIENTATION_VERTICAL
} GtkOrientation;
typedef enum
{
  GTK_CORNER_TOP_LEFT,
  GTK_CORNER_BOTTOM_LEFT,
  GTK_CORNER_TOP_RIGHT,
  GTK_CORNER_BOTTOM_RIGHT
} GtkCornerType;
typedef enum
{
  GTK_PACK_START,
  GTK_PACK_END
} GtkPackType;
typedef enum
{
  GTK_PATH_PRIO_LOWEST = 0,
  GTK_PATH_PRIO_GTK = 4,
  GTK_PATH_PRIO_APPLICATION = 8,
  GTK_PATH_PRIO_THEME = 10,
  GTK_PATH_PRIO_RC = 12,
  GTK_PATH_PRIO_HIGHEST = 15
} GtkPathPriorityType;
typedef enum
{
  GTK_PATH_WIDGET,
  GTK_PATH_WIDGET_CLASS,
  GTK_PATH_CLASS
} GtkPathType;
typedef enum
{
  GTK_POLICY_ALWAYS,
  GTK_POLICY_AUTOMATIC,
  GTK_POLICY_NEVER
} GtkPolicyType;
typedef enum
{
  GTK_POS_LEFT,
  GTK_POS_RIGHT,
  GTK_POS_TOP,
  GTK_POS_BOTTOM
} GtkPositionType;
typedef enum
{
  GTK_PREVIEW_COLOR,
  GTK_PREVIEW_GRAYSCALE
} GtkPreviewType;
typedef enum
{
  GTK_RELIEF_NORMAL,
  GTK_RELIEF_HALF,
  GTK_RELIEF_NONE
} GtkReliefStyle;
typedef enum
{
  GTK_RESIZE_PARENT,
  GTK_RESIZE_QUEUE,
  GTK_RESIZE_IMMEDIATE
} GtkResizeMode;
typedef enum
{
  GTK_RUN_FIRST = G_SIGNAL_RUN_FIRST,
  GTK_RUN_LAST = G_SIGNAL_RUN_LAST,
  GTK_RUN_BOTH = (GTK_RUN_FIRST | GTK_RUN_LAST),
  GTK_RUN_NO_RECURSE = G_SIGNAL_NO_RECURSE,
  GTK_RUN_ACTION = G_SIGNAL_ACTION,
  GTK_RUN_NO_HOOKS = G_SIGNAL_NO_HOOKS
} GtkSignalRunType;
typedef enum
{
  GTK_SCROLL_NONE,
  GTK_SCROLL_JUMP,
  GTK_SCROLL_STEP_BACKWARD,
  GTK_SCROLL_STEP_FORWARD,
  GTK_SCROLL_PAGE_BACKWARD,
  GTK_SCROLL_PAGE_FORWARD,
  GTK_SCROLL_STEP_UP,
  GTK_SCROLL_STEP_DOWN,
  GTK_SCROLL_PAGE_UP,
  GTK_SCROLL_PAGE_DOWN,
  GTK_SCROLL_STEP_LEFT,
  GTK_SCROLL_STEP_RIGHT,
  GTK_SCROLL_PAGE_LEFT,
  GTK_SCROLL_PAGE_RIGHT,
  GTK_SCROLL_START,
  GTK_SCROLL_END
} GtkScrollType;
typedef enum
{
  GTK_SELECTION_NONE,
  GTK_SELECTION_SINGLE,
  GTK_SELECTION_BROWSE,
  GTK_SELECTION_MULTIPLE,
  GTK_SELECTION_EXTENDED = GTK_SELECTION_MULTIPLE
} GtkSelectionMode;
typedef enum
{
  GTK_SHADOW_NONE,
  GTK_SHADOW_IN,
  GTK_SHADOW_OUT,
  GTK_SHADOW_ETCHED_IN,
  GTK_SHADOW_ETCHED_OUT
} GtkShadowType;
typedef enum
{
  GTK_STATE_NORMAL,
  GTK_STATE_ACTIVE,
  GTK_STATE_PRELIGHT,
  GTK_STATE_SELECTED,
  GTK_STATE_INSENSITIVE
} GtkStateType;
typedef enum
{
  GTK_DIRECTION_LEFT,
  GTK_DIRECTION_RIGHT
} GtkSubmenuDirection;
typedef enum
{
  GTK_TOP_BOTTOM,
  GTK_LEFT_RIGHT
} GtkSubmenuPlacement;
typedef enum
{
  GTK_TOOLBAR_ICONS,
  GTK_TOOLBAR_TEXT,
  GTK_TOOLBAR_BOTH,
  GTK_TOOLBAR_BOTH_HORIZ
} GtkToolbarStyle;
typedef enum
{
  GTK_UPDATE_CONTINUOUS,
  GTK_UPDATE_DISCONTINUOUS,
  GTK_UPDATE_DELAYED
} GtkUpdateType;
typedef enum
{
  GTK_VISIBILITY_NONE,
  GTK_VISIBILITY_PARTIAL,
  GTK_VISIBILITY_FULL
} GtkVisibility;
typedef enum
{
  GTK_WIN_POS_NONE,
  GTK_WIN_POS_CENTER,
  GTK_WIN_POS_MOUSE,
  GTK_WIN_POS_CENTER_ALWAYS,
  GTK_WIN_POS_CENTER_ON_PARENT
} GtkWindowPosition;
typedef enum
{
  GTK_WINDOW_TOPLEVEL,
  GTK_WINDOW_POPUP
} GtkWindowType;
typedef enum
{
  GTK_WRAP_NONE,
  GTK_WRAP_CHAR,
  GTK_WRAP_WORD,
  GTK_WRAP_WORD_CHAR
} GtkWrapMode;
typedef enum
{
  GTK_SORT_ASCENDING,
  GTK_SORT_DESCENDING
} GtkSortType;
typedef enum
{
  GTK_IM_PREEDIT_NOTHING,
  GTK_IM_PREEDIT_CALLBACK,
  GTK_IM_PREEDIT_NONE
} GtkIMPreeditStyle;
typedef enum
{
  GTK_IM_STATUS_NOTHING,
  GTK_IM_STATUS_CALLBACK,
  GTK_IM_STATUS_NONE
} GtkIMStatusStyle;
typedef enum
{
  GTK_PACK_DIRECTION_LTR,
  GTK_PACK_DIRECTION_RTL,
  GTK_PACK_DIRECTION_TTB,
  GTK_PACK_DIRECTION_BTT
} GtkPackDirection;
typedef enum {
  GTK_PRINT_PAGES_ALL,
  GTK_PRINT_PAGES_CURRENT,
  GTK_PRINT_PAGES_RANGES
} GtkPrintPages;
typedef enum {
  GTK_PAGE_SET_ALL,
  GTK_PAGE_SET_EVEN,
  GTK_PAGE_SET_ODD
} GtkPageSet;
typedef enum {
  GTK_PAGE_ORIENTATION_PORTRAIT,
  GTK_PAGE_ORIENTATION_LANDSCAPE,
  GTK_PAGE_ORIENTATION_REVERSE_PORTRAIT,
  GTK_PAGE_ORIENTATION_REVERSE_LANDSCAPE
} GtkPageOrientation;
typedef enum {
  GTK_PRINT_QUALITY_LOW,
  GTK_PRINT_QUALITY_NORMAL,
  GTK_PRINT_QUALITY_HIGH,
  GTK_PRINT_QUALITY_DRAFT
} GtkPrintQuality;
typedef enum {
  GTK_PRINT_DUPLEX_SIMPLEX,
  GTK_PRINT_DUPLEX_HORIZONTAL,
  GTK_PRINT_DUPLEX_VERTICAL
} GtkPrintDuplex;
typedef enum {
  GTK_UNIT_PIXEL,
  GTK_UNIT_POINTS,
  GTK_UNIT_INCH,
  GTK_UNIT_MM
} GtkUnit;
typedef enum {
  GTK_TREE_VIEW_GRID_LINES_NONE,
  GTK_TREE_VIEW_GRID_LINES_HORIZONTAL,
  GTK_TREE_VIEW_GRID_LINES_VERTICAL,
  GTK_TREE_VIEW_GRID_LINES_BOTH
} GtkTreeViewGridLines;
typedef enum {
  GTK_DRAG_RESULT_SUCCESS,
  GTK_DRAG_RESULT_NO_TARGET,
  GTK_DRAG_RESULT_USER_CANCELLED,
  GTK_DRAG_RESULT_TIMEOUT_EXPIRED,
  GTK_DRAG_RESULT_GRAB_BROKEN,
  GTK_DRAG_RESULT_ERROR
} GtkDragResult;
}
extern "C" {
typedef enum
{
  GTK_ACCEL_VISIBLE = 1 << 0,
  GTK_ACCEL_LOCKED = 1 << 1,
  GTK_ACCEL_MASK = 0x07
} GtkAccelFlags;
typedef struct _GtkAccelGroup GtkAccelGroup;
typedef struct _GtkAccelGroupClass GtkAccelGroupClass;
typedef struct _GtkAccelKey GtkAccelKey;
typedef struct _GtkAccelGroupEntry GtkAccelGroupEntry;
typedef gboolean (*GtkAccelGroupActivate) (GtkAccelGroup *accel_group,
        GObject *acceleratable,
        guint keyval,
        GdkModifierType modifier);
typedef gboolean (*GtkAccelGroupFindFunc) (GtkAccelKey *key,
        GClosure *closure,
        gpointer data);
struct _GtkAccelGroup
{
  GObject parent;
  guint lock_count;
  GdkModifierType modifier_mask;
  GSList *acceleratables;
  guint n_accels;
  GtkAccelGroupEntry *priv_accels;
};
struct _GtkAccelGroupClass
{
  GObjectClass parent_class;
  void (*accel_changed) (GtkAccelGroup *accel_group,
     guint keyval,
     GdkModifierType modifier,
     GClosure *accel_closure);
  void (*_gtk_reserved1) (void);
  void (*_gtk_reserved2) (void);
  void (*_gtk_reserved3) (void);
  void (*_gtk_reserved4) (void);
};
struct _GtkAccelKey
{
  guint accel_key;
  GdkModifierType accel_mods;
  guint accel_flags : 16;
};
GType gtk_accel_group_get_type (void) __attribute__((__const__));
GtkAccelGroup* gtk_accel_group_new (void);
void gtk_accel_group_lock (GtkAccelGroup *accel_group);
void gtk_accel_group_unlock (GtkAccelGroup *accel_group);
void gtk_accel_group_connect (GtkAccelGroup *accel_group,
         guint accel_key,
         GdkModifierType accel_mods,
         GtkAccelFlags accel_flags,
         GClosure *closure);
void gtk_accel_group_connect_by_path (GtkAccelGroup *accel_group,
         const gchar *accel_path,
         GClosure *closure);
gboolean gtk_accel_group_disconnect (GtkAccelGroup *accel_group,
         GClosure *closure);
gboolean gtk_accel_group_disconnect_key (GtkAccelGroup *accel_group,
         guint accel_key,
         GdkModifierType accel_mods);
gboolean gtk_accel_group_activate (GtkAccelGroup *accel_group,
                                                   GQuark accel_quark,
                                                   GObject *acceleratable,
                                                   guint accel_key,
                                                   GdkModifierType accel_mods);
void _gtk_accel_group_attach (GtkAccelGroup *accel_group,
       GObject *object);
void _gtk_accel_group_detach (GtkAccelGroup *accel_group,
       GObject *object);
gboolean gtk_accel_groups_activate (GObject *object,
       guint accel_key,
       GdkModifierType accel_mods);
GSList* gtk_accel_groups_from_object (GObject *object);
GtkAccelKey* gtk_accel_group_find (GtkAccelGroup *accel_group,
       GtkAccelGroupFindFunc find_func,
       gpointer data);
GtkAccelGroup* gtk_accel_group_from_accel_closure (GClosure *closure);
gboolean gtk_accelerator_valid (guint keyval,
            GdkModifierType modifiers) __attribute__((__const__));
void gtk_accelerator_parse (const gchar *accelerator,
            guint *accelerator_key,
            GdkModifierType *accelerator_mods);
gchar* gtk_accelerator_name (guint accelerator_key,
            GdkModifierType accelerator_mods);
gchar* gtk_accelerator_get_label (guint accelerator_key,
                                               GdkModifierType accelerator_mods);
void gtk_accelerator_set_default_mod_mask (GdkModifierType default_mod_mask);
guint gtk_accelerator_get_default_mod_mask (void);
GtkAccelGroupEntry* gtk_accel_group_query (GtkAccelGroup *accel_group,
       guint accel_key,
       GdkModifierType accel_mods,
       guint *n_entries);
void _gtk_accel_group_reconnect (GtkAccelGroup *accel_group,
       GQuark accel_path_quark);
struct _GtkAccelGroupEntry
{
  GtkAccelKey key;
  GClosure *closure;
  GQuark accel_path_quark;
};
}
extern "C" {
typedef GType GtkFundamentalType;
typedef GType GtkType;
typedef GTypeInstance GtkTypeObject;
typedef GTypeClass GtkTypeClass;
typedef GBaseInitFunc GtkClassInitFunc;
typedef GInstanceInitFunc GtkObjectInitFunc;
}
extern "C" {
GType gtk_accel_flags_get_type (void) __attribute__((__const__));
GType gtk_assistant_page_type_get_type (void) __attribute__((__const__));
GType gtk_builder_error_get_type (void) __attribute__((__const__));
GType gtk_calendar_display_options_get_type (void) __attribute__((__const__));
GType gtk_cell_renderer_state_get_type (void) __attribute__((__const__));
GType gtk_cell_renderer_mode_get_type (void) __attribute__((__const__));
GType gtk_cell_renderer_accel_mode_get_type (void) __attribute__((__const__));
GType gtk_cell_type_get_type (void) __attribute__((__const__));
GType gtk_clist_drag_pos_get_type (void) __attribute__((__const__));
GType gtk_button_action_get_type (void) __attribute__((__const__));
GType gtk_ctree_pos_get_type (void) __attribute__((__const__));
GType gtk_ctree_line_style_get_type (void) __attribute__((__const__));
GType gtk_ctree_expander_style_get_type (void) __attribute__((__const__));
GType gtk_ctree_expansion_type_get_type (void) __attribute__((__const__));
GType gtk_debug_flag_get_type (void) __attribute__((__const__));
GType gtk_dialog_flags_get_type (void) __attribute__((__const__));
GType gtk_response_type_get_type (void) __attribute__((__const__));
GType gtk_dest_defaults_get_type (void) __attribute__((__const__));
GType gtk_target_flags_get_type (void) __attribute__((__const__));
GType gtk_anchor_type_get_type (void) __attribute__((__const__));
GType gtk_arrow_type_get_type (void) __attribute__((__const__));
GType gtk_attach_options_get_type (void) __attribute__((__const__));
GType gtk_button_box_style_get_type (void) __attribute__((__const__));
GType gtk_curve_type_get_type (void) __attribute__((__const__));
GType gtk_delete_type_get_type (void) __attribute__((__const__));
GType gtk_direction_type_get_type (void) __attribute__((__const__));
GType gtk_expander_style_get_type (void) __attribute__((__const__));
GType gtk_icon_size_get_type (void) __attribute__((__const__));
GType gtk_sensitivity_type_get_type (void) __attribute__((__const__));
GType gtk_side_type_get_type (void) __attribute__((__const__));
GType gtk_text_direction_get_type (void) __attribute__((__const__));
GType gtk_justification_get_type (void) __attribute__((__const__));
GType gtk_match_type_get_type (void) __attribute__((__const__));
GType gtk_menu_direction_type_get_type (void) __attribute__((__const__));
GType gtk_metric_type_get_type (void) __attribute__((__const__));
GType gtk_movement_step_get_type (void) __attribute__((__const__));
GType gtk_scroll_step_get_type (void) __attribute__((__const__));
GType gtk_orientation_get_type (void) __attribute__((__const__));
GType gtk_corner_type_get_type (void) __attribute__((__const__));
GType gtk_pack_type_get_type (void) __attribute__((__const__));
GType gtk_path_priority_type_get_type (void) __attribute__((__const__));
GType gtk_path_type_get_type (void) __attribute__((__const__));
GType gtk_policy_type_get_type (void) __attribute__((__const__));
GType gtk_position_type_get_type (void) __attribute__((__const__));
GType gtk_preview_type_get_type (void) __attribute__((__const__));
GType gtk_relief_style_get_type (void) __attribute__((__const__));
GType gtk_resize_mode_get_type (void) __attribute__((__const__));
GType gtk_signal_run_type_get_type (void) __attribute__((__const__));
GType gtk_scroll_type_get_type (void) __attribute__((__const__));
GType gtk_selection_mode_get_type (void) __attribute__((__const__));
GType gtk_shadow_type_get_type (void) __attribute__((__const__));
GType gtk_state_type_get_type (void) __attribute__((__const__));
GType gtk_submenu_direction_get_type (void) __attribute__((__const__));
GType gtk_submenu_placement_get_type (void) __attribute__((__const__));
GType gtk_toolbar_style_get_type (void) __attribute__((__const__));
GType gtk_update_type_get_type (void) __attribute__((__const__));
GType gtk_visibility_get_type (void) __attribute__((__const__));
GType gtk_window_position_get_type (void) __attribute__((__const__));
GType gtk_window_type_get_type (void) __attribute__((__const__));
GType gtk_wrap_mode_get_type (void) __attribute__((__const__));
GType gtk_sort_type_get_type (void) __attribute__((__const__));
GType gtk_im_preedit_style_get_type (void) __attribute__((__const__));
GType gtk_im_status_style_get_type (void) __attribute__((__const__));
GType gtk_pack_direction_get_type (void) __attribute__((__const__));
GType gtk_print_pages_get_type (void) __attribute__((__const__));
GType gtk_page_set_get_type (void) __attribute__((__const__));
GType gtk_page_orientation_get_type (void) __attribute__((__const__));
GType gtk_print_quality_get_type (void) __attribute__((__const__));
GType gtk_print_duplex_get_type (void) __attribute__((__const__));
GType gtk_unit_get_type (void) __attribute__((__const__));
GType gtk_tree_view_grid_lines_get_type (void) __attribute__((__const__));
GType gtk_drag_result_get_type (void) __attribute__((__const__));
GType gtk_file_chooser_action_get_type (void) __attribute__((__const__));
GType gtk_file_chooser_confirmation_get_type (void) __attribute__((__const__));
GType gtk_file_chooser_error_get_type (void) __attribute__((__const__));
GType gtk_file_filter_flags_get_type (void) __attribute__((__const__));
GType gtk_icon_lookup_flags_get_type (void) __attribute__((__const__));
GType gtk_icon_theme_error_get_type (void) __attribute__((__const__));
GType gtk_icon_view_drop_position_get_type (void) __attribute__((__const__));
GType gtk_image_type_get_type (void) __attribute__((__const__));
GType gtk_message_type_get_type (void) __attribute__((__const__));
GType gtk_buttons_type_get_type (void) __attribute__((__const__));
GType gtk_notebook_tab_get_type (void) __attribute__((__const__));
GType gtk_object_flags_get_type (void) __attribute__((__const__));
GType gtk_arg_flags_get_type (void) __attribute__((__const__));
GType gtk_print_status_get_type (void) __attribute__((__const__));
GType gtk_print_operation_result_get_type (void) __attribute__((__const__));
GType gtk_print_operation_action_get_type (void) __attribute__((__const__));
GType gtk_print_error_get_type (void) __attribute__((__const__));
GType gtk_private_flags_get_type (void) __attribute__((__const__));
GType gtk_progress_bar_style_get_type (void) __attribute__((__const__));
GType gtk_progress_bar_orientation_get_type (void) __attribute__((__const__));
GType gtk_rc_flags_get_type (void) __attribute__((__const__));
GType gtk_rc_token_type_get_type (void) __attribute__((__const__));
GType gtk_recent_sort_type_get_type (void) __attribute__((__const__));
GType gtk_recent_chooser_error_get_type (void) __attribute__((__const__));
GType gtk_recent_filter_flags_get_type (void) __attribute__((__const__));
GType gtk_recent_manager_error_get_type (void) __attribute__((__const__));
GType gtk_size_group_mode_get_type (void) __attribute__((__const__));
GType gtk_spin_button_update_policy_get_type (void) __attribute__((__const__));
GType gtk_spin_type_get_type (void) __attribute__((__const__));
GType gtk_text_buffer_target_info_get_type (void) __attribute__((__const__));
GType gtk_text_search_flags_get_type (void) __attribute__((__const__));
GType gtk_text_window_type_get_type (void) __attribute__((__const__));
GType gtk_toolbar_child_type_get_type (void) __attribute__((__const__));
GType gtk_toolbar_space_style_get_type (void) __attribute__((__const__));
GType gtk_tree_view_mode_get_type (void) __attribute__((__const__));
GType gtk_tree_model_flags_get_type (void) __attribute__((__const__));
GType gtk_tree_view_drop_position_get_type (void) __attribute__((__const__));
GType gtk_tree_view_column_sizing_get_type (void) __attribute__((__const__));
GType gtk_ui_manager_item_type_get_type (void) __attribute__((__const__));
GType gtk_widget_flags_get_type (void) __attribute__((__const__));
GType gtk_widget_help_type_get_type (void) __attribute__((__const__));
}
extern "C" {
GType gtk_identifier_get_type (void) __attribute__((__const__));
typedef struct _GtkArg GtkArg;
typedef struct _GtkObject GtkObject;
typedef gboolean (*GtkFunction) (gpointer data);
typedef void (*GtkDestroyNotify) (gpointer data);
typedef void (*GtkCallbackMarshal) (GtkObject *object,
         gpointer data,
         guint n_args,
         GtkArg *args);
typedef void (*GtkSignalFunc) (void);
typedef struct _GtkTypeInfo GtkTypeInfo;
typedef GSignalCMarshaller GtkSignalMarshaller;
struct _GtkArg
{
  GtkType type;
  gchar *name;
  union {
    gchar char_data;
    guchar uchar_data;
    gboolean bool_data;
    gint int_data;
    guint uint_data;
    glong long_data;
    gulong ulong_data;
    gfloat float_data;
    gdouble double_data;
    gchar *string_data;
    GtkObject *object_data;
    gpointer pointer_data;
    struct {
      GtkSignalFunc f;
      gpointer d;
    } signal_data;
  } d;
};
struct _GtkTypeInfo
{
  gchar *type_name;
  guint object_size;
  guint class_size;
  GtkClassInitFunc class_init_func;
  GtkObjectInitFunc object_init_func;
  gpointer reserved_1;
  gpointer reserved_2;
  GtkClassInitFunc base_class_init_func;
};
gpointer gtk_type_class (GtkType type);
GtkType gtk_type_unique (GtkType parent_type,
     const GtkTypeInfo *gtkinfo);
gpointer gtk_type_new (GtkType type);
typedef GEnumValue GtkEnumValue;
typedef GFlagsValue GtkFlagValue;
GtkEnumValue* gtk_type_enum_get_values (GtkType enum_type);
GtkFlagValue* gtk_type_flags_get_values (GtkType flags_type);
GtkEnumValue* gtk_type_enum_find_value (GtkType enum_type,
       const gchar *value_name);
GtkFlagValue* gtk_type_flags_find_value (GtkType flags_type,
       const gchar *value_name);
void gtk_type_init (GTypeDebugFlags debug_flags);
}
extern "C" {
typedef enum {
  GTK_DEBUG_MISC = 1 << 0,
  GTK_DEBUG_PLUGSOCKET = 1 << 1,
  GTK_DEBUG_TEXT = 1 << 2,
  GTK_DEBUG_TREE = 1 << 3,
  GTK_DEBUG_UPDATES = 1 << 4,
  GTK_DEBUG_KEYBINDINGS = 1 << 5,
  GTK_DEBUG_MULTIHEAD = 1 << 6,
  GTK_DEBUG_MODULES = 1 << 7,
  GTK_DEBUG_GEOMETRY = 1 << 8,
  GTK_DEBUG_ICONTHEME = 1 << 9,
  GTK_DEBUG_PRINTING = 1 << 10,
  GTK_DEBUG_BUILDER = 1 << 11
} GtkDebugFlag;
extern guint gtk_debug_flags;
}
extern "C" {
typedef enum
{
  GTK_IN_DESTRUCTION = 1 << 0,
  GTK_FLOATING = 1 << 1,
  GTK_RESERVED_1 = 1 << 2,
  GTK_RESERVED_2 = 1 << 3
} GtkObjectFlags;
typedef struct _GtkObjectClass GtkObjectClass;
struct _GtkObject
{
  GInitiallyUnowned parent_instance;
  guint32 flags;
};
struct _GtkObjectClass
{
  GInitiallyUnownedClass parent_class;
  void (*set_arg) (GtkObject *object,
     GtkArg *arg,
     guint arg_id);
  void (*get_arg) (GtkObject *object,
     GtkArg *arg,
     guint arg_id);
  void (*destroy) (GtkObject *object);
};
GtkType gtk_object_get_type (void) __attribute__((__const__));
void gtk_object_sink (GtkObject *object);
void gtk_object_destroy (GtkObject *object);
GtkObject* gtk_object_new (GtkType type,
        const gchar *first_property_name,
        ...);
GtkObject* gtk_object_ref (GtkObject *object);
void gtk_object_unref (GtkObject *object);
void gtk_object_weakref (GtkObject *object,
      GtkDestroyNotify notify,
      gpointer data);
void gtk_object_weakunref (GtkObject *object,
      GtkDestroyNotify notify,
      gpointer data);
void gtk_object_set_data (GtkObject *object,
          const gchar *key,
          gpointer data);
void gtk_object_set_data_full (GtkObject *object,
          const gchar *key,
          gpointer data,
          GtkDestroyNotify destroy);
void gtk_object_remove_data (GtkObject *object,
          const gchar *key);
gpointer gtk_object_get_data (GtkObject *object,
          const gchar *key);
void gtk_object_remove_no_notify (GtkObject *object,
          const gchar *key);
void gtk_object_set_user_data (GtkObject *object,
       gpointer data);
gpointer gtk_object_get_user_data (GtkObject *object);
void gtk_object_set_data_by_id (GtkObject *object,
      GQuark data_id,
      gpointer data);
void gtk_object_set_data_by_id_full (GtkObject *object,
      GQuark data_id,
      gpointer data,
      GtkDestroyNotify destroy);
gpointer gtk_object_get_data_by_id (GtkObject *object,
      GQuark data_id);
void gtk_object_remove_data_by_id (GtkObject *object,
      GQuark data_id);
void gtk_object_remove_no_notify_by_id (GtkObject *object,
      GQuark key_id);
typedef enum
{
  GTK_ARG_READABLE = G_PARAM_READABLE,
  GTK_ARG_WRITABLE = G_PARAM_WRITABLE,
  GTK_ARG_CONSTRUCT = G_PARAM_CONSTRUCT,
  GTK_ARG_CONSTRUCT_ONLY = G_PARAM_CONSTRUCT_ONLY,
  GTK_ARG_CHILD_ARG = 1 << 4
} GtkArgFlags;
void gtk_object_get (GtkObject *object,
     const gchar *first_property_name,
     ...) __attribute__((__sentinel__));
void gtk_object_set (GtkObject *object,
     const gchar *first_property_name,
     ...) __attribute__((__sentinel__));
void gtk_object_add_arg_type (const gchar *arg_name,
      GtkType arg_type,
      guint arg_flags,
      guint arg_id);
}
extern "C" {
typedef struct _GtkAdjustment GtkAdjustment;
typedef struct _GtkAdjustmentClass GtkAdjustmentClass;
struct _GtkAdjustment
{
  GtkObject parent_instance;
  gdouble lower;
  gdouble upper;
  gdouble value;
  gdouble step_increment;
  gdouble page_increment;
  gdouble page_size;
};
struct _GtkAdjustmentClass
{
  GtkObjectClass parent_class;
  void (* changed) (GtkAdjustment *adjustment);
  void (* value_changed) (GtkAdjustment *adjustment);
  void (*_gtk_reserved1) (void);
  void (*_gtk_reserved2) (void);
  void (*_gtk_reserved3) (void);
  void (*_gtk_reserved4) (void);
};
GType gtk_adjustment_get_type (void) __attribute__((__const__));
GtkObject* gtk_adjustment_new (gdouble value,
       gdouble lower,
       gdouble upper,
       gdouble step_increment,
       gdouble page_increment,
       gdouble page_size);
void gtk_adjustment_changed (GtkAdjustment *adjustment);
void gtk_adjustment_value_changed (GtkAdjustment *adjustment);
void gtk_adjustment_clamp_page (GtkAdjustment *adjustment,
       gdouble lower,
       gdouble upper);
gdouble gtk_adjustment_get_value (GtkAdjustment *adjustment);
void gtk_adjustment_set_value (GtkAdjustment *adjustment,
       gdouble value);
}
extern "C" {
typedef struct _GtkBorder GtkBorder;
typedef struct _GtkStyle GtkStyle;
typedef struct _GtkStyleClass GtkStyleClass;
typedef struct _GtkThemeEngine GtkThemeEngine;
typedef struct _GtkRcStyle GtkRcStyle;
typedef struct _GtkIconSet GtkIconSet;
typedef struct _GtkIconSource GtkIconSource;
typedef struct _GtkRcProperty GtkRcProperty;
typedef struct _GtkSettings GtkSettings;
typedef gboolean (*GtkRcPropertyParser) (const GParamSpec *pspec,
      const GString *rc_string,
      GValue *property_value);
typedef struct _GtkWidget GtkWidget;
struct _GtkStyle
{
  GObject parent_instance;
  GdkColor fg[5];
  GdkColor bg[5];
  GdkColor light[5];
  GdkColor dark[5];
  GdkColor mid[5];
  GdkColor text[5];
  GdkColor base[5];
  GdkColor text_aa[5];
  GdkColor black;
  GdkColor white;
  PangoFontDescription *font_desc;
  gint xthickness;
  gint ythickness;
  GdkGC *fg_gc[5];
  GdkGC *bg_gc[5];
  GdkGC *light_gc[5];
  GdkGC *dark_gc[5];
  GdkGC *mid_gc[5];
  GdkGC *text_gc[5];
  GdkGC *base_gc[5];
  GdkGC *text_aa_gc[5];
  GdkGC *black_gc;
  GdkGC *white_gc;
  GdkPixmap *bg_pixmap[5];
  gint attach_count;
  gint depth;
  GdkColormap *colormap;
  GdkFont *private_font;
  PangoFontDescription *private_font_desc;
  GtkRcStyle *rc_style;
  GSList *styles;
  GArray *property_cache;
  GSList *icon_factories;
};
struct _GtkStyleClass
{
  GObjectClass parent_class;
  void (*realize) (GtkStyle *style);
  void (*unrealize) (GtkStyle *style);
  void (*copy) (GtkStyle *style,
     GtkStyle *src);
  GtkStyle *(*clone) (GtkStyle *style);
  void (*init_from_rc) (GtkStyle *style,
     GtkRcStyle *rc_style);
  void (*set_background) (GtkStyle *style,
     GdkWindow *window,
     GtkStateType state_type);
  GdkPixbuf * (* render_icon) (GtkStyle *style,
                                 const GtkIconSource *source,
                                 GtkTextDirection direction,
                                 GtkStateType state,
                                 GtkIconSize size,
                                 GtkWidget *widget,
                                 const gchar *detail);
  void (*draw_hline) (GtkStyle *style,
     GdkWindow *window,
     GtkStateType state_type,
     GdkRectangle *area,
     GtkWidget *widget,
     const gchar *detail,
     gint x1,
     gint x2,
     gint y);
  void (*draw_vline) (GtkStyle *style,
     GdkWindow *window,
     GtkStateType state_type,
     GdkRectangle *area,
     GtkWidget *widget,
     const gchar *detail,
     gint y1_,
     gint y2_,
     gint x);
  void (*draw_shadow) (GtkStyle *style,
     GdkWindow *window,
     GtkStateType state_type,
     GtkShadowType shadow_type,
     GdkRectangle *area,
     GtkWidget *widget,
     const gchar *detail,
     gint x,
     gint y,
     gint width,
     gint height);
  void (*draw_polygon) (GtkStyle *style,
     GdkWindow *window,
     GtkStateType state_type,
     GtkShadowType shadow_type,
     GdkRectangle *area,
     GtkWidget *widget,
     const gchar *detail,
     GdkPoint *point,
     gint npoints,
     gboolean fill);
  void (*draw_arrow) (GtkStyle *style,
     GdkWindow *window,
     GtkStateType state_type,
     GtkShadowType shadow_type,
     GdkRectangle *area,
     GtkWidget *widget,
     const gchar *detail,
     GtkArrowType arrow_type,
     gboolean fill,
     gint x,
     gint y,
     gint width,
     gint height);
  void (*draw_diamond) (GtkStyle *style,
     GdkWindow *window,
     GtkStateType state_type,
     GtkShadowType shadow_type,
     GdkRectangle *area,
     GtkWidget *widget,
     const gchar *detail,
     gint x,
     gint y,
     gint width,
     gint height);
  void (*draw_string) (GtkStyle *style,
     GdkWindow *window,
     GtkStateType state_type,
     GdkRectangle *area,
     GtkWidget *widget,
     const gchar *detail,
     gint x,
     gint y,
     const gchar *string);
  void (*draw_box) (GtkStyle *style,
     GdkWindow *window,
     GtkStateType state_type,
     GtkShadowType shadow_type,
     GdkRectangle *area,
     GtkWidget *widget,
     const gchar *detail,
     gint x,
     gint y,
     gint width,
     gint height);
  void (*draw_flat_box) (GtkStyle *style,
     GdkWindow *window,
     GtkStateType state_type,
     GtkShadowType shadow_type,
     GdkRectangle *area,
     GtkWidget *widget,
     const gchar *detail,
     gint x,
     gint y,
     gint width,
     gint height);
  void (*draw_check) (GtkStyle *style,
     GdkWindow *window,
     GtkStateType state_type,
     GtkShadowType shadow_type,
     GdkRectangle *area,
     GtkWidget *widget,
     const gchar *detail,
     gint x,
     gint y,
     gint width,
     gint height);
  void (*draw_option) (GtkStyle *style,
     GdkWindow *window,
     GtkStateType state_type,
     GtkShadowType shadow_type,
     GdkRectangle *area,
     GtkWidget *widget,
     const gchar *detail,
     gint x,
     gint y,
     gint width,
     gint height);
  void (*draw_tab) (GtkStyle *style,
     GdkWindow *window,
     GtkStateType state_type,
     GtkShadowType shadow_type,
     GdkRectangle *area,
     GtkWidget *widget,
     const gchar *detail,
     gint x,
     gint y,
     gint width,
     gint height);
  void (*draw_shadow_gap) (GtkStyle *style,
     GdkWindow *window,
     GtkStateType state_type,
     GtkShadowType shadow_type,
     GdkRectangle *area,
     GtkWidget *widget,
     const gchar *detail,
     gint x,
     gint y,
     gint width,
     gint height,
     GtkPositionType gap_side,
     gint gap_x,
     gint gap_width);
  void (*draw_box_gap) (GtkStyle *style,
     GdkWindow *window,
     GtkStateType state_type,
     GtkShadowType shadow_type,
     GdkRectangle *area,
     GtkWidget *widget,
     const gchar *detail,
     gint x,
     gint y,
     gint width,
     gint height,
     GtkPositionType gap_side,
     gint gap_x,
     gint gap_width);
  void (*draw_extension) (GtkStyle *style,
     GdkWindow *window,
     GtkStateType state_type,
     GtkShadowType shadow_type,
     GdkRectangle *area,
     GtkWidget *widget,
     const gchar *detail,
     gint x,
     gint y,
     gint width,
     gint height,
     GtkPositionType gap_side);
  void (*draw_focus) (GtkStyle *style,
     GdkWindow *window,
                                 GtkStateType state_type,
     GdkRectangle *area,
     GtkWidget *widget,
     const gchar *detail,
     gint x,
     gint y,
     gint width,
     gint height);
  void (*draw_slider) (GtkStyle *style,
     GdkWindow *window,
     GtkStateType state_type,
     GtkShadowType shadow_type,
     GdkRectangle *area,
     GtkWidget *widget,
     const gchar *detail,
     gint x,
     gint y,
     gint width,
     gint height,
     GtkOrientation orientation);
  void (*draw_handle) (GtkStyle *style,
     GdkWindow *window,
     GtkStateType state_type,
     GtkShadowType shadow_type,
     GdkRectangle *area,
     GtkWidget *widget,
     const gchar *detail,
     gint x,
     gint y,
     gint width,
     gint height,
     GtkOrientation orientation);
  void (*draw_expander) (GtkStyle *style,
     GdkWindow *window,
     GtkStateType state_type,
     GdkRectangle *area,
     GtkWidget *widget,
     const gchar *detail,
     gint x,
     gint y,
                                 GtkExpanderStyle expander_style);
  void (*draw_layout) (GtkStyle *style,
     GdkWindow *window,
     GtkStateType state_type,
     gboolean use_text,
     GdkRectangle *area,
     GtkWidget *widget,
     const gchar *detail,
     gint x,
     gint y,
                                 PangoLayout *layout);
  void (*draw_resize_grip) (GtkStyle *style,
     GdkWindow *window,
     GtkStateType state_type,
     GdkRectangle *area,
     GtkWidget *widget,
     const gchar *detail,
                                 GdkWindowEdge edge,
     gint x,
     gint y,
     gint width,
     gint height);
  void (*_gtk_reserved1) (void);
  void (*_gtk_reserved2) (void);
  void (*_gtk_reserved3) (void);
  void (*_gtk_reserved4) (void);
  void (*_gtk_reserved5) (void);
  void (*_gtk_reserved6) (void);
  void (*_gtk_reserved7) (void);
  void (*_gtk_reserved8) (void);
  void (*_gtk_reserved9) (void);
  void (*_gtk_reserved10) (void);
  void (*_gtk_reserved11) (void);
  void (*_gtk_reserved12) (void);
};
struct _GtkBorder
{
  gint left;
  gint right;
  gint top;
  gint bottom;
};
GType gtk_style_get_type (void) __attribute__((__const__));
GtkStyle* gtk_style_new (void);
GtkStyle* gtk_style_copy (GtkStyle *style);
GtkStyle* gtk_style_attach (GtkStyle *style,
           GdkWindow *window) __attribute__((warn_unused_result));
void gtk_style_detach (GtkStyle *style);
GtkStyle* gtk_style_ref (GtkStyle *style);
void gtk_style_unref (GtkStyle *style);
GdkFont * gtk_style_get_font (GtkStyle *style);
void gtk_style_set_font (GtkStyle *style,
           GdkFont *font);
void gtk_style_set_background (GtkStyle *style,
           GdkWindow *window,
           GtkStateType state_type);
void gtk_style_apply_default_background (GtkStyle *style,
           GdkWindow *window,
           gboolean set_bg,
           GtkStateType state_type,
           GdkRectangle *area,
           gint x,
           gint y,
           gint width,
           gint height);
GtkIconSet* gtk_style_lookup_icon_set (GtkStyle *style,
                                              const gchar *stock_id);
gboolean gtk_style_lookup_color (GtkStyle *style,
                                              const gchar *color_name,
                                              GdkColor *color);
GdkPixbuf* gtk_style_render_icon (GtkStyle *style,
                                       const GtkIconSource *source,
                                       GtkTextDirection direction,
                                       GtkStateType state,
                                       GtkIconSize size,
                                       GtkWidget *widget,
                                       const gchar *detail);
void gtk_draw_hline (GtkStyle *style,
     GdkWindow *window,
     GtkStateType state_type,
     gint x1,
     gint x2,
     gint y);
void gtk_draw_vline (GtkStyle *style,
     GdkWindow *window,
     GtkStateType state_type,
     gint y1_,
     gint y2_,
     gint x);
void gtk_draw_shadow (GtkStyle *style,
     GdkWindow *window,
     GtkStateType state_type,
     GtkShadowType shadow_type,
     gint x,
     gint y,
     gint width,
     gint height);
void gtk_draw_polygon (GtkStyle *style,
     GdkWindow *window,
     GtkStateType state_type,
     GtkShadowType shadow_type,
     GdkPoint *points,
     gint npoints,
     gboolean fill);
void gtk_draw_arrow (GtkStyle *style,
     GdkWindow *window,
     GtkStateType state_type,
     GtkShadowType shadow_type,
     GtkArrowType arrow_type,
     gboolean fill,
     gint x,
     gint y,
     gint width,
     gint height);
void gtk_draw_diamond (GtkStyle *style,
     GdkWindow *window,
     GtkStateType state_type,
     GtkShadowType shadow_type,
     gint x,
     gint y,
     gint width,
     gint height);
void gtk_draw_box (GtkStyle *style,
     GdkWindow *window,
     GtkStateType state_type,
     GtkShadowType shadow_type,
     gint x,
     gint y,
     gint width,
     gint height);
void gtk_draw_flat_box (GtkStyle *style,
     GdkWindow *window,
     GtkStateType state_type,
     GtkShadowType shadow_type,
     gint x,
     gint y,
     gint width,
     gint height);
void gtk_draw_check (GtkStyle *style,
     GdkWindow *window,
     GtkStateType state_type,
     GtkShadowType shadow_type,
     gint x,
     gint y,
     gint width,
     gint height);
void gtk_draw_option (GtkStyle *style,
     GdkWindow *window,
     GtkStateType state_type,
     GtkShadowType shadow_type,
     gint x,
     gint y,
     gint width,
     gint height);
void gtk_draw_tab (GtkStyle *style,
     GdkWindow *window,
     GtkStateType state_type,
     GtkShadowType shadow_type,
     gint x,
     gint y,
     gint width,
     gint height);
void gtk_draw_shadow_gap (GtkStyle *style,
     GdkWindow *window,
     GtkStateType state_type,
     GtkShadowType shadow_type,
     gint x,
     gint y,
     gint width,
     gint height,
     GtkPositionType gap_side,
     gint gap_x,
     gint gap_width);
void gtk_draw_box_gap (GtkStyle *style,
     GdkWindow *window,
     GtkStateType state_type,
     GtkShadowType shadow_type,
     gint x,
     gint y,
     gint width,
     gint height,
     GtkPositionType gap_side,
     gint gap_x,
     gint gap_width);
void gtk_draw_extension (GtkStyle *style,
     GdkWindow *window,
     GtkStateType state_type,
     GtkShadowType shadow_type,
     gint x,
     gint y,
     gint width,
     gint height,
     GtkPositionType gap_side);
void gtk_draw_focus (GtkStyle *style,
     GdkWindow *window,
     gint x,
     gint y,
     gint width,
     gint height);
void gtk_draw_slider (GtkStyle *style,
     GdkWindow *window,
     GtkStateType state_type,
     GtkShadowType shadow_type,
     gint x,
     gint y,
     gint width,
     gint height,
     GtkOrientation orientation);
void gtk_draw_handle (GtkStyle *style,
     GdkWindow *window,
     GtkStateType state_type,
     GtkShadowType shadow_type,
     gint x,
     gint y,
     gint width,
     gint height,
     GtkOrientation orientation);
void gtk_draw_expander (GtkStyle *style,
                          GdkWindow *window,
                          GtkStateType state_type,
                          gint x,
                          gint y,
     GtkExpanderStyle expander_style);
void gtk_draw_layout (GtkStyle *style,
                          GdkWindow *window,
                          GtkStateType state_type,
     gboolean use_text,
                          gint x,
                          gint y,
                          PangoLayout *layout);
void gtk_draw_resize_grip (GtkStyle *style,
                           GdkWindow *window,
                           GtkStateType state_type,
                           GdkWindowEdge edge,
                           gint x,
                           gint y,
                           gint width,
                           gint height);
void gtk_paint_hline (GtkStyle *style,
      GdkWindow *window,
      GtkStateType state_type,
      GdkRectangle *area,
      GtkWidget *widget,
      const gchar *detail,
      gint x1,
      gint x2,
      gint y);
void gtk_paint_vline (GtkStyle *style,
      GdkWindow *window,
      GtkStateType state_type,
      GdkRectangle *area,
      GtkWidget *widget,
      const gchar *detail,
      gint y1_,
      gint y2_,
      gint x);
void gtk_paint_shadow (GtkStyle *style,
      GdkWindow *window,
      GtkStateType state_type,
      GtkShadowType shadow_type,
      GdkRectangle *area,
      GtkWidget *widget,
      const gchar *detail,
      gint x,
      gint y,
      gint width,
      gint height);
void gtk_paint_polygon (GtkStyle *style,
      GdkWindow *window,
      GtkStateType state_type,
      GtkShadowType shadow_type,
      GdkRectangle *area,
      GtkWidget *widget,
      const gchar *detail,
      GdkPoint *points,
      gint npoints,
      gboolean fill);
void gtk_paint_arrow (GtkStyle *style,
      GdkWindow *window,
      GtkStateType state_type,
      GtkShadowType shadow_type,
      GdkRectangle *area,
      GtkWidget *widget,
      const gchar *detail,
      GtkArrowType arrow_type,
      gboolean fill,
      gint x,
      gint y,
      gint width,
      gint height);
void gtk_paint_diamond (GtkStyle *style,
      GdkWindow *window,
      GtkStateType state_type,
      GtkShadowType shadow_type,
      GdkRectangle *area,
      GtkWidget *widget,
      const gchar *detail,
      gint x,
      gint y,
      gint width,
      gint height);
void gtk_paint_box (GtkStyle *style,
      GdkWindow *window,
      GtkStateType state_type,
      GtkShadowType shadow_type,
      GdkRectangle *area,
      GtkWidget *widget,
      const gchar *detail,
      gint x,
      gint y,
      gint width,
      gint height);
void gtk_paint_flat_box (GtkStyle *style,
      GdkWindow *window,
      GtkStateType state_type,
      GtkShadowType shadow_type,
      GdkRectangle *area,
      GtkWidget *widget,
      const gchar *detail,
      gint x,
      gint y,
      gint width,
      gint height);
void gtk_paint_check (GtkStyle *style,
      GdkWindow *window,
      GtkStateType state_type,
      GtkShadowType shadow_type,
      GdkRectangle *area,
      GtkWidget *widget,
      const gchar *detail,
      gint x,
      gint y,
      gint width,
      gint height);
void gtk_paint_option (GtkStyle *style,
      GdkWindow *window,
      GtkStateType state_type,
      GtkShadowType shadow_type,
      GdkRectangle *area,
      GtkWidget *widget,
      const gchar *detail,
      gint x,
      gint y,
      gint width,
      gint height);
void gtk_paint_tab (GtkStyle *style,
      GdkWindow *window,
      GtkStateType state_type,
      GtkShadowType shadow_type,
      GdkRectangle *area,
      GtkWidget *widget,
      const gchar *detail,
      gint x,
      gint y,
      gint width,
      gint height);
void gtk_paint_shadow_gap (GtkStyle *style,
      GdkWindow *window,
      GtkStateType state_type,
      GtkShadowType shadow_type,
      GdkRectangle *area,
      GtkWidget *widget,
      gchar *detail,
      gint x,
      gint y,
      gint width,
      gint height,
      GtkPositionType gap_side,
      gint gap_x,
      gint gap_width);
void gtk_paint_box_gap (GtkStyle *style,
      GdkWindow *window,
      GtkStateType state_type,
      GtkShadowType shadow_type,
      GdkRectangle *area,
      GtkWidget *widget,
      gchar *detail,
      gint x,
      gint y,
      gint width,
      gint height,
      GtkPositionType gap_side,
      gint gap_x,
      gint gap_width);
void gtk_paint_extension (GtkStyle *style,
      GdkWindow *window,
      GtkStateType state_type,
      GtkShadowType shadow_type,
      GdkRectangle *area,
      GtkWidget *widget,
      gchar *detail,
      gint x,
      gint y,
      gint width,
      gint height,
      GtkPositionType gap_side);
void gtk_paint_focus (GtkStyle *style,
      GdkWindow *window,
      GtkStateType state_type,
      GdkRectangle *area,
      GtkWidget *widget,
      const gchar *detail,
      gint x,
      gint y,
      gint width,
      gint height);
void gtk_paint_slider (GtkStyle *style,
      GdkWindow *window,
      GtkStateType state_type,
      GtkShadowType shadow_type,
      GdkRectangle *area,
      GtkWidget *widget,
      const gchar *detail,
      gint x,
      gint y,
      gint width,
      gint height,
      GtkOrientation orientation);
void gtk_paint_handle (GtkStyle *style,
      GdkWindow *window,
      GtkStateType state_type,
      GtkShadowType shadow_type,
      GdkRectangle *area,
      GtkWidget *widget,
      const gchar *detail,
      gint x,
      gint y,
      gint width,
      gint height,
      GtkOrientation orientation);
void gtk_paint_expander (GtkStyle *style,
                           GdkWindow *window,
                           GtkStateType state_type,
                           GdkRectangle *area,
                           GtkWidget *widget,
                           const gchar *detail,
                           gint x,
                           gint y,
      GtkExpanderStyle expander_style);
void gtk_paint_layout (GtkStyle *style,
                           GdkWindow *window,
                           GtkStateType state_type,
      gboolean use_text,
                           GdkRectangle *area,
                           GtkWidget *widget,
                           const gchar *detail,
                           gint x,
                           gint y,
                           PangoLayout *layout);
void gtk_paint_resize_grip (GtkStyle *style,
                            GdkWindow *window,
                            GtkStateType state_type,
                            GdkRectangle *area,
                            GtkWidget *widget,
                            const gchar *detail,
                            GdkWindowEdge edge,
                            gint x,
                            gint y,
                            gint width,
                            gint height);
GType gtk_border_get_type (void) __attribute__((__const__));
GtkBorder *gtk_border_copy (const GtkBorder *border_);
void gtk_border_free (GtkBorder *border_);
const GValue* _gtk_style_peek_property_value (GtkStyle *style,
           GType widget_type,
           GParamSpec *pspec,
           GtkRcPropertyParser parser);
void _gtk_style_init_for_settings (GtkStyle *style,
                                              GtkSettings *settings);
void _gtk_style_shade (GdkColor *a,
                                              GdkColor *b,
                                              gdouble k);
void gtk_draw_string (GtkStyle *style,
     GdkWindow *window,
     GtkStateType state_type,
     gint x,
     gint y,
     const gchar *string);
void gtk_paint_string (GtkStyle *style,
      GdkWindow *window,
      GtkStateType state_type,
      GdkRectangle *area,
      GtkWidget *widget,
      const gchar *detail,
      gint x,
      gint y,
      const gchar *string);
void gtk_draw_insertion_cursor (GtkWidget *widget,
      GdkDrawable *drawable,
      GdkRectangle *area,
      GdkRectangle *location,
      gboolean is_primary,
      GtkTextDirection direction,
      gboolean draw_arrow);
GdkGC *_gtk_widget_get_cursor_gc (GtkWidget *widget);
void _gtk_widget_get_cursor_color (GtkWidget *widget,
         GdkColor *color);
}
extern "C" {
typedef struct _GtkIconFactory GtkIconFactory;
typedef struct _GtkRcContext GtkRcContext;
typedef struct _GtkRcStyleClass GtkRcStyleClass;
typedef enum
{
  GTK_RC_FG = 1 << 0,
  GTK_RC_BG = 1 << 1,
  GTK_RC_TEXT = 1 << 2,
  GTK_RC_BASE = 1 << 3
} GtkRcFlags;
struct _GtkRcStyle
{
  GObject parent_instance;
  gchar *name;
  gchar *bg_pixmap_name[5];
  PangoFontDescription *font_desc;
  GtkRcFlags color_flags[5];
  GdkColor fg[5];
  GdkColor bg[5];
  GdkColor text[5];
  GdkColor base[5];
  gint xthickness;
  gint ythickness;
  GArray *rc_properties;
  GSList *rc_style_lists;
  GSList *icon_factories;
  guint engine_specified : 1;
};
struct _GtkRcStyleClass
{
  GObjectClass parent_class;
  GtkRcStyle * (*create_rc_style) (GtkRcStyle *rc_style);
  guint (*parse) (GtkRcStyle *rc_style,
         GtkSettings *settings,
         GScanner *scanner);
  void (*merge) (GtkRcStyle *dest,
         GtkRcStyle *src);
  GtkStyle * (*create_style) (GtkRcStyle *rc_style);
  void (*_gtk_reserved1) (void);
  void (*_gtk_reserved2) (void);
  void (*_gtk_reserved3) (void);
  void (*_gtk_reserved4) (void);
};
void _gtk_rc_init (void);
GSList* _gtk_rc_parse_widget_class_path (const gchar *pattern);
void _gtk_rc_free_widget_class_path (GSList *list);
gboolean _gtk_rc_match_widget_class (GSList *list,
                                          gint length,
                                          gchar *path,
                                          gchar *path_reversed);
void gtk_rc_add_default_file (const gchar *filename);
void gtk_rc_set_default_files (gchar **filenames);
gchar** gtk_rc_get_default_files (void);
GtkStyle* gtk_rc_get_style (GtkWidget *widget);
GtkStyle* gtk_rc_get_style_by_paths (GtkSettings *settings,
      const char *widget_path,
      const char *class_path,
      GType type);
gboolean gtk_rc_reparse_all_for_settings (GtkSettings *settings,
       gboolean force_load);
void gtk_rc_reset_styles (GtkSettings *settings);
gchar* gtk_rc_find_pixmap_in_path (GtkSettings *settings,
         GScanner *scanner,
         const gchar *pixmap_file);
void gtk_rc_parse (const gchar *filename);
void gtk_rc_parse_string (const gchar *rc_string);
gboolean gtk_rc_reparse_all (void);
void gtk_rc_add_widget_name_style (GtkRcStyle *rc_style,
      const gchar *pattern);
void gtk_rc_add_widget_class_style (GtkRcStyle *rc_style,
      const gchar *pattern);
void gtk_rc_add_class_style (GtkRcStyle *rc_style,
      const gchar *pattern);
GType gtk_rc_style_get_type (void) __attribute__((__const__));
GtkRcStyle* gtk_rc_style_new (void);
GtkRcStyle* gtk_rc_style_copy (GtkRcStyle *orig);
void gtk_rc_style_ref (GtkRcStyle *rc_style);
void gtk_rc_style_unref (GtkRcStyle *rc_style);
gchar* gtk_rc_find_module_in_path (const gchar *module_file);
gchar* gtk_rc_get_theme_dir (void);
gchar* gtk_rc_get_module_dir (void);
gchar* gtk_rc_get_im_module_path (void);
gchar* gtk_rc_get_im_module_file (void);
typedef enum {
  GTK_RC_TOKEN_INVALID = G_TOKEN_LAST,
  GTK_RC_TOKEN_INCLUDE,
  GTK_RC_TOKEN_NORMAL,
  GTK_RC_TOKEN_ACTIVE,
  GTK_RC_TOKEN_PRELIGHT,
  GTK_RC_TOKEN_SELECTED,
  GTK_RC_TOKEN_INSENSITIVE,
  GTK_RC_TOKEN_FG,
  GTK_RC_TOKEN_BG,
  GTK_RC_TOKEN_TEXT,
  GTK_RC_TOKEN_BASE,
  GTK_RC_TOKEN_XTHICKNESS,
  GTK_RC_TOKEN_YTHICKNESS,
  GTK_RC_TOKEN_FONT,
  GTK_RC_TOKEN_FONTSET,
  GTK_RC_TOKEN_FONT_NAME,
  GTK_RC_TOKEN_BG_PIXMAP,
  GTK_RC_TOKEN_PIXMAP_PATH,
  GTK_RC_TOKEN_STYLE,
  GTK_RC_TOKEN_BINDING,
  GTK_RC_TOKEN_BIND,
  GTK_RC_TOKEN_WIDGET,
  GTK_RC_TOKEN_WIDGET_CLASS,
  GTK_RC_TOKEN_CLASS,
  GTK_RC_TOKEN_LOWEST,
  GTK_RC_TOKEN_GTK,
  GTK_RC_TOKEN_APPLICATION,
  GTK_RC_TOKEN_THEME,
  GTK_RC_TOKEN_RC,
  GTK_RC_TOKEN_HIGHEST,
  GTK_RC_TOKEN_ENGINE,
  GTK_RC_TOKEN_MODULE_PATH,
  GTK_RC_TOKEN_IM_MODULE_PATH,
  GTK_RC_TOKEN_IM_MODULE_FILE,
  GTK_RC_TOKEN_STOCK,
  GTK_RC_TOKEN_LTR,
  GTK_RC_TOKEN_RTL,
  GTK_RC_TOKEN_COLOR,
  GTK_RC_TOKEN_UNBIND,
  GTK_RC_TOKEN_LAST
} GtkRcTokenType;
GScanner* gtk_rc_scanner_new (void);
guint gtk_rc_parse_color (GScanner *scanner,
     GdkColor *color);
guint gtk_rc_parse_color_full (GScanner *scanner,
                                   GtkRcStyle *style,
       GdkColor *color);
guint gtk_rc_parse_state (GScanner *scanner,
     GtkStateType *state);
guint gtk_rc_parse_priority (GScanner *scanner,
     GtkPathPriorityType *priority);
struct _GtkRcProperty
{
  GQuark type_name;
  GQuark property_name;
  gchar *origin;
  GValue value;
};
const GtkRcProperty* _gtk_rc_style_lookup_rc_property (GtkRcStyle *rc_style,
             GQuark type_name,
             GQuark property_name);
void _gtk_rc_style_set_rc_property (GtkRcStyle *rc_style,
             GtkRcProperty *property);
void _gtk_rc_style_unset_rc_property (GtkRcStyle *rc_style,
             GQuark type_name,
             GQuark property_name);
GSList * _gtk_rc_style_get_color_hashes (GtkRcStyle *rc_style);
const gchar* _gtk_rc_context_get_default_font_name (GtkSettings *settings);
void _gtk_rc_context_destroy (GtkSettings *settings);
}
extern "C" {
typedef struct _GtkSettingsClass GtkSettingsClass;
typedef struct _GtkSettingsValue GtkSettingsValue;
typedef struct _GtkSettingsPropertyValue GtkSettingsPropertyValue;
struct _GtkSettings
{
  GObject parent_instance;
  GData *queued_settings;
  GtkSettingsPropertyValue *property_values;
  GtkRcContext *rc_context;
  GdkScreen *screen;
};
struct _GtkSettingsClass
{
  GObjectClass parent_class;
};
struct _GtkSettingsValue
{
  gchar *origin;
  GValue value;
};
GType gtk_settings_get_type (void) __attribute__((__const__));
GtkSettings* gtk_settings_get_default (void);
GtkSettings* gtk_settings_get_for_screen (GdkScreen *screen);
void gtk_settings_install_property (GParamSpec *pspec);
void gtk_settings_install_property_parser (GParamSpec *pspec,
            GtkRcPropertyParser parser);
gboolean gtk_rc_property_parse_color (const GParamSpec *pspec,
         const GString *gstring,
         GValue *property_value);
gboolean gtk_rc_property_parse_enum (const GParamSpec *pspec,
         const GString *gstring,
         GValue *property_value);
gboolean gtk_rc_property_parse_flags (const GParamSpec *pspec,
         const GString *gstring,
         GValue *property_value);
gboolean gtk_rc_property_parse_requisition (const GParamSpec *pspec,
         const GString *gstring,
         GValue *property_value);
gboolean gtk_rc_property_parse_border (const GParamSpec *pspec,
         const GString *gstring,
         GValue *property_value);
void gtk_settings_set_property_value (GtkSettings *settings,
        const gchar *name,
        const GtkSettingsValue *svalue);
void gtk_settings_set_string_property (GtkSettings *settings,
        const gchar *name,
        const gchar *v_string,
        const gchar *origin);
void gtk_settings_set_long_property (GtkSettings *settings,
        const gchar *name,
        glong v_long,
        const gchar *origin);
void gtk_settings_set_double_property (GtkSettings *settings,
        const gchar *name,
        gdouble v_double,
        const gchar *origin);
void _gtk_settings_set_property_value_from_rc (GtkSettings *settings,
            const gchar *name,
            const GtkSettingsValue *svalue);
void _gtk_settings_reset_rc_values (GtkSettings *settings);
void _gtk_settings_handle_event (GdkEventSetting *event);
GtkRcPropertyParser _gtk_rc_property_parser_from_type (GType type);
gboolean _gtk_settings_parse_convert (GtkRcPropertyParser parser,
             const GValue *src_value,
             GParamSpec *pspec,
             GValue *dest_value);
}
extern "C" {
extern "C" {
typedef enum
{
  ATK_STATE_INVALID,
  ATK_STATE_ACTIVE,
  ATK_STATE_ARMED,
  ATK_STATE_BUSY,
  ATK_STATE_CHECKED,
  ATK_STATE_DEFUNCT,
  ATK_STATE_EDITABLE,
  ATK_STATE_ENABLED,
  ATK_STATE_EXPANDABLE,
  ATK_STATE_EXPANDED,
  ATK_STATE_FOCUSABLE,
  ATK_STATE_FOCUSED,
  ATK_STATE_HORIZONTAL,
  ATK_STATE_ICONIFIED,
  ATK_STATE_MODAL,
  ATK_STATE_MULTI_LINE,
  ATK_STATE_MULTISELECTABLE,
  ATK_STATE_OPAQUE,
  ATK_STATE_PRESSED,
  ATK_STATE_RESIZABLE,
  ATK_STATE_SELECTABLE,
  ATK_STATE_SELECTED,
  ATK_STATE_SENSITIVE,
  ATK_STATE_SHOWING,
  ATK_STATE_SINGLE_LINE,
  ATK_STATE_STALE,
  ATK_STATE_TRANSIENT,
  ATK_STATE_VERTICAL,
  ATK_STATE_VISIBLE,
  ATK_STATE_MANAGES_DESCENDANTS,
  ATK_STATE_INDETERMINATE,
  ATK_STATE_TRUNCATED,
  ATK_STATE_REQUIRED,
  ATK_STATE_INVALID_ENTRY,
  ATK_STATE_SUPPORTS_AUTOCOMPLETION,
  ATK_STATE_SELECTABLE_TEXT,
  ATK_STATE_DEFAULT,
  ATK_STATE_ANIMATED,
  ATK_STATE_VISITED,
  ATK_STATE_LAST_DEFINED
} AtkStateType;
typedef guint64 AtkState;
AtkStateType atk_state_type_register (const gchar *name);
const gchar* atk_state_type_get_name (AtkStateType type);
AtkStateType atk_state_type_for_name (const gchar *name);
}
extern "C" {
typedef enum
{
  ATK_RELATION_NULL = 0,
  ATK_RELATION_CONTROLLED_BY,
  ATK_RELATION_CONTROLLER_FOR,
  ATK_RELATION_LABEL_FOR,
  ATK_RELATION_LABELLED_BY,
  ATK_RELATION_MEMBER_OF,
  ATK_RELATION_NODE_CHILD_OF,
  ATK_RELATION_FLOWS_TO,
  ATK_RELATION_FLOWS_FROM,
  ATK_RELATION_SUBWINDOW_OF,
  ATK_RELATION_EMBEDS,
  ATK_RELATION_EMBEDDED_BY,
  ATK_RELATION_POPUP_FOR,
  ATK_RELATION_PARENT_WINDOW_OF,
  ATK_RELATION_DESCRIBED_BY,
  ATK_RELATION_DESCRIPTION_FOR,
  ATK_RELATION_LAST_DEFINED
} AtkRelationType;
}
typedef enum
{
  ATK_ROLE_INVALID = 0,
  ATK_ROLE_ACCEL_LABEL,
  ATK_ROLE_ALERT,
  ATK_ROLE_ANIMATION,
  ATK_ROLE_ARROW,
  ATK_ROLE_CALENDAR,
  ATK_ROLE_CANVAS,
  ATK_ROLE_CHECK_BOX,
  ATK_ROLE_CHECK_MENU_ITEM,
  ATK_ROLE_COLOR_CHOOSER,
  ATK_ROLE_COLUMN_HEADER,
  ATK_ROLE_COMBO_BOX,
  ATK_ROLE_DATE_EDITOR,
  ATK_ROLE_DESKTOP_ICON,
  ATK_ROLE_DESKTOP_FRAME,
  ATK_ROLE_DIAL,
  ATK_ROLE_DIALOG,
  ATK_ROLE_DIRECTORY_PANE,
  ATK_ROLE_DRAWING_AREA,
  ATK_ROLE_FILE_CHOOSER,
  ATK_ROLE_FILLER,
  ATK_ROLE_FONT_CHOOSER,
  ATK_ROLE_FRAME,
  ATK_ROLE_GLASS_PANE,
  ATK_ROLE_HTML_CONTAINER,
  ATK_ROLE_ICON,
  ATK_ROLE_IMAGE,
  ATK_ROLE_INTERNAL_FRAME,
  ATK_ROLE_LABEL,
  ATK_ROLE_LAYERED_PANE,
  ATK_ROLE_LIST,
  ATK_ROLE_LIST_ITEM,
  ATK_ROLE_MENU,
  ATK_ROLE_MENU_BAR,
  ATK_ROLE_MENU_ITEM,
  ATK_ROLE_OPTION_PANE,
  ATK_ROLE_PAGE_TAB,
  ATK_ROLE_PAGE_TAB_LIST,
  ATK_ROLE_PANEL,
  ATK_ROLE_PASSWORD_TEXT,
  ATK_ROLE_POPUP_MENU,
  ATK_ROLE_PROGRESS_BAR,
  ATK_ROLE_PUSH_BUTTON,
  ATK_ROLE_RADIO_BUTTON,
  ATK_ROLE_RADIO_MENU_ITEM,
  ATK_ROLE_ROOT_PANE,
  ATK_ROLE_ROW_HEADER,
  ATK_ROLE_SCROLL_BAR,
  ATK_ROLE_SCROLL_PANE,
  ATK_ROLE_SEPARATOR,
  ATK_ROLE_SLIDER,
  ATK_ROLE_SPLIT_PANE,
  ATK_ROLE_SPIN_BUTTON,
  ATK_ROLE_STATUSBAR,
  ATK_ROLE_TABLE,
  ATK_ROLE_TABLE_CELL,
  ATK_ROLE_TABLE_COLUMN_HEADER,
  ATK_ROLE_TABLE_ROW_HEADER,
  ATK_ROLE_TEAR_OFF_MENU_ITEM,
  ATK_ROLE_TERMINAL,
  ATK_ROLE_TEXT,
  ATK_ROLE_TOGGLE_BUTTON,
  ATK_ROLE_TOOL_BAR,
  ATK_ROLE_TOOL_TIP,
  ATK_ROLE_TREE,
  ATK_ROLE_TREE_TABLE,
  ATK_ROLE_UNKNOWN,
  ATK_ROLE_VIEWPORT,
  ATK_ROLE_WINDOW,
  ATK_ROLE_HEADER,
  ATK_ROLE_FOOTER,
  ATK_ROLE_PARAGRAPH,
  ATK_ROLE_RULER,
  ATK_ROLE_APPLICATION,
  ATK_ROLE_AUTOCOMPLETE,
  ATK_ROLE_EDITBAR,
  ATK_ROLE_EMBEDDED,
  ATK_ROLE_ENTRY,
  ATK_ROLE_CHART,
  ATK_ROLE_CAPTION,
  ATK_ROLE_DOCUMENT_FRAME,
  ATK_ROLE_HEADING,
  ATK_ROLE_PAGE,
  ATK_ROLE_SECTION,
  ATK_ROLE_REDUNDANT_OBJECT,
  ATK_ROLE_FORM,
  ATK_ROLE_LINK,
  ATK_ROLE_INPUT_METHOD_WINDOW,
  ATK_ROLE_LAST_DEFINED
} AtkRole;
AtkRole atk_role_register (const gchar *name);
typedef enum
{
  ATK_LAYER_INVALID,
  ATK_LAYER_BACKGROUND,
  ATK_LAYER_CANVAS,
  ATK_LAYER_WIDGET,
  ATK_LAYER_MDI,
  ATK_LAYER_POPUP,
  ATK_LAYER_OVERLAY,
  ATK_LAYER_WINDOW
} AtkLayer;
typedef GSList AtkAttributeSet;
typedef struct _AtkAttribute AtkAttribute;
struct _AtkAttribute {
  gchar* name;
  gchar* value;
};
typedef struct _AtkImplementor AtkImplementor;
typedef struct _AtkImplementorIface AtkImplementorIface;
typedef struct _AtkObject AtkObject;
typedef struct _AtkObjectClass AtkObjectClass;
typedef struct _AtkRelationSet AtkRelationSet;
typedef struct _AtkStateSet AtkStateSet;
struct _AtkPropertyValues
{
  const gchar *property_name;
  GValue old_value;
  GValue new_value;
};
typedef struct _AtkPropertyValues AtkPropertyValues;
typedef gboolean (*AtkFunction) (gpointer data);
typedef void (*AtkPropertyChangeHandler) (AtkObject*, AtkPropertyValues*);
struct _AtkObject
{
  GObject parent;
  gchar *description;
  gchar *name;
  AtkObject *accessible_parent;
  AtkRole role;
  AtkRelationSet *relation_set;
  AtkLayer layer;
};
struct _AtkObjectClass
{
  GObjectClass parent;
  const gchar* (* get_name) (AtkObject *accessible);
  const gchar* (* get_description) (AtkObject *accessible);
  AtkObject* (*get_parent) (AtkObject *accessible);
  gint (* get_n_children) (AtkObject *accessible);
  AtkObject* (* ref_child) (AtkObject *accessible,
                                                    gint i);
  gint (* get_index_in_parent) (AtkObject *accessible);
  AtkRelationSet* (* ref_relation_set) (AtkObject *accessible);
  AtkRole (* get_role) (AtkObject *accessible);
  AtkLayer (* get_layer) (AtkObject *accessible);
  gint (* get_mdi_zorder) (AtkObject *accessible);
  AtkStateSet* (* ref_state_set) (AtkObject *accessible);
  void (* set_name) (AtkObject *accessible,
                                                   const gchar *name);
  void (* set_description) (AtkObject *accessible,
                                                   const gchar *description);
  void (* set_parent) (AtkObject *accessible,
                                                   AtkObject *parent);
  void (* set_role) (AtkObject *accessible,
                                                   AtkRole role);
guint (* connect_property_change_handler) (AtkObject
                 *accessible,
                                                                  AtkPropertyChangeHandler *handler);
void (* remove_property_change_handler) (AtkObject
                *accessible,
                                                                  guint
                handler_id);
void (* initialize) (AtkObject *accessible,
                                                                  gpointer data);
  void (* children_changed) (AtkObject *accessible,
                                                   guint change_index,
                                                   gpointer changed_child);
  void (* focus_event) (AtkObject *accessible,
                                                   gboolean focus_in);
  void (* property_change) (AtkObject *accessible,
                                                   AtkPropertyValues *values);
  void (* state_change) (AtkObject *accessible,
                                                   const gchar *name,
                                                   gboolean state_set);
  void (*visible_data_changed) (AtkObject *accessible);
  void (*active_descendant_changed) (AtkObject *accessible,
                                                        gpointer *child);
  AtkAttributeSet* (*get_attributes) (AtkObject *accessible);
  AtkFunction pad1;
  AtkFunction pad2;
};
GType atk_object_get_type (void);
struct _AtkImplementorIface
{
  GTypeInterface parent;
  AtkObject* (*ref_accessible) (AtkImplementor *implementor);
};
GType atk_implementor_get_type (void);
AtkObject* atk_implementor_ref_accessible (AtkImplementor *implementor);
const gchar* atk_object_get_name (AtkObject *accessible);
const gchar* atk_object_get_description (AtkObject *accessible);
AtkObject* atk_object_get_parent (AtkObject *accessible);
gint atk_object_get_n_accessible_children (AtkObject *accessible);
AtkObject* atk_object_ref_accessible_child (AtkObject *accessible,
                                                                   gint i);
AtkRelationSet* atk_object_ref_relation_set (AtkObject *accessible);
AtkRole atk_object_get_role (AtkObject *accessible);
AtkLayer atk_object_get_layer (AtkObject *accessible);
gint atk_object_get_mdi_zorder (AtkObject *accessible);
AtkAttributeSet* atk_object_get_attributes (AtkObject *accessible);
AtkStateSet* atk_object_ref_state_set (AtkObject *accessible);
gint atk_object_get_index_in_parent (AtkObject *accessible);
void atk_object_set_name (AtkObject *accessible,
                                                                   const gchar *name);
void atk_object_set_description (AtkObject *accessible,
                                                                   const gchar *description);
void atk_object_set_parent (AtkObject *accessible,
                                                                   AtkObject *parent);
void atk_object_set_role (AtkObject *accessible,
                                                                   AtkRole role);
guint atk_object_connect_property_change_handler (AtkObject *accessible,
                                                                  AtkPropertyChangeHandler *handler);
void atk_object_remove_property_change_handler (AtkObject *accessible,
                                                                  guint handler_id);
void atk_object_notify_state_change (AtkObject *accessible,
                                                                  AtkState state,
                                                                  gboolean value);
void atk_object_initialize (AtkObject *accessible,
                                                                  gpointer data);
const gchar* atk_role_get_name (AtkRole role);
AtkRole atk_role_for_name (const gchar *name);
gboolean atk_object_add_relationship (AtkObject *object,
        AtkRelationType relationship,
        AtkObject *target);
gboolean atk_object_remove_relationship (AtkObject *object,
        AtkRelationType relationship,
        AtkObject *target);
const gchar* atk_role_get_localized_name (AtkRole role);
}
extern "C" {
typedef enum
{
  GTK_TOPLEVEL = 1 << 4,
  GTK_NO_WINDOW = 1 << 5,
  GTK_REALIZED = 1 << 6,
  GTK_MAPPED = 1 << 7,
  GTK_VISIBLE = 1 << 8,
  GTK_SENSITIVE = 1 << 9,
  GTK_PARENT_SENSITIVE = 1 << 10,
  GTK_CAN_FOCUS = 1 << 11,
  GTK_HAS_FOCUS = 1 << 12,
  GTK_CAN_DEFAULT = 1 << 13,
  GTK_HAS_DEFAULT = 1 << 14,
  GTK_HAS_GRAB = 1 << 15,
  GTK_RC_STYLE = 1 << 16,
  GTK_COMPOSITE_CHILD = 1 << 17,
  GTK_NO_REPARENT = 1 << 18,
  GTK_APP_PAINTABLE = 1 << 19,
  GTK_RECEIVES_DEFAULT = 1 << 20,
  GTK_DOUBLE_BUFFERED = 1 << 21,
  GTK_NO_SHOW_ALL = 1 << 22
} GtkWidgetFlags;
typedef enum
{
  GTK_WIDGET_HELP_TOOLTIP,
  GTK_WIDGET_HELP_WHATS_THIS
} GtkWidgetHelpType;
typedef struct _GtkRequisition GtkRequisition;
typedef GdkRectangle GtkAllocation;
typedef struct _GtkSelectionData GtkSelectionData;
typedef struct _GtkWidgetClass GtkWidgetClass;
typedef struct _GtkWidgetAuxInfo GtkWidgetAuxInfo;
typedef struct _GtkWidgetShapeInfo GtkWidgetShapeInfo;
typedef struct _GtkClipboard GtkClipboard;
typedef struct _GtkTooltip GtkTooltip;
typedef struct _GtkWindow GtkWindow;
typedef void (*GtkCallback) (GtkWidget *widget,
     gpointer data);
struct _GtkRequisition
{
  gint width;
  gint height;
};
struct _GtkWidget
{
  GtkObject object;
  guint16 private_flags;
  guint8 state;
  guint8 saved_state;
  gchar *name;
  GtkStyle *style;
  GtkRequisition requisition;
  GtkAllocation allocation;
  GdkWindow *window;
  GtkWidget *parent;
};
struct _GtkWidgetClass
{
  GtkObjectClass parent_class;
  guint activate_signal;
  guint set_scroll_adjustments_signal;
  void (*dispatch_child_properties_changed) (GtkWidget *widget,
          guint n_pspecs,
          GParamSpec **pspecs);
  void (* show) (GtkWidget *widget);
  void (* show_all) (GtkWidget *widget);
  void (* hide) (GtkWidget *widget);
  void (* hide_all) (GtkWidget *widget);
  void (* map) (GtkWidget *widget);
  void (* unmap) (GtkWidget *widget);
  void (* realize) (GtkWidget *widget);
  void (* unrealize) (GtkWidget *widget);
  void (* size_request) (GtkWidget *widget,
    GtkRequisition *requisition);
  void (* size_allocate) (GtkWidget *widget,
    GtkAllocation *allocation);
  void (* state_changed) (GtkWidget *widget,
    GtkStateType previous_state);
  void (* parent_set) (GtkWidget *widget,
    GtkWidget *previous_parent);
  void (* hierarchy_changed) (GtkWidget *widget,
    GtkWidget *previous_toplevel);
  void (* style_set) (GtkWidget *widget,
    GtkStyle *previous_style);
  void (* direction_changed) (GtkWidget *widget,
    GtkTextDirection previous_direction);
  void (* grab_notify) (GtkWidget *widget,
    gboolean was_grabbed);
  void (* child_notify) (GtkWidget *widget,
    GParamSpec *pspec);
  gboolean (* mnemonic_activate) (GtkWidget *widget,
      gboolean group_cycling);
  void (* grab_focus) (GtkWidget *widget);
  gboolean (* focus) (GtkWidget *widget,
                                GtkDirectionType direction);
  gboolean (* event) (GtkWidget *widget,
      GdkEvent *event);
  gboolean (* button_press_event) (GtkWidget *widget,
      GdkEventButton *event);
  gboolean (* button_release_event) (GtkWidget *widget,
      GdkEventButton *event);
  gboolean (* scroll_event) (GtkWidget *widget,
      GdkEventScroll *event);
  gboolean (* motion_notify_event) (GtkWidget *widget,
      GdkEventMotion *event);
  gboolean (* delete_event) (GtkWidget *widget,
      GdkEventAny *event);
  gboolean (* destroy_event) (GtkWidget *widget,
      GdkEventAny *event);
  gboolean (* expose_event) (GtkWidget *widget,
      GdkEventExpose *event);
  gboolean (* key_press_event) (GtkWidget *widget,
      GdkEventKey *event);
  gboolean (* key_release_event) (GtkWidget *widget,
      GdkEventKey *event);
  gboolean (* enter_notify_event) (GtkWidget *widget,
      GdkEventCrossing *event);
  gboolean (* leave_notify_event) (GtkWidget *widget,
      GdkEventCrossing *event);
  gboolean (* configure_event) (GtkWidget *widget,
      GdkEventConfigure *event);
  gboolean (* focus_in_event) (GtkWidget *widget,
      GdkEventFocus *event);
  gboolean (* focus_out_event) (GtkWidget *widget,
      GdkEventFocus *event);
  gboolean (* map_event) (GtkWidget *widget,
      GdkEventAny *event);
  gboolean (* unmap_event) (GtkWidget *widget,
      GdkEventAny *event);
  gboolean (* property_notify_event) (GtkWidget *widget,
      GdkEventProperty *event);
  gboolean (* selection_clear_event) (GtkWidget *widget,
      GdkEventSelection *event);
  gboolean (* selection_request_event) (GtkWidget *widget,
      GdkEventSelection *event);
  gboolean (* selection_notify_event) (GtkWidget *widget,
      GdkEventSelection *event);
  gboolean (* proximity_in_event) (GtkWidget *widget,
      GdkEventProximity *event);
  gboolean (* proximity_out_event) (GtkWidget *widget,
      GdkEventProximity *event);
  gboolean (* visibility_notify_event) (GtkWidget *widget,
      GdkEventVisibility *event);
  gboolean (* client_event) (GtkWidget *widget,
      GdkEventClient *event);
  gboolean (* no_expose_event) (GtkWidget *widget,
      GdkEventAny *event);
  gboolean (* window_state_event) (GtkWidget *widget,
      GdkEventWindowState *event);
  void (* selection_get) (GtkWidget *widget,
        GtkSelectionData *selection_data,
        guint info,
        guint time_);
  void (* selection_received) (GtkWidget *widget,
        GtkSelectionData *selection_data,
        guint time_);
  void (* drag_begin) (GtkWidget *widget,
        GdkDragContext *context);
  void (* drag_end) (GtkWidget *widget,
        GdkDragContext *context);
  void (* drag_data_get) (GtkWidget *widget,
        GdkDragContext *context,
        GtkSelectionData *selection_data,
        guint info,
        guint time_);
  void (* drag_data_delete) (GtkWidget *widget,
        GdkDragContext *context);
  void (* drag_leave) (GtkWidget *widget,
        GdkDragContext *context,
        guint time_);
  gboolean (* drag_motion) (GtkWidget *widget,
        GdkDragContext *context,
        gint x,
        gint y,
        guint time_);
  gboolean (* drag_drop) (GtkWidget *widget,
        GdkDragContext *context,
        gint x,
        gint y,
        guint time_);
  void (* drag_data_received) (GtkWidget *widget,
        GdkDragContext *context,
        gint x,
        gint y,
        GtkSelectionData *selection_data,
        guint info,
        guint time_);
  gboolean (* popup_menu) (GtkWidget *widget);
  gboolean (* show_help) (GtkWidget *widget,
                                    GtkWidgetHelpType help_type);
  AtkObject* (*get_accessible) (GtkWidget *widget);
  void (*screen_changed) (GtkWidget *widget,
                                      GdkScreen *previous_screen);
  gboolean (*can_activate_accel) (GtkWidget *widget,
                                      guint signal_id);
  gboolean (*grab_broken_event) (GtkWidget *widget,
                                 GdkEventGrabBroken *event);
  void (* composited_changed) (GtkWidget *widget);
  gboolean (* query_tooltip) (GtkWidget *widget,
           gint x,
           gint y,
           gboolean keyboard_tooltip,
           GtkTooltip *tooltip);
  void (*_gtk_reserved5) (void);
  void (*_gtk_reserved6) (void);
  void (*_gtk_reserved7) (void);
};
struct _GtkWidgetAuxInfo
{
  gint x;
  gint y;
  gint width;
  gint height;
  guint x_set : 1;
  guint y_set : 1;
};
struct _GtkWidgetShapeInfo
{
  gint16 offset_x;
  gint16 offset_y;
  GdkBitmap *shape_mask;
};
GType gtk_widget_get_type (void) __attribute__((__const__));
GtkWidget* gtk_widget_new (GType type,
        const gchar *first_property_name,
        ...);
void gtk_widget_destroy (GtkWidget *widget);
void gtk_widget_destroyed (GtkWidget *widget,
        GtkWidget **widget_pointer);
GtkWidget* gtk_widget_ref (GtkWidget *widget);
void gtk_widget_unref (GtkWidget *widget);
void gtk_widget_set (GtkWidget *widget,
        const gchar *first_property_name,
        ...) __attribute__((__sentinel__));
void gtk_widget_unparent (GtkWidget *widget);
void gtk_widget_show (GtkWidget *widget);
void gtk_widget_show_now (GtkWidget *widget);
void gtk_widget_hide (GtkWidget *widget);
void gtk_widget_show_all (GtkWidget *widget);
void gtk_widget_hide_all (GtkWidget *widget);
void gtk_widget_set_no_show_all (GtkWidget *widget,
        gboolean no_show_all);
gboolean gtk_widget_get_no_show_all (GtkWidget *widget);
void gtk_widget_map (GtkWidget *widget);
void gtk_widget_unmap (GtkWidget *widget);
void gtk_widget_realize (GtkWidget *widget);
void gtk_widget_unrealize (GtkWidget *widget);
void gtk_widget_queue_draw (GtkWidget *widget);
void gtk_widget_queue_draw_area (GtkWidget *widget,
        gint x,
        gint y,
        gint width,
        gint height);
void gtk_widget_queue_clear (GtkWidget *widget);
void gtk_widget_queue_clear_area (GtkWidget *widget,
        gint x,
        gint y,
        gint width,
        gint height);
void gtk_widget_queue_resize (GtkWidget *widget);
void gtk_widget_queue_resize_no_redraw (GtkWidget *widget);
void gtk_widget_draw (GtkWidget *widget,
        GdkRectangle *area);
void gtk_widget_size_request (GtkWidget *widget,
        GtkRequisition *requisition);
void gtk_widget_size_allocate (GtkWidget *widget,
        GtkAllocation *allocation);
void gtk_widget_get_child_requisition (GtkWidget *widget,
          GtkRequisition *requisition);
void gtk_widget_add_accelerator (GtkWidget *widget,
        const gchar *accel_signal,
        GtkAccelGroup *accel_group,
        guint accel_key,
        GdkModifierType accel_mods,
        GtkAccelFlags accel_flags);
gboolean gtk_widget_remove_accelerator (GtkWidget *widget,
        GtkAccelGroup *accel_group,
        guint accel_key,
        GdkModifierType accel_mods);
void gtk_widget_set_accel_path (GtkWidget *widget,
        const gchar *accel_path,
        GtkAccelGroup *accel_group);
const gchar* _gtk_widget_get_accel_path (GtkWidget *widget,
        gboolean *locked);
GList* gtk_widget_list_accel_closures (GtkWidget *widget);
gboolean gtk_widget_can_activate_accel (GtkWidget *widget,
                                           guint signal_id);
gboolean gtk_widget_mnemonic_activate (GtkWidget *widget,
        gboolean group_cycling);
gboolean gtk_widget_event (GtkWidget *widget,
        GdkEvent *event);
gint gtk_widget_send_expose (GtkWidget *widget,
        GdkEvent *event);
gboolean gtk_widget_activate (GtkWidget *widget);
gboolean gtk_widget_set_scroll_adjustments (GtkWidget *widget,
           GtkAdjustment *hadjustment,
           GtkAdjustment *vadjustment);
void gtk_widget_reparent (GtkWidget *widget,
        GtkWidget *new_parent);
gboolean gtk_widget_intersect (GtkWidget *widget,
        GdkRectangle *area,
        GdkRectangle *intersection);
GdkRegion *gtk_widget_region_intersect (GtkWidget *widget,
        GdkRegion *region);
void gtk_widget_freeze_child_notify (GtkWidget *widget);
void gtk_widget_child_notify (GtkWidget *widget,
        const gchar *child_property);
void gtk_widget_thaw_child_notify (GtkWidget *widget);
gboolean gtk_widget_is_focus (GtkWidget *widget);
void gtk_widget_grab_focus (GtkWidget *widget);
void gtk_widget_grab_default (GtkWidget *widget);
void gtk_widget_set_name (GtkWidget *widget,
        const gchar *name);
const gchar* gtk_widget_get_name (GtkWidget *widget);
void gtk_widget_set_state (GtkWidget *widget,
        GtkStateType state);
void gtk_widget_set_sensitive (GtkWidget *widget,
        gboolean sensitive);
void gtk_widget_set_app_paintable (GtkWidget *widget,
        gboolean app_paintable);
void gtk_widget_set_double_buffered (GtkWidget *widget,
        gboolean double_buffered);
void gtk_widget_set_redraw_on_allocate (GtkWidget *widget,
        gboolean redraw_on_allocate);
void gtk_widget_set_parent (GtkWidget *widget,
        GtkWidget *parent);
void gtk_widget_set_parent_window (GtkWidget *widget,
        GdkWindow *parent_window);
void gtk_widget_set_child_visible (GtkWidget *widget,
        gboolean is_visible);
gboolean gtk_widget_get_child_visible (GtkWidget *widget);
GtkWidget *gtk_widget_get_parent (GtkWidget *widget);
GdkWindow *gtk_widget_get_parent_window (GtkWidget *widget);
gboolean gtk_widget_child_focus (GtkWidget *widget,
                                           GtkDirectionType direction);
gboolean gtk_widget_keynav_failed (GtkWidget *widget,
                                           GtkDirectionType direction);
void gtk_widget_error_bell (GtkWidget *widget);
void gtk_widget_set_size_request (GtkWidget *widget,
                                           gint width,
                                           gint height);
void gtk_widget_get_size_request (GtkWidget *widget,
                                           gint *width,
                                           gint *height);
void gtk_widget_set_uposition (GtkWidget *widget,
        gint x,
        gint y);
void gtk_widget_set_usize (GtkWidget *widget,
        gint width,
        gint height);
void gtk_widget_set_events (GtkWidget *widget,
        gint events);
void gtk_widget_add_events (GtkWidget *widget,
        gint events);
void gtk_widget_set_extension_events (GtkWidget *widget,
         GdkExtensionMode mode);
GdkExtensionMode gtk_widget_get_extension_events (GtkWidget *widget);
GtkWidget* gtk_widget_get_toplevel (GtkWidget *widget);
GtkWidget* gtk_widget_get_ancestor (GtkWidget *widget,
      GType widget_type);
GdkColormap* gtk_widget_get_colormap (GtkWidget *widget);
GdkVisual* gtk_widget_get_visual (GtkWidget *widget);
GdkScreen * gtk_widget_get_screen (GtkWidget *widget);
gboolean gtk_widget_has_screen (GtkWidget *widget);
GdkDisplay * gtk_widget_get_display (GtkWidget *widget);
GdkWindow * gtk_widget_get_root_window (GtkWidget *widget);
GtkSettings* gtk_widget_get_settings (GtkWidget *widget);
GtkClipboard *gtk_widget_get_clipboard (GtkWidget *widget,
       GdkAtom selection);
AtkObject* gtk_widget_get_accessible (GtkWidget *widget);
void gtk_widget_set_colormap (GtkWidget *widget,
      GdkColormap *colormap);
gint gtk_widget_get_events (GtkWidget *widget);
void gtk_widget_get_pointer (GtkWidget *widget,
      gint *x,
      gint *y);
gboolean gtk_widget_is_ancestor (GtkWidget *widget,
      GtkWidget *ancestor);
gboolean gtk_widget_translate_coordinates (GtkWidget *src_widget,
            GtkWidget *dest_widget,
            gint src_x,
            gint src_y,
            gint *dest_x,
            gint *dest_y);
gboolean gtk_widget_hide_on_delete (GtkWidget *widget);
void gtk_widget_set_style (GtkWidget *widget,
      GtkStyle *style);
void gtk_widget_ensure_style (GtkWidget *widget);
GtkStyle* gtk_widget_get_style (GtkWidget *widget);
void gtk_widget_modify_style (GtkWidget *widget,
        GtkRcStyle *style);
GtkRcStyle *gtk_widget_get_modifier_style (GtkWidget *widget);
void gtk_widget_modify_fg (GtkWidget *widget,
        GtkStateType state,
        const GdkColor *color);
void gtk_widget_modify_bg (GtkWidget *widget,
        GtkStateType state,
        const GdkColor *color);
void gtk_widget_modify_text (GtkWidget *widget,
        GtkStateType state,
        const GdkColor *color);
void gtk_widget_modify_base (GtkWidget *widget,
        GtkStateType state,
        const GdkColor *color);
void gtk_widget_modify_cursor (GtkWidget *widget,
        const GdkColor *primary,
        const GdkColor *secondary);
void gtk_widget_modify_font (GtkWidget *widget,
        PangoFontDescription *font_desc);
PangoContext *gtk_widget_create_pango_context (GtkWidget *widget);
PangoContext *gtk_widget_get_pango_context (GtkWidget *widget);
PangoLayout *gtk_widget_create_pango_layout (GtkWidget *widget,
            const gchar *text);
GdkPixbuf *gtk_widget_render_icon (GtkWidget *widget,
                                               const gchar *stock_id,
                                               GtkIconSize size,
                                               const gchar *detail);
void gtk_widget_set_composite_name (GtkWidget *widget,
      const gchar *name);
gchar* gtk_widget_get_composite_name (GtkWidget *widget);
void gtk_widget_reset_rc_styles (GtkWidget *widget);
void gtk_widget_push_colormap (GdkColormap *cmap);
void gtk_widget_push_composite_child (void);
void gtk_widget_pop_composite_child (void);
void gtk_widget_pop_colormap (void);
void gtk_widget_class_install_style_property (GtkWidgetClass *klass,
           GParamSpec *pspec);
void gtk_widget_class_install_style_property_parser (GtkWidgetClass *klass,
           GParamSpec *pspec,
           GtkRcPropertyParser parser);
GParamSpec* gtk_widget_class_find_style_property (GtkWidgetClass *klass,
           const gchar *property_name);
GParamSpec** gtk_widget_class_list_style_properties (GtkWidgetClass *klass,
           guint *n_properties);
void gtk_widget_style_get_property (GtkWidget *widget,
        const gchar *property_name,
        GValue *value);
void gtk_widget_style_get_valist (GtkWidget *widget,
        const gchar *first_property_name,
        va_list var_args);
void gtk_widget_style_get (GtkWidget *widget,
        const gchar *first_property_name,
        ...) __attribute__((__sentinel__));
void gtk_widget_set_default_colormap (GdkColormap *colormap);
GtkStyle* gtk_widget_get_default_style (void);
GdkColormap* gtk_widget_get_default_colormap (void);
GdkVisual* gtk_widget_get_default_visual (void);
void gtk_widget_set_direction (GtkWidget *widget,
         GtkTextDirection dir);
GtkTextDirection gtk_widget_get_direction (GtkWidget *widget);
void gtk_widget_set_default_direction (GtkTextDirection dir);
GtkTextDirection gtk_widget_get_default_direction (void);
gboolean gtk_widget_is_composited (GtkWidget *widget);
void gtk_widget_shape_combine_mask (GtkWidget *widget,
         GdkBitmap *shape_mask,
         gint offset_x,
         gint offset_y);
void gtk_widget_input_shape_combine_mask (GtkWidget *widget,
        GdkBitmap *shape_mask,
        gint offset_x,
        gint offset_y);
void gtk_widget_reset_shapes (GtkWidget *widget);
void gtk_widget_path (GtkWidget *widget,
         guint *path_length,
         gchar **path,
         gchar **path_reversed);
void gtk_widget_class_path (GtkWidget *widget,
         guint *path_length,
         gchar **path,
         gchar **path_reversed);
GList* gtk_widget_list_mnemonic_labels (GtkWidget *widget);
void gtk_widget_add_mnemonic_label (GtkWidget *widget,
      GtkWidget *label);
void gtk_widget_remove_mnemonic_label (GtkWidget *widget,
      GtkWidget *label);
void gtk_widget_set_tooltip_window (GtkWidget *widget,
                                                        GtkWindow *custom_window);
GtkWindow *gtk_widget_get_tooltip_window (GtkWidget *widget);
void gtk_widget_trigger_tooltip_query (GtkWidget *widget);
void gtk_widget_set_tooltip_text (GtkWidget *widget,
                                             const gchar *text);
gchar * gtk_widget_get_tooltip_text (GtkWidget *widget);
void gtk_widget_set_tooltip_markup (GtkWidget *widget,
                                             const gchar *markup);
gchar * gtk_widget_get_tooltip_markup (GtkWidget *widget);
void gtk_widget_set_has_tooltip (GtkWidget *widget,
          gboolean has_tooltip);
gboolean gtk_widget_get_has_tooltip (GtkWidget *widget);
GType gtk_requisition_get_type (void) __attribute__((__const__));
GtkRequisition *gtk_requisition_copy (const GtkRequisition *requisition);
void gtk_requisition_free (GtkRequisition *requisition);
void _gtk_widget_grab_notify (GtkWidget *widget,
                 gboolean was_grabbed);
GtkWidgetAuxInfo *_gtk_widget_get_aux_info (GtkWidget *widget,
          gboolean create);
void _gtk_widget_propagate_hierarchy_changed (GtkWidget *widget,
          GtkWidget *previous_toplevel);
void _gtk_widget_propagate_screen_changed (GtkWidget *widget,
          GdkScreen *previous_screen);
void _gtk_widget_propagate_composited_changed (GtkWidget *widget);
GdkColormap* _gtk_widget_peek_colormap (void);
}
extern "C" {
typedef struct _GtkTextIter GtkTextIter;
typedef struct _GtkTextTagTable GtkTextTagTable;
typedef struct _GtkTextAttributes GtkTextAttributes;
typedef struct _GtkTextTag GtkTextTag;
typedef struct _GtkTextTagClass GtkTextTagClass;
struct _GtkTextTag
{
  GObject parent_instance;
  GtkTextTagTable *table;
  char *name;
  int priority;
  GtkTextAttributes *values;
  guint bg_color_set : 1;
  guint bg_stipple_set : 1;
  guint fg_color_set : 1;
  guint scale_set : 1;
  guint fg_stipple_set : 1;
  guint justification_set : 1;
  guint left_margin_set : 1;
  guint indent_set : 1;
  guint rise_set : 1;
  guint strikethrough_set : 1;
  guint right_margin_set : 1;
  guint pixels_above_lines_set : 1;
  guint pixels_below_lines_set : 1;
  guint pixels_inside_wrap_set : 1;
  guint tabs_set : 1;
  guint underline_set : 1;
  guint wrap_mode_set : 1;
  guint bg_full_height_set : 1;
  guint invisible_set : 1;
  guint editable_set : 1;
  guint language_set : 1;
  guint pg_bg_color_set : 1;
  guint accumulative_margin : 1;
  guint pad1 : 1;
};
struct _GtkTextTagClass
{
  GObjectClass parent_class;
  gboolean (* event) (GtkTextTag *tag,
                      GObject *event_object,
                      GdkEvent *event,
                      const GtkTextIter *iter);
  void (*_gtk_reserved1) (void);
  void (*_gtk_reserved2) (void);
  void (*_gtk_reserved3) (void);
  void (*_gtk_reserved4) (void);
};
GType gtk_text_tag_get_type (void) __attribute__((__const__));
GtkTextTag *gtk_text_tag_new (const gchar *name);
gint gtk_text_tag_get_priority (GtkTextTag *tag);
void gtk_text_tag_set_priority (GtkTextTag *tag,
                                        gint priority);
gboolean gtk_text_tag_event (GtkTextTag *tag,
                                        GObject *event_object,
                                        GdkEvent *event,
                                        const GtkTextIter *iter);
typedef struct _GtkTextAppearance GtkTextAppearance;
struct _GtkTextAppearance
{
  GdkColor bg_color;
  GdkColor fg_color;
  GdkBitmap *bg_stipple;
  GdkBitmap *fg_stipple;
  gint rise;
  gpointer padding1;
  guint underline : 4;
  guint strikethrough : 1;
  guint draw_bg : 1;
  guint inside_selection : 1;
  guint is_text : 1;
  guint pad1 : 1;
  guint pad2 : 1;
  guint pad3 : 1;
  guint pad4 : 1;
};
struct _GtkTextAttributes
{
  guint refcount;
  GtkTextAppearance appearance;
  GtkJustification justification;
  GtkTextDirection direction;
  PangoFontDescription *font;
  gdouble font_scale;
  gint left_margin;
  gint indent;
  gint right_margin;
  gint pixels_above_lines;
  gint pixels_below_lines;
  gint pixels_inside_wrap;
  PangoTabArray *tabs;
  GtkWrapMode wrap_mode;
  PangoLanguage *language;
  GdkColor *pg_bg_color;
  guint invisible : 1;
  guint bg_full_height : 1;
  guint editable : 1;
  guint realized : 1;
  guint pad1 : 1;
  guint pad2 : 1;
  guint pad3 : 1;
  guint pad4 : 1;
};
GtkTextAttributes* gtk_text_attributes_new (void);
GtkTextAttributes* gtk_text_attributes_copy (GtkTextAttributes *src);
void gtk_text_attributes_copy_values (GtkTextAttributes *src,
                                                    GtkTextAttributes *dest);
void gtk_text_attributes_unref (GtkTextAttributes *values);
GtkTextAttributes *gtk_text_attributes_ref (GtkTextAttributes *values);
GType gtk_text_attributes_get_type (void) __attribute__((__const__));
}
extern "C" {
typedef struct _GtkTextChildAnchor GtkTextChildAnchor;
typedef struct _GtkTextChildAnchorClass GtkTextChildAnchorClass;
struct _GtkTextChildAnchor
{
  GObject parent_instance;
  gpointer segment;
};
struct _GtkTextChildAnchorClass
{
  GObjectClass parent_class;
  void (*_gtk_reserved1) (void);
  void (*_gtk_reserved2) (void);
  void (*_gtk_reserved3) (void);
  void (*_gtk_reserved4) (void);
};
GType gtk_text_child_anchor_get_type (void) __attribute__((__const__));
GtkTextChildAnchor* gtk_text_child_anchor_new (void);
GList* gtk_text_child_anchor_get_widgets (GtkTextChildAnchor *anchor);
gboolean gtk_text_child_anchor_get_deleted (GtkTextChildAnchor *anchor);
}
extern "C" {
typedef enum {
  GTK_TEXT_SEARCH_VISIBLE_ONLY = 1 << 0,
  GTK_TEXT_SEARCH_TEXT_ONLY = 1 << 1
} GtkTextSearchFlags;
typedef struct _GtkTextBuffer GtkTextBuffer;
struct _GtkTextIter {
  gpointer dummy1;
  gpointer dummy2;
  gint dummy3;
  gint dummy4;
  gint dummy5;
  gint dummy6;
  gint dummy7;
  gint dummy8;
  gpointer dummy9;
  gpointer dummy10;
  gint dummy11;
  gint dummy12;
  gint dummy13;
  gpointer dummy14;
};
GtkTextBuffer *gtk_text_iter_get_buffer (const GtkTextIter *iter);
GtkTextIter *gtk_text_iter_copy (const GtkTextIter *iter);
void gtk_text_iter_free (GtkTextIter *iter);
GType gtk_text_iter_get_type (void) __attribute__((__const__));
gint gtk_text_iter_get_offset (const GtkTextIter *iter);
gint gtk_text_iter_get_line (const GtkTextIter *iter);
gint gtk_text_iter_get_line_offset (const GtkTextIter *iter);
gint gtk_text_iter_get_line_index (const GtkTextIter *iter);
gint gtk_text_iter_get_visible_line_offset (const GtkTextIter *iter);
gint gtk_text_iter_get_visible_line_index (const GtkTextIter *iter);
gunichar gtk_text_iter_get_char (const GtkTextIter *iter);
gchar *gtk_text_iter_get_slice (const GtkTextIter *start,
                                          const GtkTextIter *end);
gchar *gtk_text_iter_get_text (const GtkTextIter *start,
                                          const GtkTextIter *end);
gchar *gtk_text_iter_get_visible_slice (const GtkTextIter *start,
                                          const GtkTextIter *end);
gchar *gtk_text_iter_get_visible_text (const GtkTextIter *start,
                                          const GtkTextIter *end);
GdkPixbuf* gtk_text_iter_get_pixbuf (const GtkTextIter *iter);
GSList * gtk_text_iter_get_marks (const GtkTextIter *iter);
GtkTextChildAnchor* gtk_text_iter_get_child_anchor (const GtkTextIter *iter);
GSList *gtk_text_iter_get_toggled_tags (const GtkTextIter *iter,
                                          gboolean toggled_on);
gboolean gtk_text_iter_begins_tag (const GtkTextIter *iter,
                                          GtkTextTag *tag);
gboolean gtk_text_iter_ends_tag (const GtkTextIter *iter,
                                          GtkTextTag *tag);
gboolean gtk_text_iter_toggles_tag (const GtkTextIter *iter,
                                          GtkTextTag *tag);
gboolean gtk_text_iter_has_tag (const GtkTextIter *iter,
                                          GtkTextTag *tag);
GSList *gtk_text_iter_get_tags (const GtkTextIter *iter);
gboolean gtk_text_iter_editable (const GtkTextIter *iter,
                                          gboolean default_setting);
gboolean gtk_text_iter_can_insert (const GtkTextIter *iter,
                                          gboolean default_editability);
gboolean gtk_text_iter_starts_word (const GtkTextIter *iter);
gboolean gtk_text_iter_ends_word (const GtkTextIter *iter);
gboolean gtk_text_iter_inside_word (const GtkTextIter *iter);
gboolean gtk_text_iter_starts_sentence (const GtkTextIter *iter);
gboolean gtk_text_iter_ends_sentence (const GtkTextIter *iter);
gboolean gtk_text_iter_inside_sentence (const GtkTextIter *iter);
gboolean gtk_text_iter_starts_line (const GtkTextIter *iter);
gboolean gtk_text_iter_ends_line (const GtkTextIter *iter);
gboolean gtk_text_iter_is_cursor_position (const GtkTextIter *iter);
gint gtk_text_iter_get_chars_in_line (const GtkTextIter *iter);
gint gtk_text_iter_get_bytes_in_line (const GtkTextIter *iter);
gboolean gtk_text_iter_get_attributes (const GtkTextIter *iter,
          GtkTextAttributes *values);
PangoLanguage* gtk_text_iter_get_language (const GtkTextIter *iter);
gboolean gtk_text_iter_is_end (const GtkTextIter *iter);
gboolean gtk_text_iter_is_start (const GtkTextIter *iter);
gboolean gtk_text_iter_forward_char (GtkTextIter *iter);
gboolean gtk_text_iter_backward_char (GtkTextIter *iter);
gboolean gtk_text_iter_forward_chars (GtkTextIter *iter,
                                             gint count);
gboolean gtk_text_iter_backward_chars (GtkTextIter *iter,
                                             gint count);
gboolean gtk_text_iter_forward_line (GtkTextIter *iter);
gboolean gtk_text_iter_backward_line (GtkTextIter *iter);
gboolean gtk_text_iter_forward_lines (GtkTextIter *iter,
                                             gint count);
gboolean gtk_text_iter_backward_lines (GtkTextIter *iter,
                                             gint count);
gboolean gtk_text_iter_forward_word_end (GtkTextIter *iter);
gboolean gtk_text_iter_backward_word_start (GtkTextIter *iter);
gboolean gtk_text_iter_forward_word_ends (GtkTextIter *iter,
                                             gint count);
gboolean gtk_text_iter_backward_word_starts (GtkTextIter *iter,
                                             gint count);
gboolean gtk_text_iter_forward_visible_line (GtkTextIter *iter);
gboolean gtk_text_iter_backward_visible_line (GtkTextIter *iter);
gboolean gtk_text_iter_forward_visible_lines (GtkTextIter *iter,
                                               gint count);
gboolean gtk_text_iter_backward_visible_lines (GtkTextIter *iter,
                                               gint count);
gboolean gtk_text_iter_forward_visible_word_end (GtkTextIter *iter);
gboolean gtk_text_iter_backward_visible_word_start (GtkTextIter *iter);
gboolean gtk_text_iter_forward_visible_word_ends (GtkTextIter *iter,
                                             gint count);
gboolean gtk_text_iter_backward_visible_word_starts (GtkTextIter *iter,
                                             gint count);
gboolean gtk_text_iter_forward_sentence_end (GtkTextIter *iter);
gboolean gtk_text_iter_backward_sentence_start (GtkTextIter *iter);
gboolean gtk_text_iter_forward_sentence_ends (GtkTextIter *iter,
                                                 gint count);
gboolean gtk_text_iter_backward_sentence_starts (GtkTextIter *iter,
                                                 gint count);
gboolean gtk_text_iter_forward_cursor_position (GtkTextIter *iter);
gboolean gtk_text_iter_backward_cursor_position (GtkTextIter *iter);
gboolean gtk_text_iter_forward_cursor_positions (GtkTextIter *iter,
                                                  gint count);
gboolean gtk_text_iter_backward_cursor_positions (GtkTextIter *iter,
                                                  gint count);
gboolean gtk_text_iter_forward_visible_cursor_position (GtkTextIter *iter);
gboolean gtk_text_iter_backward_visible_cursor_position (GtkTextIter *iter);
gboolean gtk_text_iter_forward_visible_cursor_positions (GtkTextIter *iter,
                                                          gint count);
gboolean gtk_text_iter_backward_visible_cursor_positions (GtkTextIter *iter,
                                                          gint count);
void gtk_text_iter_set_offset (GtkTextIter *iter,
                                           gint char_offset);
void gtk_text_iter_set_line (GtkTextIter *iter,
                                           gint line_number);
void gtk_text_iter_set_line_offset (GtkTextIter *iter,
                                           gint char_on_line);
void gtk_text_iter_set_line_index (GtkTextIter *iter,
                                           gint byte_on_line);
void gtk_text_iter_forward_to_end (GtkTextIter *iter);
gboolean gtk_text_iter_forward_to_line_end (GtkTextIter *iter);
void gtk_text_iter_set_visible_line_offset (GtkTextIter *iter,
                                                gint char_on_line);
void gtk_text_iter_set_visible_line_index (GtkTextIter *iter,
                                                gint byte_on_line);
gboolean gtk_text_iter_forward_to_tag_toggle (GtkTextIter *iter,
                                              GtkTextTag *tag);
gboolean gtk_text_iter_backward_to_tag_toggle (GtkTextIter *iter,
                                               GtkTextTag *tag);
typedef gboolean (* GtkTextCharPredicate) (gunichar ch, gpointer user_data);
gboolean gtk_text_iter_forward_find_char (GtkTextIter *iter,
                                           GtkTextCharPredicate pred,
                                           gpointer user_data,
                                           const GtkTextIter *limit);
gboolean gtk_text_iter_backward_find_char (GtkTextIter *iter,
                                           GtkTextCharPredicate pred,
                                           gpointer user_data,
                                           const GtkTextIter *limit);
gboolean gtk_text_iter_forward_search (const GtkTextIter *iter,
                                        const gchar *str,
                                        GtkTextSearchFlags flags,
                                        GtkTextIter *match_start,
                                        GtkTextIter *match_end,
                                        const GtkTextIter *limit);
gboolean gtk_text_iter_backward_search (const GtkTextIter *iter,
                                        const gchar *str,
                                        GtkTextSearchFlags flags,
                                        GtkTextIter *match_start,
                                        GtkTextIter *match_end,
                                        const GtkTextIter *limit);
gboolean gtk_text_iter_equal (const GtkTextIter *lhs,
                                        const GtkTextIter *rhs);
gint gtk_text_iter_compare (const GtkTextIter *lhs,
                                        const GtkTextIter *rhs);
gboolean gtk_text_iter_in_range (const GtkTextIter *iter,
                                        const GtkTextIter *start,
                                        const GtkTextIter *end);
void gtk_text_iter_order (GtkTextIter *first,
                                        GtkTextIter *second);
}
extern "C" {
typedef struct _GtkTargetList GtkTargetList;
typedef struct _GtkTargetEntry GtkTargetEntry;
struct _GtkSelectionData
{
  GdkAtom selection;
  GdkAtom target;
  GdkAtom type;
  gint format;
  guchar *data;
  gint length;
  GdkDisplay *display;
};
struct _GtkTargetEntry {
  gchar *target;
  guint flags;
  guint info;
};
typedef struct _GtkTargetPair GtkTargetPair;
struct _GtkTargetList {
  GList *list;
  guint ref_count;
};
struct _GtkTargetPair {
  GdkAtom target;
  guint flags;
  guint info;
};
GtkTargetList *gtk_target_list_new (const GtkTargetEntry *targets,
       guint ntargets);
GtkTargetList *gtk_target_list_ref (GtkTargetList *list);
void gtk_target_list_unref (GtkTargetList *list);
void gtk_target_list_add (GtkTargetList *list,
         GdkAtom target,
       guint flags,
       guint info);
void gtk_target_list_add_text_targets (GtkTargetList *list,
                                                      guint info);
void gtk_target_list_add_rich_text_targets (GtkTargetList *list,
                                                      guint info,
                                                      gboolean deserializable,
                                                      GtkTextBuffer *buffer);
void gtk_target_list_add_image_targets (GtkTargetList *list,
                                                      guint info,
                                                      gboolean writable);
void gtk_target_list_add_uri_targets (GtkTargetList *list,
                                                      guint info);
void gtk_target_list_add_table (GtkTargetList *list,
       const GtkTargetEntry *targets,
       guint ntargets);
void gtk_target_list_remove (GtkTargetList *list,
       GdkAtom target);
gboolean gtk_target_list_find (GtkTargetList *list,
       GdkAtom target,
       guint *info);
GtkTargetEntry * gtk_target_table_new_from_list (GtkTargetList *list,
                                                 gint *n_targets);
void gtk_target_table_free (GtkTargetEntry *targets,
                                                 gint n_targets);
gboolean gtk_selection_owner_set (GtkWidget *widget,
           GdkAtom selection,
           guint32 time_);
gboolean gtk_selection_owner_set_for_display (GdkDisplay *display,
           GtkWidget *widget,
           GdkAtom selection,
           guint32 time_);
void gtk_selection_add_target (GtkWidget *widget,
          GdkAtom selection,
          GdkAtom target,
          guint info);
void gtk_selection_add_targets (GtkWidget *widget,
          GdkAtom selection,
          const GtkTargetEntry *targets,
          guint ntargets);
void gtk_selection_clear_targets (GtkWidget *widget,
          GdkAtom selection);
gboolean gtk_selection_convert (GtkWidget *widget,
          GdkAtom selection,
          GdkAtom target,
          guint32 time_);
void gtk_selection_data_set (GtkSelectionData *selection_data,
          GdkAtom type,
          gint format,
          const guchar *data,
          gint length);
gboolean gtk_selection_data_set_text (GtkSelectionData *selection_data,
          const gchar *str,
          gint len);
guchar * gtk_selection_data_get_text (GtkSelectionData *selection_data);
gboolean gtk_selection_data_set_pixbuf (GtkSelectionData *selection_data,
              GdkPixbuf *pixbuf);
GdkPixbuf *gtk_selection_data_get_pixbuf (GtkSelectionData *selection_data);
gboolean gtk_selection_data_set_uris (GtkSelectionData *selection_data,
          gchar **uris);
gchar **gtk_selection_data_get_uris (GtkSelectionData *selection_data);
gboolean gtk_selection_data_get_targets (GtkSelectionData *selection_data,
        GdkAtom **targets,
        gint *n_atoms);
gboolean gtk_selection_data_targets_include_text (GtkSelectionData *selection_data);
gboolean gtk_selection_data_targets_include_rich_text (GtkSelectionData *selection_data,
                                                       GtkTextBuffer *buffer);
gboolean gtk_selection_data_targets_include_image (GtkSelectionData *selection_data,
         gboolean writable);
gboolean gtk_selection_data_targets_include_uri (GtkSelectionData *selection_data);
gboolean gtk_targets_include_text (GdkAtom *targets,
        gint n_targets);
gboolean gtk_targets_include_rich_text (GdkAtom *targets,
        gint n_targets,
                                                  GtkTextBuffer *buffer);
gboolean gtk_targets_include_image (GdkAtom *targets,
        gint n_targets,
        gboolean writable);
gboolean gtk_targets_include_uri (GdkAtom *targets,
        gint n_targets);
void gtk_selection_remove_all (GtkWidget *widget);
gboolean gtk_selection_clear (GtkWidget *widget,
        GdkEventSelection *event);
gboolean _gtk_selection_request (GtkWidget *widget,
        GdkEventSelection *event);
gboolean _gtk_selection_incr_event (GdkWindow *window,
        GdkEventProperty *event);
gboolean _gtk_selection_notify (GtkWidget *widget,
        GdkEventSelection *event);
gboolean _gtk_selection_property_notify (GtkWidget *widget,
        GdkEventProperty *event);
GType gtk_selection_data_get_type (void) __attribute__((__const__));
GtkSelectionData *gtk_selection_data_copy (GtkSelectionData *data);
void gtk_selection_data_free (GtkSelectionData *data);
GType gtk_target_list_get_type (void) __attribute__((__const__));
}
extern "C"
{
  typedef struct _GtkTargetEntry GtkTargetEntry;
}
namespace Gtk
{
class TargetEntry
{
public:
  TargetEntry();
  explicit TargetEntry(const Glib::ustring& target, Gtk::TargetFlags flags = Gtk::TargetFlags(0), guint info = 0);
  explicit TargetEntry(const GtkTargetEntry& gobject);
  TargetEntry(const TargetEntry& src);
  virtual ~TargetEntry();
  TargetEntry& operator=(const TargetEntry& src);
  Glib::ustring get_target() const;
  void set_target(const Glib::ustring& target);
  Gtk::TargetFlags get_flags() const;
  void set_flags(Gtk::TargetFlags flags);
  guint get_info() const;
  void set_info(guint info);
  GtkTargetEntry* gobj();
  const GtkTargetEntry* gobj() const;
protected:
  GtkTargetEntry gobject_;
};
struct TargetEntry_Traits
{
  typedef TargetEntry CppType;
  typedef GtkTargetEntry CType;
  typedef GtkTargetEntry CTypeNonConst;
  static const CType& to_c_type(const CppType& item)
    { return *item.gobj(); }
  static const CType& to_c_type(const CType& item)
    { return item; }
  static CppType to_cpp_type(const CType& item)
    { return TargetEntry(item); }
  static void release_c_type(const CType&) {}
};
typedef Glib::ArrayHandle< TargetEntry, TargetEntry_Traits > ArrayHandle_TargetEntry;
}
namespace Gtk
{
class TargetList
{
  public:
  typedef TargetList CppObjectType;
  typedef GtkTargetList BaseObjectType;
  void reference() const;
  void unreference() const;
  GtkTargetList* gobj();
  const GtkTargetList* gobj() const;
  GtkTargetList* gobj_copy() const;
protected:
  TargetList();
  void operator delete(void*, size_t);
private:
  TargetList(const TargetList&);
  TargetList& operator=(const TargetList&);
public:
  static Glib::RefPtr<Gtk::TargetList> create(const ArrayHandle_TargetEntry& targets);
  void add(const Glib::ustring& target, TargetFlags flags = TargetFlags(0), guint info = 0);
  void add(const ArrayHandle_TargetEntry& targets);
  void remove(const Glib::ustring& target);
  bool find(const Glib::ustring& target, guint* info) const;
};
}
namespace Glib
{
  Glib::RefPtr<Gtk::TargetList> wrap(GtkTargetList* object, bool take_copy = false);
}
extern "C" { typedef struct _GtkIconSource GtkIconSource; }
namespace Gtk
{
class IconSource
{
  public:
  typedef IconSource CppObjectType;
  typedef GtkIconSource BaseObjectType;
  static GType get_type() __attribute__((__const__));
  IconSource();
  explicit IconSource(GtkIconSource* gobject, bool make_a_copy = true);
  IconSource(const IconSource& other);
  IconSource& operator=(const IconSource& other);
  ~IconSource();
  void swap(IconSource& other);
  GtkIconSource* gobj() { return gobject_; }
  const GtkIconSource* gobj() const { return gobject_; }
  GtkIconSource* gobj_copy() const;
protected:
  GtkIconSource* gobject_;
private:
public:
  void set_filename(const Glib::ustring& filename);
  void set_pixbuf(const Glib::RefPtr<Gdk::Pixbuf>&pixbuf);
  Glib::ustring get_filename() const;
  Glib::RefPtr<Gdk::Pixbuf> get_pixbuf();
  Glib::RefPtr<const Gdk::Pixbuf> get_pixbuf() const;
  void set_direction_wildcarded(bool setting = true);
  void set_state_wildcarded(bool setting = true);
  void set_size_wildcarded (bool setting = true);
  bool get_size_wildcarded() const;
  bool get_state_wildcarded() const;
  bool get_direction_wildcarded() const;
  void set_direction(TextDirection direction);
  void set_state(Gtk::StateType state);
  void set_size(IconSize size);
  TextDirection get_direction() const;
  Gtk::StateType get_state() const;
  IconSize get_size() const;
  void set_icon_name(const Glib::ustring& icon_name);
  Glib::ustring get_icon_name() const;
};
}
namespace Gtk
{
inline void swap(IconSource& lhs, IconSource& rhs)
  { lhs.swap(rhs); }
}
namespace Glib
{
Gtk::IconSource wrap(GtkIconSource* object, bool take_copy = false);
template <>
class Value<Gtk::IconSource> : public Glib::Value_Boxed<Gtk::IconSource>
{};
}
extern "C" { typedef struct _GtkIconSet GtkIconSet; }
namespace Gtk
{
class Style;
class Widget;
class IconSet
{
  public:
  typedef IconSet CppObjectType;
  typedef GtkIconSet BaseObjectType;
  static GType get_type() __attribute__((__const__));
  IconSet();
  explicit IconSet(GtkIconSet* gobject, bool make_a_copy = true);
  IconSet(const IconSet& other);
  IconSet& operator=(const IconSet& other);
  ~IconSet();
  void swap(IconSet& other);
  GtkIconSet* gobj() { return gobject_; }
  const GtkIconSet* gobj() const { return gobject_; }
  GtkIconSet* gobj_copy() const;
protected:
  GtkIconSet* gobject_;
private:
public:
  explicit IconSet(const Glib::RefPtr<Gdk::Pixbuf>& pixbuf);
  IconSet copy() const;
  Glib::RefPtr<Gdk::Pixbuf> render_icon(const Glib::RefPtr<Style>& style, TextDirection direction,
                                          Gtk::StateType state, IconSize size,
                                          Widget& widget, const Glib::ustring& detail);
  void add_source(const IconSource& source);
  Glib::ArrayHandle<IconSize> get_sizes() const;
  static IconSet lookup_default(const Gtk::StockID& stock_id);
};
}
namespace Gtk
{
inline void swap(IconSet& lhs, IconSet& rhs)
  { lhs.swap(rhs); }
}
namespace Glib
{
Gtk::IconSet wrap(GtkIconSet* object, bool take_copy = false);
template <>
class Value<Gtk::IconSet> : public Glib::Value_Boxed<Gtk::IconSet>
{};
}
typedef struct _GtkStyle GtkStyle;
typedef struct _GtkStyleClass GtkStyleClass;
namespace Gtk
{ class Style_Class; }
namespace Gtk
{
class Widget;
class RcStyle;
class Style : public Glib::Object
{
public:
  typedef Style CppObjectType;
  typedef Style_Class CppClassType;
  typedef GtkStyle BaseObjectType;
  typedef GtkStyleClass BaseClassType;
private: friend class Style_Class;
  static CppClassType style_class_;
private:
  Style(const Style&);
  Style& operator=(const Style&);
protected:
  explicit Style(const Glib::ConstructParams& construct_params);
  explicit Style(GtkStyle* castitem);
public:
  virtual ~Style();
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkStyle* gobj() { return reinterpret_cast<GtkStyle*>(gobject_); }
  const GtkStyle* gobj() const { return reinterpret_cast<GtkStyle*>(gobject_); }
  GtkStyle* gobj_copy();
private:
protected:
  Style();
public:
  static Glib::RefPtr<Style> create();
  void set_fg(Gtk::StateType state, const Gdk::Color& color);
  Gdk::Color get_fg(Gtk::StateType state) const;
  void set_bg(Gtk::StateType state, const Gdk::Color& color);
  Gdk::Color get_bg(Gtk::StateType state) const;
  void set_light(Gtk::StateType state, const Gdk::Color& color);
  Gdk::Color get_light(Gtk::StateType state) const;
  void set_dark(Gtk::StateType state, const Gdk::Color& color);
  Gdk::Color get_dark(Gtk::StateType state) const;
  void set_mid(Gtk::StateType state, const Gdk::Color& color);
  Gdk::Color get_mid(Gtk::StateType state) const;
  void set_text(Gtk::StateType state, const Gdk::Color& color);
  Gdk::Color get_text(Gtk::StateType state) const;
  void set_base(Gtk::StateType state, const Gdk::Color& color);
  Gdk::Color get_base(Gtk::StateType state) const;
  void set_text_aa(Gtk::StateType state, const Gdk::Color& color);
  Gdk::Color get_text_aa(Gtk::StateType state) const;
   void set_black(const Gdk::Color& value);
    Gdk::Color get_black() const;
    void set_white(const Gdk::Color& value);
    Gdk::Color get_white() const;
  void set_font(const Pango::FontDescription& font_desc);
  Pango::FontDescription get_font() const;
  void set_xthickness(int xthickness);
   int get_xthickness() const;
  void set_ythickness(int ythickness);
   int get_ythickness() const;
  Glib::RefPtr<Gdk::GC> get_fg_gc(Gtk::StateType state_type);
  Glib::RefPtr<const Gdk::GC> get_fg_gc(Gtk::StateType state_type) const;
  Glib::RefPtr<Gdk::GC> get_bg_gc(Gtk::StateType state_type);
  Glib::RefPtr<const Gdk::GC> get_bg_gc(Gtk::StateType state_type) const;
  Glib::RefPtr<Gdk::GC> get_light_gc(Gtk::StateType state_type);
  Glib::RefPtr<const Gdk::GC> get_light_gc(Gtk::StateType state_type) const;
  Glib::RefPtr<Gdk::GC> get_dark_gc(Gtk::StateType state_type);
  Glib::RefPtr<const Gdk::GC> get_dark_gc(Gtk::StateType state_type) const;
  Glib::RefPtr<Gdk::GC> get_mid_gc ( Gtk::StateType state_type);
  Glib::RefPtr<const Gdk::GC> get_mid_gc ( Gtk::StateType state_type) const;
  Glib::RefPtr<Gdk::GC> get_text_gc(Gtk::StateType state_type);
  Glib::RefPtr<const Gdk::GC> get_text_gc(Gtk::StateType state_type) const;
  Glib::RefPtr<Gdk::GC> get_base_gc(Gtk::StateType state_type);
  Glib::RefPtr<const Gdk::GC> get_base_gc(Gtk::StateType state_type) const;
   Glib::RefPtr<Gdk::GC> get_black_gc();
  Glib::RefPtr<const Gdk::GC> get_black_gc() const;
    Glib::RefPtr<Gdk::GC> get_white_gc();
  Glib::RefPtr<const Gdk::GC> get_white_gc() const;
  Gdk::Color get_background(Gtk::StateType state_type) const;
  Glib::RefPtr<Gdk::Pixmap> get_background_pixmap(Gtk::StateType state_type);
  void set_bg_pixmap(Gtk::StateType state_type, const Glib::RefPtr<Gdk::Pixmap>& pixmap);
  void set_bg_pixmap(Gtk::StateType state_type, const Glib::RefPtr<const Gdk::Pixmap>& pixmap);
  Glib::RefPtr<Gdk::Pixmap> get_bg_pixmap(Gtk::StateType state_type);
  Glib::RefPtr<const Gdk::Pixmap> get_bg_pixmap(Gtk::StateType state_type) const;
  void paint_arrow(
                  const Glib::RefPtr<Gdk::Window>& window,
                  Gtk::StateType state_type,
                  ShadowType shadow_type,
                  const Gdk::Rectangle& area,
                  Widget& widget,
                  const Glib::ustring& detail,
                  ArrowType arrow_type,
                  bool fill,
                  int x,
                  int y,
                  int width,
                  int height) const;
  void paint_box(
                  const Glib::RefPtr<Gdk::Window>& window,
                  Gtk::StateType state_type,
                  ShadowType shadow_type,
                  const Gdk::Rectangle& area,
                  Widget& widget,
                  const Glib::ustring& detail,
                  int x,
                  int y,
                  int width,
                  int height) const;
  void paint_box_gap(
                  const Glib::RefPtr<Gdk::Window>& window,
                  Gtk::StateType state_type,
                  ShadowType shadow_type,
                  const Gdk::Rectangle& area,
                  Widget& widget,
                  const Glib::ustring& detail,
                  int x,
                  int y,
                  int width,
                  int height,
                  PositionType gap_side,
                  int gap_x,
                  int gap_width) const;
  void paint_check(
                  const Glib::RefPtr<Gdk::Window>& window,
                  Gtk::StateType state_type,
                  ShadowType shadow_type,
                  const Gdk::Rectangle& area,
                  Widget& widget,
                  const Glib::ustring& detail,
                  int x,
                  int y,
                  int width,
                  int height) const;
  void paint_diamond(
                  const Glib::RefPtr<Gdk::Window>& window,
                  Gtk::StateType state_type,
                  ShadowType shadow_type,
                  const Gdk::Rectangle& area,
                  Widget& widget,
                  const Glib::ustring& detail,
                  int x,
                  int y,
                  int width,
                  int height) const;
  void paint_extension(
                  const Glib::RefPtr<Gdk::Window>& window,
                  Gtk::StateType state_type,
                  ShadowType shadow_type,
                  const Gdk::Rectangle& area,
                  Widget& widget,
                  const Glib::ustring& detail,
                  int x,
                  int y,
                  int width,
                  int height,
                  PositionType gap_side) const;
  void paint_flat_box(
                  const Glib::RefPtr<Gdk::Window>& window,
                  Gtk::StateType state_type,
                  ShadowType shadow_type,
                  const Gdk::Rectangle& area,
                  Widget& widget,
                  const Glib::ustring& detail,
                  int x,
                  int y,
                  int width,
                  int height) const;
  void paint_focus(
                  const Glib::RefPtr<Gdk::Window>& window,
                  Gtk::StateType state_type,
                  const Gdk::Rectangle& area,
                  Widget& widget,
                  const Glib::ustring& detail,
                  int x,
                  int y,
                  int width,
                  int height) const;
  void paint_handle(
                  const Glib::RefPtr<Gdk::Window>& window,
                  Gtk::StateType state_type,
                  ShadowType shadow_type,
                  const Gdk::Rectangle& area,
                  Widget& widget,
                  const Glib::ustring& detail,
                  int x,
                  int y,
                  int width,
                  int height,
                  Orientation orientation) const;
  void paint_hline(
                  const Glib::RefPtr<Gdk::Window>& window,
                  Gtk::StateType state_type,
                  const Gdk::Rectangle& area,
                  Widget& widget,
                  const Glib::ustring& detail,
                  int x1,
                  int x2,
                  int y) const;
  void paint_option(
                  const Glib::RefPtr<Gdk::Window>& window,
                  Gtk::StateType state_type,
                  ShadowType shadow_type,
                  const Gdk::Rectangle& area,
                  Widget& widget,
                  const Glib::ustring& detail,
                  int x,
                  int y,
                  int width,
                  int height) const;
  void paint_polygon(
                  const Glib::RefPtr<Gdk::Window>& window,
                  Gtk::StateType state_type,
                  ShadowType shadow_type,
                  const Gdk::Rectangle& area,
                  Widget& widget,
                  const Glib::ustring& detail,
                  const Glib::ArrayHandle<Gdk::Point>& points,
                  bool fill) const;
  void paint_shadow(
                  const Glib::RefPtr<Gdk::Window>& window,
                  Gtk::StateType state_type,
                  ShadowType shadow_type,
                  const Gdk::Rectangle& area,
                  Widget& widget,
                  const Glib::ustring& detail,
                  int x,
                  int y,
                  int width,
                  int height) const;
  void paint_shadow_gap(
                  const Glib::RefPtr<Gdk::Window>& window,
                  Gtk::StateType state_type,
                  ShadowType shadow_type,
                  const Gdk::Rectangle& area,
                  Widget& widget,
                  const Glib::ustring& detail,
                  int x,
                  int y,
                  int width,
                  int height,
                  PositionType gap_side,
                  int gap_x,
                  int gap_width) const;
  void paint_slider(
                  const Glib::RefPtr<Gdk::Window>& window,
                  Gtk::StateType state_type,
                  ShadowType shadow_type,
                  const Gdk::Rectangle& area,
                  Widget& widget,
                  const Glib::ustring& detail,
                  int x,
                  int y,
                  int width,
                  int height,
                  Orientation orientation) const;
  void paint_tab(
                  const Glib::RefPtr<Gdk::Window>& window,
                  Gtk::StateType state_type,
                  ShadowType shadow_type,
                  const Gdk::Rectangle& area,
                  Widget& widget,
                  const Glib::ustring& detail,
                  int x,
                  int y,
                  int width,
                  int height) const;
  void paint_vline(
                  const Glib::RefPtr<Gdk::Window>& window,
                  Gtk::StateType state_type,
                  const Gdk::Rectangle& area,
                  Widget& widget,
                  const Glib::ustring& detail,
                  int y1,
                  int y2,
                  int x) const;
  void paint_expander(
                  const Glib::RefPtr<Gdk::Window>& window,
                  Gtk::StateType state_type,
                  const Gdk::Rectangle& area,
                  Widget& widget,
                  const Glib::ustring& detail,
                  int x,
                  int y,
                  ExpanderStyle expander_style) const;
  void paint_layout(
                  const Glib::RefPtr<Gdk::Window>& window,
                  Gtk::StateType state_type,
                  bool use_text,
                  const Gdk::Rectangle& area,
                  Widget& widget,
                  const Glib::ustring& detail,
                  int x,
                  int y,
                  const Glib::RefPtr<Pango::Layout>& layout) const;
  void paint_resize_grip(
                  const Glib::RefPtr<Gdk::Window>& window,
                  Gtk::StateType state_type,
                  const Gdk::Rectangle& area,
                  Widget& widget,
                  const Glib::ustring& detail,
                  Gdk::WindowEdge edge,
                  int x,
                  int y,
                  int width,
                  int height) const;
  Glib::RefPtr<Style> copy();
  Glib::RefPtr<Style> attach(const Glib::RefPtr<Gdk::Window>& window);
  void detach();
  void set_background(const Glib::RefPtr<Gdk::Window>& window, Gtk::StateType state_type);
  void apply_default_background(const Glib::RefPtr<Gdk::Window>& window, bool set_bg,
               Gtk::StateType state_type, const Gdk::Rectangle& area,
               int x, int y, int width, int height);
  IconSet lookup_icon_set(const Gtk::StockID& stock_id);
  bool lookup_color(const Glib::ustring& color_name, Gdk::Color& color) const;
  Glib::RefPtr<Gdk::Pixbuf> render_icon(const IconSource& source,
                                       Gtk::TextDirection direction, Gtk::StateType state, Gtk::IconSize size,
                                       Gtk::Widget& widget, const Glib::ustring& detail);
protected:
  virtual void realize_vfunc();
  virtual void unrealize_vfunc();
  virtual void copy_vfunc(const Glib::RefPtr<Style>& src);
  virtual Glib::RefPtr<Style> clone_vfunc();
  virtual void init_from_rc_vfunc(const Glib::RefPtr<RcStyle>& rc_style);
  virtual void set_background_vfunc(const Glib::RefPtr<Gdk::Window>& window, Gtk::StateType state_type);
  virtual Glib::RefPtr<Gdk::Pixbuf> render_icon_vfunc(const IconSource& source, TextDirection direction, Gtk::StateType state, IconSize size, Widget* widget, const Glib::ustring& detail);
  virtual void draw_hline_vfunc(const Glib::RefPtr<Gdk::Window>& window, Gtk::StateType state_type, const Gdk::Rectangle& area, Widget* widget, const Glib::ustring& detail, int x1, int x2, int y);
  virtual void draw_vline_vfunc(const Glib::RefPtr<Gdk::Window>& window, Gtk::StateType state_type, const Gdk::Rectangle& area, Widget* widget, const Glib::ustring& detail, int y1, int y2, int x);
  virtual void draw_shadow_vfunc(const Glib::RefPtr<Gdk::Window>& window, Gtk::StateType state_type, ShadowType shadow_type, const Gdk::Rectangle& area, Widget* widget, const Glib::ustring& detail, int x, int y, int width, int height);
  virtual void draw_polygon_vfunc(const Glib::RefPtr<Gdk::Window>& window, Gtk::StateType state_type, ShadowType shadow_type, const Gdk::Rectangle& area, Widget* widget, const Glib::ustring& detail, GdkPoint* point, int npoints, bool fill);
  virtual void draw_arrow_vfunc(const Glib::RefPtr<Gdk::Window>& window, Gtk::StateType state_type, ShadowType shadow_type, const Gdk::Rectangle& area, Widget* widget, const Glib::ustring& detail, Gtk::ArrowType arrow_type, bool fill, int x, int y, int width, int height);
  virtual void draw_diamond_vfunc(const Glib::RefPtr<Gdk::Window>& window, Gtk::StateType state_type, ShadowType shadow_type, const Gdk::Rectangle& area, Widget* widget, const Glib::ustring& detail, int x, int y, int width, int height);
  virtual void draw_string_vfunc(const Glib::RefPtr<Gdk::Window>& window, Gtk::StateType state_type, const Gdk::Rectangle& area, Widget* widget, const Glib::ustring& detail, int x, int y, const Glib::ustring& string);
  virtual void draw_box_vfunc(const Glib::RefPtr<Gdk::Window>& window, Gtk::StateType state_type, ShadowType shadow_type, const Gdk::Rectangle& area, Widget* widget, const Glib::ustring& detail, int x, int y, int width, int height);
  virtual void draw_flat_box_vfunc(const Glib::RefPtr<Gdk::Window>& window, Gtk::StateType state_type, ShadowType shadow_type, const Gdk::Rectangle& area, Widget* widget, const Glib::ustring& detail, int x, int y, int width, int height);
  virtual void draw_check_vfunc(const Glib::RefPtr<Gdk::Window>& window, Gtk::StateType state_type, ShadowType shadow_type, const Gdk::Rectangle& area, Widget* widget, const Glib::ustring& detail, int x, int y, int width, int height);
  virtual void draw_option_vfunc(const Glib::RefPtr<Gdk::Window>& window, Gtk::StateType state_type, ShadowType shadow_type, const Gdk::Rectangle& area, Widget* widget, const Glib::ustring& detail, int x, int y, int width, int height);
  virtual void draw_tab_vfunc(const Glib::RefPtr<Gdk::Window>& window, Gtk::StateType state_type, ShadowType shadow_type, const Gdk::Rectangle& area, Widget* widget, const Glib::ustring& detail, int x, int y, int width, int height);
  virtual void draw_shadow_gap_vfunc(const Glib::RefPtr<Gdk::Window>& window, Gtk::StateType state_type, ShadowType shadow_type, const Gdk::Rectangle& area, Widget* widget, const Glib::ustring& detail, int x, int y, int width, int height, Gtk::PositionType gap_side, int gap_x, int gap_width);
  virtual void draw_box_gap_vfunc(const Glib::RefPtr<Gdk::Window>& window, Gtk::StateType state_type, ShadowType shadow_type, const Gdk::Rectangle& area, Widget* widget, const Glib::ustring& detail, int x, int y, int width, int height, Gtk::PositionType gap_side, int gap_x, int gap_width);
  virtual void draw_extension_vfunc(const Glib::RefPtr<Gdk::Window>& window, Gtk::StateType state_type, ShadowType shadow_type, const Gdk::Rectangle& area, Widget* widget, const Glib::ustring& detail, int x, int y, int width, int height, PositionType gap_side);
  virtual void draw_focus_vfunc(const Glib::RefPtr<Gdk::Window>& window, Gtk::StateType state_type, const Gdk::Rectangle& area, Widget* widget, const Glib::ustring& detail, int x, int y, int width, int height);
  virtual void draw_slider_vfunc(const Glib::RefPtr<Gdk::Window>& window, Gtk::StateType state_type, ShadowType shadow_type, const Gdk::Rectangle& area, Widget* widget, const Glib::ustring& detail, int x, int y, int width, int height, Orientation orientation);
  virtual void draw_handle_vfunc(const Glib::RefPtr<Gdk::Window>& window, Gtk::StateType state_type, ShadowType shadow_type, const Gdk::Rectangle& area, Widget* widget, const Glib::ustring& detail, int x, int y, int width, int height, Orientation orientation);
  virtual void draw_expander_vfunc(const Glib::RefPtr<Gdk::Window>& window, Gtk::StateType state_type, const Gdk::Rectangle& area, Widget* widget, const Glib::ustring& detail, int x, int y, ExpanderStyle expander_style);
  virtual void draw_layout_vfunc(const Glib::RefPtr<Gdk::Window>& window, Gtk::StateType state_type, bool use_text, const Gdk::Rectangle& area, Widget* widget, const Glib::ustring& detail, int x, int y, const Glib::RefPtr<Pango::Layout>& layout);
  virtual void draw_resize_grip_vfunc(const Glib::RefPtr<Gdk::Window>& window, Gtk::StateType state_type, const Gdk::Rectangle& area, Widget* widget, const Glib::ustring& detail, Gdk::WindowEdge edge, int x, int y, int width, int height);
  Glib::SignalProxy0< void > signal_realize();
  Glib::SignalProxy0< void > signal_unrealize();
public:
public:
protected:
  virtual void on_realize();
  virtual void on_unrealize();
};
}
namespace Glib
{
  Glib::RefPtr<Gtk::Style> wrap(GtkStyle* object, bool take_copy = false);
}
typedef struct _GtkRcStyle GtkRcStyle;
typedef struct _GtkRcStyleClass GtkRcStyleClass;
namespace Gtk
{ class RcStyle_Class; }
namespace Gtk
{
class Widget;
class Settings;
class Style;
enum RcFlags
{
  RC_FG = 1 << 0,
  RC_BG = 1 << 1,
  RC_TEXT = 1 << 2,
  RC_BASE = 1 << 3
};
inline RcFlags operator|(RcFlags lhs, RcFlags rhs)
  { return static_cast<RcFlags>(static_cast<unsigned>(lhs) | static_cast<unsigned>(rhs)); }
inline RcFlags operator&(RcFlags lhs, RcFlags rhs)
  { return static_cast<RcFlags>(static_cast<unsigned>(lhs) & static_cast<unsigned>(rhs)); }
inline RcFlags operator^(RcFlags lhs, RcFlags rhs)
  { return static_cast<RcFlags>(static_cast<unsigned>(lhs) ^ static_cast<unsigned>(rhs)); }
inline RcFlags operator~(RcFlags flags)
  { return static_cast<RcFlags>(~static_cast<unsigned>(flags)); }
inline RcFlags& operator|=(RcFlags& lhs, RcFlags rhs)
  { return (lhs = static_cast<RcFlags>(static_cast<unsigned>(lhs) | static_cast<unsigned>(rhs))); }
inline RcFlags& operator&=(RcFlags& lhs, RcFlags rhs)
  { return (lhs = static_cast<RcFlags>(static_cast<unsigned>(lhs) & static_cast<unsigned>(rhs))); }
inline RcFlags& operator^=(RcFlags& lhs, RcFlags rhs)
  { return (lhs = static_cast<RcFlags>(static_cast<unsigned>(lhs) ^ static_cast<unsigned>(rhs))); }
}
namespace Glib
{
template <>
class Value<Gtk::RcFlags> : public Glib::Value_Flags<Gtk::RcFlags>
{
public:
  static GType value_type() __attribute__((__const__));
};
}
namespace Gtk
{
class RcStyle : public Glib::Object
{
public:
  typedef RcStyle CppObjectType;
  typedef RcStyle_Class CppClassType;
  typedef GtkRcStyle BaseObjectType;
  typedef GtkRcStyleClass BaseClassType;
private: friend class RcStyle_Class;
  static CppClassType rcstyle_class_;
private:
  RcStyle(const RcStyle&);
  RcStyle& operator=(const RcStyle&);
protected:
  explicit RcStyle(const Glib::ConstructParams& construct_params);
  explicit RcStyle(GtkRcStyle* castitem);
public:
  virtual ~RcStyle();
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkRcStyle* gobj() { return reinterpret_cast<GtkRcStyle*>(gobject_); }
  const GtkRcStyle* gobj() const { return reinterpret_cast<GtkRcStyle*>(gobject_); }
  GtkRcStyle* gobj_copy();
private:
protected:
  RcStyle();
public:
  static Glib::RefPtr<RcStyle> create();
  Glib::RefPtr<RcStyle> copy() const;
  void set_name(const Glib::ustring& name);
   Glib::ustring get_name() const;
  void set_bg_pixmap_name(Gtk::StateType state, const Glib::ustring& name);
  Glib::ustring get_bg_pixmap_name(Gtk::StateType state) const;
  void set_font(const Pango::FontDescription& font_desc);
  Pango::FontDescription get_font() const;
  void set_color_flags(Gtk::StateType state, RcFlags flags);
  void unset_color_flags(Gtk::StateType state, RcFlags flags);
  RcFlags get_color_flags(Gtk::StateType state) const;
  void set_fg(Gtk::StateType state, const Gdk::Color& color);
  Gdk::Color get_fg(Gtk::StateType state) const;
  void set_bg(Gtk::StateType state, const Gdk::Color& color);
  Gdk::Color get_bg(Gtk::StateType state) const;
  void set_text(Gtk::StateType state, const Gdk::Color& color);
  Gdk::Color get_text(Gtk::StateType state) const;
  void set_base(Gtk::StateType state, const Gdk::Color& color);
  Gdk::Color get_base(Gtk::StateType state) const;
  void set_xthickness(int xthickness);
   int get_xthickness() const;
  void set_ythickness(int ythickness);
   int get_ythickness() const;
public:
public:
protected:
};
class RC
{
public:
  explicit RC(const Glib::ustring& filename);
  static Glib::RefPtr<Style> get_style(const Widget& widget);
  static void parse_string(const Glib::ustring &rc_string);
  static void add_default_file(const Glib::ustring& filename);
  static void set_default_files(const Glib::StringArrayHandle& filenames);
  static Glib::StringArrayHandle get_default_files();
  static bool reparse_all();
  static bool reparse_all(const Glib::RefPtr<Settings>& settings, bool force_load = true);
  static void reset_styles(const Glib::RefPtr<Settings>& settings);
  static Glib::ustring find_pixmap_in_path(const Glib::RefPtr<Settings>& settings, GScanner* scanner, const Glib::ustring& pixmap_file);
  static Glib::ustring find_pixmap_in_path(const Glib::RefPtr<Settings>& settings, const Glib::ustring& pixmap_file);
  static Glib::ustring find_module_in_path(const Glib::ustring& pixmap_file);
  static Glib::ustring get_theme_dir();
  static Glib::ustring get_module_dir();
};
}
namespace Glib
{
  Glib::RefPtr<Gtk::RcStyle> wrap(GtkRcStyle* object, bool take_copy = false);
}
extern "C" { typedef struct _GtkSelectionData GtkSelectionData; }
namespace Gtk
{
class TextBuffer;
class SelectionData
{
  public:
  typedef SelectionData CppObjectType;
  typedef GtkSelectionData BaseObjectType;
  static GType get_type() __attribute__((__const__));
  SelectionData();
  explicit SelectionData(GtkSelectionData* gobject, bool make_a_copy = true);
  SelectionData(const SelectionData& other);
  SelectionData& operator=(const SelectionData& other);
  ~SelectionData();
  void swap(SelectionData& other);
  GtkSelectionData* gobj() { return gobject_; }
  const GtkSelectionData* gobj() const { return gobject_; }
  GtkSelectionData* gobj_copy() const;
protected:
  GtkSelectionData* gobject_;
private:
public:
  void set(int format, const guint8* data, int length);
  void set(const std::string& type, int format, const guint8* data, int length);
  void set(const std::string& type, const std::string& data);
  bool set_text(const Glib::ustring& data);
  Glib::ustring get_text() const;
  bool set_pixbuf(const Glib::RefPtr<Gdk::Pixbuf>& pixbuf);
  Glib::RefPtr<Gdk::Pixbuf> get_pixbuf();
  Glib::RefPtr<const Gdk::Pixbuf> get_pixbuf() const;
  bool set_uris(const Glib::StringArrayHandle& uris);
  Glib::StringArrayHandle get_uris() const;
   const guint8* get_data() const;
    int get_length() const;
  std::string get_data_as_string() const;
  std::string get_target() const;
  Gdk::ArrayHandle_AtomString get_targets() const;
   GdkAtom get_selection() const;
  std::string get_data_type() const;
   int get_format() const;
    Glib::RefPtr<Gdk::Display> get_display();
  Glib::RefPtr<const Gdk::Display> get_display() const;
  bool targets_include_uri() const;
  bool targets_include_text() const;
  bool targets_include_rich_text(const Glib::RefPtr<TextBuffer>& buffer) const;
  bool targets_include_image(bool writable = true) const;
};
}
namespace Gtk
{
inline void swap(SelectionData& lhs, SelectionData& rhs)
  { lhs.swap(rhs); }
}
namespace Glib
{
Gtk::SelectionData wrap(GtkSelectionData* object, bool take_copy = false);
template <>
class Value<Gtk::SelectionData> : public Glib::Value_Boxed<Gtk::SelectionData>
{};
}
typedef struct _GtkClipboard GtkClipboard;
typedef struct _GtkClipboardClass GtkClipboardClass;
namespace Gtk
{ class Clipboard_Class; }
namespace Gtk
{
class TextBuffer;
class Clipboard : public Glib::Object
{
public:
  typedef Clipboard CppObjectType;
  typedef Clipboard_Class CppClassType;
  typedef GtkClipboard BaseObjectType;
  typedef GtkClipboardClass BaseClassType;
private: friend class Clipboard_Class;
  static CppClassType clipboard_class_;
private:
  Clipboard(const Clipboard&);
  Clipboard& operator=(const Clipboard&);
protected:
  explicit Clipboard(const Glib::ConstructParams& construct_params);
  explicit Clipboard(GtkClipboard* castitem);
public:
  virtual ~Clipboard();
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkClipboard* gobj() { return reinterpret_cast<GtkClipboard*>(gobject_); }
  const GtkClipboard* gobj() const { return reinterpret_cast<GtkClipboard*>(gobject_); }
  GtkClipboard* gobj_copy();
private:
public:
  static Glib::RefPtr<Clipboard> get(GdkAtom selection = ((GdkAtom)((gpointer) (69))));
  static Glib::RefPtr<Clipboard> get_for_display(const Glib::RefPtr<Gdk::Display>& display, GdkAtom selection = ((GdkAtom)((gpointer) (69))));
  Glib::RefPtr<Gdk::Display> get_display();
  Glib::RefPtr<const Gdk::Display> get_display() const;
  typedef sigc::slot<void, SelectionData&, guint> SlotGet;
  typedef sigc::slot<void> SlotClear;
  bool set(const ArrayHandle_TargetEntry& targets, const SlotGet& slot_get, const SlotClear& slot_clear);
  Glib::RefPtr<Glib::Object> get_owner();
  Glib::RefPtr<const Glib::Object> get_owner() const;
  void clear();
  void set_text(const Glib::ustring& text);
  void set_image(const Glib::RefPtr<Gdk::Pixbuf>& pixbuf);
  typedef sigc::slot<void, const SelectionData&> SlotReceived;
  void request_contents(const Glib::ustring& target, const SlotReceived& slot);
  typedef sigc::slot<void, const Glib::ustring&> SlotTextReceived;
  void request_text(const SlotTextReceived& slot);
  typedef sigc::slot<void, const Glib::ustring& , const std::string&> SlotRichTextReceived;
  void request_rich_text(const Glib::RefPtr<TextBuffer>& buffer, const SlotRichTextReceived& slot);
  typedef sigc::slot<void, const Glib::RefPtr<Gdk::Pixbuf>&> SlotImageReceived;
  void request_image(const SlotImageReceived& slot);
  typedef sigc::slot<void, const Glib::StringArrayHandle&> SlotTargetsReceived;
  void request_targets(const SlotTargetsReceived& slot);
  SelectionData wait_for_contents(const Glib::ustring& target) const;
  Glib::ustring wait_for_text() const;
  std::string wait_for_rich_text(const Glib::RefPtr<TextBuffer>& buffer, std::string& format);
  Glib::RefPtr<Gdk::Pixbuf> wait_for_image() const;
  bool wait_is_text_available() const;
  bool wait_is_rich_text_available(const Glib::RefPtr<TextBuffer>& buffer) const;
  bool wait_is_image_available() const;
  bool wait_is_target_available(const Glib::ustring& target);
  Glib::StringArrayHandle wait_for_targets() const;
  void set_can_store(const ArrayHandle_TargetEntry& targets);
  void set_can_store();
  void store();
  Glib::SignalProxy1< void,GdkEventOwnerChange* > signal_owner_change();
public:
public:
protected:
};
}
namespace Glib
{
  Glib::RefPtr<Gtk::Clipboard> wrap(GtkClipboard* object, bool take_copy = false);
}
extern "C"
{
typedef struct _GtkTargetEntry GtkTargetEntry;
}
typedef struct _GtkWidget GtkWidget;
typedef struct _GtkWidgetClass GtkWidgetClass;
namespace Gtk
{ class Widget_Class; }
namespace Gtk
{
enum DestDefaults
{
  DEST_DEFAULT_MOTION = 1 << 0,
  DEST_DEFAULT_HIGHLIGHT = 1 << 1,
  DEST_DEFAULT_DROP = 1 << 2,
  DEST_DEFAULT_ALL = 0x07
};
inline DestDefaults operator|(DestDefaults lhs, DestDefaults rhs)
  { return static_cast<DestDefaults>(static_cast<unsigned>(lhs) | static_cast<unsigned>(rhs)); }
inline DestDefaults operator&(DestDefaults lhs, DestDefaults rhs)
  { return static_cast<DestDefaults>(static_cast<unsigned>(lhs) & static_cast<unsigned>(rhs)); }
inline DestDefaults operator^(DestDefaults lhs, DestDefaults rhs)
  { return static_cast<DestDefaults>(static_cast<unsigned>(lhs) ^ static_cast<unsigned>(rhs)); }
inline DestDefaults operator~(DestDefaults flags)
  { return static_cast<DestDefaults>(~static_cast<unsigned>(flags)); }
inline DestDefaults& operator|=(DestDefaults& lhs, DestDefaults rhs)
  { return (lhs = static_cast<DestDefaults>(static_cast<unsigned>(lhs) | static_cast<unsigned>(rhs))); }
inline DestDefaults& operator&=(DestDefaults& lhs, DestDefaults rhs)
  { return (lhs = static_cast<DestDefaults>(static_cast<unsigned>(lhs) & static_cast<unsigned>(rhs))); }
inline DestDefaults& operator^=(DestDefaults& lhs, DestDefaults rhs)
  { return (lhs = static_cast<DestDefaults>(static_cast<unsigned>(lhs) ^ static_cast<unsigned>(rhs))); }
}
namespace Glib
{
template <>
class Value<Gtk::DestDefaults> : public Glib::Value_Flags<Gtk::DestDefaults>
{
public:
  static GType value_type() __attribute__((__const__));
};
}
namespace Gtk
{
enum WidgetFlags
{
  TOPLEVEL = 1 << 4,
  NO_WINDOW = 1 << 5,
  REALIZED = 1 << 6,
  MAPPED = 1 << 7,
  VISIBLE = 1 << 8,
  SENSITIVE = 1 << 9,
  PARENT_SENSITIVE = 1 << 10,
  CAN_FOCUS = 1 << 11,
  HAS_FOCUS = 1 << 12,
  CAN_DEFAULT = 1 << 13,
  HAS_DEFAULT = 1 << 14,
  HAS_GRAB = 1 << 15,
  RC_STYLE = 1 << 16,
  COMPOSITE_CHILD = 1 << 17,
  NO_REPARENT = 1 << 18,
  APP_PAINTABLE = 1 << 19,
  RECEIVES_DEFAULT = 1 << 20,
  DOUBLE_BUFFERED = 1 << 21,
  NO_SHOW_ALL = 1 << 22
};
inline WidgetFlags operator|(WidgetFlags lhs, WidgetFlags rhs)
  { return static_cast<WidgetFlags>(static_cast<unsigned>(lhs) | static_cast<unsigned>(rhs)); }
inline WidgetFlags operator&(WidgetFlags lhs, WidgetFlags rhs)
  { return static_cast<WidgetFlags>(static_cast<unsigned>(lhs) & static_cast<unsigned>(rhs)); }
inline WidgetFlags operator^(WidgetFlags lhs, WidgetFlags rhs)
  { return static_cast<WidgetFlags>(static_cast<unsigned>(lhs) ^ static_cast<unsigned>(rhs)); }
inline WidgetFlags operator~(WidgetFlags flags)
  { return static_cast<WidgetFlags>(~static_cast<unsigned>(flags)); }
inline WidgetFlags& operator|=(WidgetFlags& lhs, WidgetFlags rhs)
  { return (lhs = static_cast<WidgetFlags>(static_cast<unsigned>(lhs) | static_cast<unsigned>(rhs))); }
inline WidgetFlags& operator&=(WidgetFlags& lhs, WidgetFlags rhs)
  { return (lhs = static_cast<WidgetFlags>(static_cast<unsigned>(lhs) & static_cast<unsigned>(rhs))); }
inline WidgetFlags& operator^=(WidgetFlags& lhs, WidgetFlags rhs)
  { return (lhs = static_cast<WidgetFlags>(static_cast<unsigned>(lhs) ^ static_cast<unsigned>(rhs))); }
}
namespace Glib
{
template <>
class Value<Gtk::WidgetFlags> : public Glib::Value_Flags<Gtk::WidgetFlags>
{
public:
  static GType value_type() __attribute__((__const__));
};
}
namespace Gtk
{
enum WidgetHelpType
{
  WIDGET_HELP_TOOLTIP,
  WIDGET_HELP_WHATS_THIS
};
}
namespace Glib
{
template <>
class Value<Gtk::WidgetHelpType> : public Glib::Value_Enum<Gtk::WidgetHelpType>
{
public:
  static GType value_type() __attribute__((__const__));
};
}
namespace Gtk
{
class Action;
class Style;
class AccelGroup;
class Adjustment;
class Window;
class Container;
class Settings;
class Tooltip;
typedef GtkRequisition Requisition;
typedef Gdk::Rectangle Allocation;
class Widget
: public Object
{
  public:
  typedef Widget CppObjectType;
  typedef Widget_Class CppClassType;
  typedef GtkWidget BaseObjectType;
  typedef GtkWidgetClass BaseClassType;
  virtual ~Widget();
private:
  friend class Widget_Class;
  static CppClassType widget_class_;
  Widget(const Widget&);
  Widget& operator=(const Widget&);
protected:
  explicit Widget(const Glib::ConstructParams& construct_params);
  explicit Widget(GtkWidget* castitem);
public:
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkWidget* gobj() { return reinterpret_cast<GtkWidget*>(gobject_); }
  const GtkWidget* gobj() const { return reinterpret_cast<GtkWidget*>(gobject_); }
public:
protected:
  virtual void on_show();
  virtual void on_hide();
  virtual void on_map();
  virtual void on_unmap();
  virtual void on_realize();
  virtual void on_unrealize();
  virtual void on_size_request(Requisition* requisition);
  virtual void on_size_allocate(Allocation& allocation);
  virtual void on_state_changed(Gtk::StateType previous_state);
  virtual void on_parent_changed(Widget* previous_parent);
  virtual void on_hierarchy_changed(Widget* previous_toplevel);
  virtual void on_style_changed(const Glib::RefPtr<Style>& previous_style);
  virtual void on_direction_changed(TextDirection direction);
  virtual void on_grab_notify(bool was_grabbed);
  virtual void on_child_notify(GParamSpec* pspec);
  virtual bool on_mnemonic_activate(bool group_cycling);
  virtual void on_grab_focus();
  virtual bool on_focus(DirectionType direction);
  virtual bool on_event(GdkEvent* event);
  virtual bool on_button_press_event(GdkEventButton* event);
  virtual bool on_button_release_event(GdkEventButton* event);
  virtual bool on_scroll_event(GdkEventScroll* event);
  virtual bool on_motion_notify_event(GdkEventMotion* event);
  virtual bool on_delete_event(GdkEventAny* event);
  virtual bool on_expose_event(GdkEventExpose* event);
  virtual bool on_key_press_event(GdkEventKey* event);
  virtual bool on_key_release_event(GdkEventKey* event);
  virtual bool on_enter_notify_event(GdkEventCrossing* event);
  virtual bool on_leave_notify_event(GdkEventCrossing* event);
  virtual bool on_configure_event(GdkEventConfigure* event);
  virtual bool on_focus_in_event(GdkEventFocus* event);
  virtual bool on_focus_out_event(GdkEventFocus* event);
  virtual bool on_map_event(GdkEventAny* event);
  virtual bool on_unmap_event(GdkEventAny* event);
  virtual bool on_property_notify_event(GdkEventProperty* event);
  virtual bool on_selection_clear_event(GdkEventSelection* event);
  virtual bool on_selection_request_event(GdkEventSelection* event);
  virtual bool on_selection_notify_event(GdkEventSelection* event);
  virtual bool on_proximity_in_event(GdkEventProximity* event);
  virtual bool on_proximity_out_event(GdkEventProximity* event);
  virtual bool on_visibility_notify_event(GdkEventVisibility* event);
  virtual bool on_client_event(GdkEventClient* event);
  virtual bool on_no_expose_event(GdkEventAny* event);
  virtual bool on_window_state_event(GdkEventWindowState* event);
  virtual void on_selection_get(SelectionData& selection_data, guint info, guint time);
  virtual void on_selection_received(const SelectionData& selection_data, guint time);
  virtual void on_drag_begin(const Glib::RefPtr<Gdk::DragContext>& context);
  virtual void on_drag_end(const Glib::RefPtr<Gdk::DragContext>& context);
  virtual void on_drag_data_get(const Glib::RefPtr<Gdk::DragContext>& context, SelectionData& selection_data, guint info, guint time);
  virtual void on_drag_data_delete(const Glib::RefPtr<Gdk::DragContext>& context);
  virtual void on_drag_leave(const Glib::RefPtr<Gdk::DragContext>& context, guint time);
  virtual bool on_drag_motion(const Glib::RefPtr<Gdk::DragContext>& context, int x, int y, guint time);
  virtual bool on_drag_drop(const Glib::RefPtr<Gdk::DragContext>& context, int x, int y, guint time);
  virtual void on_drag_data_received(const Glib::RefPtr<Gdk::DragContext>& context, int x, int y, const SelectionData& selection_data, guint info, guint time);
  virtual void on_screen_changed(const Glib::RefPtr<Gdk::Screen>& previous_screen);
private:
public:
  friend class Main;
  bool set_scroll_adjustments(Adjustment& hadjustment, Adjustment& vadjustment);
  void show();
  void show_now();
  void hide();
  void show_all();
  void hide_all();
  void queue_draw();
  void queue_draw_area(int x, int y, int width, int height);
  void queue_resize();
  Requisition size_request() const;
  void size_request(const Requisition& requisition);
  void size_allocate(const Allocation& allocation);
  void add_accelerator(const Glib::ustring& accel_signal, const Glib::RefPtr<AccelGroup>& accel_group,
               guint accel_key, Gdk::ModifierType accel_mods, AccelFlags accel_flags);
  bool remove_accelerator(const Glib::RefPtr<AccelGroup>& accel_group,
               guint accel_key, Gdk::ModifierType accel_mods);
  void set_accel_path(const Glib::ustring& accel_path,
                                   const Glib::RefPtr<AccelGroup>& accel_group);
  bool mnemonic_activate(bool group_cycling);
  bool event(GdkEvent* event);
  int send_expose(GdkEvent* event);
  bool activate();
  void reparent(Widget & new_parent);
  bool intersect(const Gdk::Rectangle& area) const;
  bool intersect(const Gdk::Rectangle& area, Gdk::Rectangle& intersection) const;
  Gdk::Region region_intersect(const Gdk::Region& region) const;
  void freeze_child_notify();
  void child_notify(const Glib::ustring& child_property);
  void thaw_child_notify();
  bool is_focus() const;
  void grab_focus();
  void grab_default();
  void add_modal_grab();
  void remove_modal_grab();
  static Widget* get_current_modal_grab();
  void set_name(const Glib::ustring& name);
  void unset_name();
  Glib::ustring get_name() const;
  void set_state(Gtk::StateType state);
  void set_sensitive(bool sensitive = true);
  void set_app_paintable(bool app_paintable = true);
  void set_double_buffered(bool double_buffered = true);
  void set_redraw_on_allocate(bool redraw_on_allocate = true);
  void set_child_visible(bool is_visible = true);
  bool get_child_visible() const;
  Container* get_parent();
  const Container* get_parent() const;
  Glib::RefPtr<Gdk::Window> get_parent_window();
  Glib::RefPtr<const Gdk::Window> get_parent_window() const;
  void set_parent_window(const Glib::RefPtr<const Gdk::Window>& parent_window);
  bool child_focus(DirectionType direction);
  bool keynav_failed(DirectionType direction);
  void error_bell();
  void set_size_request(int width = -1, int height = -1);
  void get_size_request(int& width, int& height) const;
  void set_events(Gdk::EventMask events);
  void add_events(Gdk::EventMask events);
  void set_extension_events(Gdk::ExtensionMode mode);
  Gdk::ExtensionMode get_extension_events() const;
  Container* get_toplevel();
  const Container* get_toplevel() const;
  Widget* get_ancestor(GType widget_type);
  const Widget* get_ancestor(GType widget_type) const;
  Glib::RefPtr<Gdk::Colormap> get_colormap();
  Glib::RefPtr<Gdk::Visual> get_visual();
  Glib::RefPtr<Gdk::Screen> get_screen();
  Glib::RefPtr<const Gdk::Screen> get_screen() const;
  bool has_screen() const;
  Glib::RefPtr<Gdk::Display> get_display();
  Glib::RefPtr<const Gdk::Display> get_display() const;
  Glib::RefPtr<Gdk::Window> get_root_window();
  Glib::RefPtr<const Gdk::Window> get_root_window() const;
  Glib::RefPtr<Settings> get_settings();
  Glib::RefPtr<Clipboard> get_clipboard(const Glib::ustring& selection);
  Glib::RefPtr<const Clipboard> get_clipboard(const Glib::ustring& selection) const;
  void set_colormap(const Glib::RefPtr<const Gdk::Colormap> &colormap);
  Gdk::EventMask get_events() const;
  void get_pointer(int &x, int &y) const;
  bool is_ancestor(Widget &ancestor) const;
  bool translate_coordinates(Widget& dest_widget,
            int src_x, int src_y,
            int& dest_x, int& dest_y);
  void set_style(const Glib::RefPtr<Style>& style);
  void unset_style();
  void ensure_style();
  Glib::RefPtr<Style> get_style();
  Glib::RefPtr<const Style> get_style() const;
  void modify_style(const Glib::RefPtr<RcStyle>& style);
  Glib::RefPtr<RcStyle> get_modifier_style();
  Glib::RefPtr<const RcStyle> get_modifier_style() const;
  void modify_fg(StateType state, const Gdk::Color& color);
  void modify_bg(StateType state, const Gdk::Color& color);
  void modify_bg_pixmap(StateType state, const Glib::ustring& pixmap_name);
  void modify_text(StateType state, const Gdk::Color& color);
  void modify_base(StateType state, const Gdk::Color& color);
  void modify_cursor(const Gdk::Color& primary, const Gdk::Color& secondary);
  void unset_cursor();
  void modify_font(const Pango::FontDescription& font_desc);
  void unset_fg(StateType state);
  void unset_bg(StateType state);
  void unset_text(StateType state);
  void unset_base(StateType state);
  void unset_font();
  template <class PropertyType>
  void get_style_property(const Glib::ustring& the_property_name, PropertyType& value) const;
  Glib::RefPtr<Pango::Context> create_pango_context();
  Glib::RefPtr<Pango::Context> get_pango_context();
  Glib::RefPtr<Pango::Layout> create_pango_layout(const Glib::ustring& text);
  Glib::RefPtr<Gdk::Pixbuf> render_icon(const StockID& stock_id, IconSize size, const Glib::ustring& detail = Glib::ustring());
  void set_composite_name(const Glib::ustring& name);
  void unset_composite_name();
  Glib::ustring get_composite_name() const;
  void reset_rc_styles();
  static void push_colormap(const Glib::RefPtr<const Gdk::Colormap>& cmap);
  static void pop_colormap();
  static void push_composite_child();
  static void pop_composite_child();
  static void set_default_colormap(const Glib::RefPtr<const Gdk::Colormap>& colormap);
  static Glib::RefPtr<Style> get_default_style();
  static Glib::RefPtr<Gdk::Colormap> get_default_colormap();
  static Glib::RefPtr<Gdk::Visual> get_default_visual();
  void set_direction(TextDirection dir);
  TextDirection get_direction();
  static void set_default_direction(TextDirection dir);
  static TextDirection get_default_direction();
  void shape_combine_mask(const Glib::RefPtr<const Gdk::Bitmap>& shape_mask, int offset_x, int offset_y);
  void unset_shape_combine_mask();
  void input_shape_combine_mask(const Glib::RefPtr<const Gdk::Bitmap>& shape_mask, int offset_x, int offset_y);
  void unset_input_shape_combine_mask();
  void reset_shapes();
  void path(Glib::ustring& path, Glib::ustring& path_reversed);
  void class_path(Glib::ustring& path, Glib::ustring& path_reversed);
  Glib::ListHandle<Widget*> list_mnemonic_labels();
  Glib::ListHandle<const Widget*> list_mnemonic_labels() const;
  void add_mnemonic_label(Widget& label);
  void remove_mnemonic_label(Widget& label);
  void drag_get_data(const Glib::RefPtr<Gdk::DragContext>& context, Glib::ustring& target, guint32 time);
  void drag_highlight();
  void drag_unhighlight();
  void drag_dest_set(DestDefaults flags = DestDefaults(0), Gdk::DragAction actions = Gdk::DragAction(0));
  void drag_dest_set(const ArrayHandle_TargetEntry& targets, DestDefaults flags = DEST_DEFAULT_ALL, Gdk::DragAction actions = Gdk::ACTION_COPY);
  void drag_dest_set_proxy(const Glib::RefPtr<Gdk::Window>& proxy_window, Gdk::DragProtocol protocol, bool use_coordinates);
  void drag_dest_unset();
  Glib::ustring drag_dest_find_target(const Glib::RefPtr<Gdk::DragContext>& context, const Glib::RefPtr<TargetList>& target_list) const;
  Glib::ustring drag_dest_find_target(const Glib::RefPtr<Gdk::DragContext>& context) const;
  Glib::RefPtr<TargetList> drag_dest_get_target_list();
  Glib::RefPtr<const TargetList> drag_dest_get_target_list() const;
  void drag_dest_set_target_list(const Glib::RefPtr<TargetList>& target_list);
  void drag_dest_add_text_targets();
  void drag_dest_add_image_targets();
  void drag_dest_add_uri_targets();
  void drag_source_set(const ArrayHandle_TargetEntry& targets, Gdk::ModifierType start_button_mask = Gdk::MODIFIER_MASK, Gdk::DragAction actions = Gdk::ACTION_COPY);
  void drag_source_unset();
  void drag_source_set_icon(const Glib::RefPtr<Gdk::Colormap>& colormap, const Glib::RefPtr<Gdk::Pixmap>& pixmap, const Glib::RefPtr<Gdk::Bitmap>& mask);
  void drag_source_set_icon(const Glib::RefPtr<Gdk::Pixbuf>& pixbuf);
  void drag_source_set_icon(const StockID& stock_id);
  void drag_source_set_icon(const Glib::ustring& icon_name);
  void drag_source_add_text_targets();
  void drag_source_add_uri_targets();
  void drag_source_add_image_targets();
  Glib::RefPtr<Gdk::DragContext> drag_begin(const Glib::RefPtr<TargetList>& targets, Gdk::DragAction actions, int button, GdkEvent* event);
  bool drag_check_threshold(int start_x, int start_y, int current_x, int current_y);
  static Widget* drag_get_source_widget(const Glib::RefPtr<Gdk::DragContext>& context);
  void drag_set_as_icon(const Glib::RefPtr<Gdk::DragContext>& context, int hot_x, int hot_y);
  void queue_resize_no_redraw();
  bool get_no_show_all() const;
  void set_no_show_all(bool no_show_all = true);
  void set_parent(Widget& parent);
  void unparent();
  void map();
  void unmap();
  void draw_insertion_cursor(Glib::RefPtr<Gdk::Drawable> drawable, const Gdk::Rectangle& area, const Gdk::Rectangle& location, bool is_primary, TextDirection direction, bool draw_arrow = true);
  void set_tooltip_window(Window& widget);
  Window* get_tooltip_window();
  void trigger_tooltip_query();
  void set_tooltip_text(const Glib::ustring& text);
  Glib::ustring get_tooltip_text() const;
  void set_tooltip_markup(const Glib::ustring& markup);
  Glib::ustring get_tooltip_markup() const;
  void set_has_tooltip(bool has_tooltip = (!(0)));
  bool get_has_tooltip() const;
  bool is_toplevel() const;
  bool has_no_window() const;
  bool is_realized() const;
  bool is_mapped() const;
  bool is_visible() const;
  bool is_drawable() const;
  bool sensitive() const;
  bool parent_sensitive() const;
  bool is_sensitive() const;
  bool can_focus() const;
  bool has_focus() const;
  bool can_default() const;
  bool has_default() const;
  bool has_grab() const;
  bool rc_style() const;
  bool is_composite_child() const;
  bool app_paintable() const;
  bool receives_default() const;
  bool double_buffered() const;
  WidgetFlags get_flags() const;
  void set_flags(WidgetFlags flags);
  void unset_flags(WidgetFlags flags);
  int get_width() const;
  int get_height() const;
  bool is_composited() const;
  Glib::RefPtr<Action> get_action();
  Glib::RefPtr<const Action> get_action() const;
   Gtk::StateType get_state() const;
    Gtk::StateType get_saved_state() const;
    Requisition get_requisition() const;
    Allocation get_allocation() const;
    Glib::RefPtr<Gdk::Window> get_window();
  Glib::RefPtr<const Gdk::Window> get_window() const;
  Glib::SignalProxy0< void > signal_show();
  Glib::SignalProxy0< void > signal_hide();
  Glib::SignalProxy0< void > signal_map();
  Glib::SignalProxy0< void > signal_unmap();
  Glib::SignalProxy0< void > signal_realize();
  Glib::SignalProxy0< void > signal_unrealize();
  Glib::SignalProxy1< void,Requisition* > signal_size_request();
  Glib::SignalProxy1< void,Allocation& > signal_size_allocate();
  Glib::SignalProxy1< void,Gtk::StateType > signal_state_changed();
  Glib::SignalProxy1< void,Widget* > signal_parent_changed();
  Glib::SignalProxy1< void,Widget* > signal_hierarchy_changed();
  Glib::SignalProxy1< void,const Glib::RefPtr<Style>& > signal_style_changed();
  Glib::SignalProxy1< void,TextDirection > signal_direction_changed();
  Glib::SignalProxy1< void,bool > signal_grab_notify();
  Glib::SignalProxy1< void,GParamSpec* > signal_child_notify();
  Glib::SignalProxy1< bool,bool > signal_mnemonic_activate();
  Glib::SignalProxy0< void > signal_grab_focus();
  Glib::SignalProxy1< bool,DirectionType > signal_focus();
  Glib::SignalProxy1< bool,GdkEvent* > signal_event();
  Glib::SignalProxy1< void,GdkEvent* > signal_event_after();
  Glib::SignalProxy1< bool,GdkEventButton* > signal_button_press_event();
  Glib::SignalProxy1< bool,GdkEventButton* > signal_button_release_event();
  Glib::SignalProxy1< bool,GdkEventScroll* > signal_scroll_event();
  Glib::SignalProxy1< bool,GdkEventMotion* > signal_motion_notify_event();
  Glib::SignalProxy1< bool,GdkEventAny* > signal_delete_event();
  Glib::SignalProxy1< bool,GdkEventExpose* > signal_expose_event();
  Glib::SignalProxy1< bool,GdkEventKey* > signal_key_press_event();
  Glib::SignalProxy1< bool,GdkEventKey* > signal_key_release_event();
  Glib::SignalProxy1< bool,GdkEventCrossing* > signal_enter_notify_event();
  Glib::SignalProxy1< bool,GdkEventCrossing* > signal_leave_notify_event();
  Glib::SignalProxy1< bool,GdkEventConfigure* > signal_configure_event();
  Glib::SignalProxy1< bool,GdkEventFocus* > signal_focus_in_event();
  Glib::SignalProxy1< bool,GdkEventFocus* > signal_focus_out_event();
  Glib::SignalProxy1< bool,GdkEventAny* > signal_map_event();
  Glib::SignalProxy1< bool,GdkEventAny* > signal_unmap_event();
  Glib::SignalProxy1< bool,GdkEventProperty* > signal_property_notify_event();
  Glib::SignalProxy1< bool,GdkEventSelection* > signal_selection_clear_event();
  Glib::SignalProxy1< bool,GdkEventSelection* > signal_selection_request_event();
  Glib::SignalProxy1< bool,GdkEventSelection* > signal_selection_notify_event();
  Glib::SignalProxy1< bool,GdkEventProximity* > signal_proximity_in_event();
  Glib::SignalProxy1< bool,GdkEventProximity* > signal_proximity_out_event();
  Glib::SignalProxy1< bool,GdkEventVisibility* > signal_visibility_notify_event();
  Glib::SignalProxy1< bool,GdkEventClient* > signal_client_event();
  Glib::SignalProxy1< bool,GdkEventAny* > signal_no_expose_event();
  Glib::SignalProxy1< bool,GdkEventWindowState* > signal_window_state_event();
  Glib::SignalProxy3< void,SelectionData&,guint,guint > signal_selection_get();
  Glib::SignalProxy2< void,const SelectionData&,guint > signal_selection_received();
  Glib::SignalProxy1< void,const Glib::RefPtr<Gdk::DragContext>& > signal_drag_begin();
  Glib::SignalProxy1< void,const Glib::RefPtr<Gdk::DragContext>& > signal_drag_end();
  Glib::SignalProxy4< void,const Glib::RefPtr<Gdk::DragContext>&,SelectionData&,guint,guint > signal_drag_data_get();
  Glib::SignalProxy1< void,const Glib::RefPtr<Gdk::DragContext>& > signal_drag_data_delete();
  Glib::SignalProxy2< void,const Glib::RefPtr<Gdk::DragContext>&,guint > signal_drag_leave();
  Glib::SignalProxy4< bool,const Glib::RefPtr<Gdk::DragContext>&,int,int,guint > signal_drag_motion();
  Glib::SignalProxy4< bool,const Glib::RefPtr<Gdk::DragContext>&,int,int,guint > signal_drag_drop();
  Glib::SignalProxy6< void,const Glib::RefPtr<Gdk::DragContext>&,int,int,const SelectionData&,guint,guint > signal_drag_data_received();
  Glib::SignalProxy1< void,const Glib::RefPtr<Gdk::Screen>& > signal_screen_changed();
  Glib::SignalProxy0< void > signal_composited_changed();
  Glib::SignalProxy4< bool,int,int,bool,const Glib::RefPtr<Tooltip>& > signal_query_tooltip();
  Glib::PropertyProxy<Glib::ustring> property_name() ;
  Glib::PropertyProxy_ReadOnly<Glib::ustring> property_name() const;
  Glib::PropertyProxy<Container*> property_parent() ;
  Glib::PropertyProxy_ReadOnly<Container*> property_parent() const;
  Glib::PropertyProxy<int> property_width_request() ;
  Glib::PropertyProxy_ReadOnly<int> property_width_request() const;
  Glib::PropertyProxy<int> property_height_request() ;
  Glib::PropertyProxy_ReadOnly<int> property_height_request() const;
  Glib::PropertyProxy<bool> property_visible() ;
  Glib::PropertyProxy_ReadOnly<bool> property_visible() const;
  Glib::PropertyProxy<bool> property_sensitive() ;
  Glib::PropertyProxy_ReadOnly<bool> property_sensitive() const;
  Glib::PropertyProxy<bool> property_app_paintable() ;
  Glib::PropertyProxy_ReadOnly<bool> property_app_paintable() const;
  Glib::PropertyProxy<bool> property_can_focus() ;
  Glib::PropertyProxy_ReadOnly<bool> property_can_focus() const;
  Glib::PropertyProxy<bool> property_has_focus() ;
  Glib::PropertyProxy_ReadOnly<bool> property_has_focus() const;
  Glib::PropertyProxy<bool> property_can_default() ;
  Glib::PropertyProxy_ReadOnly<bool> property_can_default() const;
  Glib::PropertyProxy<bool> property_has_default() ;
  Glib::PropertyProxy_ReadOnly<bool> property_has_default() const;
  Glib::PropertyProxy<bool> property_receives_default() ;
  Glib::PropertyProxy_ReadOnly<bool> property_receives_default() const;
  Glib::PropertyProxy_ReadOnly<bool> property_composite_child() const;
  Glib::PropertyProxy< Glib::RefPtr<Style> > property_style() ;
  Glib::PropertyProxy_ReadOnly< Glib::RefPtr<Style> > property_style() const;
  Glib::PropertyProxy<Gdk::EventMask> property_events() ;
  Glib::PropertyProxy_ReadOnly<Gdk::EventMask> property_events() const;
  Glib::PropertyProxy<Gdk::ExtensionMode> property_extension_events() ;
  Glib::PropertyProxy_ReadOnly<Gdk::ExtensionMode> property_extension_events() const;
  Glib::PropertyProxy<bool> property_has_tooltip() ;
  Glib::PropertyProxy_ReadOnly<bool> property_has_tooltip() const;
  Glib::PropertyProxy<Glib::ustring> property_tooltip_markup() ;
  Glib::PropertyProxy_ReadOnly<Glib::ustring> property_tooltip_markup() const;
  Glib::PropertyProxy<Glib::ustring> property_tooltip_text() ;
  Glib::PropertyProxy_ReadOnly<Glib::ustring> property_tooltip_text() const;
protected:
  virtual void dispatch_child_properties_changed_vfunc(guint p1, GParamSpec** p2);
  virtual void show_all_vfunc();
  virtual void hide_all_vfunc();
protected:
  Widget();
  void realize();
  void unrealize();
  void get_child_requisition(Requisition& requisition) const;
  void get_style_property_value(
                   const Glib::ustring& the_property_name, Glib::ValueBase& value) const;
  void realize_if_needed();
   void set_allocation(const Allocation& value);
    void set_window(const Glib::RefPtr<Gdk::Window>& value);
};
template <class PropertyType>
void Widget::get_style_property(const Glib::ustring& the_property_name, PropertyType& value) const
{
  Glib::Value<PropertyType> property_value;
  property_value.init(Glib::Value<PropertyType>::value_type());
  this->get_style_property_value(the_property_name, property_value);
  value = property_value.get();
}
}
namespace Glib
{
  Gtk::Widget* wrap(GtkWidget* object, bool take_copy = false);
}
typedef struct _GtkContainer GtkContainer;
typedef struct _GtkContainerClass GtkContainerClass;
namespace Gtk
{ class Container_Class; }
namespace Gtk
{
class Adjustment;
class Label;
class Container : public Widget
{
  public:
  typedef Container CppObjectType;
  typedef Container_Class CppClassType;
  typedef GtkContainer BaseObjectType;
  typedef GtkContainerClass BaseClassType;
  virtual ~Container();
private:
  friend class Container_Class;
  static CppClassType container_class_;
  Container(const Container&);
  Container& operator=(const Container&);
protected:
  explicit Container(const Glib::ConstructParams& construct_params);
  explicit Container(GtkContainer* castitem);
public:
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkContainer* gobj() { return reinterpret_cast<GtkContainer*>(gobject_); }
  const GtkContainer* gobj() const { return reinterpret_cast<GtkContainer*>(gobject_); }
public:
protected:
  virtual void on_add(Widget* widget);
  virtual void on_remove(Widget* widget);
  virtual void on_check_resize();
  virtual void on_set_focus_child(Widget* widget);
private:
public:
  void set_border_width(guint border_width);
  guint get_border_width() const;
 virtual void add(Widget& widget);
  void remove(Widget& widget);
  void set_resize_mode(ResizeMode resize_mode);
  ResizeMode get_resize_mode() const;
  void check_resize();
  typedef sigc::slot<void, Widget&> ForeachSlot;
  void foreach(const ForeachSlot& slot);
  Glib::ListHandle<Widget*> get_children();
  Glib::ListHandle<const Widget*> get_children() const;
  void propagate_expose(Widget& child, GdkEventExpose* event);
  void set_focus_chain(const Glib::ListHandle<Widget*>& focusable_widgets);
  bool has_focus_chain() const;
  Glib::ListHandle<Widget*> get_focus_chain();
  Glib::ListHandle<const Widget*> get_focus_chain() const;
  void unset_focus_chain();
  void set_reallocate_redraws(bool needs_redraws = true);
  void set_focus_child(Widget& widget);
  void set_focus_vadjustment(Adjustment& adjustment);
  Adjustment* get_focus_vadjustment();
  const Adjustment* get_focus_vadjustment() const;
  void set_focus_hadjustment(Adjustment& adjustment);
  Adjustment* get_focus_hadjustment();
  const Adjustment* get_focus_hadjustment() const;
  void resize_children();
  GType child_type() const;
  Glib::SignalProxy1< void,Widget* > signal_add();
  Glib::SignalProxy1< void,Widget* > signal_remove();
  Glib::SignalProxy0< void > signal_check_resize();
  Glib::SignalProxy1< void,Widget* > signal_set_focus_child();
  void show_all_children(bool recursive = true);
protected:
  Container();
  virtual GtkType child_type_vfunc() const;
  virtual void forall_vfunc(gboolean include_internals, GtkCallback callback, gpointer callback_data);
  virtual char* composite_name_vfunc(GtkWidget* child);
  virtual void set_child_property_vfunc(GtkWidget* child, guint property_id, const GValue* value, GParamSpec* pspec);
  virtual void get_child_property_vfunc(GtkWidget* child, guint property_id, GValue* value, GParamSpec* pspec) const;
  Glib::PropertyProxy<guint> property_border_width() ;
  Glib::PropertyProxy_ReadOnly<guint> property_border_width() const;
  Glib::PropertyProxy<ResizeMode> property_resize_mode() ;
  Glib::PropertyProxy_ReadOnly<ResizeMode> property_resize_mode() const;
  Glib::PropertyProxy_WriteOnly<Widget*> property_child() ;
};
}
namespace Glib
{
  Gtk::Container* wrap(GtkContainer* object, bool take_copy = false);
}
typedef struct _GtkBin GtkBin;
typedef struct _GtkBinClass GtkBinClass;
namespace Gtk
{ class Bin_Class; }
namespace Gtk
{
class Bin : public Container
{
  public:
  typedef Bin CppObjectType;
  typedef Bin_Class CppClassType;
  typedef GtkBin BaseObjectType;
  typedef GtkBinClass BaseClassType;
  virtual ~Bin();
private:
  friend class Bin_Class;
  static CppClassType bin_class_;
  Bin(const Bin&);
  Bin& operator=(const Bin&);
protected:
  explicit Bin(const Glib::ConstructParams& construct_params);
  explicit Bin(GtkBin* castitem);
public:
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkBin* gobj() { return reinterpret_cast<GtkBin*>(gobject_); }
  const GtkBin* gobj() const { return reinterpret_cast<GtkBin*>(gobject_); }
public:
protected:
private:
protected:
  Bin();
public:
   Widget* get_child();
  const Widget* get_child() const;
  void remove();
  void add_label(const Glib::ustring& label, bool mnemonic = false,
   double x_align = 0.5, double y_align = 0.5);
  void add_label(const Glib::ustring& label, bool mnemonic,
   AlignmentEnum x_align, AlignmentEnum y_align = ALIGN_CENTER);
  void add_pixmap(const Glib::RefPtr<Gdk::Pixmap>& pixmap,
    const Glib::RefPtr<Gdk::Bitmap>& mask);
  void add_pixlabel(const Glib::RefPtr<Gdk::Pixmap>& pixmap,
                    const Glib::RefPtr<Gdk::Bitmap>& mask,
                    const Glib::ustring& label,
                  double x_align = 0.5, double y_align = 0.5);
  void add_pixlabel(const Glib::ustring& pixfile,
                    const Glib::ustring& label,
                  double x_align = 0.5, double y_align = 0.5);
};
}
namespace Glib
{
  Gtk::Bin* wrap(GtkBin* object, bool take_copy = false);
}
typedef struct _GtkWindowGroup GtkWindowGroup;
typedef struct _GtkWindowGroupClass GtkWindowGroupClass;
namespace Gtk
{ class WindowGroup_Class; }
typedef struct _GtkWindow GtkWindow;
typedef struct _GtkWindowClass GtkWindowClass;
namespace Gtk
{ class Window_Class; }
namespace Gtk
{
class AccelGroup;
class WindowGroup;
class WindowGroup : public Glib::Object
{
public:
  typedef WindowGroup CppObjectType;
  typedef WindowGroup_Class CppClassType;
  typedef GtkWindowGroup BaseObjectType;
  typedef GtkWindowGroupClass BaseClassType;
private: friend class WindowGroup_Class;
  static CppClassType windowgroup_class_;
private:
  WindowGroup(const WindowGroup&);
  WindowGroup& operator=(const WindowGroup&);
protected:
  explicit WindowGroup(const Glib::ConstructParams& construct_params);
  explicit WindowGroup(GtkWindowGroup* castitem);
public:
  virtual ~WindowGroup();
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkWindowGroup* gobj() { return reinterpret_cast<GtkWindowGroup*>(gobject_); }
  const GtkWindowGroup* gobj() const { return reinterpret_cast<GtkWindowGroup*>(gobject_); }
  GtkWindowGroup* gobj_copy();
private:
protected:
  WindowGroup();
public:
  static Glib::RefPtr<WindowGroup> create();
  void add_window(Window& window);
  void remove_window(Window& window);
public:
public:
protected:
};
class Window : public Bin
{
  public:
  typedef Window CppObjectType;
  typedef Window_Class CppClassType;
  typedef GtkWindow BaseObjectType;
  typedef GtkWindowClass BaseClassType;
  virtual ~Window();
private:
  friend class Window_Class;
  static CppClassType window_class_;
  Window(const Window&);
  Window& operator=(const Window&);
protected:
  explicit Window(const Glib::ConstructParams& construct_params);
  explicit Window(GtkWindow* castitem);
public:
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkWindow* gobj() { return reinterpret_cast<GtkWindow*>(gobject_); }
  const GtkWindow* gobj() const { return reinterpret_cast<GtkWindow*>(gobject_); }
public:
protected:
  virtual void on_set_focus(Widget* focus);
  virtual bool on_frame_event(GdkEvent* event);
private:
public:
   explicit Window(WindowType type = WINDOW_TOPLEVEL);
  Glib::PropertyProxy<Glib::ustring> property_title() ;
  Glib::PropertyProxy_ReadOnly<Glib::ustring> property_title() const;
  Glib::PropertyProxy<bool> property_allow_shrink() ;
  Glib::PropertyProxy_ReadOnly<bool> property_allow_shrink() const;
  Glib::PropertyProxy<bool> property_allow_grow() ;
  Glib::PropertyProxy_ReadOnly<bool> property_allow_grow() const;
  Glib::PropertyProxy<bool> property_resizable() ;
  Glib::PropertyProxy_ReadOnly<bool> property_resizable() const;
  Glib::PropertyProxy<bool> property_modal() ;
  Glib::PropertyProxy_ReadOnly<bool> property_modal() const;
  Glib::PropertyProxy<WindowPosition> property_window_position() ;
  Glib::PropertyProxy_ReadOnly<WindowPosition> property_window_position() const;
  Glib::PropertyProxy<int> property_default_width() ;
  Glib::PropertyProxy_ReadOnly<int> property_default_width() const;
  Glib::PropertyProxy<int> property_default_height() ;
  Glib::PropertyProxy_ReadOnly<int> property_default_height() const;
  Glib::PropertyProxy<bool> property_destroy_with_parent() ;
  Glib::PropertyProxy_ReadOnly<bool> property_destroy_with_parent() const;
  Glib::PropertyProxy< Glib::RefPtr<Gdk::Pixbuf> > property_icon() ;
  Glib::PropertyProxy_ReadOnly< Glib::RefPtr<Gdk::Pixbuf> > property_icon() const;
  Glib::PropertyProxy< Glib::RefPtr<Gdk::Screen> > property_screen() ;
  Glib::PropertyProxy_ReadOnly< Glib::RefPtr<Gdk::Screen> > property_screen() const;
  Glib::PropertyProxy_ReadOnly<bool> property_is_active() const;
  Glib::PropertyProxy_ReadOnly<bool> property_has_toplevel_focus() const;
  Glib::PropertyProxy<GdkWindowTypeHint> property_type_hint() ;
  Glib::PropertyProxy_ReadOnly<GdkWindowTypeHint> property_type_hint() const;
  Glib::PropertyProxy<bool> property_skip_taskbar_hint() ;
  Glib::PropertyProxy_ReadOnly<bool> property_skip_taskbar_hint() const;
  Glib::PropertyProxy<bool> property_skip_pager_hint() ;
  Glib::PropertyProxy_ReadOnly<bool> property_skip_pager_hint() const;
  Glib::PropertyProxy<Glib::ustring> property_role() ;
  Glib::PropertyProxy_ReadOnly<Glib::ustring> property_role() const;
  Glib::PropertyProxy<bool> property_decorated() ;
  Glib::PropertyProxy_ReadOnly<bool> property_decorated() const;
  Glib::PropertyProxy<Gdk::Gravity> property_gravity() ;
  Glib::PropertyProxy_ReadOnly<Gdk::Gravity> property_gravity() const;
  Glib::PropertyProxy<Window*> property_transient_for() ;
  Glib::PropertyProxy_ReadOnly<Window*> property_transient_for() const;
  Glib::PropertyProxy<bool> property_urgency_hint() ;
  Glib::PropertyProxy_ReadOnly<bool> property_urgency_hint() const;
  Glib::PropertyProxy<bool> property_deletable() ;
  Glib::PropertyProxy_ReadOnly<bool> property_deletable() const;
  Glib::PropertyProxy<double> property_opacity() ;
  Glib::PropertyProxy_ReadOnly<double> property_opacity() const;
  bool is_toplevel() const;
  bool is_dialog() const;
  bool is_popup() const;
   WindowType get_window_type() const;
   Glib::RefPtr<Gdk::Window> get_frame();
  Glib::RefPtr<const Gdk::Window> get_frame() const;
  Glib::SignalProxy1< void,Widget* > signal_set_focus();
  Glib::SignalProxy1< bool,GdkEvent* > signal_frame_event();
  void set_title(const Glib::ustring& title);
  Glib::ustring get_title() const;
  void set_wmclass(const Glib::ustring& wmclass_name,
                                const Glib::ustring& wmclass_class);
  void set_role(const Glib::ustring& role);
  Glib::ustring get_role() const;
  void add_accel_group(const Glib::RefPtr<AccelGroup>& accel_group);
  void remove_accel_group(const Glib::RefPtr<AccelGroup>& accel_group);
  void set_position(WindowPosition position);
  bool activate_focus();
  void set_focus(Gtk::Widget& focus);
  void unset_focus();
  Widget* get_focus();
  const Widget* get_focus() const;
  void set_default(Gtk::Widget& default_widget);
  void unset_default();
  bool activate_default();
  void set_transient_for(Window& parent);
  Window* get_transient_for();
  const Window* get_transient_for() const;
  void set_opacity(double opacity);
  double get_opacity() const;
  void set_type_hint(Gdk::WindowTypeHint hint);
  Gdk::WindowTypeHint get_type_hint() const;
  void set_skip_taskbar_hint(bool setting = true);
  bool get_skip_taskbar_hint() const;
  void set_skip_pager_hint(bool setting = true);
  bool get_skip_pager_hint() const;
  void set_urgency_hint(bool setting = true);
  bool get_urgency_hint() const;
  void set_accept_focus(bool setting = true);
  bool get_accept_focus() const;
  void set_focus_on_map(bool setting = true);
  bool get_focus_on_map() const;
  bool get_destroy_with_parent() const;
  void set_resizable(bool resizable = true);
  bool get_resizable() const;
  void set_gravity(Gdk::Gravity gravity);
  Gdk::Gravity get_gravity() const;
  void set_geometry_hints(Widget& geometry_widget,
                                       const Gdk::Geometry& geometry,
                                       Gdk::WindowHints geom_mask);
  void set_screen(const Glib::RefPtr<Gdk::Screen>& screen);
  Glib::RefPtr<Gdk::Screen> get_screen();
  Glib::RefPtr<const Gdk::Screen> get_screen() const;
  void set_has_frame(bool setting = true);
  bool get_has_frame() const;
  void set_frame_dimensions(int left, int top,
                                         int right, int bottom);
  void get_frame_dimensions(int& left, int& top,
                                         int& right, int& bottom) const;
  void set_decorated(bool setting = true);
  bool get_decorated() const;
  void set_deletable(bool setting = true);
  bool get_deletable() const;
  Glib::ListHandle< Glib::RefPtr<Gdk::Pixbuf> > get_icon_list();
  Glib::ListHandle< Glib::RefPtr<const Gdk::Pixbuf> > get_icon_list() const;
  void set_icon_list(const Glib::ListHandle< Glib::RefPtr<Gdk::Pixbuf> >& list);
  void set_icon(const Glib::RefPtr<Gdk::Pixbuf>& icon);
  bool set_icon_from_file(const std::string& filename);
  Glib::RefPtr<Gdk::Pixbuf> get_icon();
  Glib::RefPtr<const Gdk::Pixbuf> get_icon() const;
  static void set_default_icon_list(
                   const Glib::ListHandle< Glib::RefPtr<Gdk::Pixbuf> >& list);
  static Glib::ListHandle< Glib::RefPtr<Gdk::Pixbuf> > get_default_icon_list();
  static void set_default_icon(const Glib::RefPtr<Gdk::Pixbuf>& icon);
  static void set_default_icon_name(const Glib::ustring& name);
  static bool set_default_icon_from_file(const std::string& filename);
  static void set_auto_startup_notification(bool setting = true);
  void set_modal(bool modal = true);
  bool get_modal() const;
  static Glib::ListHandle<Window*> list_toplevels();
  void add_mnemonic(guint keyval, Widget& target);
  void remove_mnemonic(guint keyval, Widget& target);
  bool mnemonic_activate(guint keyval, Gdk::ModifierType modifier);
  void set_mnemonic_modifier(Gdk::ModifierType modifier);
  Gdk::ModifierType get_mnemonic_modifier();
  void present();
  void present(guint32 timestamp);
  void iconify();
  void deiconify();
  void stick();
  void unstick();
  void maximize();
  void unmaximize();
  void fullscreen();
  void unfullscreen();
  void begin_resize_drag(Gdk::WindowEdge edge,
                   int button, int root_x, int root_y, guint32 timestamp);
  void begin_move_drag(
                   int button, int root_x, int root_y, guint32 timestamp);
  void set_default_size(int width, int height);
  void get_default_size(int& width, int& height) const;
  void resize(int width, int height);
  void get_size(int& width, int& height) const;
  void move(int x, int y);
  void get_position(int& root_x, int& root_y) const;
  bool parse_geometry(const Glib::ustring& geometry);
  Glib::RefPtr<WindowGroup> get_group();
  Glib::RefPtr<const WindowGroup> get_group() const;
  void reshow_with_initial_size();
  void set_keep_above(bool setting = true);
  void set_keep_below(bool setting = true);
  Glib::RefPtr<AccelGroup> get_accel_group();
  virtual void raise();
  virtual void set_manage();
protected:
  void destroy_();
  void _destroy_c_instance();
private:
  Glib::RefPtr<AccelGroup> accel_group_;
};
}
namespace Glib
{
  Glib::RefPtr<Gtk::WindowGroup> wrap(GtkWindowGroup* object, bool take_copy = false);
}
namespace Glib
{
  Gtk::Window* wrap(GtkWindow* object, bool take_copy = false);
}
extern "C" {
typedef struct _GtkContainer GtkContainer;
typedef struct _GtkContainerClass GtkContainerClass;
struct _GtkContainer
{
  GtkWidget widget;
  GtkWidget *focus_child;
  guint border_width : 16;
  guint need_resize : 1;
  guint resize_mode : 2;
  guint reallocate_redraws : 1;
  guint has_focus_chain : 1;
};
struct _GtkContainerClass
{
  GtkWidgetClass parent_class;
  void (*add) (GtkContainer *container,
     GtkWidget *widget);
  void (*remove) (GtkContainer *container,
     GtkWidget *widget);
  void (*check_resize) (GtkContainer *container);
  void (*forall) (GtkContainer *container,
     gboolean include_internals,
     GtkCallback callback,
     gpointer callback_data);
  void (*set_focus_child) (GtkContainer *container,
     GtkWidget *widget);
  GType (*child_type) (GtkContainer *container);
  gchar* (*composite_name) (GtkContainer *container,
     GtkWidget *child);
  void (*set_child_property) (GtkContainer *container,
     GtkWidget *child,
     guint property_id,
     const GValue *value,
     GParamSpec *pspec);
  void (*get_child_property) (GtkContainer *container,
                                 GtkWidget *child,
     guint property_id,
     GValue *value,
     GParamSpec *pspec);
  void (*_gtk_reserved1) (void);
  void (*_gtk_reserved2) (void);
  void (*_gtk_reserved3) (void);
  void (*_gtk_reserved4) (void);
};
GType gtk_container_get_type (void) __attribute__((__const__));
void gtk_container_set_border_width (GtkContainer *container,
       guint border_width);
guint gtk_container_get_border_width (GtkContainer *container);
void gtk_container_add (GtkContainer *container,
       GtkWidget *widget);
void gtk_container_remove (GtkContainer *container,
       GtkWidget *widget);
void gtk_container_set_resize_mode (GtkContainer *container,
       GtkResizeMode resize_mode);
GtkResizeMode gtk_container_get_resize_mode (GtkContainer *container);
void gtk_container_check_resize (GtkContainer *container);
void gtk_container_foreach (GtkContainer *container,
         GtkCallback callback,
         gpointer callback_data);
void gtk_container_foreach_full (GtkContainer *container,
         GtkCallback callback,
         GtkCallbackMarshal marshal,
         gpointer callback_data,
         GtkDestroyNotify notify);
GList* gtk_container_get_children (GtkContainer *container);
void gtk_container_propagate_expose (GtkContainer *container,
      GtkWidget *child,
      GdkEventExpose *event);
void gtk_container_set_focus_chain (GtkContainer *container,
                                         GList *focusable_widgets);
gboolean gtk_container_get_focus_chain (GtkContainer *container,
      GList **focusable_widgets);
void gtk_container_unset_focus_chain (GtkContainer *container);
void gtk_container_set_reallocate_redraws (GtkContainer *container,
          gboolean needs_redraws);
void gtk_container_set_focus_child (GtkContainer *container,
         GtkWidget *child);
void gtk_container_set_focus_vadjustment (GtkContainer *container,
         GtkAdjustment *adjustment);
GtkAdjustment *gtk_container_get_focus_vadjustment (GtkContainer *container);
void gtk_container_set_focus_hadjustment (GtkContainer *container,
         GtkAdjustment *adjustment);
GtkAdjustment *gtk_container_get_focus_hadjustment (GtkContainer *container);
void gtk_container_resize_children (GtkContainer *container);
GType gtk_container_child_type (GtkContainer *container);
void gtk_container_class_install_child_property (GtkContainerClass *cclass,
        guint property_id,
        GParamSpec *pspec);
GParamSpec* gtk_container_class_find_child_property (GObjectClass *cclass,
        const gchar *property_name);
GParamSpec** gtk_container_class_list_child_properties (GObjectClass *cclass,
        guint *n_properties);
void gtk_container_add_with_properties (GtkContainer *container,
        GtkWidget *widget,
        const gchar *first_prop_name,
        ...) __attribute__((__sentinel__));
void gtk_container_child_set (GtkContainer *container,
        GtkWidget *child,
        const gchar *first_prop_name,
        ...) __attribute__((__sentinel__));
void gtk_container_child_get (GtkContainer *container,
        GtkWidget *child,
        const gchar *first_prop_name,
        ...) __attribute__((__sentinel__));
void gtk_container_child_set_valist (GtkContainer *container,
        GtkWidget *child,
        const gchar *first_property_name,
        va_list var_args);
void gtk_container_child_get_valist (GtkContainer *container,
        GtkWidget *child,
        const gchar *first_property_name,
        va_list var_args);
void gtk_container_child_set_property (GtkContainer *container,
        GtkWidget *child,
        const gchar *property_name,
        const GValue *value);
void gtk_container_child_get_property (GtkContainer *container,
        GtkWidget *child,
        const gchar *property_name,
        GValue *value);
void gtk_container_forall (GtkContainer *container,
           GtkCallback callback,
           gpointer callback_data);
void _gtk_container_queue_resize (GtkContainer *container);
void _gtk_container_clear_resize_widgets (GtkContainer *container);
gchar* _gtk_container_child_composite_name (GtkContainer *container,
           GtkWidget *child);
void _gtk_container_dequeue_resize_handler (GtkContainer *container);
GList *_gtk_container_focus_sort (GtkContainer *container,
           GList *children,
           GtkDirectionType direction,
           GtkWidget *old_focus);
}
extern "C" {
typedef struct _GtkBox GtkBox;
typedef struct _GtkBoxClass GtkBoxClass;
typedef struct _GtkBoxChild GtkBoxChild;
struct _GtkBox
{
  GtkContainer container;
  GList *children;
  gint16 spacing;
  guint homogeneous : 1;
};
struct _GtkBoxClass
{
  GtkContainerClass parent_class;
};
struct _GtkBoxChild
{
  GtkWidget *widget;
  guint16 padding;
  guint expand : 1;
  guint fill : 1;
  guint pack : 1;
  guint is_secondary : 1;
};
GType gtk_box_get_type (void) __attribute__((__const__));
void gtk_box_pack_start (GtkBox *box,
     GtkWidget *child,
     gboolean expand,
     gboolean fill,
     guint padding);
void gtk_box_pack_end (GtkBox *box,
     GtkWidget *child,
     gboolean expand,
     gboolean fill,
     guint padding);
void gtk_box_pack_start_defaults (GtkBox *box,
     GtkWidget *widget);
void gtk_box_pack_end_defaults (GtkBox *box,
     GtkWidget *widget);
void gtk_box_set_homogeneous (GtkBox *box,
     gboolean homogeneous);
gboolean gtk_box_get_homogeneous (GtkBox *box);
void gtk_box_set_spacing (GtkBox *box,
     gint spacing);
gint gtk_box_get_spacing (GtkBox *box);
void gtk_box_reorder_child (GtkBox *box,
     GtkWidget *child,
     gint position);
void gtk_box_query_child_packing (GtkBox *box,
     GtkWidget *child,
     gboolean *expand,
     gboolean *fill,
     guint *padding,
     GtkPackType *pack_type);
void gtk_box_set_child_packing (GtkBox *box,
     GtkWidget *child,
     gboolean expand,
     gboolean fill,
     guint padding,
     GtkPackType pack_type);
}
typedef struct _GtkBox GtkBox;
typedef struct _GtkBoxClass GtkBoxClass;
namespace Gtk
{ class Box_Class; }
typedef struct _GtkVBox GtkVBox;
typedef struct _GtkVBoxClass GtkVBoxClass;
namespace Gtk
{ class VBox_Class; }
typedef struct _GtkHBox GtkHBox;
typedef struct _GtkHBoxClass GtkHBoxClass;
namespace Gtk
{ class HBox_Class; }
namespace Gtk
{
enum PackOptions
{
  PACK_SHRINK,
  PACK_EXPAND_PADDING,
  PACK_EXPAND_WIDGET
};
class Box;
namespace Box_Helpers
{
class Child : protected _GtkBoxChild
{
private:
  Child& operator=(const Child&);
  Child(const Child&);
public:
  inline _GtkBoxChild* gobj() { return this; }
  inline const _GtkBoxChild* gobj() const { return this; }
  Widget* get_widget() const;
  inline guint16 get_padding() const { return (gobj()->padding); }
  inline bool get_expand() const { return (gobj()->expand); }
  inline bool get_fill() const { return (gobj()->fill); }
  inline bool get_pack() const { return (gobj()->pack); }
  void set_options(PackOptions options, guint padding = 0);
  void set_options(bool expand, bool fill, guint padding = 0);
  void set_pack(PackType pack);
protected:
  inline GtkBox* parent()
    { return (GtkBox*) (gobj()->widget->parent); }
  void redraw();
  friend class Dummy_;
};
class Element
{
public:
 Element(Widget& widget,
          PackOptions options = PACK_EXPAND_WIDGET,
          guint padding = 0,
          PackType pack = PACK_START)
      : widget_(&widget), options_(options),
        padding_(padding), pack_(pack)
    {}
  Widget* widget_;
  PackOptions options_;
  guint padding_;
  PackType pack_;
};
typedef Element StartElem;
struct EndElem : public Element
{
  EndElem(Widget& widget,
          PackOptions options = PACK_EXPAND_WIDGET,
          guint padding = 0)
      : Element (widget, options, padding, PACK_END)
    {}
};
class BoxList : public Glib::HelperList< Child, const Element, Glib::List_Iterator< Child > >
{
public:
  BoxList();
  explicit BoxList(GtkBox* gparent);
  BoxList(const BoxList& src);
  virtual ~BoxList() {}
  BoxList& operator=(const BoxList& src);
  typedef Glib::HelperList< Child, const Element, Glib::List_Iterator< Child > > type_base;
  GtkBox* gparent();
  const GtkBox* gparent() const;
  virtual GList*& glist() const;
  virtual void erase(iterator start, iterator stop);
  virtual iterator erase(iterator);
  virtual void remove(const_reference);
  reference operator[](size_type l) const;
public:
  iterator insert(iterator position, element_type& e);
  template <class InputIterator>
  inline void insert(iterator position, InputIterator first, InputIterator last)
  {
    for(;first != last; ++first)
      position = insert(position, *first);
  }
 inline void push_front(element_type& e)
    { insert(begin(), e); }
  inline void push_back(element_type& e)
    { insert(end(), e); }
  iterator find(const_reference c);
  iterator find(Widget&);
virtual void remove(Widget& w);
        void reorder(iterator loc,iterator pos);
  };
}
class Box : public Container
{
  public:
  typedef Box CppObjectType;
  typedef Box_Class CppClassType;
  typedef GtkBox BaseObjectType;
  typedef GtkBoxClass BaseClassType;
  virtual ~Box();
private:
  friend class Box_Class;
  static CppClassType box_class_;
  Box(const Box&);
  Box& operator=(const Box&);
protected:
  explicit Box(const Glib::ConstructParams& construct_params);
  explicit Box(GtkBox* castitem);
public:
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkBox* gobj() { return reinterpret_cast<GtkBox*>(gobject_); }
  const GtkBox* gobj() const { return reinterpret_cast<GtkBox*>(gobject_); }
public:
protected:
private:
public:
  typedef Box_Helpers::BoxList BoxList;
protected:
  Box();
public:
  void pack_start(Widget& child, bool expand, bool fill, guint padding = 0);
  void pack_start(Widget& child, PackOptions options = PACK_EXPAND_WIDGET, guint padding = 0);
  void pack_end(Widget& child, bool expand, bool fill, guint padding = 0);
  void pack_end(Widget& child, PackOptions options = PACK_EXPAND_WIDGET, guint padding = 0);
  void set_homogeneous(bool homogeneous = true);
  bool get_homogeneous() const;
  void set_spacing(int spacing);
  int get_spacing() const;
  void reorder_child(Widget& child, int pos);
  BoxList& children();
  const BoxList& children() const;
  Glib::PropertyProxy<int> property_spacing() ;
  Glib::PropertyProxy_ReadOnly<int> property_spacing() const;
  Glib::PropertyProxy<bool> property_homogeneous() ;
  Glib::PropertyProxy_ReadOnly<bool> property_homogeneous() const;
protected:
  mutable BoxList children_proxy_;
};
class VBox : public Box
{
  public:
  typedef VBox CppObjectType;
  typedef VBox_Class CppClassType;
  typedef GtkVBox BaseObjectType;
  typedef GtkVBoxClass BaseClassType;
  virtual ~VBox();
private:
  friend class VBox_Class;
  static CppClassType vbox_class_;
  VBox(const VBox&);
  VBox& operator=(const VBox&);
protected:
  explicit VBox(const Glib::ConstructParams& construct_params);
  explicit VBox(GtkVBox* castitem);
public:
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkVBox* gobj() { return reinterpret_cast<GtkVBox*>(gobject_); }
  const GtkVBox* gobj() const { return reinterpret_cast<GtkVBox*>(gobject_); }
public:
protected:
private:
public:
  explicit VBox(bool homogeneous = false, int spacing = 0);
};
class HBox : public Box
{
  public:
  typedef HBox CppObjectType;
  typedef HBox_Class CppClassType;
  typedef GtkHBox BaseObjectType;
  typedef GtkHBoxClass BaseClassType;
  virtual ~HBox();
private:
  friend class HBox_Class;
  static CppClassType hbox_class_;
  HBox(const HBox&);
  HBox& operator=(const HBox&);
protected:
  explicit HBox(const Glib::ConstructParams& construct_params);
  explicit HBox(GtkHBox* castitem);
public:
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkHBox* gobj() { return reinterpret_cast<GtkHBox*>(gobject_); }
  const GtkHBox* gobj() const { return reinterpret_cast<GtkHBox*>(gobject_); }
public:
protected:
private:
public:
  explicit HBox(bool homogeneous = false, int spacing = 0);
};
}
namespace Glib
{
  Gtk::Box* wrap(GtkBox* object, bool take_copy = false);
}
namespace Glib
{
  Gtk::VBox* wrap(GtkVBox* object, bool take_copy = false);
}
namespace Glib
{
  Gtk::HBox* wrap(GtkHBox* object, bool take_copy = false);
}
typedef struct _GtkButton GtkButton;
typedef struct _GtkButtonClass GtkButtonClass;
namespace Gtk
{ class Button_Class; }
namespace Gtk
{
namespace Stock { struct BuiltinStockID; }
class Button : public Bin
{
  public:
  typedef Button CppObjectType;
  typedef Button_Class CppClassType;
  typedef GtkButton BaseObjectType;
  typedef GtkButtonClass BaseClassType;
  virtual ~Button();
private:
  friend class Button_Class;
  static CppClassType button_class_;
  Button(const Button&);
  Button& operator=(const Button&);
protected:
  explicit Button(const Glib::ConstructParams& construct_params);
  explicit Button(GtkButton* castitem);
public:
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkButton* gobj() { return reinterpret_cast<GtkButton*>(gobject_); }
  const GtkButton* gobj() const { return reinterpret_cast<GtkButton*>(gobject_); }
public:
protected:
  virtual void on_pressed();
  virtual void on_released();
  virtual void on_clicked();
  virtual void on_enter();
  virtual void on_leave();
  virtual void on_activate();
private:
public:
  Button();
  explicit Button(const Glib::ustring& label, bool mnemonic = false);
  explicit Button(const StockID& stock_id);
  void pressed();
  void released();
  void clicked();
  void enter();
  void leave();
  void set_relief(ReliefStyle newstyle);
  ReliefStyle get_relief() const;
  void set_label(const Glib::ustring& label);
  Glib::ustring get_label() const;
  void set_use_underline(bool use_underline = true);
  bool get_use_underline() const;
  void set_use_stock(bool use_stock = true);
  bool get_use_stock() const;
  void set_focus_on_click(bool focus_on_click = true);
  bool get_focus_on_click() const;
  void set_alignment(float xalign, float yalign);
  void get_alignment(float& xalign, float& yalign);
  void set_image(Widget& image);
  Widget* get_image();
  const Widget* get_image() const;
  void set_image_position(PositionType position);
  PositionType get_image_position() const;
  Glib::SignalProxy0< void > signal_pressed();
  Glib::SignalProxy0< void > signal_released();
  Glib::SignalProxy0< void > signal_clicked();
  Glib::SignalProxy0< void > signal_enter();
  Glib::SignalProxy0< void > signal_leave();
  Glib::SignalProxy0< void > signal_activate();
  Glib::PropertyProxy<Glib::ustring> property_label() ;
  Glib::PropertyProxy_ReadOnly<Glib::ustring> property_label() const;
  Glib::PropertyProxy<ReliefStyle> property_relief() ;
  Glib::PropertyProxy_ReadOnly<ReliefStyle> property_relief() const;
  Glib::PropertyProxy<bool> property_use_underline() ;
  Glib::PropertyProxy_ReadOnly<bool> property_use_underline() const;
  Glib::PropertyProxy<bool> property_use_stock() ;
  Glib::PropertyProxy_ReadOnly<bool> property_use_stock() const;
  Glib::PropertyProxy<bool> property_focus_on_click() ;
  Glib::PropertyProxy_ReadOnly<bool> property_focus_on_click() const;
  Glib::PropertyProxy<float> property_xalign() ;
  Glib::PropertyProxy_ReadOnly<float> property_xalign() const;
  Glib::PropertyProxy<float> property_yalign() ;
  Glib::PropertyProxy_ReadOnly<float> property_yalign() const;
  Glib::PropertyProxy<Gtk::Widget*> property_image() ;
  Glib::PropertyProxy_ReadOnly<Gtk::Widget*> property_image() const;
  Glib::PropertyProxy<PositionType> property_image_position() ;
  Glib::PropertyProxy_ReadOnly<PositionType> property_image_position() const;
};
}
namespace Glib
{
  Gtk::Button* wrap(GtkButton* object, bool take_copy = false);
}
typedef struct _GtkButtonBox GtkButtonBox;
typedef struct _GtkButtonBoxClass GtkButtonBoxClass;
namespace Gtk
{ class ButtonBox_Class; }
typedef struct _GtkVButtonBox GtkVButtonBox;
typedef struct _GtkVButtonBoxClass GtkVButtonBoxClass;
namespace Gtk
{ class VButtonBox_Class; }
typedef struct _GtkHButtonBox GtkHButtonBox;
typedef struct _GtkHButtonBoxClass GtkHButtonBoxClass;
namespace Gtk
{ class HButtonBox_Class; }
namespace Gtk
{
enum { BUTTONBOX_DEFAULT = -1 };
class ButtonBox : public Box
{
  public:
  typedef ButtonBox CppObjectType;
  typedef ButtonBox_Class CppClassType;
  typedef GtkButtonBox BaseObjectType;
  typedef GtkButtonBoxClass BaseClassType;
  virtual ~ButtonBox();
private:
  friend class ButtonBox_Class;
  static CppClassType buttonbox_class_;
  ButtonBox(const ButtonBox&);
  ButtonBox& operator=(const ButtonBox&);
protected:
  explicit ButtonBox(const Glib::ConstructParams& construct_params);
  explicit ButtonBox(GtkButtonBox* castitem);
public:
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkButtonBox* gobj() { return reinterpret_cast<GtkButtonBox*>(gobject_); }
  const GtkButtonBox* gobj() const { return reinterpret_cast<GtkButtonBox*>(gobject_); }
public:
protected:
private:
public:
  ButtonBoxStyle get_layout() const;
  void set_layout(ButtonBoxStyle layout_style);
  void set_child_secondary(Widget& child, bool is_secondary = true);
  bool get_child_secondary(const Gtk::Widget& child) const;
   int get_child_min_width() const;
    void set_child_min_width(const int& value);
   int get_child_min_height() const;
    void set_child_min_height(const int& value);
   int get_child_ipadding_x() const;
    void set_child_ipadding_x(const int& value);
   int get_child_ipadding_y() const;
    void set_child_ipadding_y(const int& value);
  Glib::PropertyProxy<ButtonBoxStyle> property_layout_style() ;
  Glib::PropertyProxy_ReadOnly<ButtonBoxStyle> property_layout_style() const;
};
class VButtonBox : public ButtonBox
{
  public:
  typedef VButtonBox CppObjectType;
  typedef VButtonBox_Class CppClassType;
  typedef GtkVButtonBox BaseObjectType;
  typedef GtkVButtonBoxClass BaseClassType;
  virtual ~VButtonBox();
private:
  friend class VButtonBox_Class;
  static CppClassType vbuttonbox_class_;
  VButtonBox(const VButtonBox&);
  VButtonBox& operator=(const VButtonBox&);
protected:
  explicit VButtonBox(const Glib::ConstructParams& construct_params);
  explicit VButtonBox(GtkVButtonBox* castitem);
public:
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkVButtonBox* gobj() { return reinterpret_cast<GtkVButtonBox*>(gobject_); }
  const GtkVButtonBox* gobj() const { return reinterpret_cast<GtkVButtonBox*>(gobject_); }
public:
protected:
private:
public:
  explicit VButtonBox(ButtonBoxStyle layout = BUTTONBOX_DEFAULT_STYLE, int spacing = BUTTONBOX_DEFAULT);
};
class HButtonBox : public ButtonBox
{
  public:
  typedef HButtonBox CppObjectType;
  typedef HButtonBox_Class CppClassType;
  typedef GtkHButtonBox BaseObjectType;
  typedef GtkHButtonBoxClass BaseClassType;
  virtual ~HButtonBox();
private:
  friend class HButtonBox_Class;
  static CppClassType hbuttonbox_class_;
  HButtonBox(const HButtonBox&);
  HButtonBox& operator=(const HButtonBox&);
protected:
  explicit HButtonBox(const Glib::ConstructParams& construct_params);
  explicit HButtonBox(GtkHButtonBox* castitem);
public:
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkHButtonBox* gobj() { return reinterpret_cast<GtkHButtonBox*>(gobject_); }
  const GtkHButtonBox* gobj() const { return reinterpret_cast<GtkHButtonBox*>(gobject_); }
public:
protected:
private:
public:
  explicit HButtonBox(ButtonBoxStyle layout = BUTTONBOX_DEFAULT_STYLE, int spacing = BUTTONBOX_DEFAULT);
};
}
namespace Glib
{
  Gtk::ButtonBox* wrap(GtkButtonBox* object, bool take_copy = false);
}
namespace Glib
{
  Gtk::VButtonBox* wrap(GtkVButtonBox* object, bool take_copy = false);
}
namespace Glib
{
  Gtk::HButtonBox* wrap(GtkHButtonBox* object, bool take_copy = false);
}
typedef struct _GtkDialog GtkDialog;
typedef struct _GtkDialogClass GtkDialogClass;
namespace Gtk
{ class Dialog_Class; }
namespace Gtk
{
enum ResponseType
{
  RESPONSE_NONE = -1,
  RESPONSE_REJECT = -2,
  RESPONSE_ACCEPT = -3,
  RESPONSE_DELETE_EVENT = -4,
  RESPONSE_OK = -5,
  RESPONSE_CANCEL = -6,
  RESPONSE_CLOSE = -7,
  RESPONSE_YES = -8,
  RESPONSE_NO = -9,
  RESPONSE_APPLY = -10,
  RESPONSE_HELP = -11
};
}
namespace Glib
{
template <>
class Value<Gtk::ResponseType> : public Glib::Value_Enum<Gtk::ResponseType>
{
public:
  static GType value_type() __attribute__((__const__));
};
}
namespace Gtk
{
class Dialog : public Window
{
  public:
  typedef Dialog CppObjectType;
  typedef Dialog_Class CppClassType;
  typedef GtkDialog BaseObjectType;
  typedef GtkDialogClass BaseClassType;
  virtual ~Dialog();
private:
  friend class Dialog_Class;
  static CppClassType dialog_class_;
  Dialog(const Dialog&);
  Dialog& operator=(const Dialog&);
protected:
  explicit Dialog(const Glib::ConstructParams& construct_params);
  explicit Dialog(GtkDialog* castitem);
public:
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkDialog* gobj() { return reinterpret_cast<GtkDialog*>(gobject_); }
  const GtkDialog* gobj() const { return reinterpret_cast<GtkDialog*>(gobject_); }
public:
protected:
  virtual void on_response(int response_id);
private:
public:
  Dialog();
  explicit Dialog(const Glib::ustring& title, bool modal = false, bool use_separator = false);
  Dialog(const Glib::ustring& title, Gtk::Window& parent, bool modal = false, bool use_separator = false);
  void add_action_widget(Widget& child, int response_id);
  Button* add_button(const Glib::ustring& button_text, int response_id);
  Button* add_button(const Gtk::StockID& stock_id, int response_id);
  void set_response_sensitive(int response_id, bool setting = true);
  void set_default_response(int response_id);
  int get_response_for_widget(const Gtk::Widget& widget) const;
  void set_has_separator(bool setting = true);
  bool get_has_separator() const;
  static bool alternative_button_order(const Glib::RefPtr<const Gdk::Screen>& screen);
  void set_alternative_button_order_from_array(const Glib::ArrayHandle<int>& new_order);
  void response(int response_id);
  int run();
   VBox* get_vbox();
  const VBox* get_vbox() const;
    HButtonBox* get_action_area();
  const HButtonBox* get_action_area() const;
  Glib::PropertyProxy<bool> property_has_separator() ;
  Glib::PropertyProxy_ReadOnly<bool> property_has_separator() const;
  Glib::SignalProxy1< void,int > signal_response();
protected:
  void construct_(bool modal, bool use_separator);
};
}
namespace Glib
{
  Gtk::Dialog* wrap(GtkDialog* object, bool take_copy = false);
}
typedef struct _GtkAboutDialog GtkAboutDialog;
typedef struct _GtkAboutDialogClass GtkAboutDialogClass;
namespace Gtk
{ class AboutDialog_Class; }
namespace Gtk
{
class AboutDialog : public Dialog
{
  public:
  typedef AboutDialog CppObjectType;
  typedef AboutDialog_Class CppClassType;
  typedef GtkAboutDialog BaseObjectType;
  typedef GtkAboutDialogClass BaseClassType;
  virtual ~AboutDialog();
private:
  friend class AboutDialog_Class;
  static CppClassType aboutdialog_class_;
  AboutDialog(const AboutDialog&);
  AboutDialog& operator=(const AboutDialog&);
protected:
  explicit AboutDialog(const Glib::ConstructParams& construct_params);
  explicit AboutDialog(GtkAboutDialog* castitem);
public:
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkAboutDialog* gobj() { return reinterpret_cast<GtkAboutDialog*>(gobject_); }
  const GtkAboutDialog* gobj() const { return reinterpret_cast<GtkAboutDialog*>(gobject_); }
public:
protected:
private:
public:
  AboutDialog();
  Glib::ustring get_name() const;
  void set_name(const Glib::ustring& name);
  Glib::ustring get_program_name() const;
  void set_program_name(const Glib::ustring& name);
  Glib::ustring get_version() const;
  void set_version(const Glib::ustring& version);
  Glib::ustring get_copyright() const;
  void set_copyright(const Glib::ustring& copyright);
  Glib::ustring get_comments() const;
  void set_comments(const Glib::ustring& comments);
  Glib::ustring get_license() const;
  void set_license(const Glib::ustring& license);
  Glib::ustring get_website() const;
  void set_website(const Glib::ustring& website);
  Glib::ustring get_website_label() const;
  void set_website_label(const Glib::ustring& website_label);
  Glib::StringArrayHandle get_authors() const;
  void set_authors(const Glib::StringArrayHandle& authors) const;
  Glib::StringArrayHandle get_documenters() const;
  void set_documenters(const Glib::StringArrayHandle& documenters);
  Glib::StringArrayHandle get_artists() const;
  void set_artists(const Glib::StringArrayHandle& artists);
  Glib::ustring get_translator_credits() const;
  void set_translator_credits(const Glib::ustring& translator_credits);
  Glib::RefPtr<Gdk::Pixbuf> get_logo();
  Glib::RefPtr<const Gdk::Pixbuf> get_logo() const;
  void set_logo(const Glib::RefPtr<Gdk::Pixbuf>& logo);
  Glib::ustring get_logo_icon_name() const;
  void set_logo_icon_name(const Glib::ustring& icon_name);
  bool get_wrap_license() const;
  void set_wrap_license(bool wrap_license);
  typedef sigc::slot<void, AboutDialog& , const Glib::ustring& > SlotActivateLink;
  static void set_email_hook(const SlotActivateLink& slot);
  static void set_url_hook(const SlotActivateLink& slot);
  Glib::PropertyProxy<Glib::ustring> property_name() ;
  Glib::PropertyProxy_ReadOnly<Glib::ustring> property_name() const;
  Glib::PropertyProxy<Glib::ustring> property_program_name() ;
  Glib::PropertyProxy_ReadOnly<Glib::ustring> property_program_name() const;
  Glib::PropertyProxy<Glib::ustring> property_version() ;
  Glib::PropertyProxy_ReadOnly<Glib::ustring> property_version() const;
  Glib::PropertyProxy<Glib::ustring> property_copyright() ;
  Glib::PropertyProxy_ReadOnly<Glib::ustring> property_copyright() const;
  Glib::PropertyProxy<Glib::ustring> property_comments() ;
  Glib::PropertyProxy_ReadOnly<Glib::ustring> property_comments() const;
  Glib::PropertyProxy<Glib::ustring> property_website() ;
  Glib::PropertyProxy_ReadOnly<Glib::ustring> property_website() const;
  Glib::PropertyProxy<Glib::ustring> property_website_label() ;
  Glib::PropertyProxy_ReadOnly<Glib::ustring> property_website_label() const;
  Glib::PropertyProxy<Glib::ustring> property_license() ;
  Glib::PropertyProxy_ReadOnly<Glib::ustring> property_license() const;
  Glib::PropertyProxy<Glib::StringArrayHandle> property_authors() ;
  Glib::PropertyProxy_ReadOnly<Glib::StringArrayHandle> property_authors() const;
  Glib::PropertyProxy<Glib::StringArrayHandle> property_documenters() ;
  Glib::PropertyProxy_ReadOnly<Glib::StringArrayHandle> property_documenters() const;
  Glib::PropertyProxy<Glib::StringArrayHandle> property_translator_credits() ;
  Glib::PropertyProxy_ReadOnly<Glib::StringArrayHandle> property_translator_credits() const;
  Glib::PropertyProxy<Glib::StringArrayHandle> property_artists() ;
  Glib::PropertyProxy_ReadOnly<Glib::StringArrayHandle> property_artists() const;
  Glib::PropertyProxy< Glib::RefPtr<Gdk::Pixbuf> > property_logo() ;
  Glib::PropertyProxy_ReadOnly< Glib::RefPtr<Gdk::Pixbuf> > property_logo() const;
  Glib::PropertyProxy<Glib::ustring> property_logo_icon_name() ;
  Glib::PropertyProxy_ReadOnly<Glib::ustring> property_logo_icon_name() const;
  Glib::PropertyProxy<bool> property_wrap_license() ;
  Glib::PropertyProxy_ReadOnly<bool> property_wrap_license() const;
};
}
namespace Glib
{
  Gtk::AboutDialog* wrap(GtkAboutDialog* object, bool take_copy = false);
}
namespace Gtk
{
class AccelKey
{
public:
  AccelKey();
  AccelKey(guint accel_key, Gdk::ModifierType accel_mods,
           const Glib::ustring& accel_path = "");
  AccelKey(const Glib::ustring& accelerator,
           const Glib::ustring& accel_path = Glib::ustring());
  AccelKey(const AccelKey& src);
  AccelKey& operator=(const AccelKey& src);
  bool is_null() const;
  guint get_key() const;
  Gdk::ModifierType get_mod() const;
  Glib::ustring get_path() const;
  Glib::ustring get_abbrev() const;
protected:
  guint key_;
  Gdk::ModifierType mod_;
  Glib::ustring path_;
};
}
typedef struct _GtkAccelGroup GtkAccelGroup;
typedef struct _GtkAccelGroupClass GtkAccelGroupClass;
namespace Gtk
{ class AccelGroup_Class; }
namespace Gtk
{
class AccelGroup : public Glib::Object
{
public:
  typedef AccelGroup CppObjectType;
  typedef AccelGroup_Class CppClassType;
  typedef GtkAccelGroup BaseObjectType;
  typedef GtkAccelGroupClass BaseClassType;
private: friend class AccelGroup_Class;
  static CppClassType accelgroup_class_;
private:
  AccelGroup(const AccelGroup&);
  AccelGroup& operator=(const AccelGroup&);
protected:
  explicit AccelGroup(const Glib::ConstructParams& construct_params);
  explicit AccelGroup(GtkAccelGroup* castitem);
public:
  virtual ~AccelGroup();
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkAccelGroup* gobj() { return reinterpret_cast<GtkAccelGroup*>(gobject_); }
  const GtkAccelGroup* gobj() const { return reinterpret_cast<GtkAccelGroup*>(gobject_); }
  GtkAccelGroup* gobj_copy();
private:
protected:
  AccelGroup();
public:
  static Glib::RefPtr<AccelGroup> create();
  void lock();
  void unlock();
  bool disconnect_key(guint accel_key, Gdk::ModifierType accel_mods);
  static bool valid(guint keyval, Gdk::ModifierType modifiers);
  static void parse(const Glib::ustring& accelerator, guint& accelerator_key, Gdk::ModifierType& accelerator_mods);
  static Glib::ustring name(guint accelerator_key, Gdk::ModifierType accelerator_mods);
  static Glib::ustring get_label(guint accelerator_key, Gdk::ModifierType accelerator_mods);
  static void set_default_mod_mask(Gdk::ModifierType default_mod_mask);
  static Gdk::ModifierType get_default_mod_mask();
  bool activate(GQuark accel_quark, const Glib::RefPtr<Glib::Object>& acceleratable, guint accel_key, Gdk::ModifierType accel_mods);
  static bool activate(Gtk::Object& object, guint accel_key, Gdk::ModifierType accel_mods);
  Glib::SignalProxy3< bool,const Glib::RefPtr<Glib::Object>&,guint,Gdk::ModifierType > signal_accel_activate();
  Glib::SignalProxy3< void,guint,Gdk::ModifierType,GClosure* > signal_accel_changed();
public:
public:
protected:
  virtual void on_accel_changed(guint keyval, Gdk::ModifierType modifier, GClosure* accel_closure);
};
}
namespace Glib
{
  Glib::RefPtr<Gtk::AccelGroup> wrap(GtkAccelGroup* object, bool take_copy = false);
}
typedef struct _GtkAdjustment GtkAdjustment;
typedef struct _GtkAdjustmentClass GtkAdjustmentClass;
namespace Gtk
{ class Adjustment_Class; }
namespace Gtk
{
class Adjustment : public Object
{
  public:
  typedef Adjustment CppObjectType;
  typedef Adjustment_Class CppClassType;
  typedef GtkAdjustment BaseObjectType;
  typedef GtkAdjustmentClass BaseClassType;
  virtual ~Adjustment();
private:
  friend class Adjustment_Class;
  static CppClassType adjustment_class_;
  Adjustment(const Adjustment&);
  Adjustment& operator=(const Adjustment&);
protected:
  explicit Adjustment(const Glib::ConstructParams& construct_params);
  explicit Adjustment(GtkAdjustment* castitem);
public:
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkAdjustment* gobj() { return reinterpret_cast<GtkAdjustment*>(gobject_); }
  const GtkAdjustment* gobj() const { return reinterpret_cast<GtkAdjustment*>(gobject_); }
public:
protected:
  virtual void on_changed();
  virtual void on_value_changed();
private:
public:
  friend class Range;
  friend class HScrollbar;
  friend class VScrollbar;
  Adjustment(double value, double lower, double upper, double step_increment = 1, double page_increment = 10, double page_size = 0);
  void changed();
  void value_changed();
  void clamp_page(double lower, double upper);
  void set_value(double value);
  double get_value() const;
   double get_lower() const;
   double get_upper() const;
   double get_step_increment() const;
   double get_page_increment() const;
   double get_page_size() const;
  void set_lower(double lower);
  void set_upper(double upper);
  void set_step_increment(double incr);
  void set_page_increment(double incr);
  void set_page_size(double size);
  Glib::SignalProxy0< void > signal_changed();
  Glib::SignalProxy0< void > signal_value_changed();
};
}
namespace Glib
{
  Gtk::Adjustment* wrap(GtkAdjustment* object, bool take_copy = false);
}
typedef struct _GtkAlignment GtkAlignment;
typedef struct _GtkAlignmentClass GtkAlignmentClass;
namespace Gtk
{ class Alignment_Class; }
namespace Gtk
{
class Alignment : public Bin
{
  public:
  typedef Alignment CppObjectType;
  typedef Alignment_Class CppClassType;
  typedef GtkAlignment BaseObjectType;
  typedef GtkAlignmentClass BaseClassType;
  virtual ~Alignment();
private:
  friend class Alignment_Class;
  static CppClassType alignment_class_;
  Alignment(const Alignment&);
  Alignment& operator=(const Alignment&);
protected:
  explicit Alignment(const Glib::ConstructParams& construct_params);
  explicit Alignment(GtkAlignment* castitem);
public:
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkAlignment* gobj() { return reinterpret_cast<GtkAlignment*>(gobject_); }
  const GtkAlignment* gobj() const { return reinterpret_cast<GtkAlignment*>(gobject_); }
public:
protected:
private:
public:
  explicit Alignment(float xalign = 0.5, float yalign = 0.5, float xscale = 1.0, float yscale = 1.0);
  explicit Alignment(AlignmentEnum xalign, AlignmentEnum yalign = Gtk::ALIGN_CENTER, float xscale = 1.0, float yscale = 1.0);
  void set(float xalign = 0.5, float yalign = 0.5, float xscale = 1.0, float yscale= 1.0);
  void set(AlignmentEnum xalign, AlignmentEnum yalign = Gtk::ALIGN_CENTER, float xscale = 1.0, float yscale= 1.0);
  void set_padding(guint padding_top, guint padding_bottom, guint padding_left, guint padding_right);
  void get_padding(guint& padding_top, guint& padding_bottom, guint& padding_left, guint& padding_right);
  Glib::PropertyProxy<float> property_xalign() ;
  Glib::PropertyProxy_ReadOnly<float> property_xalign() const;
  Glib::PropertyProxy<float> property_yalign() ;
  Glib::PropertyProxy_ReadOnly<float> property_yalign() const;
  Glib::PropertyProxy<float> property_xscale() ;
  Glib::PropertyProxy_ReadOnly<float> property_xscale() const;
  Glib::PropertyProxy<float> property_yscale() ;
  Glib::PropertyProxy_ReadOnly<float> property_yscale() const;
  Glib::PropertyProxy<guint> property_top_padding() ;
  Glib::PropertyProxy_ReadOnly<guint> property_top_padding() const;
  Glib::PropertyProxy<guint> property_bottom_padding() ;
  Glib::PropertyProxy_ReadOnly<guint> property_bottom_padding() const;
  Glib::PropertyProxy<guint> property_left_padding() ;
  Glib::PropertyProxy_ReadOnly<guint> property_left_padding() const;
  Glib::PropertyProxy<guint> property_right_padding() ;
  Glib::PropertyProxy_ReadOnly<guint> property_right_padding() const;
};
}
namespace Glib
{
  Gtk::Alignment* wrap(GtkAlignment* object, bool take_copy = false);
}
typedef struct _GtkMisc GtkMisc;
typedef struct _GtkMiscClass GtkMiscClass;
namespace Gtk
{ class Misc_Class; }
namespace Gtk
{
class Misc : public Widget
{
  public:
  typedef Misc CppObjectType;
  typedef Misc_Class CppClassType;
  typedef GtkMisc BaseObjectType;
  typedef GtkMiscClass BaseClassType;
  virtual ~Misc();
private:
  friend class Misc_Class;
  static CppClassType misc_class_;
  Misc(const Misc&);
  Misc& operator=(const Misc&);
protected:
  explicit Misc(const Glib::ConstructParams& construct_params);
  explicit Misc(GtkMisc* castitem);
public:
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkMisc* gobj() { return reinterpret_cast<GtkMisc*>(gobject_); }
  const GtkMisc* gobj() const { return reinterpret_cast<GtkMisc*>(gobject_); }
public:
protected:
private:
protected:
  Misc();
public:
  void set_alignment(float xalign = 0.0, float yalign = 0.5);
  void set_alignment(AlignmentEnum xalign = Gtk::ALIGN_LEFT, AlignmentEnum yalign = Gtk::ALIGN_CENTER);
  void get_alignment(float& xalign, float& yalign) const;
  void set_padding(int xpad, int ypad);
  void get_padding(int& xpad, int& ypad) const;
  Glib::PropertyProxy<float> property_xalign() ;
  Glib::PropertyProxy_ReadOnly<float> property_xalign() const;
  Glib::PropertyProxy<float> property_yalign() ;
  Glib::PropertyProxy_ReadOnly<float> property_yalign() const;
  Glib::PropertyProxy<int> property_xpad() ;
  Glib::PropertyProxy_ReadOnly<int> property_xpad() const;
  Glib::PropertyProxy<int> property_ypad() ;
  Glib::PropertyProxy_ReadOnly<int> property_ypad() const;
};
}
namespace Glib
{
  Gtk::Misc* wrap(GtkMisc* object, bool take_copy = false);
}
typedef struct _GtkArrow GtkArrow;
typedef struct _GtkArrowClass GtkArrowClass;
namespace Gtk
{ class Arrow_Class; }
namespace Gtk
{
class Arrow : public Misc {
  public:
  typedef Arrow CppObjectType;
  typedef Arrow_Class CppClassType;
  typedef GtkArrow BaseObjectType;
  typedef GtkArrowClass BaseClassType;
  virtual ~Arrow();
private:
  friend class Arrow_Class;
  static CppClassType arrow_class_;
  Arrow(const Arrow&);
  Arrow& operator=(const Arrow&);
protected:
  explicit Arrow(const Glib::ConstructParams& construct_params);
  explicit Arrow(GtkArrow* castitem);
public:
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkArrow* gobj() { return reinterpret_cast<GtkArrow*>(gobject_); }
  const GtkArrow* gobj() const { return reinterpret_cast<GtkArrow*>(gobject_); }
public:
protected:
private:
public:
  explicit Arrow(ArrowType arrow_type, ShadowType shadow_type);
  void set(ArrowType arrow_type, ShadowType shadow_type);
  Glib::PropertyProxy<ArrowType> property_arrow_type() ;
  Glib::PropertyProxy_ReadOnly<ArrowType> property_arrow_type() const;
  Glib::PropertyProxy<ShadowType> property_shadow_type() ;
  Glib::PropertyProxy_ReadOnly<ShadowType> property_shadow_type() const;
};
}
namespace Glib
{
  Gtk::Arrow* wrap(GtkArrow* object, bool take_copy = false);
}
typedef struct _GtkFrame GtkFrame;
typedef struct _GtkFrameClass GtkFrameClass;
namespace Gtk
{ class Frame_Class; }
namespace Gtk
{
class Frame : public Bin
{
  public:
  typedef Frame CppObjectType;
  typedef Frame_Class CppClassType;
  typedef GtkFrame BaseObjectType;
  typedef GtkFrameClass BaseClassType;
  virtual ~Frame();
private:
  friend class Frame_Class;
  static CppClassType frame_class_;
  Frame(const Frame&);
  Frame& operator=(const Frame&);
protected:
  explicit Frame(const Glib::ConstructParams& construct_params);
  explicit Frame(GtkFrame* castitem);
public:
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkFrame* gobj() { return reinterpret_cast<GtkFrame*>(gobject_); }
  const GtkFrame* gobj() const { return reinterpret_cast<GtkFrame*>(gobject_); }
public:
protected:
private:
public:
  Frame();
  explicit Frame(const Glib::ustring& label);
  void set_label(const Glib::ustring& label);
  void unset_label();
  Glib::ustring get_label() const;
  void set_label_widget(Widget& label_widget);
  Widget* get_label_widget();
  const Widget* get_label_widget() const;
  void set_label_align(float xalign = 0.0, float yalign = 0.5);
  void set_label_align(AlignmentEnum xalign, AlignmentEnum yalign = Gtk::ALIGN_CENTER);
  void get_label_align(float& xalign, float& yalign) const;
  void set_shadow_type(ShadowType type);
  ShadowType get_shadow_type() const;
  Glib::PropertyProxy<Glib::ustring> property_label() ;
  Glib::PropertyProxy_ReadOnly<Glib::ustring> property_label() const;
  Glib::PropertyProxy<double> property_label_xalign() ;
  Glib::PropertyProxy_ReadOnly<double> property_label_xalign() const;
  Glib::PropertyProxy<double> property_label_yalign() ;
  Glib::PropertyProxy_ReadOnly<double> property_label_yalign() const;
  Glib::PropertyProxy<ShadowType> property_shadow_type() ;
  Glib::PropertyProxy_ReadOnly<ShadowType> property_shadow_type() const;
  Glib::PropertyProxy<Widget*> property_label_widget() ;
  Glib::PropertyProxy_ReadOnly<Widget*> property_label_widget() const;
protected:
  virtual void compute_child_allocation_vfunc(Allocation& allocation);
};
}
namespace Glib
{
  Gtk::Frame* wrap(GtkFrame* object, bool take_copy = false);
}
typedef struct _GtkAspectFrame GtkAspectFrame;
typedef struct _GtkAspectFrameClass GtkAspectFrameClass;
namespace Gtk
{ class AspectFrame_Class; }
namespace Gtk
{
class AspectFrame : public Frame
{
  public:
  typedef AspectFrame CppObjectType;
  typedef AspectFrame_Class CppClassType;
  typedef GtkAspectFrame BaseObjectType;
  typedef GtkAspectFrameClass BaseClassType;
  virtual ~AspectFrame();
private:
  friend class AspectFrame_Class;
  static CppClassType aspectframe_class_;
  AspectFrame(const AspectFrame&);
  AspectFrame& operator=(const AspectFrame&);
protected:
  explicit AspectFrame(const Glib::ConstructParams& construct_params);
  explicit AspectFrame(GtkAspectFrame* castitem);
public:
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkAspectFrame* gobj() { return reinterpret_cast<GtkAspectFrame*>(gobject_); }
  const GtkAspectFrame* gobj() const { return reinterpret_cast<GtkAspectFrame*>(gobject_); }
public:
protected:
private:
public:
  explicit AspectFrame(const Glib::ustring& label = Glib::ustring(),
    AlignmentEnum xalign = Gtk::ALIGN_CENTER, AlignmentEnum yalign = Gtk::ALIGN_CENTER,
    float ratio = 1.0, bool obey_child = false);
  explicit AspectFrame(const Glib::ustring& label,
    float xalign, float yalign,
    float ratio = 1.0, bool obey_child = false);
  void set(float xalign, float yalign, float ratio, bool obey_child = true);
  void set(AlignmentEnum xalign, AlignmentEnum yalign, float ratio, bool obey_child = true);
  Glib::PropertyProxy<float> property_xalign() ;
  Glib::PropertyProxy_ReadOnly<float> property_xalign() const;
  Glib::PropertyProxy<float> property_yalign() ;
  Glib::PropertyProxy_ReadOnly<float> property_yalign() const;
  Glib::PropertyProxy<float> property_ratio() ;
  Glib::PropertyProxy_ReadOnly<float> property_ratio() const;
  Glib::PropertyProxy<bool> property_obey_child() ;
  Glib::PropertyProxy_ReadOnly<bool> property_obey_child() const;
};
}
namespace Glib
{
  Gtk::AspectFrame* wrap(GtkAspectFrame* object, bool take_copy = false);
}
typedef struct _GtkAssistant GtkAssistant;
typedef struct _GtkAssistantClass GtkAssistantClass;
namespace Gtk
{ class Assistant_Class; }
namespace Gtk
{
enum AssistantPageType
{
  ASSISTANT_PAGE_CONTENT,
  ASSISTANT_PAGE_INTRO,
  ASSISTANT_PAGE_CONFIRM,
  ASSISTANT_PAGE_SUMMARY,
  ASSISTANT_PAGE_PROGRESS
};
}
namespace Glib
{
template <>
class Value<Gtk::AssistantPageType> : public Glib::Value_Enum<Gtk::AssistantPageType>
{
public:
  static GType value_type() __attribute__((__const__));
};
}
namespace Gtk
{
class Assistant : public Window
{
  public:
  typedef Assistant CppObjectType;
  typedef Assistant_Class CppClassType;
  typedef GtkAssistant BaseObjectType;
  typedef GtkAssistantClass BaseClassType;
  virtual ~Assistant();
private:
  friend class Assistant_Class;
  static CppClassType assistant_class_;
  Assistant(const Assistant&);
  Assistant& operator=(const Assistant&);
protected:
  explicit Assistant(const Glib::ConstructParams& construct_params);
  explicit Assistant(GtkAssistant* castitem);
public:
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkAssistant* gobj() { return reinterpret_cast<GtkAssistant*>(gobject_); }
  const GtkAssistant* gobj() const { return reinterpret_cast<GtkAssistant*>(gobject_); }
public:
protected:
  virtual void on_prepare(Gtk::Widget* page);
  virtual void on_apply();
  virtual void on_close();
  virtual void on_cancel();
private:
public:
  Assistant();
  int get_current_page() const;
  void set_current_page(int page_num);
  int get_n_pages() const;
  Widget* get_nth_page(int page_num);
  const Widget* get_nth_page(int page_num) const;
  int prepend_page(Widget& page);
  int append_page(Widget& page);
  int insert_page(Widget& page, int position);
  typedef sigc::slot<int, int > SlotForwardPage;
  void set_forward_page_func(const SlotForwardPage& slot);
  void set_page_type(const Widget& page, AssistantPageType type);
  AssistantPageType get_page_type(const Widget& page) const;
  void set_page_title(const Widget& page, const Glib::ustring& title);
  Glib::ustring get_page_title(const Widget& page) const;
  void set_page_header_image(const Widget& page, const Glib::RefPtr<Gdk::Pixbuf>& pixbuf);
  Glib::RefPtr<Gdk::Pixbuf> get_page_header_image(const Widget& page);
  Glib::RefPtr<const Gdk::Pixbuf> get_page_header_image(const Widget& page) const;
  void set_page_side_image(const Widget& page, const Glib::RefPtr<Gdk::Pixbuf>& pixbuf);
  Glib::RefPtr<Gdk::Pixbuf> get_page_side_image(const Widget& page);
  Glib::RefPtr<const Gdk::Pixbuf> get_page_side_image(const Widget& page) const;
  void set_page_complete(const Widget& page, bool complete = true);
  bool get_page_complete(const Widget& page) const;
  void add_action_widget(Widget& child);
  void remove_action_widget(Widget& child);
  void update_buttons_state();
  Glib::SignalProxy1< void,Gtk::Widget* > signal_prepare();
  Glib::SignalProxy0< void > signal_apply();
  Glib::SignalProxy0< void > signal_close();
  Glib::SignalProxy0< void > signal_cancel();
};
}
namespace Glib
{
  Gtk::Assistant* wrap(GtkAssistant* object, bool take_copy = false);
}
typedef struct _GtkBuilder GtkBuilder;
typedef struct _GtkBuilderClass GtkBuilderClass;
namespace Gtk
{ class Builder_Class; }
namespace Gtk
{
class BuilderError : public Glib::Error
{
public:
  enum Code
  {
    INVALID_TYPE_FUNCTION,
    UNHANDLED_TAG,
    MISSING_ATTRIBUTE,
    INVALID_ATTRIBUTE,
    INVALID_TAG,
    MISSING_PROPERTY_VALUE,
    INVALID_VALUE
  };
  BuilderError(Code error_code, const Glib::ustring& error_message);
  explicit BuilderError(GError* gobject);
  Code code() const;
private:
  static void throw_func(GError* gobject);
  friend void wrap_init();
};
}
namespace Glib
{
template <>
class Value<Gtk::BuilderError::Code> : public Glib::Value_Enum<Gtk::BuilderError::Code>
{
public:
  static GType value_type() __attribute__((__const__));
};
}
namespace Gtk
{
class Builder : public Glib::Object
{
public:
  typedef Builder CppObjectType;
  typedef Builder_Class CppClassType;
  typedef GtkBuilder BaseObjectType;
  typedef GtkBuilderClass BaseClassType;
private: friend class Builder_Class;
  static CppClassType builder_class_;
private:
  Builder(const Builder&);
  Builder& operator=(const Builder&);
protected:
  explicit Builder(const Glib::ConstructParams& construct_params);
  explicit Builder(GtkBuilder* castitem);
public:
  virtual ~Builder();
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkBuilder* gobj() { return reinterpret_cast<GtkBuilder*>(gobject_); }
  const GtkBuilder* gobj() const { return reinterpret_cast<GtkBuilder*>(gobject_); }
  GtkBuilder* gobj_copy();
private:
protected:
 Builder();
public:
  static Glib::RefPtr<Builder> create();
  static Glib::RefPtr<Builder> create_from_file(const std::string& filename);
  static Glib::RefPtr<Builder> create_from_string(const Glib::ustring& buffer);
  bool add_from_file(const std::string& filename);
  bool add_from_string(const Glib::ustring& buffer);
  bool add_from_string(const char* buffer, gsize length);
  Glib::RefPtr<Glib::Object> get_object(const Glib::ustring& name);
  template <class T_Widget> inline
  void get_widget(const Glib::ustring& name, T_Widget*& widget)
  {
    widget = 0;
    widget = dynamic_cast<T_Widget*>(this->get_widget_checked(name, T_Widget::get_base_type()));
    if(!widget)
      g_log (((gchar*) 0), G_LOG_LEVEL_CRITICAL, "Gtk::Builder::get_widget(): dynamic_cast<> failed.");
  }
  template <class T_Widget> inline
  void get_widget_derived(const Glib::ustring& name, T_Widget*& widget)
  {
     widget = 0;
     typedef typename T_Widget::BaseObjectType cwidget_type;
     cwidget_type* pCWidget = (cwidget_type*)get_cwidget(name);
     if(!pCWidget)
       return;
     Glib::ObjectBase* pObjectBase = ObjectBase::_get_current_wrapper((GObject*)pCWidget);
     if(pObjectBase)
     {
       widget = dynamic_cast<T_Widget*>( Glib::wrap((GtkWidget*)pCWidget) );
       if(!widget)
        g_log (((gchar*) 0), G_LOG_LEVEL_CRITICAL, "Gtk::Builder::get_widget_derived(): dynamic_cast<> failed. An existing C++ instance, of a different type, seems to exist.");
     }
     else
     {
       Glib::RefPtr<Gtk::Builder> refThis(this);
       refThis->reference();
       widget = new T_Widget(pCWidget, refThis);
     }
  }
  void set_translation_domain(const Glib::ustring& domain);
  Glib::ustring get_translation_domain() const;
protected:
  Gtk::Widget* get_widget_checked(const Glib::ustring& name, GType type);
  GtkWidget* get_cwidget(const Glib::ustring& name);
public:
public:
protected:
};
}
namespace Glib
{
  Glib::RefPtr<Gtk::Builder> wrap(GtkBuilder* object, bool take_copy = false);
}
extern "C"
{
typedef struct _GtkCellEditableIface GtkCellEditableIface;
typedef union _GdkEvent GdkEvent;
}
typedef struct _GtkCellEditable GtkCellEditable;
typedef struct _GtkCellEditableClass GtkCellEditableClass;
namespace Gtk
{ class CellEditable_Class; }
namespace Gtk
{
class CellEditable : public Glib::Interface
{
public:
  typedef CellEditable CppObjectType;
  typedef CellEditable_Class CppClassType;
  typedef GtkCellEditable BaseObjectType;
  typedef GtkCellEditableIface BaseClassType;
private:
  friend class CellEditable_Class;
  static CppClassType celleditable_class_;
  CellEditable(const CellEditable&);
  CellEditable& operator=(const CellEditable&);
protected:
  CellEditable();
public:
  explicit CellEditable(GtkCellEditable* castitem);
protected:
public:
  virtual ~CellEditable();
  static void add_interface(GType gtype_implementer);
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkCellEditable* gobj() { return reinterpret_cast<GtkCellEditable*>(gobject_); }
  const GtkCellEditable* gobj() const { return reinterpret_cast<GtkCellEditable*>(gobject_); }
private:
public:
  void start_editing(GdkEvent* event);
  void editing_done();
  void remove_widget();
  Glib::SignalProxy0< void > signal_editing_done();
  Glib::SignalProxy0< void > signal_remove_widget();
protected:
  virtual void start_editing_vfunc(GdkEvent* event);
public:
public:
protected:
  virtual void on_editing_done();
  virtual void on_remove_widget();
};
}
namespace Glib
{
  Glib::RefPtr<Gtk::CellEditable> wrap(GtkCellEditable* object, bool take_copy = false);
}
typedef struct _GtkCellRenderer GtkCellRenderer;
typedef struct _GtkCellRendererClass GtkCellRendererClass;
namespace Gtk
{ class CellRenderer_Class; }
namespace Gtk
{
enum CellRendererState
{
  CELL_RENDERER_SELECTED = 1 << 0,
  CELL_RENDERER_PRELIT = 1 << 1,
  CELL_RENDERER_INSENSITIVE = 1 << 2,
  CELL_RENDERER_SORTED = 1 << 3,
  CELL_RENDERER_FOCUSED = 1 << 4
};
inline CellRendererState operator|(CellRendererState lhs, CellRendererState rhs)
  { return static_cast<CellRendererState>(static_cast<unsigned>(lhs) | static_cast<unsigned>(rhs)); }
inline CellRendererState operator&(CellRendererState lhs, CellRendererState rhs)
  { return static_cast<CellRendererState>(static_cast<unsigned>(lhs) & static_cast<unsigned>(rhs)); }
inline CellRendererState operator^(CellRendererState lhs, CellRendererState rhs)
  { return static_cast<CellRendererState>(static_cast<unsigned>(lhs) ^ static_cast<unsigned>(rhs)); }
inline CellRendererState operator~(CellRendererState flags)
  { return static_cast<CellRendererState>(~static_cast<unsigned>(flags)); }
inline CellRendererState& operator|=(CellRendererState& lhs, CellRendererState rhs)
  { return (lhs = static_cast<CellRendererState>(static_cast<unsigned>(lhs) | static_cast<unsigned>(rhs))); }
inline CellRendererState& operator&=(CellRendererState& lhs, CellRendererState rhs)
  { return (lhs = static_cast<CellRendererState>(static_cast<unsigned>(lhs) & static_cast<unsigned>(rhs))); }
inline CellRendererState& operator^=(CellRendererState& lhs, CellRendererState rhs)
  { return (lhs = static_cast<CellRendererState>(static_cast<unsigned>(lhs) ^ static_cast<unsigned>(rhs))); }
}
namespace Glib
{
template <>
class Value<Gtk::CellRendererState> : public Glib::Value_Flags<Gtk::CellRendererState>
{
public:
  static GType value_type() __attribute__((__const__));
};
}
namespace Gtk
{
enum CellRendererMode
{
  CELL_RENDERER_MODE_INERT,
  CELL_RENDERER_MODE_ACTIVATABLE,
  CELL_RENDERER_MODE_EDITABLE
};
}
namespace Glib
{
template <>
class Value<Gtk::CellRendererMode> : public Glib::Value_Enum<Gtk::CellRendererMode>
{
public:
  static GType value_type() __attribute__((__const__));
};
}
namespace Gtk
{
class CellRenderer : public Gtk::Object
{
  public:
  typedef CellRenderer CppObjectType;
  typedef CellRenderer_Class CppClassType;
  typedef GtkCellRenderer BaseObjectType;
  typedef GtkCellRendererClass BaseClassType;
  virtual ~CellRenderer();
private:
  friend class CellRenderer_Class;
  static CppClassType cellrenderer_class_;
  CellRenderer(const CellRenderer&);
  CellRenderer& operator=(const CellRenderer&);
protected:
  explicit CellRenderer(const Glib::ConstructParams& construct_params);
  explicit CellRenderer(GtkCellRenderer* castitem);
public:
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkCellRenderer* gobj() { return reinterpret_cast<GtkCellRenderer*>(gobject_); }
  const GtkCellRenderer* gobj() const { return reinterpret_cast<GtkCellRenderer*>(gobject_); }
public:
protected:
  virtual void on_editing_canceled();
private:
public:
  void get_size(
                  Widget& widget,
                  const Gdk::Rectangle& cell_area,
                  int& x_offset, int& y_offset,
                  int& width, int& height) const;
  void get_size(Widget& widget, int& x_offset, int& y_offset, int& width, int& height) const;
  void render(
                  const Glib::RefPtr<Gdk::Window>& window,
                  Widget& widget,
                  const Gdk::Rectangle& background_area,
                  const Gdk::Rectangle& cell_area,
                  const Gdk::Rectangle& expose_area,
                  CellRendererState flags);
  bool activate(
                  GdkEvent* event,
                  Widget& widget,
                  const Glib::ustring& path,
                  const Gdk::Rectangle& background_area,
                  const Gdk::Rectangle& cell_area,
                  CellRendererState flags);
  CellEditable* start_editing(
                  GdkEvent* event, Widget& widget,
                  const Glib::ustring& path,
                  const Gdk::Rectangle& background_area,
                  const Gdk::Rectangle& cell_area,
                  CellRendererState flags = CellRendererState(0));
  void set_fixed_size(int width, int height);
  void get_fixed_size(int& width, int& height) const;
  void editing_canceled();
  void stop_editing(bool canceled = false);
  virtual Glib::PropertyProxy_Base _property_renderable();
  Glib::SignalProxy0< void > signal_editing_canceled();
  Glib::SignalProxy2< void,CellEditable*,const Glib::ustring& > signal_editing_started();
  Glib::PropertyProxy<CellRendererMode> property_mode() ;
  Glib::PropertyProxy_ReadOnly<CellRendererMode> property_mode() const;
  Glib::PropertyProxy<bool> property_visible() ;
  Glib::PropertyProxy_ReadOnly<bool> property_visible() const;
  Glib::PropertyProxy<bool> property_sensitive() ;
  Glib::PropertyProxy_ReadOnly<bool> property_sensitive() const;
  Glib::PropertyProxy<float> property_xalign() ;
  Glib::PropertyProxy_ReadOnly<float> property_xalign() const;
  Glib::PropertyProxy<float> property_yalign() ;
  Glib::PropertyProxy_ReadOnly<float> property_yalign() const;
  Glib::PropertyProxy<unsigned int> property_xpad() ;
  Glib::PropertyProxy_ReadOnly<unsigned int> property_xpad() const;
  Glib::PropertyProxy<unsigned int> property_ypad() ;
  Glib::PropertyProxy_ReadOnly<unsigned int> property_ypad() const;
  Glib::PropertyProxy<int> property_width() ;
  Glib::PropertyProxy_ReadOnly<int> property_width() const;
  Glib::PropertyProxy<int> property_height() ;
  Glib::PropertyProxy_ReadOnly<int> property_height() const;
  Glib::PropertyProxy<bool> property_is_expander() ;
  Glib::PropertyProxy_ReadOnly<bool> property_is_expander() const;
  Glib::PropertyProxy<bool> property_is_expanded() ;
  Glib::PropertyProxy_ReadOnly<bool> property_is_expanded() const;
  Glib::PropertyProxy_WriteOnly<Glib::ustring> property_cell_background() ;
  Glib::PropertyProxy<Gdk::Color> property_cell_background_gdk() ;
  Glib::PropertyProxy_ReadOnly<Gdk::Color> property_cell_background_gdk() const;
  Glib::PropertyProxy<bool> property_cell_background_set() ;
  Glib::PropertyProxy_ReadOnly<bool> property_cell_background_set() const;
protected:
  CellRenderer();
  virtual void get_size_vfunc(Widget& widget, const Gdk::Rectangle* cell_area, int* x_offset, int* y_offset, int* width, int* height) const;
  virtual void render_vfunc(const Glib::RefPtr<Gdk::Drawable>& window, Widget& widget, const Gdk::Rectangle& background_area, const Gdk::Rectangle& cell_area, const Gdk::Rectangle& expose_area, CellRendererState flags);
  virtual bool activate_vfunc(GdkEvent* event, Widget& widget, const Glib::ustring& path, const Gdk::Rectangle& background_area, const Gdk::Rectangle& cell_area, CellRendererState flags);
  virtual CellEditable* start_editing_vfunc(GdkEvent* event, Widget& widget, const Glib::ustring& path, const Gdk::Rectangle& background_area, const Gdk::Rectangle& cell_area, CellRendererState flags);
};
}
namespace Glib
{
  Gtk::CellRenderer* wrap(GtkCellRenderer* object, bool take_copy = false);
}
typedef struct _GtkCellRendererText GtkCellRendererText;
typedef struct _GtkCellRendererTextClass GtkCellRendererTextClass;
namespace Gtk
{ class CellRendererText_Class; }
namespace Gtk
{
class CellRendererText : public CellRenderer
{
  public:
  typedef CellRendererText CppObjectType;
  typedef CellRendererText_Class CppClassType;
  typedef GtkCellRendererText BaseObjectType;
  typedef GtkCellRendererTextClass BaseClassType;
  virtual ~CellRendererText();
private:
  friend class CellRendererText_Class;
  static CppClassType cellrenderertext_class_;
  CellRendererText(const CellRendererText&);
  CellRendererText& operator=(const CellRendererText&);
protected:
  explicit CellRendererText(const Glib::ConstructParams& construct_params);
  explicit CellRendererText(GtkCellRendererText* castitem);
public:
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkCellRendererText* gobj() { return reinterpret_cast<GtkCellRendererText*>(gobject_); }
  const GtkCellRendererText* gobj() const { return reinterpret_cast<GtkCellRendererText*>(gobject_); }
public:
protected:
  virtual void on_edited(const Glib::ustring& path, const Glib::ustring& new_text);
private:
public:
  CellRendererText();
  void set_fixed_height_from_font(int number_of_rows);
  Glib::SignalProxy2< void,const Glib::ustring&,const Glib::ustring& > signal_edited();
  Glib::PropertyProxy<Glib::ustring> property_text() ;
  Glib::PropertyProxy_ReadOnly<Glib::ustring> property_text() const;
  Glib::PropertyProxy_WriteOnly<Glib::ustring> property_markup() ;
  Glib::PropertyProxy<Pango::AttrList> property_attributes() ;
  Glib::PropertyProxy_ReadOnly<Pango::AttrList> property_attributes() const;
  Glib::PropertyProxy_WriteOnly<Glib::ustring> property_background() ;
  Glib::PropertyProxy_WriteOnly<Glib::ustring> property_foreground() ;
  Glib::PropertyProxy<Gdk::Color> property_background_gdk() ;
  Glib::PropertyProxy_ReadOnly<Gdk::Color> property_background_gdk() const;
  Glib::PropertyProxy<Gdk::Color> property_foreground_gdk() ;
  Glib::PropertyProxy_ReadOnly<Gdk::Color> property_foreground_gdk() const;
  Glib::PropertyProxy<Glib::ustring> property_font() ;
  Glib::PropertyProxy_ReadOnly<Glib::ustring> property_font() const;
  Glib::PropertyProxy<Pango::FontDescription> property_font_desc() ;
  Glib::PropertyProxy_ReadOnly<Pango::FontDescription> property_font_desc() const;
  Glib::PropertyProxy<Glib::ustring> property_family() ;
  Glib::PropertyProxy_ReadOnly<Glib::ustring> property_family() const;
  Glib::PropertyProxy<Pango::Style> property_style() ;
  Glib::PropertyProxy_ReadOnly<Pango::Style> property_style() const;
  Glib::PropertyProxy<Pango::Variant> property_variant() ;
  Glib::PropertyProxy_ReadOnly<Pango::Variant> property_variant() const;
  Glib::PropertyProxy<int> property_weight() ;
  Glib::PropertyProxy_ReadOnly<int> property_weight() const;
  Glib::PropertyProxy<Pango::Stretch> property_stretch() ;
  Glib::PropertyProxy_ReadOnly<Pango::Stretch> property_stretch() const;
  Glib::PropertyProxy<int> property_size() ;
  Glib::PropertyProxy_ReadOnly<int> property_size() const;
  Glib::PropertyProxy<double> property_size_points() ;
  Glib::PropertyProxy_ReadOnly<double> property_size_points() const;
  Glib::PropertyProxy<double> property_scale() ;
  Glib::PropertyProxy_ReadOnly<double> property_scale() const;
  Glib::PropertyProxy<bool> property_editable() ;
  Glib::PropertyProxy_ReadOnly<bool> property_editable() const;
  Glib::PropertyProxy<bool> property_strikethrough() ;
  Glib::PropertyProxy_ReadOnly<bool> property_strikethrough() const;
  Glib::PropertyProxy<Pango::Underline> property_underline() ;
  Glib::PropertyProxy_ReadOnly<Pango::Underline> property_underline() const;
  Glib::PropertyProxy<int> property_rise() ;
  Glib::PropertyProxy_ReadOnly<int> property_rise() const;
  Glib::PropertyProxy<Glib::ustring> property_language() ;
  Glib::PropertyProxy_ReadOnly<Glib::ustring> property_language() const;
  Glib::PropertyProxy<Pango::EllipsizeMode> property_ellipsize() ;
  Glib::PropertyProxy_ReadOnly<Pango::EllipsizeMode> property_ellipsize() const;
  Glib::PropertyProxy<int> property_width_chars() ;
  Glib::PropertyProxy_ReadOnly<int> property_width_chars() const;
  Glib::PropertyProxy<Pango::WrapMode> property_wrap_mode() ;
  Glib::PropertyProxy_ReadOnly<Pango::WrapMode> property_wrap_mode() const;
  Glib::PropertyProxy<int> property_wrap_width() ;
  Glib::PropertyProxy_ReadOnly<int> property_wrap_width() const;
  Glib::PropertyProxy<Pango::Alignment> property_alignment() ;
  Glib::PropertyProxy_ReadOnly<Pango::Alignment> property_alignment() const;
  Glib::PropertyProxy<bool> property_background_set() ;
  Glib::PropertyProxy_ReadOnly<bool> property_background_set() const;
  Glib::PropertyProxy<bool> property_foreground_set() ;
  Glib::PropertyProxy_ReadOnly<bool> property_foreground_set() const;
  Glib::PropertyProxy<bool> property_family_set() ;
  Glib::PropertyProxy_ReadOnly<bool> property_family_set() const;
  Glib::PropertyProxy<bool> property_style_set() ;
  Glib::PropertyProxy_ReadOnly<bool> property_style_set() const;
  Glib::PropertyProxy<bool> property_variant_set() ;
  Glib::PropertyProxy_ReadOnly<bool> property_variant_set() const;
  Glib::PropertyProxy<bool> property_weight_set() ;
  Glib::PropertyProxy_ReadOnly<bool> property_weight_set() const;
  Glib::PropertyProxy<bool> property_stretch_set() ;
  Glib::PropertyProxy_ReadOnly<bool> property_stretch_set() const;
  Glib::PropertyProxy<bool> property_size_set() ;
  Glib::PropertyProxy_ReadOnly<bool> property_size_set() const;
  Glib::PropertyProxy<bool> property_scale_set() ;
  Glib::PropertyProxy_ReadOnly<bool> property_scale_set() const;
  Glib::PropertyProxy<bool> property_editable_set() ;
  Glib::PropertyProxy_ReadOnly<bool> property_editable_set() const;
  Glib::PropertyProxy<bool> property_strikethrough_set() ;
  Glib::PropertyProxy_ReadOnly<bool> property_strikethrough_set() const;
  Glib::PropertyProxy<bool> property_underline_set() ;
  Glib::PropertyProxy_ReadOnly<bool> property_underline_set() const;
  Glib::PropertyProxy<bool> property_rise_set() ;
  Glib::PropertyProxy_ReadOnly<bool> property_rise_set() const;
  Glib::PropertyProxy<bool> property_language_set() ;
  Glib::PropertyProxy_ReadOnly<bool> property_language_set() const;
  Glib::PropertyProxy<bool> property_ellipsize_set() ;
  Glib::PropertyProxy_ReadOnly<bool> property_ellipsize_set() const;
  Glib::PropertyProxy<bool> property_single_paragraph_mode() ;
  Glib::PropertyProxy_ReadOnly<bool> property_single_paragraph_mode() const;
  virtual Glib::PropertyProxy_Base _property_renderable();
protected:
  void edited(const Glib::ustring& path, const Glib::ustring& new_text);
};
}
namespace Glib
{
  Gtk::CellRendererText* wrap(GtkCellRendererText* object, bool take_copy = false);
}
typedef struct _GtkCellRendererPixbuf GtkCellRendererPixbuf;
typedef struct _GtkCellRendererPixbufClass GtkCellRendererPixbufClass;
namespace Gtk
{ class CellRendererPixbuf_Class; }
namespace Gtk
{
class CellRendererPixbuf : public CellRenderer
{
  public:
  typedef CellRendererPixbuf CppObjectType;
  typedef CellRendererPixbuf_Class CppClassType;
  typedef GtkCellRendererPixbuf BaseObjectType;
  typedef GtkCellRendererPixbufClass BaseClassType;
  virtual ~CellRendererPixbuf();
private:
  friend class CellRendererPixbuf_Class;
  static CppClassType cellrendererpixbuf_class_;
  CellRendererPixbuf(const CellRendererPixbuf&);
  CellRendererPixbuf& operator=(const CellRendererPixbuf&);
protected:
  explicit CellRendererPixbuf(const Glib::ConstructParams& construct_params);
  explicit CellRendererPixbuf(GtkCellRendererPixbuf* castitem);
public:
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkCellRendererPixbuf* gobj() { return reinterpret_cast<GtkCellRendererPixbuf*>(gobject_); }
  const GtkCellRendererPixbuf* gobj() const { return reinterpret_cast<GtkCellRendererPixbuf*>(gobject_); }
public:
protected:
private:
public:
  CellRendererPixbuf();
  Glib::PropertyProxy< Glib::RefPtr<Gdk::Pixbuf> > property_pixbuf() ;
  Glib::PropertyProxy_ReadOnly< Glib::RefPtr<Gdk::Pixbuf> > property_pixbuf() const;
  Glib::PropertyProxy< Glib::RefPtr<Gdk::Pixbuf> > property_pixbuf_expander_open() ;
  Glib::PropertyProxy_ReadOnly< Glib::RefPtr<Gdk::Pixbuf> > property_pixbuf_expander_open() const;
  Glib::PropertyProxy< Glib::RefPtr<Gdk::Pixbuf> > property_pixbuf_expander_closed() ;
  Glib::PropertyProxy_ReadOnly< Glib::RefPtr<Gdk::Pixbuf> > property_pixbuf_expander_closed() const;
  Glib::PropertyProxy<Glib::ustring> property_stock_id() ;
  Glib::PropertyProxy_ReadOnly<Glib::ustring> property_stock_id() const;
  Glib::PropertyProxy<guint> property_stock_size() ;
  Glib::PropertyProxy_ReadOnly<guint> property_stock_size() const;
  Glib::PropertyProxy<Glib::ustring> property_stock_detail() ;
  Glib::PropertyProxy_ReadOnly<Glib::ustring> property_stock_detail() const;
  virtual Glib::PropertyProxy_Base _property_renderable();
};
}
namespace Glib
{
  Gtk::CellRendererPixbuf* wrap(GtkCellRendererPixbuf* object, bool take_copy = false);
}
typedef struct _GtkCellRendererToggle GtkCellRendererToggle;
typedef struct _GtkCellRendererToggleClass GtkCellRendererToggleClass;
namespace Gtk
{ class CellRendererToggle_Class; }
namespace Gtk
{
class CellRendererToggle : public CellRenderer
{
  public:
  typedef CellRendererToggle CppObjectType;
  typedef CellRendererToggle_Class CppClassType;
  typedef GtkCellRendererToggle BaseObjectType;
  typedef GtkCellRendererToggleClass BaseClassType;
  virtual ~CellRendererToggle();
private:
  friend class CellRendererToggle_Class;
  static CppClassType cellrenderertoggle_class_;
  CellRendererToggle(const CellRendererToggle&);
  CellRendererToggle& operator=(const CellRendererToggle&);
protected:
  explicit CellRendererToggle(const Glib::ConstructParams& construct_params);
  explicit CellRendererToggle(GtkCellRendererToggle* castitem);
public:
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkCellRendererToggle* gobj() { return reinterpret_cast<GtkCellRendererToggle*>(gobject_); }
  const GtkCellRendererToggle* gobj() const { return reinterpret_cast<GtkCellRendererToggle*>(gobject_); }
public:
protected:
  virtual void on_toggled(const Glib::ustring& path);
private:
public:
  CellRendererToggle();
  bool get_radio() const;
  void set_radio(bool radio = true);
  bool get_active() const;
  void set_active(bool setting = true);
  Glib::SignalProxy1< void,const Glib::ustring& > signal_toggled();
  Glib::PropertyProxy<bool> property_activatable() ;
  Glib::PropertyProxy_ReadOnly<bool> property_activatable() const;
  Glib::PropertyProxy<bool> property_active() ;
  Glib::PropertyProxy_ReadOnly<bool> property_active() const;
  Glib::PropertyProxy<bool> property_radio() ;
  Glib::PropertyProxy_ReadOnly<bool> property_radio() const;
  Glib::PropertyProxy<int> property_indicator_size() ;
  Glib::PropertyProxy_ReadOnly<int> property_indicator_size() const;
  virtual Glib::PropertyProxy_Base _property_renderable();
};
}
namespace Glib
{
  Gtk::CellRendererToggle* wrap(GtkCellRendererToggle* object, bool take_copy = false);
}
typedef struct _GtkCellRendererAccel GtkCellRendererAccel;
typedef struct _GtkCellRendererAccelClass GtkCellRendererAccelClass;
namespace Gtk
{ class CellRendererAccel_Class; }
namespace Gtk
{
class CellRendererAccel : public CellRendererText
{
  public:
  typedef CellRendererAccel CppObjectType;
  typedef CellRendererAccel_Class CppClassType;
  typedef GtkCellRendererAccel BaseObjectType;
  typedef GtkCellRendererAccelClass BaseClassType;
  virtual ~CellRendererAccel();
private:
  friend class CellRendererAccel_Class;
  static CppClassType cellrendereraccel_class_;
  CellRendererAccel(const CellRendererAccel&);
  CellRendererAccel& operator=(const CellRendererAccel&);
protected:
  explicit CellRendererAccel(const Glib::ConstructParams& construct_params);
  explicit CellRendererAccel(GtkCellRendererAccel* castitem);
public:
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkCellRendererAccel* gobj() { return reinterpret_cast<GtkCellRendererAccel*>(gobject_); }
  const GtkCellRendererAccel* gobj() const { return reinterpret_cast<GtkCellRendererAccel*>(gobject_); }
public:
protected:
  virtual void on_accel_edited(const Glib::ustring& path_string, guint accel_key, Gdk::ModifierType accel_mods, guint hardware_keycode);
  virtual void on_accel_cleared(const Glib::ustring& path_string);
private:
public:
  CellRendererAccel();
  Glib::SignalProxy4< void,const Glib::ustring&,guint,Gdk::ModifierType,guint > signal_accel_edited();
  Glib::SignalProxy1< void,const Glib::ustring& > signal_accel_cleared();
  Glib::PropertyProxy<guint> property_accel_key() ;
  Glib::PropertyProxy_ReadOnly<guint> property_accel_key() const;
  Glib::PropertyProxy<Gdk::ModifierType> property_accel_mods() ;
  Glib::PropertyProxy_ReadOnly<Gdk::ModifierType> property_accel_mods() const;
  Glib::PropertyProxy<guint> property_keycode() ;
  Glib::PropertyProxy_ReadOnly<guint> property_keycode() const;
  virtual Glib::PropertyProxy_Base _property_renderable();
};
}
namespace Glib
{
  Gtk::CellRendererAccel* wrap(GtkCellRendererAccel* object, bool take_copy = false);
}
namespace Gtk
{
namespace CellRenderer_Generation
{
template<class T_ModelColumnType>
CellRenderer* generate_cellrenderer(bool editable = false)
{
  CellRendererText* pCellRenderer = new CellRendererText();
  pCellRenderer->property_editable() = editable;
  return pCellRenderer;
}
template<>
CellRenderer* generate_cellrenderer<bool>(bool editable);
template<>
CellRenderer* generate_cellrenderer< Glib::RefPtr<Gdk::Pixbuf> >(bool editable);
template<>
CellRenderer* generate_cellrenderer<AccelKey>(bool editable);
}
}
extern "C" {
typedef struct _GtkTreeIter GtkTreeIter;
typedef struct _GtkTreePath GtkTreePath;
typedef struct _GtkTreeRowReference GtkTreeRowReference;
typedef struct _GtkTreeModel GtkTreeModel;
typedef struct _GtkTreeModelIface GtkTreeModelIface;
typedef gboolean (* GtkTreeModelForeachFunc) (GtkTreeModel *model, GtkTreePath *path, GtkTreeIter *iter, gpointer data);
typedef enum
{
  GTK_TREE_MODEL_ITERS_PERSIST = 1 << 0,
  GTK_TREE_MODEL_LIST_ONLY = 1 << 1
} GtkTreeModelFlags;
struct _GtkTreeIter
{
  gint stamp;
  gpointer user_data;
  gpointer user_data2;
  gpointer user_data3;
};
struct _GtkTreeModelIface
{
  GTypeInterface g_iface;
  void (* row_changed) (GtkTreeModel *tree_model,
       GtkTreePath *path,
       GtkTreeIter *iter);
  void (* row_inserted) (GtkTreeModel *tree_model,
       GtkTreePath *path,
       GtkTreeIter *iter);
  void (* row_has_child_toggled) (GtkTreeModel *tree_model,
       GtkTreePath *path,
       GtkTreeIter *iter);
  void (* row_deleted) (GtkTreeModel *tree_model,
       GtkTreePath *path);
  void (* rows_reordered) (GtkTreeModel *tree_model,
       GtkTreePath *path,
       GtkTreeIter *iter,
       gint *new_order);
  GtkTreeModelFlags (* get_flags) (GtkTreeModel *tree_model);
  gint (* get_n_columns) (GtkTreeModel *tree_model);
  GType (* get_column_type) (GtkTreeModel *tree_model,
        gint index_);
  gboolean (* get_iter) (GtkTreeModel *tree_model,
        GtkTreeIter *iter,
        GtkTreePath *path);
  GtkTreePath *(* get_path) (GtkTreeModel *tree_model,
        GtkTreeIter *iter);
  void (* get_value) (GtkTreeModel *tree_model,
        GtkTreeIter *iter,
        gint column,
        GValue *value);
  gboolean (* iter_next) (GtkTreeModel *tree_model,
        GtkTreeIter *iter);
  gboolean (* iter_children) (GtkTreeModel *tree_model,
        GtkTreeIter *iter,
        GtkTreeIter *parent);
  gboolean (* iter_has_child) (GtkTreeModel *tree_model,
        GtkTreeIter *iter);
  gint (* iter_n_children) (GtkTreeModel *tree_model,
        GtkTreeIter *iter);
  gboolean (* iter_nth_child) (GtkTreeModel *tree_model,
        GtkTreeIter *iter,
        GtkTreeIter *parent,
        gint n);
  gboolean (* iter_parent) (GtkTreeModel *tree_model,
        GtkTreeIter *iter,
        GtkTreeIter *child);
  void (* ref_node) (GtkTreeModel *tree_model,
        GtkTreeIter *iter);
  void (* unref_node) (GtkTreeModel *tree_model,
        GtkTreeIter *iter);
};
GtkTreePath *gtk_tree_path_new (void);
GtkTreePath *gtk_tree_path_new_from_string (const gchar *path);
GtkTreePath *gtk_tree_path_new_from_indices (gint first_index,
          ...);
gchar *gtk_tree_path_to_string (GtkTreePath *path);
GtkTreePath *gtk_tree_path_new_first (void);
void gtk_tree_path_append_index (GtkTreePath *path,
          gint index_);
void gtk_tree_path_prepend_index (GtkTreePath *path,
          gint index_);
gint gtk_tree_path_get_depth (GtkTreePath *path);
gint *gtk_tree_path_get_indices (GtkTreePath *path);
void gtk_tree_path_free (GtkTreePath *path);
GtkTreePath *gtk_tree_path_copy (const GtkTreePath *path);
GType gtk_tree_path_get_type (void) __attribute__((__const__));
gint gtk_tree_path_compare (const GtkTreePath *a,
          const GtkTreePath *b);
void gtk_tree_path_next (GtkTreePath *path);
gboolean gtk_tree_path_prev (GtkTreePath *path);
gboolean gtk_tree_path_up (GtkTreePath *path);
void gtk_tree_path_down (GtkTreePath *path);
gboolean gtk_tree_path_is_ancestor (GtkTreePath *path,
                                             GtkTreePath *descendant);
gboolean gtk_tree_path_is_descendant (GtkTreePath *path,
                                             GtkTreePath *ancestor);
GType gtk_tree_row_reference_get_type (void) __attribute__((__const__));
GtkTreeRowReference *gtk_tree_row_reference_new (GtkTreeModel *model,
             GtkTreePath *path);
GtkTreeRowReference *gtk_tree_row_reference_new_proxy (GObject *proxy,
             GtkTreeModel *model,
             GtkTreePath *path);
GtkTreePath *gtk_tree_row_reference_get_path (GtkTreeRowReference *reference);
GtkTreeModel *gtk_tree_row_reference_get_model (GtkTreeRowReference *reference);
gboolean gtk_tree_row_reference_valid (GtkTreeRowReference *reference);
GtkTreeRowReference *gtk_tree_row_reference_copy (GtkTreeRowReference *reference);
void gtk_tree_row_reference_free (GtkTreeRowReference *reference);
void gtk_tree_row_reference_inserted (GObject *proxy,
             GtkTreePath *path);
void gtk_tree_row_reference_deleted (GObject *proxy,
             GtkTreePath *path);
void gtk_tree_row_reference_reordered (GObject *proxy,
             GtkTreePath *path,
             GtkTreeIter *iter,
             gint *new_order);
GtkTreeIter * gtk_tree_iter_copy (GtkTreeIter *iter);
void gtk_tree_iter_free (GtkTreeIter *iter);
GType gtk_tree_iter_get_type (void) __attribute__((__const__));
GType gtk_tree_model_get_type (void) __attribute__((__const__));
GtkTreeModelFlags gtk_tree_model_get_flags (GtkTreeModel *tree_model);
gint gtk_tree_model_get_n_columns (GtkTreeModel *tree_model);
GType gtk_tree_model_get_column_type (GtkTreeModel *tree_model,
        gint index_);
gboolean gtk_tree_model_get_iter (GtkTreeModel *tree_model,
        GtkTreeIter *iter,
        GtkTreePath *path);
gboolean gtk_tree_model_get_iter_from_string (GtkTreeModel *tree_model,
             GtkTreeIter *iter,
             const gchar *path_string);
gchar * gtk_tree_model_get_string_from_iter (GtkTreeModel *tree_model,
                                                       GtkTreeIter *iter);
gboolean gtk_tree_model_get_iter_first (GtkTreeModel *tree_model,
        GtkTreeIter *iter);
GtkTreePath * gtk_tree_model_get_path (GtkTreeModel *tree_model,
        GtkTreeIter *iter);
void gtk_tree_model_get_value (GtkTreeModel *tree_model,
        GtkTreeIter *iter,
        gint column,
        GValue *value);
gboolean gtk_tree_model_iter_next (GtkTreeModel *tree_model,
        GtkTreeIter *iter);
gboolean gtk_tree_model_iter_children (GtkTreeModel *tree_model,
        GtkTreeIter *iter,
        GtkTreeIter *parent);
gboolean gtk_tree_model_iter_has_child (GtkTreeModel *tree_model,
        GtkTreeIter *iter);
gint gtk_tree_model_iter_n_children (GtkTreeModel *tree_model,
        GtkTreeIter *iter);
gboolean gtk_tree_model_iter_nth_child (GtkTreeModel *tree_model,
        GtkTreeIter *iter,
        GtkTreeIter *parent,
        gint n);
gboolean gtk_tree_model_iter_parent (GtkTreeModel *tree_model,
        GtkTreeIter *iter,
        GtkTreeIter *child);
void gtk_tree_model_ref_node (GtkTreeModel *tree_model,
        GtkTreeIter *iter);
void gtk_tree_model_unref_node (GtkTreeModel *tree_model,
        GtkTreeIter *iter);
void gtk_tree_model_get (GtkTreeModel *tree_model,
        GtkTreeIter *iter,
        ...);
void gtk_tree_model_get_valist (GtkTreeModel *tree_model,
        GtkTreeIter *iter,
        va_list var_args);
void gtk_tree_model_foreach (GtkTreeModel *model,
        GtkTreeModelForeachFunc func,
        gpointer user_data);
void gtk_tree_model_row_changed (GtkTreeModel *tree_model,
        GtkTreePath *path,
        GtkTreeIter *iter);
void gtk_tree_model_row_inserted (GtkTreeModel *tree_model,
        GtkTreePath *path,
        GtkTreeIter *iter);
void gtk_tree_model_row_has_child_toggled (GtkTreeModel *tree_model,
        GtkTreePath *path,
        GtkTreeIter *iter);
void gtk_tree_model_row_deleted (GtkTreeModel *tree_model,
        GtkTreePath *path);
void gtk_tree_model_rows_reordered (GtkTreeModel *tree_model,
        GtkTreePath *path,
        GtkTreeIter *iter,
        gint *new_order);
}
namespace Gtk
{
class TreeModelColumnBase;
class TreeModelColumnRecord
{
public:
  TreeModelColumnRecord();
  virtual ~TreeModelColumnRecord();
  void add(TreeModelColumnBase& column);
  unsigned int size() const;
  const GType* types() const;
private:
  std::vector<GType> column_types_;
  TreeModelColumnRecord(const TreeModelColumnRecord&);
  TreeModelColumnRecord& operator=(const TreeModelColumnRecord&);
};
class TreeModelColumnBase
{
public:
  GType type() const { return type_; }
  int index() const { return index_; }
protected:
  explicit TreeModelColumnBase(GType type);
private:
  GType type_;
  int index_;
  friend class Gtk::TreeModelColumnRecord;
};
inline bool operator==(const TreeModelColumnBase& lhs, const TreeModelColumnBase& rhs)
  { return (lhs.index() == rhs.index()); }
inline bool operator!=(const TreeModelColumnBase& lhs, const TreeModelColumnBase& rhs)
  { return (lhs.index() != rhs.index()); }
template <class T>
class TreeModelColumn : public TreeModelColumnBase
{
public:
  typedef T ElementType;
  typedef Glib::Value<T> ValueType;
  TreeModelColumn() : TreeModelColumnBase(ValueType::value_type()) {}
};
}
namespace Gtk
{
class TreeModel;
class TreeRow;
class TreeNodeChildren;
class TreeIterBase
{
  public:
  typedef TreeIterBase CppObjectType;
  typedef GtkTreeIter BaseObjectType;
  static GType get_type() __attribute__((__const__));
  TreeIterBase();
  explicit TreeIterBase(const GtkTreeIter* gobject);
  GtkTreeIter* gobj() { return &gobject_; }
  const GtkTreeIter* gobj() const { return &gobject_; }
protected:
  GtkTreeIter gobject_;
private:
};
class TreeIter : public TreeIterBase
{
public:
  typedef std::bidirectional_iterator_tag iterator_category;
  typedef Gtk::TreeRow value_type;
  typedef int difference_type;
  typedef const Gtk::TreeRow& reference;
  typedef const Gtk::TreeRow* pointer;
  TreeIter();
  TreeIter& operator++();
  const TreeIter operator++(int);
  TreeIter& operator--();
  const TreeIter operator--(int);
  inline reference operator*() const;
  inline pointer operator->() const;
  bool equal(const TreeIter& other) const;
  operator bool() const;
  int get_stamp() const;
  void set_stamp(int stamp);
  explicit TreeIter(TreeModel* model);
  TreeIter(GtkTreeModel* model, const GtkTreeIter* iter);
  void set_model_refptr(const Glib::RefPtr<TreeModel>& model);
  void set_model_gobject(GtkTreeModel* model);
  GtkTreeModel* get_model_gobject() const;
  void setup_end_iterator(const TreeIter& last_valid);
  const GtkTreeIter* get_gobject_if_not_end() const
    { return (!is_end_) ? &gobject_ : 0; }
  const GtkTreeIter* get_parent_gobject_if_end() const
    { return (is_end_ && gobject_.stamp) ? &gobject_ : 0; }
protected:
  TreeModel* model_;
  bool is_end_;
  friend class Gtk::TreeRow;
  friend class Gtk::TreeNodeChildren;
  friend class Gtk::TreeModel;
};
inline bool operator==(const TreeIter& lhs, const TreeIter& rhs)
  { return lhs.equal(rhs); }
inline bool operator!=(const TreeIter& lhs, const TreeIter& rhs)
  { return !lhs.equal(rhs); }
template <class ColumnType>
class TreeValueProxy
{
public:
  inline TreeValueProxy(const TreeRow& row, const TreeModelColumn<ColumnType>& column);
  inline TreeValueProxy<ColumnType>& operator=(const ColumnType& data);
  inline operator ColumnType() const;
private:
  const TreeRow& row_;
  const TreeModelColumn<ColumnType>& column_;
  TreeValueProxy<ColumnType>& operator=(const TreeValueProxy<ColumnType>&);
};
class TreeRow : public TreeIter
{
public:
  template <class ColumnType> inline
  TreeValueProxy<ColumnType> operator[](const TreeModelColumn<ColumnType>& column) const;
  template <class ColumnType>
  void set_value(const TreeModelColumn<ColumnType>& column, const ColumnType& data) const;
  template <class ColumnType>
  void set_value(int column, const ColumnType& data) const;
  template <class ColumnType>
  ColumnType get_value(const TreeModelColumn<ColumnType>& column) const;
  template <class ColumnType>
  void get_value(int column, ColumnType& data) const;
  const TreeNodeChildren& children() const;
  TreeIter parent() const;
  operator bool() const;
  GtkTreeIter* gobj() { return TreeIter::gobj(); }
  const GtkTreeIter* gobj() const { return TreeIter::gobj(); }
private:
  void set_value_impl(int column, const Glib::ValueBase& value) const;
  void get_value_impl(int column, Glib::ValueBase& value) const;
};
class TreeNodeChildren : public TreeIter
{
public:
  typedef Gtk::TreeRow value_type;
  typedef unsigned int size_type;
  typedef int difference_type;
  typedef Gtk::TreeIter iterator;
    typedef std::reverse_iterator<iterator> reverse_iterator;
    typedef Gtk::TreeIter const_iterator;
    typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
  iterator begin();
  const_iterator begin() const;
  iterator end();
  const_iterator end() const;
  reverse_iterator rbegin() { return reverse_iterator(end()); }
  reverse_iterator rend() { return reverse_iterator(begin()); }
  const_reverse_iterator rbegin() const { return const_reverse_iterator(end()); }
  const_reverse_iterator rend() const { return const_reverse_iterator(begin()); }
  value_type operator[](size_type index) const;
  size_type size() const;
  bool empty() const;
  operator bool() const { return !empty(); }
  explicit TreeNodeChildren(TreeModel* model)
    : TreeIter(model) {}
  const GtkTreeIter* get_parent_gobject() const
    { return (gobject_.stamp != 0) ? &gobject_ : 0; }
};
inline
TreeIter::reference TreeIter::operator*() const
{
  return static_cast<const TreeRow&>(*this);
}
inline
TreeIter::pointer TreeIter::operator->() const
{
  return static_cast<const TreeRow*>(this);
}
template <class ColumnType> inline
TreeValueProxy<ColumnType>::TreeValueProxy(const TreeRow& row, const TreeModelColumn<ColumnType>& column)
:
  row_ (row),
  column_ (column)
{}
template <class ColumnType> inline
TreeValueProxy<ColumnType>& TreeValueProxy<ColumnType>::operator=(const ColumnType& data)
{
  row_.set_value(column_, data);
  return *this;
}
template <class ColumnType> inline
TreeValueProxy<ColumnType>::operator ColumnType() const
{
  return row_.get_value(column_);
}
template <class ColumnType> inline
TreeValueProxy<ColumnType> TreeRow::operator[](const TreeModelColumn<ColumnType>& column) const
{
  return TreeValueProxy<ColumnType>(*this, column);
}
template <class ColumnType>
void TreeRow::set_value(const TreeModelColumn<ColumnType>& column, const ColumnType& data) const
{
  typedef typename Gtk::TreeModelColumn<ColumnType>::ValueType ValueType;
  ValueType value;
  value.init(column.type());
  value.set(data);
  this->set_value_impl(column.index(), value);
}
template <class ColumnType>
void TreeRow::set_value(int column, const ColumnType& data) const
{
  typedef typename Gtk::TreeModelColumn<ColumnType> type_cppcolumn;
  typedef typename type_cppcolumn::ValueType ValueType;
  ValueType value;
  value.init(ValueType::value_type());
  value.set(data);
  this->set_value_impl(column, value);
}
template <class ColumnType>
ColumnType TreeRow::get_value(const TreeModelColumn<ColumnType>& column) const
{
  typedef typename Gtk::TreeModelColumn<ColumnType>::ValueType ValueType;
  ValueType value;
  this->get_value_impl(column.index(), value);
  return value.get();
}
template <class ColumnType>
void TreeRow::get_value(int column, ColumnType& data) const
{
  typedef typename Gtk::TreeModelColumn<ColumnType>::ValueType ValueType;
  ValueType value;
  this->get_value_impl(column, value);
  data = value.get();
}
}
namespace Glib
{
template <>
class Value<Gtk::TreeIterBase> : public Glib::Value_Boxed<Gtk::TreeIterBase>
{};
}
typedef struct _GtkTreeModel GtkTreeModel;
typedef struct _GtkTreeModelClass GtkTreeModelClass;
namespace Gtk
{ class TreeModel_Class; }
namespace Gtk
{
class TreeModelSort;
class TreePath;
class TreeRowReference;
enum TreeModelFlags
{
  TREE_MODEL_ITERS_PERSIST = 1 << 0,
  TREE_MODEL_LIST_ONLY = 1 << 1
};
inline TreeModelFlags operator|(TreeModelFlags lhs, TreeModelFlags rhs)
  { return static_cast<TreeModelFlags>(static_cast<unsigned>(lhs) | static_cast<unsigned>(rhs)); }
inline TreeModelFlags operator&(TreeModelFlags lhs, TreeModelFlags rhs)
  { return static_cast<TreeModelFlags>(static_cast<unsigned>(lhs) & static_cast<unsigned>(rhs)); }
inline TreeModelFlags operator^(TreeModelFlags lhs, TreeModelFlags rhs)
  { return static_cast<TreeModelFlags>(static_cast<unsigned>(lhs) ^ static_cast<unsigned>(rhs)); }
inline TreeModelFlags operator~(TreeModelFlags flags)
  { return static_cast<TreeModelFlags>(~static_cast<unsigned>(flags)); }
inline TreeModelFlags& operator|=(TreeModelFlags& lhs, TreeModelFlags rhs)
  { return (lhs = static_cast<TreeModelFlags>(static_cast<unsigned>(lhs) | static_cast<unsigned>(rhs))); }
inline TreeModelFlags& operator&=(TreeModelFlags& lhs, TreeModelFlags rhs)
  { return (lhs = static_cast<TreeModelFlags>(static_cast<unsigned>(lhs) & static_cast<unsigned>(rhs))); }
inline TreeModelFlags& operator^=(TreeModelFlags& lhs, TreeModelFlags rhs)
  { return (lhs = static_cast<TreeModelFlags>(static_cast<unsigned>(lhs) ^ static_cast<unsigned>(rhs))); }
}
namespace Glib
{
template <>
class Value<Gtk::TreeModelFlags> : public Glib::Value_Flags<Gtk::TreeModelFlags>
{
public:
  static GType value_type() __attribute__((__const__));
};
}
namespace Gtk
{
class TreeModel : public Glib::Interface
{
public:
  typedef TreeModel CppObjectType;
  typedef TreeModel_Class CppClassType;
  typedef GtkTreeModel BaseObjectType;
  typedef GtkTreeModelIface BaseClassType;
private:
  friend class TreeModel_Class;
  static CppClassType treemodel_class_;
  TreeModel(const TreeModel&);
  TreeModel& operator=(const TreeModel&);
protected:
  TreeModel();
public:
  explicit TreeModel(GtkTreeModel* castitem);
protected:
public:
  virtual ~TreeModel();
  static void add_interface(GType gtype_implementer);
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkTreeModel* gobj() { return reinterpret_cast<GtkTreeModel*>(gobject_); }
  const GtkTreeModel* gobj() const { return reinterpret_cast<GtkTreeModel*>(gobject_); }
private:
public:
  typedef TreeModelColumnRecord ColumnRecord;
  typedef TreeNodeChildren Children;
  typedef Children::iterator iterator;
  typedef Children::reverse_iterator reverse_iterator;
  typedef Children::const_iterator const_iterator;
  typedef Children::const_reverse_iterator const_reverse_iterator;
  typedef TreeRow Row;
  typedef TreePath Path;
  typedef TreeRowReference RowReference;
  iterator get_iter(const Path& path);
  iterator get_iter(const Glib::ustring& path_string);
  Children children();
  Children children() const;
  typedef sigc::slot<bool, const TreeModel::iterator&> SlotForeachIter;
  void foreach_iter(const SlotForeachIter& slot);
  typedef sigc::slot<bool, const TreeModel::Path&> SlotForeachPath;
  void foreach_path(const SlotForeachPath& slot);
  typedef sigc::slot<bool, const TreeModel::Path&, const TreeModel::iterator&> SlotForeachPathAndIter;
  void foreach(const SlotForeachPathAndIter& slot);
  TreeModelFlags get_flags() const;
  int get_n_columns() const;
  GType get_column_type(int index) const;
  TreeModel::Path get_path(const iterator& iter) const;
  void row_changed(const Path& path, const iterator& iter);
  void row_inserted(const Path& path, const iterator& iter);
  void row_has_child_toggled(const Path& path, const iterator& iter);
  void row_deleted(const Path& path);
  void rows_reordered(const Path& path, const iterator& iter, const Glib::ArrayHandle<int>& new_order);
  void rows_reordered(const Path& path, const Glib::ArrayHandle<int>& new_order);
  void rows_reordered(const Path& path, const iterator& iter, int* new_order);
  Glib::ustring get_string(const iterator& iter) const;
  Glib::SignalProxy2< void,const TreeModel::Path&,const TreeModel::iterator& > signal_row_changed();
  Glib::SignalProxy2< void,const TreeModel::Path&,const TreeModel::iterator& > signal_row_inserted();
  Glib::SignalProxy2< void,const TreeModel::Path&,const TreeModel::iterator& > signal_row_has_child_toggled();
  Glib::SignalProxy1< void,const TreeModel::Path& > signal_row_deleted();
  Glib::SignalProxy3< void,const TreeModel::Path&,const TreeModel::iterator&,int* > signal_rows_reordered();
protected:
  virtual TreeModelFlags get_flags_vfunc() const;
  virtual int get_n_columns_vfunc() const;
  virtual GType get_column_type_vfunc(int index) const;
  virtual bool iter_next_vfunc(const iterator& iter, iterator& iter_next) const;
  virtual bool get_iter_vfunc(const Path& path, iterator& iter) const;
  virtual bool iter_children_vfunc(const iterator& parent, iterator& iter) const;
  virtual bool iter_parent_vfunc(const iterator& child, iterator& iter) const;
  virtual bool iter_nth_child_vfunc(const iterator& parent, int n, iterator& iter) const;
  virtual bool iter_nth_root_child_vfunc(int n, iterator& iter) const;
  virtual bool iter_has_child_vfunc(const iterator& iter) const;
  virtual int iter_n_children_vfunc(const iterator& iter) const;
  virtual int iter_n_root_children_vfunc() const;
  virtual void ref_node_vfunc(const iterator& iter) const;
  virtual void unref_node_vfunc(const iterator& iter) const;
  virtual TreeModel::Path get_path_vfunc(const iterator& iter) const;
  virtual void get_value_vfunc(const iterator& iter, int column, Glib::ValueBase& value) const;
  virtual bool iter_is_valid(const iterator& iter) const;
  virtual void set_value_impl(const iterator& row, int column, const Glib::ValueBase& value);
  virtual void get_value_impl(const iterator& row, int column, Glib::ValueBase& value) const;
  friend class Gtk::TreeModelSort;
  friend class Gtk::TreeRow;
  friend class Gtk::TreeIter;
public:
public:
protected:
  virtual void on_row_changed(const TreeModel::Path& path, const TreeModel::iterator& iter);
  virtual void on_row_inserted(const TreeModel::Path& path, const TreeModel::iterator& iter);
  virtual void on_row_has_child_toggled(const TreeModel::Path& path, const TreeModel::iterator& iter);
  virtual void on_row_deleted(const TreeModel::Path& path);
  virtual void on_rows_reordered(const TreeModel::Path& path, const TreeModel::iterator& iter, int* new_order);
};
}
namespace Glib
{
  Glib::RefPtr<Gtk::TreeModel> wrap(GtkTreeModel* object, bool take_copy = false);
}
extern "C"
{
typedef struct _GtkCellLayoutIface GtkCellLayoutIface;
}
typedef struct _GtkCellLayout GtkCellLayout;
typedef struct _GtkCellLayoutClass GtkCellLayoutClass;
namespace Gtk
{ class CellLayout_Class; }
namespace Gtk
{
class CellLayout : public Glib::Interface
{
public:
  typedef CellLayout CppObjectType;
  typedef CellLayout_Class CppClassType;
  typedef GtkCellLayout BaseObjectType;
  typedef GtkCellLayoutIface BaseClassType;
private:
  friend class CellLayout_Class;
  static CppClassType celllayout_class_;
  CellLayout(const CellLayout&);
  CellLayout& operator=(const CellLayout&);
protected:
  CellLayout();
public:
  explicit CellLayout(GtkCellLayout* castitem);
protected:
public:
  virtual ~CellLayout();
  static void add_interface(GType gtype_implementer);
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkCellLayout* gobj() { return reinterpret_cast<GtkCellLayout*>(gobject_); }
  const GtkCellLayout* gobj() const { return reinterpret_cast<GtkCellLayout*>(gobject_); }
private:
public:
  template <class ColumnType> inline
  void pack_start(const TreeModelColumn<ColumnType>& model_column, bool expand = true);
  void pack_start(CellRenderer& cell, bool expand = true);
  void pack_end(CellRenderer& cell, bool expand = true);
  Glib::ListHandle<CellRenderer*> get_cells();
  Glib::ListHandle<const CellRenderer*> get_cells() const;
  void clear();
  void add_attribute(CellRenderer& cell, const Glib::ustring& attribute, int column);
  void add_attribute(const Glib::PropertyProxy_Base& property, const TreeModelColumnBase& column);
  void add_attribute(CellRenderer& cell, const Glib::ustring& attribute, const TreeModelColumnBase& column);
  typedef sigc::slot<void, const TreeModel::const_iterator&> SlotCellData;
  void set_cell_data_func(CellRenderer& cell, const SlotCellData& slot);
  void clear_attributes(CellRenderer& cell);
  void reorder(CellRenderer& cell, int position);
protected:
  virtual void pack_start_vfunc(CellRenderer* cell, bool expand);
  virtual void pack_end_vfunc(CellRenderer* cell, bool expand);
  virtual void clear_vfunc();
  virtual void add_attribute_vfunc(CellRenderer* cell, const Glib::ustring& attribute, int column);
  virtual void clear_attributes_vfunc(CellRenderer* cell);
  virtual void reorder_vfunc(CellRenderer* cell, int position);
public:
public:
protected:
};
template<class T_ModelColumnType>
void CellLayout::pack_start(const TreeModelColumn<T_ModelColumnType>& column, bool expand)
{
  CellRenderer* pCellRenderer = manage( CellRenderer_Generation::generate_cellrenderer<T_ModelColumnType>() );
  pack_start(*pCellRenderer, expand);
  add_attribute(pCellRenderer->_property_renderable(), column);
}
}
namespace Glib
{
  Glib::RefPtr<Gtk::CellLayout> wrap(GtkCellLayout* object, bool take_copy = false);
}
extern "C" { typedef struct _GtkTreePath GtkTreePath; }
namespace Gtk
{
class TreePath
{
  public:
  typedef TreePath CppObjectType;
  typedef GtkTreePath BaseObjectType;
  static GType get_type() __attribute__((__const__));
  TreePath();
  explicit TreePath(GtkTreePath* gobject, bool make_a_copy = true);
  TreePath(const TreePath& other);
  TreePath& operator=(const TreePath& other);
  ~TreePath();
  void swap(TreePath& other);
  GtkTreePath* gobj() { return gobject_; }
  const GtkTreePath* gobj() const { return gobject_; }
  GtkTreePath* gobj_copy() const;
protected:
  GtkTreePath* gobject_;
private:
public:
  typedef unsigned int size_type;
  typedef int difference_type;
  typedef int value_type;
  typedef int& reference;
  typedef const int& const_reference;
  typedef int* iterator;
  typedef const int* const_iterator;
  typedef std::reverse_iterator<iterator> reverse_iterator;
  typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
  explicit TreePath(size_type n, value_type value = 0);
  explicit TreePath(const Glib::ustring& path);
  explicit TreePath(const TreeModel::iterator& iter);
  template <class In> inline TreePath(In pbegin, In pend);
  void clear();
  TreePath& operator=(const TreeModel::iterator& iter);
  template <class In> inline void assign(In pbegin, In pend);
  template <class In> void append(In pbegin, In pend);
  void push_back(int index);
  void push_front(int index);
  size_type size() const;
  bool empty() const;
  reference operator[](size_type i);
  const_reference operator[](size_type i) const;
  iterator begin();
  iterator end();
  const_iterator begin() const;
  const_iterator end() const;
  reverse_iterator rbegin() { return reverse_iterator(end()); }
  reverse_iterator rend() { return reverse_iterator(begin()); }
  const_reverse_iterator rbegin() const { return const_reverse_iterator(end()); }
  const_reverse_iterator rend() const { return const_reverse_iterator(begin()); }
  reference front() { return *begin(); }
  const_reference front() const { return *begin(); }
  reference back() { return *rbegin(); }
  const_reference back() const { return *rbegin(); }
  void next();
  bool prev();
  bool up();
  void down();
  bool is_ancestor(const TreePath& descendant) const;
  bool is_descendant(const TreePath& ancestor) const;
  Glib::ustring to_string() const;
  void append_index(int index);
  void prepend_index(int index);
  int get_depth() const;
  Glib::ArrayHandle<int> get_indices() const;
  static bool get_from_selection_data(const SelectionData& selection_data, Glib::RefPtr<TreeModel>& model, TreePath& path);
  static bool get_from_selection_data(const SelectionData& selection_data, TreePath& path);
  bool set_in_selection_data(SelectionData& selection_data, const Glib::RefPtr<const TreeModel>& model) const;
};
template <class In>
void TreePath::append(In pbegin, In pend)
{
  for(; pbegin != pend; ++pbegin)
    this->push_back(*pbegin);
}
template <class In> inline
TreePath::TreePath(In pbegin, In pend)
{
  this->append(pbegin, pend);
}
template <class In> inline
void TreePath::assign(In pbegin, In pend)
{
  TreePath temp (pbegin, pend);
  this->swap(temp);
}
struct TreePath_Traits
{
  typedef TreePath CppType;
  typedef const GtkTreePath* CType;
  typedef GtkTreePath* CTypeNonConst;
  static CType to_c_type(const CppType& item)
    { return item.gobj(); }
  static CType to_c_type(CType item)
    { return item; }
  static CppType to_cpp_type(CType item)
    { return CppType(const_cast<CTypeNonConst>(item)); }
  static void release_c_type(CType item)
    { gtk_tree_path_free(const_cast<CTypeNonConst>(item)); }
};
}
namespace Gtk
{
bool operator==(const TreePath& lhs, const TreePath& rhs);
bool operator!=(const TreePath& lhs, const TreePath& rhs);
bool operator<(const TreePath& lhs, const TreePath& rhs);
bool operator>(const TreePath& lhs, const TreePath& rhs);
bool operator<=(const TreePath& lhs, const TreePath& rhs);
bool operator>=(const TreePath& lhs, const TreePath& rhs);
}
namespace Gtk
{
inline void swap(TreePath& lhs, TreePath& rhs)
  { lhs.swap(rhs); }
}
namespace Glib
{
Gtk::TreePath wrap(GtkTreePath* object, bool take_copy = false);
template <>
class Value<Gtk::TreePath> : public Glib::Value_Boxed<Gtk::TreePath>
{};
}
typedef struct _GtkCellView GtkCellView;
typedef struct _GtkCellViewClass GtkCellViewClass;
namespace Gtk
{ class CellView_Class; }
namespace Gtk
{
class CellView :
  public Widget,
  public CellLayout
{
  public:
  typedef CellView CppObjectType;
  typedef CellView_Class CppClassType;
  typedef GtkCellView BaseObjectType;
  typedef GtkCellViewClass BaseClassType;
  virtual ~CellView();
private:
  friend class CellView_Class;
  static CppClassType cellview_class_;
  CellView(const CellView&);
  CellView& operator=(const CellView&);
protected:
  explicit CellView(const Glib::ConstructParams& construct_params);
  explicit CellView(GtkCellView* castitem);
public:
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkCellView* gobj() { return reinterpret_cast<GtkCellView*>(gobject_); }
  const GtkCellView* gobj() const { return reinterpret_cast<GtkCellView*>(gobject_); }
public:
protected:
private:
public:
  CellView();
  explicit CellView(const Glib::ustring& text, bool use_markup = false);
  explicit CellView(const Glib::RefPtr<Gdk::Pixbuf>& pixbuf);
  void set_model(const Glib::RefPtr<TreeModel>& model);
  void set_displayed_row(const TreeModel::Path& path);
  TreeModel::Path get_displayed_row() const;
  bool get_size_of_row(const TreeModel::Path& path, Requisition& requisition) const;
  void set_background_color(const Gdk::Color& color);
  Glib::ListHandle<CellRenderer*> get_cell_renderers();
  Glib::ListHandle<const CellRenderer*> get_cell_renderers() const;
};
}
namespace Glib
{
  Gtk::CellView* wrap(GtkCellView* object, bool take_copy = false);
}
typedef struct _GtkToggleButton GtkToggleButton;
typedef struct _GtkToggleButtonClass GtkToggleButtonClass;
namespace Gtk
{ class ToggleButton_Class; }
namespace Gtk
{
class ToggleButton : public Button
{
  public:
  typedef ToggleButton CppObjectType;
  typedef ToggleButton_Class CppClassType;
  typedef GtkToggleButton BaseObjectType;
  typedef GtkToggleButtonClass BaseClassType;
  virtual ~ToggleButton();
private:
  friend class ToggleButton_Class;
  static CppClassType togglebutton_class_;
  ToggleButton(const ToggleButton&);
  ToggleButton& operator=(const ToggleButton&);
protected:
  explicit ToggleButton(const Glib::ConstructParams& construct_params);
  explicit ToggleButton(GtkToggleButton* castitem);
public:
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkToggleButton* gobj() { return reinterpret_cast<GtkToggleButton*>(gobject_); }
  const GtkToggleButton* gobj() const { return reinterpret_cast<GtkToggleButton*>(gobject_); }
public:
protected:
  virtual void on_toggled();
private:
public:
  ToggleButton();
  explicit ToggleButton(const Glib::ustring& label, bool mnemonic = false);
  explicit ToggleButton(const StockID& stock_id);
  void set_mode(bool draw_indicator = true);
  bool get_mode() const;
  void set_active(bool is_active = true);
  bool get_active() const;
  void set_inconsistent(bool setting = true);
  bool get_inconsistent() const;
  void toggled();
  Glib::SignalProxy0< void > signal_toggled();
  Glib::PropertyProxy<bool> property_active() ;
  Glib::PropertyProxy_ReadOnly<bool> property_active() const;
  Glib::PropertyProxy<bool> property_inconsistent() ;
  Glib::PropertyProxy_ReadOnly<bool> property_inconsistent() const;
  Glib::PropertyProxy<bool> property_draw_indicator() ;
  Glib::PropertyProxy_ReadOnly<bool> property_draw_indicator() const;
};
}
namespace Glib
{
  Gtk::ToggleButton* wrap(GtkToggleButton* object, bool take_copy = false);
}
typedef struct _GtkCheckButton GtkCheckButton;
typedef struct _GtkCheckButtonClass GtkCheckButtonClass;
namespace Gtk
{ class CheckButton_Class; }
namespace Gtk
{
class CheckButton : public ToggleButton
{
  public:
  typedef CheckButton CppObjectType;
  typedef CheckButton_Class CppClassType;
  typedef GtkCheckButton BaseObjectType;
  typedef GtkCheckButtonClass BaseClassType;
  virtual ~CheckButton();
private:
  friend class CheckButton_Class;
  static CppClassType checkbutton_class_;
  CheckButton(const CheckButton&);
  CheckButton& operator=(const CheckButton&);
protected:
  explicit CheckButton(const Glib::ConstructParams& construct_params);
  explicit CheckButton(GtkCheckButton* castitem);
public:
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkCheckButton* gobj() { return reinterpret_cast<GtkCheckButton*>(gobject_); }
  const GtkCheckButton* gobj() const { return reinterpret_cast<GtkCheckButton*>(gobject_); }
public:
protected:
private:
public:
  CheckButton();
  explicit CheckButton(const Glib::ustring& label, bool mnemonic = false);
protected:
  virtual void draw_indicator_vfunc(GdkRectangle* area);
};
}
namespace Glib
{
  Gtk::CheckButton* wrap(GtkCheckButton* object, bool take_copy = false);
}
typedef struct _GtkItem GtkItem;
typedef struct _GtkItemClass GtkItemClass;
namespace Gtk
{ class Item_Class; }
namespace Gtk
{
class Item : public Bin
{
  public:
  typedef Item CppObjectType;
  typedef Item_Class CppClassType;
  typedef GtkItem BaseObjectType;
  typedef GtkItemClass BaseClassType;
  virtual ~Item();
private:
  friend class Item_Class;
  static CppClassType item_class_;
  Item(const Item&);
  Item& operator=(const Item&);
protected:
  explicit Item(const Glib::ConstructParams& construct_params);
  explicit Item(GtkItem* castitem);
public:
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkItem* gobj() { return reinterpret_cast<GtkItem*>(gobject_); }
  const GtkItem* gobj() const { return reinterpret_cast<GtkItem*>(gobject_); }
public:
protected:
  virtual void on_select();
  virtual void on_deselect();
  virtual void on_toggle();
private:
public:
  void select();
  Glib::SignalProxy0< void > signal_select();
  void deselect();
  Glib::SignalProxy0< void > signal_deselect();
  void toggle();
  Glib::SignalProxy0< void > signal_toggle();
protected:
  Item();
};
}
namespace Glib
{
  Gtk::Item* wrap(GtkItem* object, bool take_copy = false);
}
typedef struct _GtkLabel GtkLabel;
typedef struct _GtkLabelClass GtkLabelClass;
namespace Gtk
{ class Label_Class; }
namespace Gtk
{
class Menu;
class Label : public Misc
{
  public:
  typedef Label CppObjectType;
  typedef Label_Class CppClassType;
  typedef GtkLabel BaseObjectType;
  typedef GtkLabelClass BaseClassType;
  virtual ~Label();
private:
  friend class Label_Class;
  static CppClassType label_class_;
  Label(const Label&);
  Label& operator=(const Label&);
protected:
  explicit Label(const Glib::ConstructParams& construct_params);
  explicit Label(GtkLabel* castitem);
public:
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkLabel* gobj() { return reinterpret_cast<GtkLabel*>(gobject_); }
  const GtkLabel* gobj() const { return reinterpret_cast<GtkLabel*>(gobject_); }
public:
protected:
  virtual void on_populate_popup(Menu* menu);
private:
public:
  Label();
  explicit Label(const Glib::ustring& label, bool mnemonic = false);
  Label(const Glib::ustring& label, float xalign, float yalign, bool mnemonic = false);
  Label(const Glib::ustring& label, AlignmentEnum xalign, AlignmentEnum yalign = ALIGN_CENTER, bool mnemonic = false);
  void set_text(const Glib::ustring &str);
  Glib::ustring get_text() const;
  void set_attributes(Pango::AttrList& attrs);
  Pango::AttrList get_attributes() const;
  void set_label(const Glib::ustring& str);
  Glib::ustring get_label() const;
  void set_markup(const Glib::ustring& str);
  void set_use_markup(bool setting = true);
  bool get_use_markup() const;
  void set_use_underline(bool setting = true);
  bool get_use_underline() const;
  void set_markup_with_mnemonic(const Glib::ustring& str);
  guint get_mnemonic_keyval() const;
  void set_mnemonic_widget(Widget& widget);
  Widget* get_mnemonic_widget();
  const Widget* get_mnemonic_widget() const;
  void set_text_with_mnemonic(const Glib::ustring& str);
  void set_justify(Justification jtype);
  Justification get_justify() const;
  void set_ellipsize(Pango::EllipsizeMode mode);
  Pango::EllipsizeMode get_ellipsize() const;
  void set_width_chars(int n_chars);
  int get_width_chars() const;
  void set_max_width_chars(int n_chars);
  int get_max_width_chars() const;
  void set_pattern(const Glib::ustring& pattern);
  void set_line_wrap(bool wrap = true);
  bool get_line_wrap() const;
  void set_line_wrap_mode(Pango::WrapMode wrap_mode);
  Pango::WrapMode get_line_wrap_mode() const;
  void set_selectable(bool setting = true);
  bool get_selectable() const;
  void set_angle(double angle);
  double get_angle() const;
  void select_region(int start_offset, int end_offset);
  void select_region(int start_offset);
  bool get_selection_bounds(int& start, int& end) const;
  Glib::RefPtr<Pango::Layout> get_layout();
  Glib::RefPtr<const Pango::Layout> get_layout() const;
  void get_layout_offsets(int& x, int& y) const;
  void set_single_line_mode(bool single_line_mode = true);
  bool get_single_line_mode() const;
  Glib::SignalProxy1< void,Menu* > signal_populate_popup();
  Glib::PropertyProxy<Glib::ustring> property_label() ;
  Glib::PropertyProxy_ReadOnly<Glib::ustring> property_label() const;
  Glib::PropertyProxy<Pango::AttrList> property_attributes() ;
  Glib::PropertyProxy_ReadOnly<Pango::AttrList> property_attributes() const;
  Glib::PropertyProxy<bool> property_use_markup() ;
  Glib::PropertyProxy_ReadOnly<bool> property_use_markup() const;
  Glib::PropertyProxy<bool> property_use_underline() ;
  Glib::PropertyProxy_ReadOnly<bool> property_use_underline() const;
  Glib::PropertyProxy<Justification> property_justify() ;
  Glib::PropertyProxy_ReadOnly<Justification> property_justify() const;
  Glib::PropertyProxy_WriteOnly<Glib::ustring> property_pattern() ;
  Glib::PropertyProxy<bool> property_wrap() ;
  Glib::PropertyProxy_ReadOnly<bool> property_wrap() const;
  Glib::PropertyProxy<Pango::WrapMode> property_wrap_mode() ;
  Glib::PropertyProxy_ReadOnly<Pango::WrapMode> property_wrap_mode() const;
  Glib::PropertyProxy<bool> property_selectable() ;
  Glib::PropertyProxy_ReadOnly<bool> property_selectable() const;
  Glib::PropertyProxy_ReadOnly<guint> property_mnemonic_keyval() const;
  Glib::PropertyProxy<Widget*> property_mnemonic_widget() ;
  Glib::PropertyProxy_ReadOnly<Widget*> property_mnemonic_widget() const;
  Glib::PropertyProxy_ReadOnly<int> property_cursor_position() const;
  Glib::PropertyProxy_ReadOnly<int> property_selection_bound() const;
  Glib::PropertyProxy<Pango::EllipsizeMode> property_ellipsize() ;
  Glib::PropertyProxy_ReadOnly<Pango::EllipsizeMode> property_ellipsize() const;
  Glib::PropertyProxy<int> property_width_chars() ;
  Glib::PropertyProxy_ReadOnly<int> property_width_chars() const;
  Glib::PropertyProxy<bool> property_single_line_mode() ;
  Glib::PropertyProxy_ReadOnly<bool> property_single_line_mode() const;
  Glib::PropertyProxy<double> property_angle() ;
  Glib::PropertyProxy_ReadOnly<double> property_angle() const;
  Glib::PropertyProxy<int> property_max_width_chars() ;
  Glib::PropertyProxy_ReadOnly<int> property_max_width_chars() const;
};
}
namespace Glib
{
  Gtk::Label* wrap(GtkLabel* object, bool take_copy = false);
}
typedef struct _GtkAccelLabel GtkAccelLabel;
typedef struct _GtkAccelLabelClass GtkAccelLabelClass;
namespace Gtk
{ class AccelLabel_Class; }
namespace Gtk
{
class AccelLabel : public Label
{
  public:
  typedef AccelLabel CppObjectType;
  typedef AccelLabel_Class CppClassType;
  typedef GtkAccelLabel BaseObjectType;
  typedef GtkAccelLabelClass BaseClassType;
  virtual ~AccelLabel();
private:
  friend class AccelLabel_Class;
  static CppClassType accellabel_class_;
  AccelLabel(const AccelLabel&);
  AccelLabel& operator=(const AccelLabel&);
protected:
  explicit AccelLabel(const Glib::ConstructParams& construct_params);
  explicit AccelLabel(GtkAccelLabel* castitem);
public:
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkAccelLabel* gobj() { return reinterpret_cast<GtkAccelLabel*>(gobject_); }
  const GtkAccelLabel* gobj() const { return reinterpret_cast<GtkAccelLabel*>(gobject_); }
public:
protected:
private:
public:
  AccelLabel();
  explicit AccelLabel(const Glib::ustring& label, bool mnemonic = false);
  void set_accel_widget(const Widget& accel_widget);
  void unset_accel_widget();
  Widget* get_accel_widget();
  const Widget* get_accel_widget() const;
  guint get_accel_width() const;
  bool refetch();
  Glib::PropertyProxy<Gtk::Widget*> property_accel_widget() ;
  Glib::PropertyProxy_ReadOnly<Gtk::Widget*> property_accel_widget() const;
};
}
namespace Glib
{
  Gtk::AccelLabel* wrap(GtkAccelLabel* object, bool take_copy = false);
}
typedef struct _GtkMenuItem GtkMenuItem;
typedef struct _GtkMenuItemClass GtkMenuItemClass;
namespace Gtk
{ class MenuItem_Class; }
namespace Gtk
{
class Menu;
namespace Menu_Helpers { class Element; }
class MenuItem : public Item
{
  public:
  typedef MenuItem CppObjectType;
  typedef MenuItem_Class CppClassType;
  typedef GtkMenuItem BaseObjectType;
  typedef GtkMenuItemClass BaseClassType;
  virtual ~MenuItem();
private:
  friend class MenuItem_Class;
  static CppClassType menuitem_class_;
  MenuItem(const MenuItem&);
  MenuItem& operator=(const MenuItem&);
protected:
  explicit MenuItem(const Glib::ConstructParams& construct_params);
  explicit MenuItem(GtkMenuItem* castitem);
public:
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkMenuItem* gobj() { return reinterpret_cast<GtkMenuItem*>(gobject_); }
  const GtkMenuItem* gobj() const { return reinterpret_cast<GtkMenuItem*>(gobject_); }
public:
protected:
  virtual void on_activate();
  virtual void on_activate_item();
  virtual void on_toggle_size_request(int* requisition);
  virtual void on_toggle_size_allocate(int allocation);
private:
public:
  MenuItem();
  explicit MenuItem(Widget& widget);
  explicit MenuItem(const Glib::ustring& label, bool mnemonic = false);
  void set_submenu(Menu& submenu);
  Menu* get_submenu();
  const Menu* get_submenu() const;
  bool has_submenu() const;
  void remove_submenu();
  void select();
  void deselect();
  void activate();
  void toggle_size_request(int& requisition);
  void toggle_size_allocate(int allocation);
  void set_right_justified(bool right_justified = true);
  bool get_right_justified() const;
  void set_accel_path(const Glib::ustring& accel_path);
  void unset_accel_path();
  Glib::SignalProxy0< void > signal_activate();
  Glib::SignalProxy0< void > signal_activate_item();
  Glib::SignalProxy1< void,int* > signal_toggle_size_request();
  Glib::SignalProxy1< void,int > signal_toggle_size_allocate();
  void accelerate(Window& window);
protected:
  void add_accel_label(const Glib::ustring& label, bool mnemonic = true);
  void set_accel_key(const AccelKey& accel_key);
private:
  friend class Menu_Helpers::Element;
  AccelKey accel_key_;
};
}
namespace Glib
{
  Gtk::MenuItem* wrap(GtkMenuItem* object, bool take_copy = false);
}
typedef struct _GtkCheckMenuItem GtkCheckMenuItem;
typedef struct _GtkCheckMenuItemClass GtkCheckMenuItemClass;
namespace Gtk
{ class CheckMenuItem_Class; }
namespace Gtk
{
class CheckMenuItem : public MenuItem
{
  public:
  typedef CheckMenuItem CppObjectType;
  typedef CheckMenuItem_Class CppClassType;
  typedef GtkCheckMenuItem BaseObjectType;
  typedef GtkCheckMenuItemClass BaseClassType;
  virtual ~CheckMenuItem();
private:
  friend class CheckMenuItem_Class;
  static CppClassType checkmenuitem_class_;
  CheckMenuItem(const CheckMenuItem&);
  CheckMenuItem& operator=(const CheckMenuItem&);
protected:
  explicit CheckMenuItem(const Glib::ConstructParams& construct_params);
  explicit CheckMenuItem(GtkCheckMenuItem* castitem);
public:
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkCheckMenuItem* gobj() { return reinterpret_cast<GtkCheckMenuItem*>(gobject_); }
  const GtkCheckMenuItem* gobj() const { return reinterpret_cast<GtkCheckMenuItem*>(gobject_); }
public:
protected:
  virtual void on_toggled();
private:
public:
  CheckMenuItem();
  explicit CheckMenuItem(const Glib::ustring& label, bool mnemonic = false);
  void set_active(bool state = true);
  bool get_active() const;
  void toggled();
  void set_inconsistent(bool setting = true);
  bool get_inconsistent() const;
  void set_draw_as_radio(bool draw_as_radio = true);
  bool get_draw_as_radio() const;
  Glib::SignalProxy0< void > signal_toggled();
  Glib::PropertyProxy<bool> property_active() ;
  Glib::PropertyProxy_ReadOnly<bool> property_active() const;
  Glib::PropertyProxy<bool> property_inconsistent() ;
  Glib::PropertyProxy_ReadOnly<bool> property_inconsistent() const;
  Glib::PropertyProxy<bool> property_draw_as_radio() ;
  Glib::PropertyProxy_ReadOnly<bool> property_draw_as_radio() const;
protected:
  virtual void draw_indicator_vfunc(GdkRectangle* area);
};
}
namespace Glib
{
  Gtk::CheckMenuItem* wrap(GtkCheckMenuItem* object, bool take_copy = false);
}
typedef struct _GtkCellRendererCombo GtkCellRendererCombo;
typedef struct _GtkCellRendererComboClass GtkCellRendererComboClass;
namespace Gtk
{ class CellRendererCombo_Class; }
namespace Gtk
{
class CellRendererCombo : public CellRendererText
{
  public:
  typedef CellRendererCombo CppObjectType;
  typedef CellRendererCombo_Class CppClassType;
  typedef GtkCellRendererCombo BaseObjectType;
  typedef GtkCellRendererComboClass BaseClassType;
  virtual ~CellRendererCombo();
private:
  friend class CellRendererCombo_Class;
  static CppClassType cellrenderercombo_class_;
  CellRendererCombo(const CellRendererCombo&);
  CellRendererCombo& operator=(const CellRendererCombo&);
protected:
  explicit CellRendererCombo(const Glib::ConstructParams& construct_params);
  explicit CellRendererCombo(GtkCellRendererCombo* castitem);
public:
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkCellRendererCombo* gobj() { return reinterpret_cast<GtkCellRendererCombo*>(gobject_); }
  const GtkCellRendererCombo* gobj() const { return reinterpret_cast<GtkCellRendererCombo*>(gobject_); }
public:
protected:
private:
public:
  CellRendererCombo();
  Glib::PropertyProxy< Glib::RefPtr<Gtk::TreeModel> > property_model() ;
  Glib::PropertyProxy_ReadOnly< Glib::RefPtr<Gtk::TreeModel> > property_model() const;
  Glib::PropertyProxy<int> property_text_column() ;
  Glib::PropertyProxy_ReadOnly<int> property_text_column() const;
  Glib::PropertyProxy<bool> property_has_entry() ;
  Glib::PropertyProxy_ReadOnly<bool> property_has_entry() const;
  virtual Glib::PropertyProxy_Base _property_renderable();
};
}
namespace Glib
{
  Gtk::CellRendererCombo* wrap(GtkCellRendererCombo* object, bool take_copy = false);
}
typedef struct _GtkCellRendererProgress GtkCellRendererProgress;
typedef struct _GtkCellRendererProgressClass GtkCellRendererProgressClass;
namespace Gtk
{ class CellRendererProgress_Class; }
namespace Gtk
{
class CellRendererProgress : public CellRenderer
{
  public:
  typedef CellRendererProgress CppObjectType;
  typedef CellRendererProgress_Class CppClassType;
  typedef GtkCellRendererProgress BaseObjectType;
  typedef GtkCellRendererProgressClass BaseClassType;
  virtual ~CellRendererProgress();
private:
  friend class CellRendererProgress_Class;
  static CppClassType cellrendererprogress_class_;
  CellRendererProgress(const CellRendererProgress&);
  CellRendererProgress& operator=(const CellRendererProgress&);
protected:
  explicit CellRendererProgress(const Glib::ConstructParams& construct_params);
  explicit CellRendererProgress(GtkCellRendererProgress* castitem);
public:
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkCellRendererProgress* gobj() { return reinterpret_cast<GtkCellRendererProgress*>(gobject_); }
  const GtkCellRendererProgress* gobj() const { return reinterpret_cast<GtkCellRendererProgress*>(gobject_); }
public:
protected:
private:
public:
  CellRendererProgress();
  Glib::PropertyProxy<int> property_value() ;
  Glib::PropertyProxy_ReadOnly<int> property_value() const;
  Glib::PropertyProxy<Glib::ustring> property_text() ;
  Glib::PropertyProxy_ReadOnly<Glib::ustring> property_text() const;
  Glib::PropertyProxy<int> property_pulse() ;
  Glib::PropertyProxy_ReadOnly<int> property_pulse() const;
  Glib::PropertyProxy<float> property_text_xalign() ;
  Glib::PropertyProxy_ReadOnly<float> property_text_xalign() const;
  Glib::PropertyProxy<float> property_text_yalign() ;
  Glib::PropertyProxy_ReadOnly<float> property_text_yalign() const;
  virtual Glib::PropertyProxy_Base _property_renderable();
};
}
namespace Glib
{
  Gtk::CellRendererProgress* wrap(GtkCellRendererProgress* object, bool take_copy = false);
}
typedef struct _GtkCellRendererSpin GtkCellRendererSpin;
typedef struct _GtkCellRendererSpinClass GtkCellRendererSpinClass;
namespace Gtk
{ class CellRendererSpin_Class; }
namespace Gtk
{
class CellRendererSpin : public CellRendererText
{
  public:
  typedef CellRendererSpin CppObjectType;
  typedef CellRendererSpin_Class CppClassType;
  typedef GtkCellRendererSpin BaseObjectType;
  typedef GtkCellRendererSpinClass BaseClassType;
  virtual ~CellRendererSpin();
private:
  friend class CellRendererSpin_Class;
  static CppClassType cellrendererspin_class_;
  CellRendererSpin(const CellRendererSpin&);
  CellRendererSpin& operator=(const CellRendererSpin&);
protected:
  explicit CellRendererSpin(const Glib::ConstructParams& construct_params);
  explicit CellRendererSpin(GtkCellRendererSpin* castitem);
public:
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkCellRendererSpin* gobj() { return reinterpret_cast<GtkCellRendererSpin*>(gobject_); }
  const GtkCellRendererSpin* gobj() const { return reinterpret_cast<GtkCellRendererSpin*>(gobject_); }
public:
protected:
private:
public:
  CellRendererSpin();
  Glib::PropertyProxy<Gtk::Adjustment*> property_adjustment() ;
  Glib::PropertyProxy_ReadOnly<Gtk::Adjustment*> property_adjustment() const;
  Glib::PropertyProxy<double> property_climb_rate() ;
  Glib::PropertyProxy_ReadOnly<double> property_climb_rate() const;
  Glib::PropertyProxy<guint> property_digits() ;
  Glib::PropertyProxy_ReadOnly<guint> property_digits() const;
  virtual Glib::PropertyProxy_Base _property_renderable();
};
}
namespace Glib
{
  Gtk::CellRendererSpin* wrap(GtkCellRendererSpin* object, bool take_copy = false);
}
typedef struct _GtkColorButton GtkColorButton;
typedef struct _GtkColorButtonClass GtkColorButtonClass;
namespace Gtk
{ class ColorButton_Class; }
namespace Gtk
{
class ColorButton : public Button
{
  public:
  typedef ColorButton CppObjectType;
  typedef ColorButton_Class CppClassType;
  typedef GtkColorButton BaseObjectType;
  typedef GtkColorButtonClass BaseClassType;
  virtual ~ColorButton();
private:
  friend class ColorButton_Class;
  static CppClassType colorbutton_class_;
  ColorButton(const ColorButton&);
  ColorButton& operator=(const ColorButton&);
protected:
  explicit ColorButton(const Glib::ConstructParams& construct_params);
  explicit ColorButton(GtkColorButton* castitem);
public:
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkColorButton* gobj() { return reinterpret_cast<GtkColorButton*>(gobject_); }
  const GtkColorButton* gobj() const { return reinterpret_cast<GtkColorButton*>(gobject_); }
public:
protected:
  virtual void on_color_set();
private:
public:
  ColorButton();
  explicit ColorButton(const Gdk::Color& color);
  void set_color(const Gdk::Color& color);
  void set_alpha(guint16 alpha);
  Gdk::Color get_color() const;
  guint16 get_alpha() const;
  void set_use_alpha(bool use_alpha = true);
  bool get_use_alpha() const;
  void set_title(const Glib::ustring& title);
  Glib::ustring get_title() const;
  Glib::PropertyProxy<bool> property_use_alpha() ;
  Glib::PropertyProxy_ReadOnly<bool> property_use_alpha() const;
  Glib::PropertyProxy<Glib::ustring> property_title() ;
  Glib::PropertyProxy_ReadOnly<Glib::ustring> property_title() const;
  Glib::PropertyProxy<Gdk::Color> property_color() ;
  Glib::PropertyProxy_ReadOnly<Gdk::Color> property_color() const;
  Glib::PropertyProxy<guint16> property_alpha() ;
  Glib::PropertyProxy_ReadOnly<guint16> property_alpha() const;
  Glib::SignalProxy0< void > signal_color_set();
};
}
namespace Glib
{
  Gtk::ColorButton* wrap(GtkColorButton* object, bool take_copy = false);
}
typedef struct _GtkColorSelection GtkColorSelection;
typedef struct _GtkColorSelectionClass GtkColorSelectionClass;
namespace Gtk
{ class ColorSelection_Class; }
typedef struct _GtkColorSelectionDialog GtkColorSelectionDialog;
typedef struct _GtkColorSelectionDialogClass GtkColorSelectionDialogClass;
namespace Gtk
{ class ColorSelectionDialog_Class; }
namespace Gtk
{
class ColorSelection : public VBox
{
  public:
  typedef ColorSelection CppObjectType;
  typedef ColorSelection_Class CppClassType;
  typedef GtkColorSelection BaseObjectType;
  typedef GtkColorSelectionClass BaseClassType;
  virtual ~ColorSelection();
private:
  friend class ColorSelection_Class;
  static CppClassType colorselection_class_;
  ColorSelection(const ColorSelection&);
  ColorSelection& operator=(const ColorSelection&);
protected:
  explicit ColorSelection(const Glib::ConstructParams& construct_params);
  explicit ColorSelection(GtkColorSelection* castitem);
public:
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkColorSelection* gobj() { return reinterpret_cast<GtkColorSelection*>(gobject_); }
  const GtkColorSelection* gobj() const { return reinterpret_cast<GtkColorSelection*>(gobject_); }
public:
protected:
  virtual void on_color_changed();
private:
public:
  ColorSelection();
  bool get_has_opacity_control() const;
  void set_has_opacity_control(bool has_opacity = true);
  bool get_has_palette() const;
  void set_has_palette(bool has_palette = true);
  void set_current_color(const Gdk::Color& color);
  void set_current_alpha(guint16 alpha);
  Gdk::Color get_current_color() const;
  guint16 get_current_alpha() const;
  void set_previous_color(const Gdk::Color& color);
  void set_previous_alpha(guint16 alpha);
  Gdk::Color get_previous_color() const;
  guint16 get_previous_alpha() const;
  bool is_adjusting() const;
  static Gdk::ArrayHandle_Color palette_from_string(const Glib::ustring& str);
  static Glib::ustring palette_to_string(const Gdk::ArrayHandle_Color& colors);
  typedef sigc::slot<void, const Glib::RefPtr<Gdk::Screen>&,
                            const Gdk::ArrayHandle_Color&> SlotChangePaletteHook;
  static SlotChangePaletteHook set_change_palette_hook(const SlotChangePaletteHook& slot);
  Glib::SignalProxy0< void > signal_color_changed();
  Glib::PropertyProxy<bool> property_has_palette() ;
  Glib::PropertyProxy_ReadOnly<bool> property_has_palette() const;
  Glib::PropertyProxy<bool> property_has_opacity_control() ;
  Glib::PropertyProxy_ReadOnly<bool> property_has_opacity_control() const;
  Glib::PropertyProxy<Gdk::Color> property_current_color() ;
  Glib::PropertyProxy_ReadOnly<Gdk::Color> property_current_color() const;
  Glib::PropertyProxy<guint> property_current_alpha() ;
  Glib::PropertyProxy_ReadOnly<guint> property_current_alpha() const;
};
class ColorSelectionDialog : public Dialog
{
  public:
  typedef ColorSelectionDialog CppObjectType;
  typedef ColorSelectionDialog_Class CppClassType;
  typedef GtkColorSelectionDialog BaseObjectType;
  typedef GtkColorSelectionDialogClass BaseClassType;
  virtual ~ColorSelectionDialog();
private:
  friend class ColorSelectionDialog_Class;
  static CppClassType colorselectiondialog_class_;
  ColorSelectionDialog(const ColorSelectionDialog&);
  ColorSelectionDialog& operator=(const ColorSelectionDialog&);
protected:
  explicit ColorSelectionDialog(const Glib::ConstructParams& construct_params);
  explicit ColorSelectionDialog(GtkColorSelectionDialog* castitem);
public:
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkColorSelectionDialog* gobj() { return reinterpret_cast<GtkColorSelectionDialog*>(gobject_); }
  const GtkColorSelectionDialog* gobj() const { return reinterpret_cast<GtkColorSelectionDialog*>(gobject_); }
public:
protected:
private:
public:
  ColorSelectionDialog();
  explicit ColorSelectionDialog(const Glib::ustring& title);
   ColorSelection* get_colorsel();
  const ColorSelection* get_colorsel() const;
    Button* get_ok_button();
  const Button* get_ok_button() const;
    Button* get_cancel_button();
  const Button* get_cancel_button() const;
    Button* get_help_button();
  const Button* get_help_button() const;
};
}
namespace Glib
{
  Gtk::ColorSelection* wrap(GtkColorSelection* object, bool take_copy = false);
}
namespace Glib
{
  Gtk::ColorSelectionDialog* wrap(GtkColorSelectionDialog* object, bool take_copy = false);
}
extern "C" {
typedef struct _GtkEditable GtkEditable;
typedef struct _GtkEditableClass GtkEditableClass;
struct _GtkEditableClass
{
  GTypeInterface base_iface;
  void (* insert_text) (GtkEditable *editable,
         const gchar *text,
         gint length,
         gint *position);
  void (* delete_text) (GtkEditable *editable,
         gint start_pos,
         gint end_pos);
  void (* changed) (GtkEditable *editable);
  void (* do_insert_text) (GtkEditable *editable,
         const gchar *text,
         gint length,
         gint *position);
  void (* do_delete_text) (GtkEditable *editable,
         gint start_pos,
         gint end_pos);
  gchar* (* get_chars) (GtkEditable *editable,
         gint start_pos,
         gint end_pos);
  void (* set_selection_bounds) (GtkEditable *editable,
         gint start_pos,
         gint end_pos);
  gboolean (* get_selection_bounds) (GtkEditable *editable,
         gint *start_pos,
         gint *end_pos);
  void (* set_position) (GtkEditable *editable,
         gint position);
  gint (* get_position) (GtkEditable *editable);
};
GType gtk_editable_get_type (void) __attribute__((__const__));
void gtk_editable_select_region (GtkEditable *editable,
         gint start,
         gint end);
gboolean gtk_editable_get_selection_bounds (GtkEditable *editable,
         gint *start,
         gint *end);
void gtk_editable_insert_text (GtkEditable *editable,
         const gchar *new_text,
         gint new_text_length,
         gint *position);
void gtk_editable_delete_text (GtkEditable *editable,
         gint start_pos,
         gint end_pos);
gchar* gtk_editable_get_chars (GtkEditable *editable,
         gint start_pos,
         gint end_pos);
void gtk_editable_cut_clipboard (GtkEditable *editable);
void gtk_editable_copy_clipboard (GtkEditable *editable);
void gtk_editable_paste_clipboard (GtkEditable *editable);
void gtk_editable_delete_selection (GtkEditable *editable);
void gtk_editable_set_position (GtkEditable *editable,
         gint position);
gint gtk_editable_get_position (GtkEditable *editable);
void gtk_editable_set_editable (GtkEditable *editable,
         gboolean is_editable);
gboolean gtk_editable_get_editable (GtkEditable *editable);
}
typedef struct _GtkEditable GtkEditable;
typedef struct _GtkEditableClass GtkEditableClass;
namespace Gtk
{ class Editable_Class; }
namespace Gtk
{
class Editable : public Glib::Interface
{
public:
  typedef Editable CppObjectType;
  typedef Editable_Class CppClassType;
  typedef GtkEditable BaseObjectType;
  typedef GtkEditableClass BaseClassType;
private:
  friend class Editable_Class;
  static CppClassType editable_class_;
  Editable(const Editable&);
  Editable& operator=(const Editable&);
protected:
  Editable();
public:
  explicit Editable(GtkEditable* castitem);
protected:
public:
  virtual ~Editable();
  static void add_interface(GType gtype_implementer);
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkEditable* gobj() { return reinterpret_cast<GtkEditable*>(gobject_); }
  const GtkEditable* gobj() const { return reinterpret_cast<GtkEditable*>(gobject_); }
private:
public:
  void cut_clipboard();
  void copy_clipboard();
  void paste_clipboard();
  void delete_selection();
  void set_editable(bool is_editable = true);
  bool get_editable() const;
  void insert_text(const Glib::ustring& text, int length, int& position);
  void delete_text(int start_pos, int end_pos);
  Glib::ustring get_chars(int start_pos, int end_pos) const;
  void select_region(int start_pos, int end_pos);
  bool get_selection_bounds(int& start_pos, int& end_pos) const;
  void set_position(int position);
  int get_position() const;
  Glib::SignalProxy2< void,const Glib::ustring&,int* > signal_insert_text();
  Glib::SignalProxy2< void,int,int > signal_delete_text();
  Glib::SignalProxy0< void > signal_changed();
protected:
  virtual void delete_text_vfunc(int start_pos, int end_pos);
  virtual Glib::ustring get_chars_vfunc(int start_pos, int end_pos) const;
  virtual void select_region_vfunc(int start_pos, int end_pos);
  virtual bool get_selection_bounds_vfunc(int& start_pos, int& end_pos) const;
  virtual void set_position_vfunc(int position);
  virtual int get_position_vfunc() const;
public:
public:
protected:
virtual void insert_text_vfunc(const Glib::ustring& text, int& position);
  virtual void on_insert_text(const Glib::ustring& text, int* position);
  virtual void on_delete_text(int start_pos, int end_pos);
  virtual void on_changed();
};
}
namespace Glib
{
  Glib::RefPtr<Gtk::Editable> wrap(GtkEditable* object, bool take_copy = false);
}
typedef struct _GtkImageMenuItem GtkImageMenuItem;
typedef struct _GtkImageMenuItemClass GtkImageMenuItemClass;
namespace Gtk
{ class ImageMenuItem_Class; }
namespace Gtk
{
class ImageMenuItem : public MenuItem
{
  public:
  typedef ImageMenuItem CppObjectType;
  typedef ImageMenuItem_Class CppClassType;
  typedef GtkImageMenuItem BaseObjectType;
  typedef GtkImageMenuItemClass BaseClassType;
  virtual ~ImageMenuItem();
private:
  friend class ImageMenuItem_Class;
  static CppClassType imagemenuitem_class_;
  ImageMenuItem(const ImageMenuItem&);
  ImageMenuItem& operator=(const ImageMenuItem&);
protected:
  explicit ImageMenuItem(const Glib::ConstructParams& construct_params);
  explicit ImageMenuItem(GtkImageMenuItem* castitem);
public:
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkImageMenuItem* gobj() { return reinterpret_cast<GtkImageMenuItem*>(gobject_); }
  const GtkImageMenuItem* gobj() const { return reinterpret_cast<GtkImageMenuItem*>(gobject_); }
public:
protected:
private:
public:
  ImageMenuItem();
  explicit ImageMenuItem(Widget& image,
                         const Glib::ustring& label, bool mnemonic = false);
  explicit ImageMenuItem(const Glib::ustring& label, bool mnemonic = false);
  explicit ImageMenuItem(const StockID& id);
  void set_image(Widget& image);
  Widget* get_image();
  const Widget* get_image() const;
};
}
namespace Glib
{
  Gtk::ImageMenuItem* wrap(GtkImageMenuItem* object, bool take_copy = false);
}
extern "C"
{
  typedef struct _GSList GSList;
}
namespace Gtk
{
class RadioButton;
class RadioMenuItem;
class RadioAction;
class RadioToolButton;
class RadioButtonGroup
{
public:
  RadioButtonGroup();
  RadioButtonGroup(const RadioButtonGroup& src);
  RadioButtonGroup& operator=(const RadioButtonGroup& src);
protected:
  explicit RadioButtonGroup(GSList* group);
  friend class Gtk::RadioButton;
  friend class Gtk::RadioMenuItem;
  friend class Gtk::RadioAction;
  friend class Gtk::RadioToolButton;
  void add(RadioButton& item);
  void add(RadioMenuItem& item);
  void add(const Glib::RefPtr<RadioAction>& item);
  void add(RadioToolButton& item);
  void* operator new(size_t);
  GSList* group_;
};
}
typedef struct _GtkRadioButton GtkRadioButton;
typedef struct _GtkRadioButtonClass GtkRadioButtonClass;
namespace Gtk
{ class RadioButton_Class; }
namespace Gtk
{
class RadioButton : public CheckButton
{
  public:
  typedef RadioButton CppObjectType;
  typedef RadioButton_Class CppClassType;
  typedef GtkRadioButton BaseObjectType;
  typedef GtkRadioButtonClass BaseClassType;
  virtual ~RadioButton();
private:
  friend class RadioButton_Class;
  static CppClassType radiobutton_class_;
  RadioButton(const RadioButton&);
  RadioButton& operator=(const RadioButton&);
protected:
  explicit RadioButton(const Glib::ConstructParams& construct_params);
  explicit RadioButton(GtkRadioButton* castitem);
public:
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkRadioButton* gobj() { return reinterpret_cast<GtkRadioButton*>(gobject_); }
  const GtkRadioButton* gobj() const { return reinterpret_cast<GtkRadioButton*>(gobject_); }
public:
protected:
  virtual void on_group_changed();
private:
public:
  typedef RadioButtonGroup Group;
  RadioButton();
  explicit RadioButton(const Glib::ustring& label, bool mnemonic = false);
  explicit RadioButton(Group& group);
  RadioButton(Group& group, const Glib::ustring& label, bool mnemonic = false);
  Group get_group();
  void set_group(Group& group);
  void reset_group();
  Glib::SignalProxy0< void > signal_group_changed();
};
}
namespace Glib
{
  Gtk::RadioButton* wrap(GtkRadioButton* object, bool take_copy = false);
}
typedef struct _GtkRadioMenuItem GtkRadioMenuItem;
typedef struct _GtkRadioMenuItemClass GtkRadioMenuItemClass;
namespace Gtk
{ class RadioMenuItem_Class; }
namespace Gtk
{
class RadioMenuItem;
class RadioMenuItem : public CheckMenuItem
{
  public:
  typedef RadioMenuItem CppObjectType;
  typedef RadioMenuItem_Class CppClassType;
  typedef GtkRadioMenuItem BaseObjectType;
  typedef GtkRadioMenuItemClass BaseClassType;
  virtual ~RadioMenuItem();
private:
  friend class RadioMenuItem_Class;
  static CppClassType radiomenuitem_class_;
  RadioMenuItem(const RadioMenuItem&);
  RadioMenuItem& operator=(const RadioMenuItem&);
protected:
  explicit RadioMenuItem(const Glib::ConstructParams& construct_params);
  explicit RadioMenuItem(GtkRadioMenuItem* castitem);
public:
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkRadioMenuItem* gobj() { return reinterpret_cast<GtkRadioMenuItem*>(gobject_); }
  const GtkRadioMenuItem* gobj() const { return reinterpret_cast<GtkRadioMenuItem*>(gobject_); }
public:
protected:
  virtual void on_group_changed();
private:
public:
  typedef RadioButtonGroup Group;
  RadioMenuItem(Group& groupx);
  RadioMenuItem(Group& groupx, const Glib::ustring& label, bool mnemonic = false);
  Group get_group();
  void set_group(Group& group);
  void reset_group();
  Glib::SignalProxy0< void > signal_group_changed();
protected:
  void constructor(const Group& group);
};
}
namespace Glib
{
  Gtk::RadioMenuItem* wrap(GtkRadioMenuItem* object, bool take_copy = false);
}
typedef struct _GtkTearoffMenuItem GtkTearoffMenuItem;
typedef struct _GtkTearoffMenuItemClass GtkTearoffMenuItemClass;
namespace Gtk
{ class TearoffMenuItem_Class; }
namespace Gtk
{
class TearoffMenuItem : public MenuItem
{
  public:
  typedef TearoffMenuItem CppObjectType;
  typedef TearoffMenuItem_Class CppClassType;
  typedef GtkTearoffMenuItem BaseObjectType;
  typedef GtkTearoffMenuItemClass BaseClassType;
  virtual ~TearoffMenuItem();
private:
  friend class TearoffMenuItem_Class;
  static CppClassType tearoffmenuitem_class_;
  TearoffMenuItem(const TearoffMenuItem&);
  TearoffMenuItem& operator=(const TearoffMenuItem&);
protected:
  explicit TearoffMenuItem(const Glib::ConstructParams& construct_params);
  explicit TearoffMenuItem(GtkTearoffMenuItem* castitem);
public:
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkTearoffMenuItem* gobj() { return reinterpret_cast<GtkTearoffMenuItem*>(gobject_); }
  const GtkTearoffMenuItem* gobj() const { return reinterpret_cast<GtkTearoffMenuItem*>(gobject_); }
public:
protected:
private:
public:
  TearoffMenuItem();
  bool is_torn_off() const;
};
}
namespace Glib
{
  Gtk::TearoffMenuItem* wrap(GtkTearoffMenuItem* object, bool take_copy = false);
}
typedef struct _GtkSeparatorMenuItem GtkSeparatorMenuItem;
typedef struct _GtkSeparatorMenuItemClass GtkSeparatorMenuItemClass;
namespace Gtk
{ class SeparatorMenuItem_Class; }
namespace Gtk
{
class SeparatorMenuItem : public MenuItem
{
  public:
  typedef SeparatorMenuItem CppObjectType;
  typedef SeparatorMenuItem_Class CppClassType;
  typedef GtkSeparatorMenuItem BaseObjectType;
  typedef GtkSeparatorMenuItemClass BaseClassType;
  virtual ~SeparatorMenuItem();
private:
  friend class SeparatorMenuItem_Class;
  static CppClassType separatormenuitem_class_;
  SeparatorMenuItem(const SeparatorMenuItem&);
  SeparatorMenuItem& operator=(const SeparatorMenuItem&);
protected:
  explicit SeparatorMenuItem(const Glib::ConstructParams& construct_params);
  explicit SeparatorMenuItem(GtkSeparatorMenuItem* castitem);
public:
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkSeparatorMenuItem* gobj() { return reinterpret_cast<GtkSeparatorMenuItem*>(gobject_); }
  const GtkSeparatorMenuItem* gobj() const { return reinterpret_cast<GtkSeparatorMenuItem*>(gobject_); }
public:
protected:
private:
public:
  SeparatorMenuItem();
};
}
namespace Glib
{
  Gtk::SeparatorMenuItem* wrap(GtkSeparatorMenuItem* object, bool take_copy = false);
}
namespace Gtk
{
class Menu;
namespace Menu_Helpers
{
class Element
{
public:
  typedef sigc::slot<void> CallSlot;
  Element();
  Element(MenuItem& child);
  ~Element();
  const Glib::RefPtr<MenuItem>& get_child() const;
protected:
  void set_child(MenuItem* pChild);
  void set_accel_key(const AccelKey& accel_key);
  Glib::RefPtr<MenuItem> child_;
};
class MenuElem : public Element
{
public:
  MenuElem(MenuItem& child);
  MenuElem(const Glib::ustring& label, const CallSlot& slot = CallSlot());
  MenuElem(const Glib::ustring& label, const AccelKey& key,
           const CallSlot& slot = CallSlot());
  MenuElem(const Glib::ustring& label, Gtk::Menu& submenu);
  MenuElem(const Glib::ustring& label,
           const AccelKey& key,
           Gtk::Menu& submenu);
};
class SeparatorElem : public Element
{
public:
  SeparatorElem();
};
class ImageMenuElem : public Element
{
public:
  ImageMenuElem(ImageMenuItem& child);
  ImageMenuElem(const Glib::ustring& label,
                Gtk::Widget& image_widget,
                const CallSlot& slot = CallSlot());
  ImageMenuElem(const Glib::ustring& label, const AccelKey& key,
                Gtk::Widget& image_widget,
                const CallSlot& slot = CallSlot());
  ImageMenuElem(const Glib::ustring& label,
                Gtk::Widget& image_widget,
                Gtk::Menu& submenu);
  ImageMenuElem(const Glib::ustring& label, const AccelKey& key,
                Gtk::Widget& image_widget,
                Gtk::Menu& submenu);
};
class StockMenuElem : public Element
{
public:
  StockMenuElem(const Gtk::StockID& stock_id,
                const CallSlot& slot = CallSlot());
  StockMenuElem(const Gtk::StockID& stock_id,
                const AccelKey& key,
                const CallSlot& slot = CallSlot());
  StockMenuElem(const Gtk::StockID& stock_id,
                Gtk::Menu& submenu);
  StockMenuElem(const Gtk::StockID& stock_id,
                const AccelKey& key,
                Gtk::Menu& submenu);
};
class CheckMenuElem : public Element
{
public:
  CheckMenuElem(CheckMenuItem& child);
  CheckMenuElem(const Glib::ustring& label, const CallSlot& slot = CallSlot());
  CheckMenuElem(const Glib::ustring& label, const AccelKey& key,
                const CallSlot& slot = CallSlot());
};
class RadioMenuElem : public Element
{
public:
  RadioMenuElem(RadioMenuItem& child);
  RadioMenuElem(RadioMenuItem::Group&, const Glib::ustring& label,
                const CallSlot& slot = CallSlot());
  RadioMenuElem(RadioMenuItem::Group& group, const Glib::ustring& label,
                const AccelKey& key,
                const CallSlot& slot = CallSlot());
protected:
  RadioMenuItem::Group* gr_;
};
class TearoffMenuElem : public Element
{
public:
  TearoffMenuElem(TearoffMenuItem& child);
  TearoffMenuElem(const CallSlot& slot = CallSlot());
  TearoffMenuElem(const AccelKey& key,
                  const CallSlot& slot = CallSlot());
};
}
}
typedef struct _GtkMenuShell GtkMenuShell;
typedef struct _GtkMenuShellClass GtkMenuShellClass;
namespace Gtk
{ class MenuShell_Class; }
namespace Gtk
{
class Menu;
class MenuShell;
class Window;
namespace Menu_Helpers
{
class MenuList : public Glib::HelperList< MenuItem, const Element, Glib::List_Cpp_Iterator<GtkMenuItem,MenuItem> >
{
public:
  MenuList();
  explicit MenuList(GtkMenuShell* gparent);
  MenuList(const MenuList& src);
  virtual ~MenuList() {}
  MenuList& operator=(const MenuList& src);
  typedef Glib::HelperList< MenuItem, const Element, Glib::List_Cpp_Iterator<GtkMenuItem,MenuItem> > type_base;
  GtkMenuShell* gparent();
  const GtkMenuShell* gparent() const;
  virtual GList*& glist() const;
  virtual void erase(iterator start, iterator stop);
  virtual iterator erase(iterator);
  virtual void remove(const_reference);
  reference operator[](size_type l) const;
public:
  iterator insert(iterator position, element_type& e);
  template <class InputIterator>
  inline void insert(iterator position, InputIterator first, InputIterator last)
  {
    for(;first != last; ++first)
      position = insert(position, *first);
  }
 inline void push_front(element_type& e)
    { insert(begin(), e); }
  inline void push_back(element_type& e)
    { insert(end(), e); }
  virtual void remove(Widget& widget);
  };
}
class MenuShell : public Container
{
  public:
  typedef MenuShell CppObjectType;
  typedef MenuShell_Class CppClassType;
  typedef GtkMenuShell BaseObjectType;
  typedef GtkMenuShellClass BaseClassType;
  virtual ~MenuShell();
private:
  friend class MenuShell_Class;
  static CppClassType menushell_class_;
  MenuShell(const MenuShell&);
  MenuShell& operator=(const MenuShell&);
protected:
  explicit MenuShell(const Glib::ConstructParams& construct_params);
  explicit MenuShell(GtkMenuShell* castitem);
public:
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkMenuShell* gobj() { return reinterpret_cast<GtkMenuShell*>(gobject_); }
  const GtkMenuShell* gobj() const { return reinterpret_cast<GtkMenuShell*>(gobject_); }
public:
protected:
  virtual void on_deactivate();
  virtual void on_selection_done();
private:
public:
  typedef Menu_Helpers::MenuList MenuList;
  friend class Menu_Helpers::MenuList;
  void append(MenuItem& menu_item);
  void prepend(MenuItem& menu_item);
  void insert(MenuItem& menu_item, int position);
  void select_item(MenuItem& menu_item);
  void deselect();
  void activate_item(MenuItem& menu_item, bool force_deactivate = false);
  void select_first(bool search_sensitive = true);
  void deactivate();
  void cancel();
  Glib::SignalProxy0< void > signal_deactivate();
  Glib::SignalProxy0< void > signal_selection_done();
  Glib::SignalProxy1< gboolean,int > signal_move_selected();
  MenuList& items();
  const MenuList& items() const;
  void accelerate(Window& window);
  void accelerate(Widget& parent);
  bool get_take_focus() const;
  void set_take_focus(bool take_focus = true);
  Glib::PropertyProxy<bool> property_take_focus() ;
  Glib::PropertyProxy_ReadOnly<bool> property_take_focus() const;
protected:
  MenuShell();
private:
  MenuList items_proxy_;
  Gtk::Window* accel_window_;
};
}
namespace Glib
{
  Gtk::MenuShell* wrap(GtkMenuShell* object, bool take_copy = false);
}
typedef struct _GtkMenu GtkMenu;
typedef struct _GtkMenuClass GtkMenuClass;
namespace Gtk
{ class Menu_Class; }
namespace Gtk
{
class AccelGroup;
class Menu : public MenuShell
{
  public:
  typedef Menu CppObjectType;
  typedef Menu_Class CppClassType;
  typedef GtkMenu BaseObjectType;
  typedef GtkMenuClass BaseClassType;
  virtual ~Menu();
private:
  friend class Menu_Class;
  static CppClassType menu_class_;
  Menu(const Menu&);
  Menu& operator=(const Menu&);
protected:
  explicit Menu(const Glib::ConstructParams& construct_params);
  explicit Menu(GtkMenu* castitem);
public:
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkMenu* gobj() { return reinterpret_cast<GtkMenu*>(gobject_); }
  const GtkMenu* gobj() const { return reinterpret_cast<GtkMenu*>(gobject_); }
public:
protected:
private:
public:
  Menu();
  typedef sigc::slot<void, int&, int&, bool&> SlotPositionCalc;
  void popup(MenuShell& parent_menu_shell, MenuItem& parent_menu_item, const SlotPositionCalc& slot, guint button, guint32 activate_time);
  void popup(const SlotPositionCalc& position_calc_slot, guint button, guint32 activate_time);
  void popup(guint button, guint32 activate_time);
  void reposition();
  void popdown();
  MenuItem* get_active();
  const MenuItem* get_active() const;
  void set_active(guint index);
  void set_accel_group(const Glib::RefPtr<AccelGroup>& accel_group);
  void unset_accel_group();
  Glib::RefPtr<AccelGroup> get_accel_group();
  Glib::RefPtr<const AccelGroup> get_accel_group() const;
  void set_accel_path(const Glib::ustring& accel_path);
  void detach();
  Widget* get_attach_widget();
  const Widget* get_attach_widget() const;
  void set_tearoff_state(bool torn_off = true);
  bool get_tearoff_state() const;
  void set_title(const Glib::ustring& title);
  void unset_title();
  Glib::ustring get_title() const;
  void set_screen(const Glib::RefPtr<Gdk::Screen>& screen);
  void attach(Gtk::Widget& child, guint left_attach, guint right_attach, guint top_attach, guint bottom_attach);
  void set_monitor(int monitor_num);
  void reorder_child(const MenuItem& child, int position);
  Glib::PropertyProxy<Glib::ustring> property_tearoff_title() ;
  Glib::PropertyProxy_ReadOnly<Glib::ustring> property_tearoff_title() const;
protected:
  typedef void (*GtkMenuDetachFunc) (GtkWidget *attach_widget, GtkMenu *menu);
  void attach_to_widget(Widget& attach_widget, GtkMenuDetachFunc detacher);
  void attach_to_widget(Widget& attach_widget);
};
}
namespace Glib
{
  Gtk::Menu* wrap(GtkMenu* object, bool take_copy = false);
}
typedef struct _GtkEntryCompletion GtkEntryCompletion;
typedef struct _GtkEntryCompletionClass GtkEntryCompletionClass;
namespace Gtk
{ class EntryCompletion_Class; }
namespace Gtk
{
class Entry;
class EntryCompletion : public Glib::Object
{
public:
  typedef EntryCompletion CppObjectType;
  typedef EntryCompletion_Class CppClassType;
  typedef GtkEntryCompletion BaseObjectType;
  typedef GtkEntryCompletionClass BaseClassType;
private: friend class EntryCompletion_Class;
  static CppClassType entrycompletion_class_;
private:
  EntryCompletion(const EntryCompletion&);
  EntryCompletion& operator=(const EntryCompletion&);
protected:
  explicit EntryCompletion(const Glib::ConstructParams& construct_params);
  explicit EntryCompletion(GtkEntryCompletion* castitem);
public:
  virtual ~EntryCompletion();
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkEntryCompletion* gobj() { return reinterpret_cast<GtkEntryCompletion*>(gobject_); }
  const GtkEntryCompletion* gobj() const { return reinterpret_cast<GtkEntryCompletion*>(gobject_); }
  GtkEntryCompletion* gobj_copy();
private:
protected:
  EntryCompletion();
public:
  static Glib::RefPtr<EntryCompletion> create();
  Entry* get_entry();
  const Entry* get_entry() const;
  void set_model(const Glib::RefPtr<TreeModel>& model);
  Glib::RefPtr<TreeModel> get_model();
  Glib::RefPtr<const TreeModel> get_model() const;
  typedef sigc::slot<bool, const Glib::ustring&, const TreeModel::const_iterator&> SlotMatch;
  void set_match_func(const SlotMatch& slot);
  void set_minimum_key_length(int length);
  int get_minimum_key_length() const;
  void complete();
  void insert_prefix();
  void insert_action_text(const Glib::ustring& text, int index);
  void prepend_action_text(const Glib::ustring& text);
  void insert_action_markup(const Glib::ustring& markup, int index);
  void prepend_action_markup(const Glib::ustring& markup);
  void delete_action(int index = 0);
  void set_inline_completion(bool inline_completion = true);
  bool get_inline_completion() const;
  void set_inline_selection(bool inline_selection = true);
  bool get_inline_selection() const;
  void set_popup_completion(bool popup_completion = true);
  bool get_popup_completion() const;
  void set_popup_set_width(bool popup_set_width = true);
  bool get_popup_set_width() const;
  void set_popup_single_width(bool popup_single_match = true);
  bool get_popup_single_match() const;
  Glib::ustring get_completion_prefix() const;
  void set_text_column(const TreeModelColumnBase& column);
  void set_text_column(int column);
  int get_text_column();
  Glib::SignalProxy1< void,int > signal_action_activated();
  Glib::SignalProxy1< bool, const TreeModel::iterator& > signal_match_selected();
  Glib::SignalProxy1< bool, const TreeModel::iterator& > signal_cursor_on_match();
  Glib::SignalProxy1< bool,const Glib::ustring& > signal_insert_prefix();
  Glib::PropertyProxy< Glib::RefPtr<Gtk::TreeModel> > property_model() ;
  Glib::PropertyProxy_ReadOnly< Glib::RefPtr<Gtk::TreeModel> > property_model() const;
  Glib::PropertyProxy<int> property_minimum_key_length() ;
  Glib::PropertyProxy_ReadOnly<int> property_minimum_key_length() const;
  Glib::PropertyProxy<int> property_text_column() ;
  Glib::PropertyProxy_ReadOnly<int> property_text_column() const;
  Glib::PropertyProxy<bool> property_inline_completion() ;
  Glib::PropertyProxy_ReadOnly<bool> property_inline_completion() const;
  Glib::PropertyProxy<bool> property_popup_completion() ;
  Glib::PropertyProxy_ReadOnly<bool> property_popup_completion() const;
  Glib::PropertyProxy<bool> property_popup_set_width() ;
  Glib::PropertyProxy_ReadOnly<bool> property_popup_set_width() const;
  Glib::PropertyProxy<bool> property_popup_single_match() ;
  Glib::PropertyProxy_ReadOnly<bool> property_popup_single_match() const;
  Glib::PropertyProxy<bool> property_inline_selection() ;
  Glib::PropertyProxy_ReadOnly<bool> property_inline_selection() const;
protected:
  virtual bool on_match_selected(const TreeModel::iterator& iter);
public:
public:
protected:
  virtual void on_action_activated(int index);
};
}
namespace Glib
{
  Glib::RefPtr<Gtk::EntryCompletion> wrap(GtkEntryCompletion* object, bool take_copy = false);
}
typedef struct _GtkEntry GtkEntry;
typedef struct _GtkEntryClass GtkEntryClass;
namespace Gtk
{ class Entry_Class; }
namespace Gtk
{
typedef GtkBorder Border;
class Entry
: public Widget,
  public Editable,
  public CellEditable
{
  public:
  typedef Entry CppObjectType;
  typedef Entry_Class CppClassType;
  typedef GtkEntry BaseObjectType;
  typedef GtkEntryClass BaseClassType;
  virtual ~Entry();
private:
  friend class Entry_Class;
  static CppClassType entry_class_;
  Entry(const Entry&);
  Entry& operator=(const Entry&);
protected:
  explicit Entry(const Glib::ConstructParams& construct_params);
  explicit Entry(GtkEntry* castitem);
public:
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkEntry* gobj() { return reinterpret_cast<GtkEntry*>(gobject_); }
  const GtkEntry* gobj() const { return reinterpret_cast<GtkEntry*>(gobject_); }
public:
protected:
  virtual void on_populate_popup(Menu* menu);
  virtual void on_insert_at_cursor(const Glib::ustring& str);
  virtual void on_activate();
private:
public:
  Entry();
  void set_visibility(bool visible = true);
  bool get_visibility() const;
  void set_invisible_char(gunichar ch);
  gunichar get_invisible_char() const;
  void set_has_frame(bool setting = true);
  bool get_has_frame() const;
  void set_inner_border(const Border& border);
  Border get_inner_border() const;
  void set_max_length(int max);
  int get_max_length() const;
  void set_activates_default(bool setting = true);
  gboolean get_activates_default() const;
  void set_width_chars(int n_chars);
  int get_width_chars() const;
  void set_text(const Glib::ustring &text);
  Glib::ustring get_text() const;
  Glib::RefPtr<Pango::Layout> get_layout();
  Glib::RefPtr<const Pango::Layout> get_layout() const;
  void get_layout_offsets(int& x, int& y);
  int layout_index_to_text_index(int layout_index) const;
  int text_index_to_layout_index(int text_index) const;
  void set_cursor_hadjustment (Adjustment& adjustment);
  Adjustment* get_cursor_hadjustment();
  const Adjustment* get_cursor_hadjustment() const;
  void set_alignment(float xalign);
  void set_alignment(AlignmentEnum xalign);
  float get_alignment() const;
  void set_completion(const Glib::RefPtr<EntryCompletion>& completion);
  Glib::RefPtr<EntryCompletion> get_completion();
  Glib::RefPtr<const EntryCompletion> get_completion() const;
   guint16 get_text_length() const;
  Glib::SignalProxy1< void,Menu* > signal_populate_popup();
  Glib::SignalProxy1< void,const Glib::ustring& > signal_insert_at_cursor();
  Glib::SignalProxy0< void > signal_activate();
  Glib::PropertyProxy_ReadOnly<int> property_cursor_position() const;
  Glib::PropertyProxy_ReadOnly<int> property_selection_bound() const;
  Glib::PropertyProxy<bool> property_editable() ;
  Glib::PropertyProxy_ReadOnly<bool> property_editable() const;
  Glib::PropertyProxy<int> property_max_length() ;
  Glib::PropertyProxy_ReadOnly<int> property_max_length() const;
  Glib::PropertyProxy<bool> property_visibility() ;
  Glib::PropertyProxy_ReadOnly<bool> property_visibility() const;
  Glib::PropertyProxy<bool> property_has_frame() ;
  Glib::PropertyProxy_ReadOnly<bool> property_has_frame() const;
  Glib::PropertyProxy<gunichar> property_invisible_char() ;
  Glib::PropertyProxy_ReadOnly<gunichar> property_invisible_char() const;
  Glib::PropertyProxy<bool> property_activates_default() ;
  Glib::PropertyProxy_ReadOnly<bool> property_activates_default() const;
  Glib::PropertyProxy<int> property_width_chars() ;
  Glib::PropertyProxy_ReadOnly<int> property_width_chars() const;
  Glib::PropertyProxy_ReadOnly<int> property_scroll_offset() const;
  Glib::PropertyProxy<Glib::ustring> property_text() ;
  Glib::PropertyProxy_ReadOnly<Glib::ustring> property_text() const;
  Glib::PropertyProxy<float> property_xalign() ;
  Glib::PropertyProxy_ReadOnly<float> property_xalign() const;
  Glib::PropertyProxy<bool> property_truncate_multiline() ;
  Glib::PropertyProxy_ReadOnly<bool> property_truncate_multiline() const;
};
}
namespace Glib
{
  Gtk::Entry* wrap(GtkEntry* object, bool take_copy = false);
}
typedef struct _GtkListItem GtkListItem;
typedef struct _GtkListItemClass GtkListItemClass;
namespace Gtk
{ class ComboDropDownItem_Class; }
typedef struct _GtkList GtkList;
typedef struct _GtkListClass GtkListClass;
namespace Gtk
{ class ComboDropDown_Class; }
typedef struct _GtkCombo GtkCombo;
typedef struct _GtkComboClass GtkComboClass;
namespace Gtk
{ class Combo_Class; }
namespace Gtk
{
class ComboDropDownItem : public Gtk::Item
{
  public:
  typedef ComboDropDownItem CppObjectType;
  typedef ComboDropDownItem_Class CppClassType;
  typedef GtkListItem BaseObjectType;
  typedef GtkListItemClass BaseClassType;
  virtual ~ComboDropDownItem();
private:
  friend class ComboDropDownItem_Class;
  static CppClassType combodropdownitem_class_;
  ComboDropDownItem(const ComboDropDownItem&);
  ComboDropDownItem& operator=(const ComboDropDownItem&);
protected:
  explicit ComboDropDownItem(const Glib::ConstructParams& construct_params);
  explicit ComboDropDownItem(GtkListItem* castitem);
public:
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkListItem* gobj() { return reinterpret_cast<GtkListItem*>(gobject_); }
  const GtkListItem* gobj() const { return reinterpret_cast<GtkListItem*>(gobject_); }
public:
protected:
  virtual void on_scroll_horizontal(ScrollType scroll_type, float position);
  virtual void on_scroll_vertical(ScrollType scroll_type, float position);
private:
public:
  ComboDropDownItem();
  Glib::SignalProxy2< void,ScrollType,float > signal_scroll_horizontal();
  Glib::SignalProxy2< void,ScrollType,float > signal_scroll_vertical();
};
namespace ComboDropDown_Helpers
{
typedef Gtk::ComboDropDownItem Element;
class ComboDropDownList : public Glib::HelperList< ComboDropDownItem, const Element, Glib::List_Cpp_Iterator<GtkListItem,ComboDropDownItem> >
{
public:
  ComboDropDownList();
  explicit ComboDropDownList(GtkList* gparent);
  ComboDropDownList(const ComboDropDownList& src);
  virtual ~ComboDropDownList() {}
  ComboDropDownList& operator=(const ComboDropDownList& src);
  typedef Glib::HelperList< ComboDropDownItem, const Element, Glib::List_Cpp_Iterator<GtkListItem,ComboDropDownItem> > type_base;
  GtkList* gparent();
  const GtkList* gparent() const;
  virtual GList*& glist() const;
  virtual void erase(iterator start, iterator stop);
  virtual iterator erase(iterator);
  virtual void remove(const_reference);
  reference operator[](size_type l) const;
public:
  iterator insert(iterator position, element_type& e);
  template <class InputIterator>
  inline void insert(iterator position, InputIterator first, InputIterator last)
  {
    for(;first != last; ++first)
      position = insert(position, *first);
  }
 inline void push_front(element_type& e)
    { insert(begin(), e); }
  inline void push_back(element_type& e)
    { insert(end(), e); }
  iterator find(const_reference c);
  iterator find(Widget&);
  };
}
class Combo;
class ComboDropDown : public Gtk::Container
{
  public:
  typedef ComboDropDown CppObjectType;
  typedef ComboDropDown_Class CppClassType;
  typedef GtkList BaseObjectType;
  typedef GtkListClass BaseClassType;
  virtual ~ComboDropDown();
private:
  friend class ComboDropDown_Class;
  static CppClassType combodropdown_class_;
  ComboDropDown(const ComboDropDown&);
  ComboDropDown& operator=(const ComboDropDown&);
protected:
  explicit ComboDropDown(const Glib::ConstructParams& construct_params);
  explicit ComboDropDown(GtkList* castitem);
public:
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkList* gobj() { return reinterpret_cast<GtkList*>(gobject_); }
  const GtkList* gobj() const { return reinterpret_cast<GtkList*>(gobject_); }
public:
protected:
  virtual void on_select_child(Widget& item);
  virtual void on_selection_changed();
  virtual void on_unselect_child(Widget& item);
private:
public:
  typedef ComboDropDown_Helpers::ComboDropDownList ComboDropDownList;
protected:
  ComboDropDown();
  friend class Combo;
public:
  void scroll_horizontal(ScrollType scroll_type, float position);
  void scroll_vertical(ScrollType scroll_type, float position);
  ComboDropDownList& children();
  const ComboDropDownList& children() const;
  Glib::SignalProxy1< void,Widget& > signal_select_child();
  Glib::SignalProxy0< void > signal_selection_changed();
  Glib::SignalProxy1< void,Widget& > signal_unselect_child();
protected:
  mutable ComboDropDownList children_proxy_;
};
class ScrolledWindow;
class Window;
class Combo : public HBox
{
  public:
  typedef Combo CppObjectType;
  typedef Combo_Class CppClassType;
  typedef GtkCombo BaseObjectType;
  typedef GtkComboClass BaseClassType;
  virtual ~Combo();
private:
  friend class Combo_Class;
  static CppClassType combo_class_;
  Combo(const Combo&);
  Combo& operator=(const Combo&);
protected:
  explicit Combo(const Glib::ConstructParams& construct_params);
  explicit Combo(GtkCombo* castitem);
public:
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkCombo* gobj() { return reinterpret_cast<GtkCombo*>(gobject_); }
  const GtkCombo* gobj() const { return reinterpret_cast<GtkCombo*>(gobject_); }
public:
protected:
private:
public:
  Combo();
  void set_value_in_list(bool value = true, bool empty = false);
  void set_use_arrows(bool arrows_on = true);
  void set_use_arrows_always(bool arrows_always = true);
  void set_case_sensitive(bool val = true);
  void set_item_string(Gtk::Item& item, const Glib::ustring& item_value);
   void remove_item_string(Gtk::Item& item);
  void set_popdown_strings(const Glib::ListHandle<Glib::ustring>& strings);
  Glib::ListHandle<Glib::ustring> get_popdown_strings() const;
  void disable_activate();
   Entry* get_entry();
  const Entry* get_entry() const;
    ComboDropDown* get_list();
  const ComboDropDown* get_list() const;
  Glib::PropertyProxy<bool> property_enable_arrow_keys() ;
  Glib::PropertyProxy_ReadOnly<bool> property_enable_arrow_keys() const;
  Glib::PropertyProxy<bool> property_enable_arrows_always() ;
  Glib::PropertyProxy_ReadOnly<bool> property_enable_arrows_always() const;
  Glib::PropertyProxy<bool> property_case_sensitive() ;
  Glib::PropertyProxy_ReadOnly<bool> property_case_sensitive() const;
  Glib::PropertyProxy<bool> property_allow_empty() ;
  Glib::PropertyProxy_ReadOnly<bool> property_allow_empty() const;
  Glib::PropertyProxy<bool> property_value_in_list() ;
  Glib::PropertyProxy_ReadOnly<bool> property_value_in_list() const;
};
}
namespace Glib
{
  Gtk::ComboDropDownItem* wrap(GtkListItem* object, bool take_copy = false);
}
namespace Glib
{
  Gtk::ComboDropDown* wrap(GtkList* object, bool take_copy = false);
}
namespace Glib
{
  Gtk::Combo* wrap(GtkCombo* object, bool take_copy = false);
}
typedef struct _GtkTreeViewColumn GtkTreeViewColumn;
typedef struct _GtkTreeViewColumnClass GtkTreeViewColumnClass;
namespace Gtk
{ class TreeViewColumn_Class; }
namespace Gtk
{
enum TreeViewColumnSizing
{
  TREE_VIEW_COLUMN_GROW_ONLY,
  TREE_VIEW_COLUMN_AUTOSIZE,
  TREE_VIEW_COLUMN_FIXED
};
}
namespace Glib
{
template <>
class Value<Gtk::TreeViewColumnSizing> : public Glib::Value_Enum<Gtk::TreeViewColumnSizing>
{
public:
  static GType value_type() __attribute__((__const__));
};
}
namespace Gtk
{
class TreeViewColumn : public Gtk::Object
{
  public:
  typedef TreeViewColumn CppObjectType;
  typedef TreeViewColumn_Class CppClassType;
  typedef GtkTreeViewColumn BaseObjectType;
  typedef GtkTreeViewColumnClass BaseClassType;
  virtual ~TreeViewColumn();
private:
  friend class TreeViewColumn_Class;
  static CppClassType treeviewcolumn_class_;
  TreeViewColumn(const TreeViewColumn&);
  TreeViewColumn& operator=(const TreeViewColumn&);
protected:
  explicit TreeViewColumn(const Glib::ConstructParams& construct_params);
  explicit TreeViewColumn(GtkTreeViewColumn* castitem);
public:
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkTreeViewColumn* gobj() { return reinterpret_cast<GtkTreeViewColumn*>(gobject_); }
  const GtkTreeViewColumn* gobj() const { return reinterpret_cast<GtkTreeViewColumn*>(gobject_); }
public:
protected:
  virtual void on_clicked();
private:
public:
  typedef TreeViewColumn Column;
  TreeViewColumn();
  explicit TreeViewColumn(const Glib::ustring& title);
  TreeViewColumn(const Glib::ustring& title, CellRenderer& cell);
  template<class T_ModelColumnType>
  TreeViewColumn(const Glib::ustring& title, const TreeModelColumn<T_ModelColumnType>& column);
  void pack_start(CellRenderer& cell, bool expand = true);
  void pack_end(CellRenderer& cell, bool expand = true);
  template<class T_ModelColumnType>
  void pack_start(const TreeModelColumn<T_ModelColumnType>& column, bool expand = true);
  template<class T_ModelColumnType>
  void pack_end(const TreeModelColumn<T_ModelColumnType>& column, bool expand = true);
  void clear();
  CellRenderer* get_first_cell_renderer();
  const CellRenderer* get_first_cell_renderer() const;
  Glib::ListHandle<CellRenderer*> get_cell_renderers();
  Glib::ListHandle<const CellRenderer*> get_cell_renderers() const;
  void add_attribute(CellRenderer& cell_renderer, const Glib::ustring& attribute, int column);
  void add_attribute(const Glib::PropertyProxy_Base& property, const TreeModelColumnBase& column);
  void add_attribute(Gtk::CellRenderer& cell, const Glib::ustring& property_name, const TreeModelColumnBase& column);
  void set_renderer(Gtk::CellRenderer& renderer, const TreeModelColumnBase& column);
  typedef sigc::slot<void, CellRenderer*, const Gtk::TreeModel::iterator&> SlotCellData;
  void set_cell_data_func(CellRenderer& cell_renderer, const SlotCellData& slot);
  void unset_cell_data_func(CellRenderer& cell_renderer);
  void clear_attributes(CellRenderer& cell_renderer);
  void set_spacing(int spacing);
  int get_spacing() const;
  void set_visible(bool visible = true);
  bool get_visible() const;
  void set_resizable(bool resizable = true);
  bool get_resizable() const;
  void set_sizing(TreeViewColumnSizing type);
  TreeViewColumnSizing get_sizing();
  int get_width() const;
  int get_fixed_width() const;
  void set_fixed_width(int fixed_width);
  void set_min_width(int min_width);
  int get_min_width() const;
  void set_max_width(int max_width);
  int get_max_width() const;
  void clicked();
  void set_title(const Glib::ustring& title);
  Glib::ustring get_title() const;
  void set_expand(bool expand = true);
  bool get_expand() const;
  void set_clickable(bool clickable = true);
  bool get_clickable() const;
  void set_widget(Gtk::Widget& widget);
  Widget* get_widget();
  const Widget* get_widget() const;
  void set_alignment(float xalign);
  void set_alignment(AlignmentEnum xalign);
  float get_alignment() const;
  void set_reorderable(bool reorderable = true);
  bool get_reorderable() const;
  void set_sort_column(const TreeModelColumnBase& sort_column_id);
  void set_sort_column(int sort_column_id);
  void set_sort_column_id(const TreeModelColumnBase& sort_column_id);
  void set_sort_column_id(int sort_column_id);
  int get_sort_column_id() const;
  void set_sort_indicator(bool setting);
  bool get_sort_indicator() const;
  void set_sort_order(SortType order);
  SortType get_sort_order() const;
  void cell_set_cell_data(const Glib::RefPtr<TreeModel>& tree_model, const TreeModel::iterator& iter, bool is_expander, bool is_expanded);
  void cell_get_size(Gdk::Rectangle& cell_area, int& x_offset, int& y_offset, int& width, int& height) const;
  bool cell_is_visible() const;
  void focus_cell(CellRenderer& cell);
  bool get_cell_position(const CellRenderer& cell_renderer, int& start_pos, int& width) const;
  void queue_resize();
  Glib::SignalProxy0< void > signal_clicked();
  Glib::PropertyProxy<bool> property_visible() ;
  Glib::PropertyProxy_ReadOnly<bool> property_visible() const;
  Glib::PropertyProxy_ReadOnly<int> property_width() const;
  Glib::PropertyProxy<TreeViewColumnSizing> property_sizing() ;
  Glib::PropertyProxy_ReadOnly<TreeViewColumnSizing> property_sizing() const;
  Glib::PropertyProxy<int> property_fixed_width() ;
  Glib::PropertyProxy_ReadOnly<int> property_fixed_width() const;
  Glib::PropertyProxy<int> property_min_width() ;
  Glib::PropertyProxy_ReadOnly<int> property_min_width() const;
  Glib::PropertyProxy<int> property_max_width() ;
  Glib::PropertyProxy_ReadOnly<int> property_max_width() const;
  Glib::PropertyProxy<Glib::ustring> property_title() ;
  Glib::PropertyProxy_ReadOnly<Glib::ustring> property_title() const;
  Glib::PropertyProxy<bool> property_expand() ;
  Glib::PropertyProxy_ReadOnly<bool> property_expand() const;
  Glib::PropertyProxy<bool> property_clickable() ;
  Glib::PropertyProxy_ReadOnly<bool> property_clickable() const;
  Glib::PropertyProxy<Widget*> property_widget() ;
  Glib::PropertyProxy_ReadOnly<Widget*> property_widget() const;
  Glib::PropertyProxy<float> property_alignment() ;
  Glib::PropertyProxy_ReadOnly<float> property_alignment() const;
  Glib::PropertyProxy<bool> property_reorderable() ;
  Glib::PropertyProxy_ReadOnly<bool> property_reorderable() const;
  Glib::PropertyProxy<bool> property_sort_indicator() ;
  Glib::PropertyProxy_ReadOnly<bool> property_sort_indicator() const;
  Glib::PropertyProxy<SortType> property_sort_order() ;
  Glib::PropertyProxy_ReadOnly<SortType> property_sort_order() const;
private:
  static const Glib::Class& class_init_();
};
template<class T_ModelColumnType> inline
void TreeViewColumn::pack_start(const TreeModelColumn<T_ModelColumnType>& column, bool expand)
{
  CellRenderer* pCellRenderer = manage( CellRenderer_Generation::generate_cellrenderer<T_ModelColumnType>() );
  pack_start(*pCellRenderer, expand);
  set_renderer(*pCellRenderer, column);
}
template<class T_ModelColumnType> inline
void TreeViewColumn::pack_end(const TreeModelColumn<T_ModelColumnType>& column, bool expand)
{
  CellRenderer* pCellRenderer= manage( CellRenderer_Generation::generate_cellrenderer<T_ModelColumnType>() );
  pack_end(*pCellRenderer, expand);
  set_renderer(*pCellRenderer, column);
}
template <class T_ModelColumnType> inline
TreeViewColumn::TreeViewColumn(const Glib::ustring& title,
                               const TreeModelColumn<T_ModelColumnType>& column)
:
  Glib::ObjectBase(0),
  Gtk::Object(Glib::ConstructParams(class_init_(), "title", title.c_str(), (char*) 0))
{
  pack_start(column, true );
}
}
namespace Glib
{
  Gtk::TreeViewColumn* wrap(GtkTreeViewColumn* object, bool take_copy = false);
}
typedef struct _GtkTreeSelection GtkTreeSelection;
typedef struct _GtkTreeSelectionClass GtkTreeSelectionClass;
namespace Gtk
{ class TreeSelection_Class; }
namespace Gtk
{
class TreeView;
class TreeModel;
class TreePath;
class TreeSelection : public Glib::Object
{
public:
  typedef TreeSelection CppObjectType;
  typedef TreeSelection_Class CppClassType;
  typedef GtkTreeSelection BaseObjectType;
  typedef GtkTreeSelectionClass BaseClassType;
private: friend class TreeSelection_Class;
  static CppClassType treeselection_class_;
private:
  TreeSelection(const TreeSelection&);
  TreeSelection& operator=(const TreeSelection&);
protected:
  explicit TreeSelection(const Glib::ConstructParams& construct_params);
  explicit TreeSelection(GtkTreeSelection* castitem);
public:
  virtual ~TreeSelection();
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkTreeSelection* gobj() { return reinterpret_cast<GtkTreeSelection*>(gobject_); }
  const GtkTreeSelection* gobj() const { return reinterpret_cast<GtkTreeSelection*>(gobject_); }
  GtkTreeSelection* gobj_copy();
private:
protected:
public:
  void set_mode(SelectionMode type);
  SelectionMode get_mode() const;
  typedef sigc::slot<bool, const Glib::RefPtr<TreeModel>&, const TreeModel::Path&, bool> SlotSelect;
  void set_select_function(const SlotSelect& slot);
  TreeView* get_tree_view();
  const TreeView* get_tree_view() const;
  Glib::RefPtr<TreeModel> get_model();
  Glib::RefPtr<const TreeModel> get_model() const;
  TreeModel::iterator get_selected();
  TreeModel::iterator get_selected(Glib::RefPtr<TreeModel>& model);
  typedef Glib::ListHandle<TreeModel::Path, TreePath_Traits> ListHandle_Path;
  ListHandle_Path get_selected_rows() const;
  ListHandle_Path get_selected_rows(Glib::RefPtr<TreeModel>& model);
  int count_selected_rows() const;
  typedef sigc::slot<void, const TreeModel::iterator&> SlotForeachIter;
  void selected_foreach_iter(const SlotForeachIter& slot) const;
  typedef sigc::slot<void, const TreeModel::Path&> SlotForeachPath;
  void selected_foreach_path(const SlotForeachPath& slot) const;
  typedef sigc::slot<void, const TreeModel::Path&, const TreeModel::iterator&> SlotForeachPathAndIter;
  void selected_foreach(const SlotForeachPathAndIter& slot) const;
  void select(const TreeModel::Path& path);
  void select(const TreeModel::iterator& iter);
  void select(const TreeModel::Row& row);
  void select(const TreeModel::Path& start_path, const TreeModel::Path& end_path);
  void unselect(const TreeModel::Path& path);
  void unselect(const TreeModel::Path& start_path, const TreeModel::Path& end_path);
  void unselect(const TreeModel::iterator& iter);
  bool is_selected(const TreeModel::Path& path) const;
  bool is_selected(const TreeModel::iterator& iter) const;
  void select_all();
  void unselect_all();
  Glib::SignalProxy0< void > signal_changed();
public:
public:
protected:
  virtual void on_changed();
};
}
namespace Glib
{
  Glib::RefPtr<Gtk::TreeSelection> wrap(GtkTreeSelection* object, bool take_copy = false);
}
typedef struct _GtkTooltip GtkTooltip;
typedef struct _GtkTooltipClass GtkTooltipClass;
namespace Gtk
{ class Tooltip_Class; }
namespace Gtk
{
class Tooltip : public Glib::Object
{
protected:
public:
  typedef Tooltip CppObjectType;
  typedef Tooltip_Class CppClassType;
  typedef GtkTooltip BaseObjectType;
  typedef GtkTooltipClass BaseClassType;
private: friend class Tooltip_Class;
  static CppClassType tooltip_class_;
private:
  Tooltip(const Tooltip&);
  Tooltip& operator=(const Tooltip&);
protected:
  explicit Tooltip(const Glib::ConstructParams& construct_params);
  explicit Tooltip(GtkTooltip* castitem);
public:
  virtual ~Tooltip();
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkTooltip* gobj() { return reinterpret_cast<GtkTooltip*>(gobject_); }
  const GtkTooltip* gobj() const { return reinterpret_cast<GtkTooltip*>(gobject_); }
  GtkTooltip* gobj_copy();
private:
public:
  void set_markup(const Glib::ustring& markup);
  void set_text(const Glib::ustring& markup);
  void set_icon(const Glib::RefPtr<Gdk::Pixbuf>& pixbuf);
  void set_icon_from_stock(const StockID& stock_id, IconSize size);
  void set_custom(Widget& custom_widget);
  void set_tip_area(const Gdk::Rectangle& rect);
  static void trigger_tooltip_query(const Glib::RefPtr<Gdk::Display>& display);
public:
public:
protected:
};
}
namespace Glib
{
  Glib::RefPtr<Gtk::Tooltip> wrap(GtkTooltip* object, bool take_copy = false);
}
typedef struct _GtkTreeView GtkTreeView;
typedef struct _GtkTreeViewClass GtkTreeViewClass;
namespace Gtk
{ class TreeView_Class; }
namespace Gtk
{
enum TreeViewDropPosition
{
  TREE_VIEW_DROP_BEFORE,
  TREE_VIEW_DROP_AFTER,
  TREE_VIEW_DROP_INTO_OR_BEFORE,
  TREE_VIEW_DROP_INTO_OR_AFTER
};
}
namespace Glib
{
template <>
class Value<Gtk::TreeViewDropPosition> : public Glib::Value_Enum<Gtk::TreeViewDropPosition>
{
public:
  static GType value_type() __attribute__((__const__));
};
}
namespace Gtk
{
enum TreeViewGridLines
{
  TREE_VIEW_GRID_LINES_NONE,
  TREE_VIEW_GRID_LINES_HORIZONTAL,
  TREE_VIEW_GRID_LINES_VERTICAL,
  TREE_VIEW_GRID_LINES_BOTH
};
}
namespace Glib
{
template <>
class Value<Gtk::TreeViewGridLines> : public Glib::Value_Enum<Gtk::TreeViewGridLines>
{
public:
  static GType value_type() __attribute__((__const__));
};
}
namespace Gtk
{
class TreeView;
namespace TreeView_Private
{
  template <class ColumnType> inline
  void _connect_auto_store_editable_signal_handler(Gtk::TreeView* this_p, Gtk::CellRenderer* pCellRenderer, const Gtk::TreeModelColumn<ColumnType>& model_column);
  template<class ColumnType> inline
  void _auto_store_on_cellrenderer_text_edited_string(const Glib::ustring& path_string, const Glib::ustring& new_text, int model_column, const Glib::RefPtr<Gtk::TreeModel>& model);
  template <class ColumnType> inline
  void _auto_store_on_cellrenderer_text_edited_numerical(const Glib::ustring& path_string, const Glib::ustring& new_text, int model_column, const Glib::RefPtr<Gtk::TreeModel>& model);
  template <class ColumnType> inline
  void _auto_cell_data_func(Gtk::CellRenderer* cell, const Gtk::TreeModel::iterator& iter, int model_column, const Glib::ustring& format);
}
class TreeModel;
class TreeView : public Container
{
  public:
  typedef TreeView CppObjectType;
  typedef TreeView_Class CppClassType;
  typedef GtkTreeView BaseObjectType;
  typedef GtkTreeViewClass BaseClassType;
  virtual ~TreeView();
private:
  friend class TreeView_Class;
  static CppClassType treeview_class_;
  TreeView(const TreeView&);
  TreeView& operator=(const TreeView&);
protected:
  explicit TreeView(const Glib::ConstructParams& construct_params);
  explicit TreeView(GtkTreeView* castitem);
public:
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkTreeView* gobj() { return reinterpret_cast<GtkTreeView*>(gobject_); }
  const GtkTreeView* gobj() const { return reinterpret_cast<GtkTreeView*>(gobject_); }
public:
protected:
  virtual void on_set_scroll_adjustments(Adjustment* hadjustment, Adjustment* vadjustment);
  virtual void on_row_activated(const TreeModel::Path& path, TreeViewColumn* column);
  virtual bool on_test_expand_row(const TreeModel::iterator& iter, const TreeModel::Path& path);
  virtual bool on_test_collapse_row(const TreeModel::iterator& iter, const TreeModel::Path& path);
  virtual void on_row_expanded(const TreeModel::iterator& iter, const TreeModel::Path& path);
  virtual void on_row_collapsed(const TreeModel::iterator& iter, const TreeModel::Path& path);
  virtual void on_cursor_changed();
  virtual void on_columns_changed();
private:
public:
  typedef TreeViewColumn Column;
  typedef TreeSelection Selection;
  TreeView();
  explicit TreeView(const Glib::RefPtr<TreeModel>& model);
  Glib::RefPtr<TreeModel> get_model();
  Glib::RefPtr<const TreeModel> get_model() const;
  void set_model(const Glib::RefPtr<TreeModel>& model);
  void unset_model();
  Glib::RefPtr<TreeSelection> get_selection();
  Glib::RefPtr<const TreeSelection> get_selection() const;
  Adjustment* get_hadjustment();
  const Adjustment* get_hadjustment() const;
  void set_hadjustment(Adjustment& adjustment);
  void unset_hadjustment();
  Adjustment* get_vadjustment();
  const Adjustment* get_vadjustment() const;
  void set_vadjustment(Adjustment& adjustment);
  void unset_vadjustment();
  bool get_headers_visible() const;
  void set_headers_visible(bool headers_visible);
  void columns_autosize();
  bool get_headers_clickable() const;
  void set_headers_clickable(bool setting = true);
  void set_rules_hint(bool setting = true);
  bool get_rules_hint() const;
  int append_column(TreeViewColumn& column);
  template <class ColumnType> inline
  int append_column(const Glib::ustring& title, const TreeModelColumn<ColumnType>& model_column);
  template <class ColumnType> inline
  int append_column_numeric(const Glib::ustring& title, const TreeModelColumn<ColumnType>& model_column, const Glib::ustring& format);
  template <class ColumnType> inline
  int append_column_editable(const Glib::ustring& title, const TreeModelColumn<ColumnType>& model_column);
  template <class ColumnType> inline
  int append_column_numeric_editable(const Glib::ustring& title, const TreeModelColumn<ColumnType>& model_column, const Glib::ustring& format);
  int append_column(const Glib::ustring& title, CellRenderer& cell);
  int remove_column(TreeViewColumn& column);
  void remove_all_columns();
  int insert_column(TreeViewColumn& column, int position);
  int insert_column(const Glib::ustring& title, CellRenderer& cell, int position);
  template <class ColumnType> inline
  int insert_column(const Glib::ustring& title, const TreeModelColumn<ColumnType>& model_column, int position);
  template <class ColumnType> inline
  int insert_column_editable(const Glib::ustring& title, const TreeModelColumn<ColumnType>& model_column, int position);
  typedef TreeViewColumn::SlotCellData SlotCellData;
  int insert_column_with_data_func(int position, const Glib::ustring& title, CellRenderer& cell, const SlotCellData& slot);
  TreeViewColumn* get_column(int n);
  const TreeViewColumn* get_column(int n) const;
  CellRenderer* get_column_cell_renderer(int n);
  const CellRenderer* get_column_cell_renderer(int n) const;
  Glib::ListHandle<TreeViewColumn*> get_columns();
  Glib::ListHandle<const TreeViewColumn*> get_columns() const;
  void move_column_after(TreeViewColumn& column, TreeViewColumn& base_column);
  void move_column_to_start(TreeViewColumn& column);
  void set_expander_column(TreeViewColumn& column);
  void reset_expander_column();
  TreeViewColumn* get_expander_column();
  const TreeViewColumn* get_expander_column() const;
  typedef sigc::slot<bool, TreeView*, TreeViewColumn*, TreeViewColumn*, TreeViewColumn*> SlotColumnDrop;
  void set_column_drag_function(const SlotColumnDrop& slot);
  void unset_column_drag_function();
  void scroll_to_point(int tree_x, int tree_y);
  void scroll_to_cell(const TreeModel::Path& path, TreeViewColumn& column, float row_align, float col_align);
  void scroll_to_cell(const TreeModel::Path& path, TreeViewColumn& column);
  void scroll_to_row(const TreeModel::Path& path, float row_align);
  void scroll_to_row(const TreeModel::Path& path);
  void scroll_to_column(TreeViewColumn& column, float col_align);
  void scroll_to_column(TreeViewColumn& column);
  void row_activated(const TreeModel::Path& path,TreeViewColumn& column);
  void expand_all();
  void collapse_all();
  void expand_to_path(const TreeModel::Path& path);
  bool expand_row(const TreeModel::Path& path, bool open_all);
  bool collapse_row(const TreeModel::Path& path);
  typedef sigc::slot<void, TreeView*, const TreeModel::Path&> SlotMapping;
  void map_expanded_rows(const SlotMapping& slot);
  bool row_expanded(const TreeModel::Path& path);
  void set_reorderable(bool reorderable = true);
  bool get_reorderable() const;
  void set_cursor(const TreeModel::Path& path, TreeViewColumn& focus_column, bool start_editing = false);
  void set_cursor(const TreeModel::Path& path, TreeViewColumn& focus_column, CellRenderer& focus_cell, bool start_editing = false);
  void set_cursor(const TreeModel::Path& path);
  void get_cursor(TreeModel::Path& path, TreeViewColumn*& focus_column);
  Glib::RefPtr<Gdk::Window> get_bin_window();
  Glib::RefPtr<const Gdk::Window> get_bin_window() const;
  bool get_path_at_pos(int x, int y, TreeModel::Path& path, TreeViewColumn*& column, int& cell_x, int& cell_y);
  bool get_path_at_pos(int x, int y, TreeModel::Path& path, TreeViewColumn*& column, int& cell_x, int& cell_y) const;
  void get_cell_area(const TreeModel::Path& path, TreeViewColumn& column, Gdk::Rectangle& rect);
  void get_cell_area(const TreeModel::Path& path, TreeViewColumn& column, Gdk::Rectangle& rect) const;
  void get_background_area(const TreeModel::Path& path, TreeViewColumn& column, Gdk::Rectangle& rect);
  void get_background_area(const TreeModel::Path& path, TreeViewColumn& column, Gdk::Rectangle& rect) const;
  void get_visible_rect(Gdk::Rectangle& visible_rect);
  void get_visible_rect(Gdk::Rectangle& visible_rect) const;
  void widget_to_tree_coords(int wx, int wy, int& tx, int& ty);
  void widget_to_tree_coords(int wx, int wy, int& tx, int& ty) const;
  void tree_to_widget_coords(int tx, int ty, int& wx, int& wy);
  void tree_to_widget_coords(int tx, int ty, int& wx, int& wy) const;
   bool get_visible_range(TreeModel::Path& start_path, TreeModel::Path& end_path) const;
  void enable_model_drag_source(const ArrayHandle_TargetEntry& targets,
                                Gdk::ModifierType start_button_mask = Gdk::MODIFIER_MASK,
                                Gdk::DragAction actions = Gdk::ACTION_COPY | Gdk::ACTION_MOVE);
  void enable_model_drag_source(Gdk::ModifierType start_button_mask = Gdk::MODIFIER_MASK,
                                Gdk::DragAction actions = Gdk::ACTION_COPY | Gdk::ACTION_MOVE);
  void enable_model_drag_dest(const ArrayHandle_TargetEntry& targets, Gdk::DragAction actions = Gdk::ACTION_COPY | Gdk::ACTION_MOVE);
  void enable_model_drag_dest(Gdk::DragAction actions = Gdk::ACTION_COPY | Gdk::ACTION_MOVE);
  void unset_rows_drag_source();
  void unset_rows_drag_dest();
  void set_drag_dest_row(const TreeModel::Path& path, TreeViewDropPosition pos);
  void get_drag_dest_row(TreeModel::Path& path, TreeViewDropPosition& pos) const;
  bool get_dest_row_at_pos(int drag_x, int drag_y, TreeModel::Path& path, TreeViewDropPosition& pos) const;
  Glib::RefPtr<Gdk::Pixmap> create_row_drag_icon(const TreeModel::Path& path);
  void set_enable_search(bool enable_search = true);
  bool get_enable_search() const;
  int get_search_column() const;
  void set_search_column(const TreeModelColumnBase& column);
  void set_search_column(int column);
  typedef sigc::slot<bool, const Glib::RefPtr<TreeModel>&, int, const Glib::ustring&, const TreeModel::iterator&> SlotSearchEqual;
  void set_search_equal_func(const SlotSearchEqual& slot);
  Entry* get_search_entry();
  const Entry* get_search_entry() const;
  void set_search_entry(Entry& entry);
  typedef sigc::slot<void, Gtk::Widget* > SlotSearchPosition;
  void set_search_position_func(const SlotSearchPosition& slot);
  void convert_widget_to_tree_coords(int wx, int wy, int& tx, int& ty) const;
  void convert_tree_to_widget_coords(int tx, int ty, int& wx, int& wy) const;
  void convert_widget_to_bin_window_coords(int wx, int wy, int& bx, int& by) const;
  void convert_bin_window_to_widget_coords(int bx, int by, int& wx, int& wy) const;
  void convert_tree_to_bin_window_coords(int tx, int ty, int& bx, int& by) const;
  void convert_bin_window_to_tree_coords(int bx, int by, int& tx, int& ty) const;
  void set_fixed_height_mode(bool enable = true);
  bool get_fixed_height_mode() const;
  void set_hover_selection(bool hover = true);
  bool get_hover_selection() const;
  void set_hover_expand(bool expand = true);
  bool get_hover_expand() const;
  void set_rubber_banding(bool enable = true);
  bool get_rubber_banding() const;
  bool is_rubber_banding_active() const;
  typedef sigc::slot<bool, const Glib::RefPtr<TreeModel>&, const TreeModel::iterator&> SlotRowSeparator;
  void set_row_separator_func(const SlotRowSeparator& slot);
  void set_grid_lines(TreeViewGridLines grid_lines);
  TreeViewGridLines get_grid_lines() const;
  void set_enable_tree_lines(bool enable = true);
  bool get_enable_tree_lines() const;
  void set_show_expanders(bool enabled = true);
  bool get_show_expanders() const;
  void set_level_indentation(int indentation);
  int get_level_indentation() const;
  void set_tooltip_row(const Glib::RefPtr<Tooltip>& tooltip, const TreePath& path);
  void set_tooltip_cell(const Glib::RefPtr<Tooltip>& tooltip, const TreeModel::Path* path, TreeViewColumn* column, CellRenderer* cell);
  bool get_tooltip_context_path(int& x, int& y,
                                bool keyboard_tip,
                                TreeModel::Path& path);
  bool get_tooltip_context_iter(int& x, int& y,
                                bool keyboard_tip,
                                Gtk::TreeModel::iterator& iter);
  void set_tooltip_column(int column);
  int get_tooltip_column() const;
  Glib::SignalProxy2< void,Adjustment*,Adjustment* > signal_set_scroll_adjustments();
  Glib::SignalProxy2< void,const TreeModel::Path&,TreeViewColumn* > signal_row_activated();
  Glib::SignalProxy2< bool,const TreeModel::iterator&,const TreeModel::Path& > signal_test_expand_row();
  Glib::SignalProxy2< bool,const TreeModel::iterator&,const TreeModel::Path& > signal_test_collapse_row();
  Glib::SignalProxy2< void,const TreeModel::iterator&,const TreeModel::Path& > signal_row_expanded();
  Glib::SignalProxy2< void,const TreeModel::iterator&,const TreeModel::Path& > signal_row_collapsed();
  Glib::SignalProxy0< void > signal_cursor_changed();
  Glib::SignalProxy0< void > signal_columns_changed();
  Glib::PropertyProxy< Glib::RefPtr<TreeModel> > property_model() ;
  Glib::PropertyProxy_ReadOnly< Glib::RefPtr<TreeModel> > property_model() const;
  Glib::PropertyProxy<Adjustment*> property_hadjustment() ;
  Glib::PropertyProxy_ReadOnly<Adjustment*> property_hadjustment() const;
  Glib::PropertyProxy<Adjustment*> property_vadjustment() ;
  Glib::PropertyProxy_ReadOnly<Adjustment*> property_vadjustment() const;
  Glib::PropertyProxy<bool> property_headers_visible() ;
  Glib::PropertyProxy_ReadOnly<bool> property_headers_visible() const;
  Glib::PropertyProxy<bool> property_headers_clickable() ;
  Glib::PropertyProxy_ReadOnly<bool> property_headers_clickable() const;
  Glib::PropertyProxy<TreeViewColumn*> property_expander_column() ;
  Glib::PropertyProxy_ReadOnly<TreeViewColumn*> property_expander_column() const;
  Glib::PropertyProxy<bool> property_reorderable() ;
  Glib::PropertyProxy_ReadOnly<bool> property_reorderable() const;
  Glib::PropertyProxy<bool> property_rules_hint() ;
  Glib::PropertyProxy_ReadOnly<bool> property_rules_hint() const;
  Glib::PropertyProxy<bool> property_enable_search() ;
  Glib::PropertyProxy_ReadOnly<bool> property_enable_search() const;
  Glib::PropertyProxy<int> property_search_column() ;
  Glib::PropertyProxy_ReadOnly<int> property_search_column() const;
  Glib::PropertyProxy<bool> property_fixed_height_mode() ;
  Glib::PropertyProxy_ReadOnly<bool> property_fixed_height_mode() const;
  Glib::PropertyProxy<bool> property_hover_selection() ;
  Glib::PropertyProxy_ReadOnly<bool> property_hover_selection() const;
  Glib::PropertyProxy<bool> property_hover_expand() ;
  Glib::PropertyProxy_ReadOnly<bool> property_hover_expand() const;
  Glib::PropertyProxy<bool> property_show_expanders() ;
  Glib::PropertyProxy_ReadOnly<bool> property_show_expanders() const;
  Glib::PropertyProxy<bool> property_level_indentation() ;
  Glib::PropertyProxy_ReadOnly<bool> property_level_indentation() const;
  Glib::PropertyProxy<bool> property_rubber_banding() ;
  Glib::PropertyProxy_ReadOnly<bool> property_rubber_banding() const;
  Glib::PropertyProxy<bool> property_enable_grid_lines() ;
  Glib::PropertyProxy_ReadOnly<bool> property_enable_grid_lines() const;
  Glib::PropertyProxy<bool> property_enable_tree_lines() ;
  Glib::PropertyProxy_ReadOnly<bool> property_enable_tree_lines() const;
  Glib::RefPtr<Gtk::TreeModel> _get_base_model();
protected:
  template<class ColumnType> friend
  void _auto_store_on_cellrenderer_text_edited_string(const Glib::ustring& path_string, const Glib::ustring& new_text, int model_column, const Glib::RefPtr<Gtk::TreeModel>& model);
  template <class ColumnType> friend
  void _auto_store_on_cellrenderer_text_edited_numerical(const Glib::ustring& path_string, const Glib::ustring& new_text, int model_column, const Glib::RefPtr<Gtk::TreeModel>& model);
  void _auto_store_on_cellrenderer_toggle_edited_with_model(const Glib::ustring& path_string, int model_column, const Glib::RefPtr<Gtk::TreeModel>& model);
  void _auto_store_on_cellrenderer_toggle_edited(const Glib::ustring& path_string, int model_column);
  template<class ColumnType> friend
  void TreeView_Private::_connect_auto_store_editable_signal_handler(TreeView*, CellRenderer*, const TreeModelColumn<ColumnType>&);
};
template <class ColumnType> inline
int TreeView::append_column(const Glib::ustring& title, const TreeModelColumn<ColumnType>& model_column)
{
  TreeViewColumn *const pViewColumn = Gtk::manage( new TreeViewColumn(title, model_column) );
  return append_column(*pViewColumn);
}
template <class ColumnType> inline
int TreeView::append_column_numeric(const Glib::ustring& title, const TreeModelColumn<ColumnType>& model_column, const Glib::ustring& format)
{
  TreeViewColumn* const pViewColumn = Gtk::manage( new TreeViewColumn(title) );
  CellRenderer* pCellRenderer = manage( new CellRendererText() );
  pViewColumn->pack_start(*pCellRenderer);
  typedef void (*type_fptr)(Gtk::CellRenderer* cell, const Gtk::TreeModel::iterator& iter, int model_column, const Glib::ustring& format);
  type_fptr fptr = TreeView_Private::_auto_cell_data_func<ColumnType>;
  Gtk::TreeViewColumn::SlotCellData slot = sigc::bind<-1>(
    sigc::bind<-1>( sigc::ptr_fun(fptr), format),
    model_column.index()
  );
  pViewColumn->set_cell_data_func(*pCellRenderer, slot);
  return append_column(*pViewColumn);
}
template <class ColumnType> inline
int TreeView::append_column_numeric_editable(const Glib::ustring& title, const TreeModelColumn<ColumnType>& model_column, const Glib::ustring& format)
{
  int cols_count = append_column_numeric(title, model_column, format);
  CellRenderer *const cell = get_column_cell_renderer(cols_count - 1);
  if(cell)
  {
    TreeView_Private::_connect_auto_store_editable_signal_handler<ColumnType>(this, cell, model_column);
  }
  return cols_count;
}
template <class ColumnType> inline
int TreeView::append_column_editable(const Glib::ustring& title, const TreeModelColumn<ColumnType>& model_column)
{
  TreeViewColumn *const pViewColumn = Gtk::manage( new TreeViewColumn(title, model_column) );
  CellRenderer* pCellRender = pViewColumn->get_first_cell_renderer();
  TreeView_Private::_connect_auto_store_editable_signal_handler<ColumnType>(this, pCellRender, model_column);
  return append_column(*pViewColumn);
}
template <class ColumnType> inline
int TreeView::insert_column(const Glib::ustring& title, const TreeModelColumn<ColumnType>& model_column, int position)
{
  TreeViewColumn *const pViewColumn = Gtk::manage( new TreeViewColumn(title, model_column) );
  return insert_column(*pViewColumn, position);
}
template <class ColumnType> inline
int TreeView::insert_column_editable(const Glib::ustring& title, const TreeModelColumn<ColumnType>& model_column, int position)
{
  TreeViewColumn *const pViewColumn = Gtk::manage( new TreeViewColumn(title, model_column) );
  CellRenderer* pCellRender = pViewColumn->get_first_cell_renderer();
  TreeView_Private::_connect_auto_store_editable_signal_handler(this, pCellRender, model_column);
  return insert_column(*pViewColumn, position);
}
namespace TreeView_Private
{
template<> inline
void _connect_auto_store_editable_signal_handler(Gtk::TreeView* this_p, Gtk::CellRenderer* pCellRenderer, const Gtk::TreeModelColumn<bool>& model_column)
{
  Gtk::CellRendererToggle* pCellToggle = dynamic_cast<Gtk::CellRendererToggle*>(pCellRenderer);
  if(pCellToggle)
  {
    pCellToggle->property_activatable() = true;
    sigc::slot<void, const Glib::ustring&, int> slot_temp =
      sigc::bind<-1>(
        sigc::mem_fun(*this_p, &Gtk::TreeView::_auto_store_on_cellrenderer_toggle_edited_with_model),
        this_p->_get_base_model()
      );
    pCellToggle->signal_toggled().connect(
      sigc::bind<-1>(
        slot_temp,
        model_column.index()
      )
    );
  }
}
template<> inline
void _connect_auto_store_editable_signal_handler(Gtk::TreeView* this_p, Gtk::CellRenderer* pCellRenderer, const Gtk::TreeModelColumn<int>& model_column)
{
  Gtk::CellRendererText* pCellText = dynamic_cast<Gtk::CellRendererText*>(pCellRenderer);
  if(pCellText)
  {
    pCellText->property_editable() = true;
    typedef void (*type_fptr)(const Glib::ustring& path_string, const Glib::ustring& new_text, int model_column, const Glib::RefPtr<Gtk::TreeModel>& model);
    type_fptr fptr = _auto_store_on_cellrenderer_text_edited_numerical<int>;
    pCellText->signal_edited().connect(
      sigc::bind<-1>(
        sigc::bind<-1>(
          sigc::ptr_fun(fptr),
          this_p->_get_base_model() ),
        model_column.index()
      )
    );
  }
}
template<> inline
void _connect_auto_store_editable_signal_handler(Gtk::TreeView* this_p, Gtk::CellRenderer* pCellRenderer, const Gtk::TreeModelColumn<unsigned int>& model_column)
{
  Gtk::CellRendererText* pCellText = dynamic_cast<Gtk::CellRendererText*>(pCellRenderer);
  if(pCellText)
  {
    pCellText->property_editable() = true;
    typedef void (*type_fptr)(const Glib::ustring& path_string, const Glib::ustring& new_text, int model_column, const Glib::RefPtr<Gtk::TreeModel>& model);
    type_fptr fptr = _auto_store_on_cellrenderer_text_edited_numerical<unsigned int>;
    pCellText->signal_edited().connect(
      sigc::bind<-1>(
        sigc::bind<-1>(
          sigc::ptr_fun(fptr),
          this_p->_get_base_model() ),
        model_column.index()
      )
    );
  }
}
template<> inline
void _connect_auto_store_editable_signal_handler(Gtk::TreeView* this_p, Gtk::CellRenderer* pCellRenderer, const Gtk::TreeModelColumn<long>& model_column)
{
  Gtk::CellRendererText* pCellText = dynamic_cast<Gtk::CellRendererText*>(pCellRenderer);
  if(pCellText)
  {
    pCellText->property_editable() = true;
    typedef void (*type_fptr)(const Glib::ustring& path_string, const Glib::ustring& new_text, int model_column, const Glib::RefPtr<Gtk::TreeModel>& model);
    type_fptr fptr = _auto_store_on_cellrenderer_text_edited_numerical<long>;
    pCellText->signal_edited().connect(
      sigc::bind<-1>(
        sigc::bind<-1>(
          sigc::ptr_fun(fptr),
          this_p->_get_base_model() ),
        model_column.index()
      )
    );
  }
}
template<> inline
void _connect_auto_store_editable_signal_handler(Gtk::TreeView* this_p, Gtk::CellRenderer* pCellRenderer, const Gtk::TreeModelColumn<unsigned long>& model_column)
{
  Gtk::CellRendererText* pCellText = dynamic_cast<Gtk::CellRendererText*>(pCellRenderer);
  if(pCellText)
  {
    pCellText->property_editable() = true;
    typedef void (*type_fptr)(const Glib::ustring& path_string, const Glib::ustring& new_text, int model_column, const Glib::RefPtr<Gtk::TreeModel>& model);
    type_fptr fptr = _auto_store_on_cellrenderer_text_edited_numerical<unsigned long>;
    pCellText->signal_edited().connect(
      sigc::bind<-1>(
        sigc::bind<-1>(
          sigc::ptr_fun(fptr),
          this_p->_get_base_model() ),
        model_column.index()
      )
    );
  }
}
template<> inline
void _connect_auto_store_editable_signal_handler(Gtk::TreeView* this_p, Gtk::CellRenderer* pCellRenderer, const Gtk::TreeModelColumn<float>& model_column)
{
  Gtk::CellRendererText* pCellText = dynamic_cast<Gtk::CellRendererText*>(pCellRenderer);
  if(pCellText)
  {
    pCellText->property_editable() = true;
    typedef void (*type_fptr)(const Glib::ustring& path_string, const Glib::ustring& new_text, int model_column, const Glib::RefPtr<Gtk::TreeModel>& model);
    type_fptr fptr = _auto_store_on_cellrenderer_text_edited_numerical<float>;
    pCellText->signal_edited().connect(
      sigc::bind<-1>(
        sigc::bind<-1>(
          sigc::ptr_fun(fptr),
          this_p->_get_base_model() ),
        model_column.index()
      )
    );
  }
}
template<> inline
void _connect_auto_store_editable_signal_handler(Gtk::TreeView* this_p, Gtk::CellRenderer* pCellRenderer, const Gtk::TreeModelColumn<double>& model_column)
{
  Gtk::CellRendererText* pCellText = dynamic_cast<Gtk::CellRendererText*>(pCellRenderer);
  if(pCellText)
  {
    pCellText->property_editable() = true;
    typedef void (*type_fptr)(const Glib::ustring& path_string, const Glib::ustring& new_text, int model_column, const Glib::RefPtr<Gtk::TreeModel>& model);
    type_fptr fptr = _auto_store_on_cellrenderer_text_edited_numerical<double>;
    pCellText->signal_edited().connect(
      sigc::bind<-1>(
        sigc::bind<-1>(
          sigc::ptr_fun(fptr),
          this_p->_get_base_model() ),
        model_column.index()
      )
    );
  }
}
}
namespace TreeView_Private
{
template <class ColumnType> inline
void _connect_auto_store_editable_signal_handler(Gtk::TreeView* this_p, Gtk::CellRenderer* pCellRenderer, const Gtk::TreeModelColumn<ColumnType>& model_column)
{
  Gtk::CellRendererText* pCellText = dynamic_cast<Gtk::CellRendererText*>(pCellRenderer);
  if(pCellText)
  {
    pCellText->property_editable() = true;
    typedef void (*type_func)(const Glib::ustring&, const Glib::ustring&, int, const Glib::RefPtr<Gtk::TreeModel>&);
    type_func func = &(_auto_store_on_cellrenderer_text_edited_string<ColumnType>);
    sigc::slot<void, const Glib::ustring&, const Glib::ustring&, int, const Glib::RefPtr<Gtk::TreeModel>&> theslot =
      sigc::ptr_fun(func);
    pCellText->signal_edited().connect(
      sigc::bind<-1>(
        sigc::bind<-1>( theslot, this_p->_get_base_model()),
        model_column.index()
      )
    );
  }
}
template <class ColumnType> inline
void _auto_store_on_cellrenderer_text_edited_string(const Glib::ustring& path_string, const Glib::ustring& new_text, int model_column, const Glib::RefPtr<Gtk::TreeModel>& model)
{
  Gtk::TreePath path(path_string);
  if(model)
  {
    Gtk::TreeModel::iterator iter = model->get_iter(path);
    if(iter)
    {
        Gtk::TreeRow row = *iter;
        row.set_value(model_column, (ColumnType)new_text);
    }
  }
}
template <class ColumnType> inline
void _auto_store_on_cellrenderer_text_edited_numerical(const Glib::ustring& path_string, const Glib::ustring& new_text, int model_column, const Glib::RefPtr<Gtk::TreeModel>& model)
{
  Gtk::TreePath path(path_string);
  if(model)
  {
    Gtk::TreeModel::iterator iter = model->get_iter(path);
    if(iter)
    {
      char* pchEnd = 0;
      ColumnType new_value = static_cast<ColumnType>( strtod(new_text.c_str(), &pchEnd) );
      Gtk::TreeRow row = *iter;
      row.set_value(model_column, (ColumnType)new_value);
    }
  }
}
template <class ColumnType> inline
void _auto_cell_data_func(Gtk::CellRenderer* cell, const Gtk::TreeModel::iterator& iter, int model_column, const Glib::ustring& format)
{
  Gtk::CellRendererText* pTextRenderer = dynamic_cast<Gtk::CellRendererText*>(cell);
  if(!pTextRenderer)
  {
    g_log (((gchar*) 0), G_LOG_LEVEL_WARNING, "gtkmm: TextView: append_column_numeric() was used with a non-numeric type.");
  }
  else
  {
    if(iter)
    {
      Gtk::TreeModel::Row row = *iter;
      ColumnType value = ColumnType();
      row.get_value(model_column, value);
      char buff[20];
      int used = g_snprintf(buff, sizeof(buff), format.c_str(), value);
      if(used > 0)
      {
        pTextRenderer->property_text() = buff;
      }
    }
  }
}
}
}
namespace Glib
{
  Gtk::TreeView* wrap(GtkTreeView* object, bool take_copy = false);
}
typedef struct _GtkComboBox GtkComboBox;
typedef struct _GtkComboBoxClass GtkComboBoxClass;
namespace Gtk
{ class ComboBox_Class; }
namespace Gtk
{
class ComboBox
: public Bin,
  public CellLayout
{
  public:
  typedef ComboBox CppObjectType;
  typedef ComboBox_Class CppClassType;
  typedef GtkComboBox BaseObjectType;
  typedef GtkComboBoxClass BaseClassType;
  virtual ~ComboBox();
private:
  friend class ComboBox_Class;
  static CppClassType combobox_class_;
  ComboBox(const ComboBox&);
  ComboBox& operator=(const ComboBox&);
protected:
  explicit ComboBox(const Glib::ConstructParams& construct_params);
  explicit ComboBox(GtkComboBox* castitem);
public:
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkComboBox* gobj() { return reinterpret_cast<GtkComboBox*>(gobject_); }
  const GtkComboBox* gobj() const { return reinterpret_cast<GtkComboBox*>(gobject_); }
public:
protected:
  virtual void on_changed();
private:
public:
  ComboBox();
  explicit ComboBox(const Glib::RefPtr<TreeModel>& model);
  void set_wrap_width(int width);
  int get_wrap_width() const;
  void set_row_span_column(int row_span);
  int get_row_span_column() const;
  void set_column_span_column(int column_span);
  int get_column_span_column() const;
  bool get_add_tearoffs() const;
  void set_add_tearoffs(bool add_tearoffs = true);
  Glib::ustring get_title() const;
  void set_title(const Glib::ustring& title);
  bool get_focus_on_click() const;
  void set_focus_on_click(bool focus_on_click = true);
  int get_active_row_number() const;
  TreeModel::iterator get_active();
  TreeModel::const_iterator get_active() const;
  void set_active(int index);
  void set_active(const TreeModel::iterator& iter);
  void unset_active();
  Glib::RefPtr<TreeModel> get_model();
  Glib::RefPtr<const TreeModel> get_model() const;
  void set_model(const Glib::RefPtr<TreeModel>& model);
  typedef TreeView::SlotRowSeparator SlotRowSeparator;
  void set_row_separator_func(const SlotRowSeparator& slot);
  void unset_row_separator_func();
  void popup();
  void popdown();
  Glib::PropertyProxy< Glib::RefPtr<TreeModel> > property_model() ;
  Glib::PropertyProxy_ReadOnly< Glib::RefPtr<TreeModel> > property_model() const;
  Glib::PropertyProxy<int> property_wrap_width() ;
  Glib::PropertyProxy_ReadOnly<int> property_wrap_width() const;
  Glib::PropertyProxy<int> property_row_span_column() ;
  Glib::PropertyProxy_ReadOnly<int> property_row_span_column() const;
  Glib::PropertyProxy<int> property_column_span_column() ;
  Glib::PropertyProxy_ReadOnly<int> property_column_span_column() const;
  Glib::PropertyProxy<int> property_active() ;
  Glib::PropertyProxy_ReadOnly<int> property_active() const;
  Glib::PropertyProxy<bool> property_add_tearoffs() ;
  Glib::PropertyProxy_ReadOnly<bool> property_add_tearoffs() const;
  Glib::PropertyProxy<bool> property_has_frame() ;
  Glib::PropertyProxy_ReadOnly<bool> property_has_frame() const;
  Glib::PropertyProxy<bool> property_focus_on_click() ;
  Glib::PropertyProxy_ReadOnly<bool> property_focus_on_click() const;
  Glib::PropertyProxy<Glib::ustring> property_tearoff_title() ;
  Glib::PropertyProxy_ReadOnly<Glib::ustring> property_tearoff_title() const;
  Glib::SignalProxy0< void > signal_changed();
};
}
namespace Glib
{
  Gtk::ComboBox* wrap(GtkComboBox* object, bool take_copy = false);
}
typedef struct _GtkComboBoxEntry GtkComboBoxEntry;
typedef struct _GtkComboBoxEntryClass GtkComboBoxEntryClass;
namespace Gtk
{ class ComboBoxEntry_Class; }
namespace Gtk
{
class ComboBoxEntry : public ComboBox
{
  public:
  typedef ComboBoxEntry CppObjectType;
  typedef ComboBoxEntry_Class CppClassType;
  typedef GtkComboBoxEntry BaseObjectType;
  typedef GtkComboBoxEntryClass BaseClassType;
  virtual ~ComboBoxEntry();
private:
  friend class ComboBoxEntry_Class;
  static CppClassType comboboxentry_class_;
  ComboBoxEntry(const ComboBoxEntry&);
  ComboBoxEntry& operator=(const ComboBoxEntry&);
protected:
  explicit ComboBoxEntry(const Glib::ConstructParams& construct_params);
  explicit ComboBoxEntry(GtkComboBoxEntry* castitem);
public:
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkComboBoxEntry* gobj() { return reinterpret_cast<GtkComboBoxEntry*>(gobject_); }
  const GtkComboBoxEntry* gobj() const { return reinterpret_cast<GtkComboBoxEntry*>(gobject_); }
public:
protected:
private:
public:
  ComboBoxEntry();
  explicit ComboBoxEntry(const Glib::RefPtr<TreeModel>& model, const TreeModelColumnBase& text_column);
  explicit ComboBoxEntry(const Glib::RefPtr<TreeModel>& model, int text_column = 0);
  void set_text_column(const TreeModelColumnBase& text_column) const;
  void set_text_column(int text_column) const;
  int get_text_column() const;
  Entry* get_entry();
  const Entry* get_entry() const;
};
}
namespace Glib
{
  Gtk::ComboBoxEntry* wrap(GtkComboBoxEntry* object, bool take_copy = false);
}
namespace Gtk
{
class ComboBoxEntryText
: public ComboBoxEntry
{
private:
  ComboBoxEntryText(const ComboBoxEntryText&);
  ComboBoxEntryText& operator=(const ComboBoxEntryText&);
protected:
  explicit ComboBoxEntryText(const Glib::ConstructParams& construct_params);
  explicit ComboBoxEntryText(GtkComboBoxEntry* castitem);
public:
  ComboBoxEntryText();
  void append_text(const Glib::ustring& text);
  void insert_text(int position, const Glib::ustring& text);
  void prepend_text(const Glib::ustring& text);
  Glib::ustring get_active_text() const;
  void set_active_text(const Glib::ustring& text);
  void clear();
  void clear_items();
  void remove_text(const Glib::ustring& text);
protected:
  class TextModelColumns : public Gtk::TreeModel::ColumnRecord
  {
  public:
    TextModelColumns()
    { add(m_column); }
    Gtk::TreeModelColumn<Glib::ustring> m_column;
  };
  TextModelColumns m_text_columns;
};
}
namespace Gtk
{
class ComboBoxText
: public ComboBox
{
private:
  ComboBoxText(const ComboBoxText&);
  ComboBoxText& operator=(const ComboBoxText&);
protected:
  explicit ComboBoxText(const Glib::ConstructParams& construct_params);
  explicit ComboBoxText(GtkComboBox* castitem);
public:
  ComboBoxText();
  void append_text(const Glib::ustring& text);
  void insert_text(int position, const Glib::ustring& text);
  void prepend_text(const Glib::ustring& text);
  Glib::ustring get_active_text() const;
  void set_active_text(const Glib::ustring& text);
  void clear();
  void clear_items();
  void remove_text(const Glib::ustring& text);
protected:
  class TextModelColumns : public Gtk::TreeModel::ColumnRecord
  {
  public:
    TextModelColumns()
    { add(m_column); }
    Gtk::TreeModelColumn<Glib::ustring> m_column;
  };
  TextModelColumns m_text_columns;
};
}
typedef struct _GtkDrawingArea GtkDrawingArea;
typedef struct _GtkDrawingAreaClass GtkDrawingAreaClass;
namespace Gtk
{ class DrawingArea_Class; }
namespace Gtk
{
class DrawingArea : public Widget
{
  public:
  typedef DrawingArea CppObjectType;
  typedef DrawingArea_Class CppClassType;
  typedef GtkDrawingArea BaseObjectType;
  typedef GtkDrawingAreaClass BaseClassType;
  virtual ~DrawingArea();
private:
  friend class DrawingArea_Class;
  static CppClassType drawingarea_class_;
  DrawingArea(const DrawingArea&);
  DrawingArea& operator=(const DrawingArea&);
protected:
  explicit DrawingArea(const Glib::ConstructParams& construct_params);
  explicit DrawingArea(GtkDrawingArea* castitem);
public:
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkDrawingArea* gobj() { return reinterpret_cast<GtkDrawingArea*>(gobject_); }
  const GtkDrawingArea* gobj() const { return reinterpret_cast<GtkDrawingArea*>(gobject_); }
public:
protected:
private:
public:
  DrawingArea();
};
}
namespace Glib
{
  Gtk::DrawingArea* wrap(GtkDrawingArea* object, bool take_copy = false);
}
typedef struct _GtkCurve GtkCurve;
typedef struct _GtkCurveClass GtkCurveClass;
namespace Gtk
{ class Curve_Class; }
typedef struct _GtkGammaCurve GtkGammaCurve;
typedef struct _GtkGammaCurveClass GtkGammaCurveClass;
namespace Gtk
{ class GammaCurve_Class; }
namespace Gtk
{
class Curve : public DrawingArea
{
  public:
  typedef Curve CppObjectType;
  typedef Curve_Class CppClassType;
  typedef GtkCurve BaseObjectType;
  typedef GtkCurveClass BaseClassType;
  virtual ~Curve();
private:
  friend class Curve_Class;
  static CppClassType curve_class_;
  Curve(const Curve&);
  Curve& operator=(const Curve&);
protected:
  explicit Curve(const Glib::ConstructParams& construct_params);
  explicit Curve(GtkCurve* castitem);
public:
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkCurve* gobj() { return reinterpret_cast<GtkCurve*>(gobject_); }
  const GtkCurve* gobj() const { return reinterpret_cast<GtkCurve*>(gobject_); }
public:
protected:
  virtual void on_curve_type_changed();
private:
public:
  Curve();
  void reset();
  void set_gamma(float gamma);
  void set_range(float min_x, float max_x, float min_y, float max_y);
  void get_vector(int veclen, float* data) const;
  Glib::ArrayHandle<float> get_vector(int veclen) const;
  void set_vector(const Glib::ArrayHandle<float>& array);
  void set_curve_type(CurveType type);
  Glib::SignalProxy0< void > signal_curve_type_changed();
  Glib::PropertyProxy<CurveType> property_curve_type() ;
  Glib::PropertyProxy_ReadOnly<CurveType> property_curve_type() const;
  Glib::PropertyProxy<float> property_min_x() ;
  Glib::PropertyProxy_ReadOnly<float> property_min_x() const;
  Glib::PropertyProxy<float> property_max_x() ;
  Glib::PropertyProxy_ReadOnly<float> property_max_x() const;
  Glib::PropertyProxy<float> property_min_y() ;
  Glib::PropertyProxy_ReadOnly<float> property_min_y() const;
  Glib::PropertyProxy<float> property_max_y() ;
  Glib::PropertyProxy_ReadOnly<float> property_max_y() const;
};
class GammaCurve : public VBox
{
  public:
  typedef GammaCurve CppObjectType;
  typedef GammaCurve_Class CppClassType;
  typedef GtkGammaCurve BaseObjectType;
  typedef GtkGammaCurveClass BaseClassType;
  virtual ~GammaCurve();
private:
  friend class GammaCurve_Class;
  static CppClassType gammacurve_class_;
  GammaCurve(const GammaCurve&);
  GammaCurve& operator=(const GammaCurve&);
protected:
  explicit GammaCurve(const Glib::ConstructParams& construct_params);
  explicit GammaCurve(GtkGammaCurve* castitem);
public:
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkGammaCurve* gobj() { return reinterpret_cast<GtkGammaCurve*>(gobject_); }
  const GtkGammaCurve* gobj() const { return reinterpret_cast<GtkGammaCurve*>(gobject_); }
public:
protected:
private:
public:
  GammaCurve();
};
}
namespace Glib
{
  Gtk::Curve* wrap(GtkCurve* object, bool take_copy = false);
}
namespace Glib
{
  Gtk::GammaCurve* wrap(GtkGammaCurve* object, bool take_copy = false);
}
typedef struct _GtkExpander GtkExpander;
typedef struct _GtkExpanderClass GtkExpanderClass;
namespace Gtk
{ class Expander_Class; }
namespace Gtk
{
class Expander : public Bin
{
  public:
  typedef Expander CppObjectType;
  typedef Expander_Class CppClassType;
  typedef GtkExpander BaseObjectType;
  typedef GtkExpanderClass BaseClassType;
  virtual ~Expander();
private:
  friend class Expander_Class;
  static CppClassType expander_class_;
  Expander(const Expander&);
  Expander& operator=(const Expander&);
protected:
  explicit Expander(const Glib::ConstructParams& construct_params);
  explicit Expander(GtkExpander* castitem);
public:
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkExpander* gobj() { return reinterpret_cast<GtkExpander*>(gobject_); }
  const GtkExpander* gobj() const { return reinterpret_cast<GtkExpander*>(gobject_); }
public:
protected:
private:
public:
  Expander();
  explicit Expander(const Glib::ustring& label, bool mnemonic = false);
  void set_expanded(bool expanded = true);
  bool get_expanded() const;
  void set_spacing(int spacing);
  int get_spacing() const;
  void set_label(const Glib::ustring& label);
  Glib::ustring get_label() const;
  void set_use_underline(bool use_underline = true);
  bool get_use_underline() const;
  void set_use_markup(bool use_markup = true);
  bool get_use_markup() const;
  void set_label_widget(Widget& label_widget);
  Widget* get_label_widget();
  const Widget* get_label_widget() const;
  Glib::PropertyProxy<bool> property_expanded() ;
  Glib::PropertyProxy_ReadOnly<bool> property_expanded() const;
  Glib::PropertyProxy<Glib::ustring> property_label() ;
  Glib::PropertyProxy_ReadOnly<Glib::ustring> property_label() const;
  Glib::PropertyProxy<bool> property_use_underline() ;
  Glib::PropertyProxy_ReadOnly<bool> property_use_underline() const;
  Glib::PropertyProxy<bool> property_use_markup() ;
  Glib::PropertyProxy_ReadOnly<bool> property_use_markup() const;
  Glib::PropertyProxy<int> property_spacing() ;
  Glib::PropertyProxy_ReadOnly<int> property_spacing() const;
  Glib::PropertyProxy<Widget*> property_label_widget() ;
  Glib::PropertyProxy_ReadOnly<Widget*> property_label_widget() const;
};
}
namespace Glib
{
  Gtk::Expander* wrap(GtkExpander* object, bool take_copy = false);
}
typedef struct _GtkEventBox GtkEventBox;
typedef struct _GtkEventBoxClass GtkEventBoxClass;
namespace Gtk
{ class EventBox_Class; }
namespace Gtk
{
class EventBox : public Bin
{
  public:
  typedef EventBox CppObjectType;
  typedef EventBox_Class CppClassType;
  typedef GtkEventBox BaseObjectType;
  typedef GtkEventBoxClass BaseClassType;
  virtual ~EventBox();
private:
  friend class EventBox_Class;
  static CppClassType eventbox_class_;
  EventBox(const EventBox&);
  EventBox& operator=(const EventBox&);
protected:
  explicit EventBox(const Glib::ConstructParams& construct_params);
  explicit EventBox(GtkEventBox* castitem);
public:
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkEventBox* gobj() { return reinterpret_cast<GtkEventBox*>(gobject_); }
  const GtkEventBox* gobj() const { return reinterpret_cast<GtkEventBox*>(gobject_); }
public:
protected:
private:
public:
  EventBox();
  bool get_visible_window() const;
  void set_visible_window(bool visible_window = true);
  bool get_above_child() const;
  void set_above_child(bool above_child = true);
  Glib::PropertyProxy<bool> property_visible_window() ;
  Glib::PropertyProxy_ReadOnly<bool> property_visible_window() const;
  Glib::PropertyProxy<bool> property_above_child() ;
  Glib::PropertyProxy_ReadOnly<bool> property_above_child() const;
};
}
namespace Glib
{
  Gtk::EventBox* wrap(GtkEventBox* object, bool take_copy = false);
}
typedef struct _GtkFileFilter GtkFileFilter;
typedef struct _GtkFileFilterClass GtkFileFilterClass;
namespace Gtk
{ class FileFilter_Class; }
namespace Gtk
{
enum FileFilterFlags
{
  FILE_FILTER_FILENAME = 1 << 0,
  FILE_FILTER_URI = 1 << 1,
  FILE_FILTER_DISPLAY_NAME = 1 << 2,
  FILE_FILTER_MIME_TYPE = 1 << 3
};
inline FileFilterFlags operator|(FileFilterFlags lhs, FileFilterFlags rhs)
  { return static_cast<FileFilterFlags>(static_cast<unsigned>(lhs) | static_cast<unsigned>(rhs)); }
inline FileFilterFlags operator&(FileFilterFlags lhs, FileFilterFlags rhs)
  { return static_cast<FileFilterFlags>(static_cast<unsigned>(lhs) & static_cast<unsigned>(rhs)); }
inline FileFilterFlags operator^(FileFilterFlags lhs, FileFilterFlags rhs)
  { return static_cast<FileFilterFlags>(static_cast<unsigned>(lhs) ^ static_cast<unsigned>(rhs)); }
inline FileFilterFlags operator~(FileFilterFlags flags)
  { return static_cast<FileFilterFlags>(~static_cast<unsigned>(flags)); }
inline FileFilterFlags& operator|=(FileFilterFlags& lhs, FileFilterFlags rhs)
  { return (lhs = static_cast<FileFilterFlags>(static_cast<unsigned>(lhs) | static_cast<unsigned>(rhs))); }
inline FileFilterFlags& operator&=(FileFilterFlags& lhs, FileFilterFlags rhs)
  { return (lhs = static_cast<FileFilterFlags>(static_cast<unsigned>(lhs) & static_cast<unsigned>(rhs))); }
inline FileFilterFlags& operator^=(FileFilterFlags& lhs, FileFilterFlags rhs)
  { return (lhs = static_cast<FileFilterFlags>(static_cast<unsigned>(lhs) ^ static_cast<unsigned>(rhs))); }
}
namespace Glib
{
template <>
class Value<Gtk::FileFilterFlags> : public Glib::Value_Flags<Gtk::FileFilterFlags>
{
public:
  static GType value_type() __attribute__((__const__));
};
}
namespace Gtk
{
class FileFilter : public Gtk::Object
{
  public:
  typedef FileFilter CppObjectType;
  typedef FileFilter_Class CppClassType;
  typedef GtkFileFilter BaseObjectType;
  typedef GtkFileFilterClass BaseClassType;
  virtual ~FileFilter();
private:
  friend class FileFilter_Class;
  static CppClassType filefilter_class_;
  FileFilter(const FileFilter&);
  FileFilter& operator=(const FileFilter&);
protected:
  explicit FileFilter(const Glib::ConstructParams& construct_params);
  explicit FileFilter(GtkFileFilter* castitem);
public:
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkFileFilter* gobj() { return reinterpret_cast<GtkFileFilter*>(gobject_); }
  const GtkFileFilter* gobj() const { return reinterpret_cast<GtkFileFilter*>(gobject_); }
public:
protected:
private:
public:
 FileFilter();
  void set_name(const Glib::ustring& name);
  Glib::ustring get_name() const;
  void add_mime_type(const Glib::ustring& mime_type);
  void add_pattern(const Glib::ustring& pattern);
  void add_pixbuf_formats();
  class Info
  {
  public:
    FileFilterFlags contains;
    Glib::ustring filename;
    Glib::ustring uri;
    Glib::ustring display_name;
    Glib::ustring mime_type;
  };
  typedef sigc::slot<bool, const Info&> SlotCustom;
  void add_custom(FileFilterFlags needed, const SlotCustom& slot);
  FileFilterFlags get_needed() const;
};
}
namespace Glib
{
  Gtk::FileFilter* wrap(GtkFileFilter* object, bool take_copy = false);
}
typedef struct _GtkFileChooser GtkFileChooser;
typedef struct _GtkFileChooserClass GtkFileChooserClass;
namespace Gtk
{ class FileChooser_Class; }
namespace Gtk
{
enum FileChooserAction
{
  FILE_CHOOSER_ACTION_OPEN,
  FILE_CHOOSER_ACTION_SAVE,
  FILE_CHOOSER_ACTION_SELECT_FOLDER,
  FILE_CHOOSER_ACTION_CREATE_FOLDER
};
}
namespace Glib
{
template <>
class Value<Gtk::FileChooserAction> : public Glib::Value_Enum<Gtk::FileChooserAction>
{
public:
  static GType value_type() __attribute__((__const__));
};
}
namespace Gtk
{
enum FileChooserConfirmation
{
  FILE_CHOOSER_CONFIRMATION_CONFIRM,
  FILE_CHOOSER_CONFIRMATION_ACCEPT_FILENAME,
  FILE_CHOOSER_CONFIRMATION_SELECT_AGAIN
};
}
namespace Glib
{
template <>
class Value<Gtk::FileChooserConfirmation> : public Glib::Value_Enum<Gtk::FileChooserConfirmation>
{
public:
  static GType value_type() __attribute__((__const__));
};
}
namespace Gtk
{
class FileChooserError : public Glib::Error
{
public:
  enum Code
  {
    NONEXISTENT,
    BAD_FILENAME,
    ALREADY_EXISTS
  };
  FileChooserError(Code error_code, const Glib::ustring& error_message);
  explicit FileChooserError(GError* gobject);
  Code code() const;
private:
  static void throw_func(GError* gobject);
  friend void wrap_init();
};
}
namespace Glib
{
template <>
class Value<Gtk::FileChooserError::Code> : public Glib::Value_Enum<Gtk::FileChooserError::Code>
{
public:
  static GType value_type() __attribute__((__const__));
};
}
namespace Gtk
{
class FileChooser : public Glib::Interface
{
public:
  typedef FileChooser CppObjectType;
  typedef FileChooser_Class CppClassType;
  typedef GtkFileChooser BaseObjectType;
  typedef GtkFileChooserClass BaseClassType;
private:
  friend class FileChooser_Class;
  static CppClassType filechooser_class_;
  FileChooser(const FileChooser&);
  FileChooser& operator=(const FileChooser&);
protected:
  FileChooser();
public:
  explicit FileChooser(GtkFileChooser* castitem);
protected:
public:
  virtual ~FileChooser();
  static void add_interface(GType gtype_implementer);
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkFileChooser* gobj() { return reinterpret_cast<GtkFileChooser*>(gobject_); }
  const GtkFileChooser* gobj() const { return reinterpret_cast<GtkFileChooser*>(gobject_); }
private:
public:
  void set_action(FileChooserAction action);
  FileChooserAction get_action() const;
  void set_local_only(bool local_only = true);
  bool get_local_only() const;
  void set_select_multiple(bool select_multiple = true);
  bool get_select_multiple() const;
  void set_show_hidden(bool show_hidden = true);
  bool get_show_hidden() const;
  void set_do_overwrite_confirmation(bool do_overwrite_confirmation = true);
  bool get_do_overwrite_confirmation() const;
  void set_current_name(const Glib::ustring& name);
  Glib::ustring get_filename() const;
  bool set_filename(const Glib::ustring& filename);
  bool select_filename(const Glib::ustring& filename);
  void unselect_filename(const Glib::ustring& filename);
  void select_all();
  void unselect_all();
  Glib::SListHandle<Glib::ustring> get_filenames() const;
  bool set_current_folder(const Glib::ustring& filename);
  Glib::ustring get_current_folder() const;
  Glib::ustring get_uri() const;
  bool set_uri(const Glib::ustring& uri);
  bool select_uri(const Glib::ustring& uri);
  void unselect_uri(const Glib::ustring& uri);
  Glib::SListHandle<Glib::ustring> get_uris() const;
  bool set_current_folder_uri(const Glib::ustring& uri);
  Glib::ustring get_current_folder_uri() const;
  void set_preview_widget(Gtk::Widget& preview_widget);
  const Gtk::Widget* get_preview_widget() const;
  Gtk::Widget* get_preview_widget();
  void set_preview_widget_active(bool active = true);
  bool get_preview_widget_active() const;
  void set_use_preview_label(bool use_label = true);
  bool get_use_preview_label() const;
  Glib::ustring get_preview_filename() const;
  Glib::ustring get_preview_uri() const;
  void set_extra_widget(Gtk::Widget& extra_widget);
  Gtk::Widget* get_extra_widget();
  const Gtk::Widget* get_extra_widget() const;
  void add_filter(const FileFilter& filter);
  void remove_filter (const FileFilter& filter);
  Glib::SListHandle< FileFilter* > list_filters();
  Glib::SListHandle< const FileFilter* > list_filters() const;
  void set_filter(const FileFilter& filter);
  FileFilter* get_filter();
  const FileFilter* get_filter() const;
  bool add_shortcut_folder(const Glib::ustring& folder);
  bool remove_shortcut_folder(const Glib::ustring& folder);
  Glib::SListHandle<Glib::ustring> list_shortcut_folders() const;
  bool add_shortcut_folder_uri(const Glib::ustring& uri);
  bool remove_shortcut_folder_uri(const Glib::ustring& uri);
  Glib::SListHandle<Glib::ustring> list_shortcut_folder_uris() const;
  Glib::SignalProxy0< void > signal_current_folder_changed();
  Glib::SignalProxy0< void > signal_selection_changed();
  Glib::SignalProxy0< void > signal_update_preview();
  Glib::SignalProxy0< void > signal_file_activated();
  Glib::SignalProxy0< FileChooserConfirmation > signal_confirm_overwrite();
  Glib::PropertyProxy<FileChooserAction> property_action() ;
  Glib::PropertyProxy_ReadOnly<FileChooserAction> property_action() const;
  Glib::PropertyProxy<FileFilter*> property_filter() ;
  Glib::PropertyProxy_ReadOnly<FileFilter*> property_filter() const;
  Glib::PropertyProxy<bool> property_folder_mode() ;
  Glib::PropertyProxy_ReadOnly<bool> property_folder_mode() const;
  Glib::PropertyProxy<bool> property_local_only() ;
  Glib::PropertyProxy_ReadOnly<bool> property_local_only() const;
  Glib::PropertyProxy<Widget*> property_preview_widget() ;
  Glib::PropertyProxy_ReadOnly<Widget*> property_preview_widget() const;
  Glib::PropertyProxy<bool> property_preview_widget_active() ;
  Glib::PropertyProxy_ReadOnly<bool> property_preview_widget_active() const;
  Glib::PropertyProxy<bool> property_use_preview_label() ;
  Glib::PropertyProxy_ReadOnly<bool> property_use_preview_label() const;
  Glib::PropertyProxy<Widget*> property_extra_widget() ;
  Glib::PropertyProxy_ReadOnly<Widget*> property_extra_widget() const;
  Glib::PropertyProxy<bool> property_select_multiple() ;
  Glib::PropertyProxy_ReadOnly<bool> property_select_multiple() const;
  Glib::PropertyProxy<bool> property_show_hidden() ;
  Glib::PropertyProxy_ReadOnly<bool> property_show_hidden() const;
  Glib::PropertyProxy<bool> property_do_overwrite_confirmation() ;
  Glib::PropertyProxy_ReadOnly<bool> property_do_overwrite_confirmation() const;
public:
public:
protected:
};
}
namespace Glib
{
  Glib::RefPtr<Gtk::FileChooser> wrap(GtkFileChooser* object, bool take_copy = false);
}
typedef struct _GtkFileChooserDialog GtkFileChooserDialog;
typedef struct _GtkFileChooserDialogClass GtkFileChooserDialogClass;
namespace Gtk
{ class FileChooserDialog_Class; }
namespace Gtk
{
class FileChooserDialog
  : public Dialog,
    public FileChooser
{
  public:
  typedef FileChooserDialog CppObjectType;
  typedef FileChooserDialog_Class CppClassType;
  typedef GtkFileChooserDialog BaseObjectType;
  typedef GtkFileChooserDialogClass BaseClassType;
  virtual ~FileChooserDialog();
private:
  friend class FileChooserDialog_Class;
  static CppClassType filechooserdialog_class_;
  FileChooserDialog(const FileChooserDialog&);
  FileChooserDialog& operator=(const FileChooserDialog&);
protected:
  explicit FileChooserDialog(const Glib::ConstructParams& construct_params);
  explicit FileChooserDialog(GtkFileChooserDialog* castitem);
public:
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkFileChooserDialog* gobj() { return reinterpret_cast<GtkFileChooserDialog*>(gobject_); }
  const GtkFileChooserDialog* gobj() const { return reinterpret_cast<GtkFileChooserDialog*>(gobject_); }
public:
protected:
private:
public:
  explicit FileChooserDialog(Gtk::Window& parent, const Glib::ustring& title, FileChooserAction action = FILE_CHOOSER_ACTION_OPEN);
  explicit FileChooserDialog(const Glib::ustring& title, FileChooserAction action = FILE_CHOOSER_ACTION_OPEN);
  explicit FileChooserDialog(Gtk::Window& parent, const Glib::ustring& title, FileChooserAction action, const Glib::ustring& backend);
  explicit FileChooserDialog(const Glib::ustring& title, FileChooserAction action, const Glib::ustring& backend);
};
}
namespace Glib
{
  Gtk::FileChooserDialog* wrap(GtkFileChooserDialog* object, bool take_copy = false);
}
typedef struct _GtkFileChooserButton GtkFileChooserButton;
typedef struct _GtkFileChooserButtonClass GtkFileChooserButtonClass;
namespace Gtk
{ class FileChooserButton_Class; }
namespace Gtk
{
class FileChooserButton
  : public HBox,
    public FileChooser
{
  public:
  typedef FileChooserButton CppObjectType;
  typedef FileChooserButton_Class CppClassType;
  typedef GtkFileChooserButton BaseObjectType;
  typedef GtkFileChooserButtonClass BaseClassType;
  virtual ~FileChooserButton();
private:
  friend class FileChooserButton_Class;
  static CppClassType filechooserbutton_class_;
  FileChooserButton(const FileChooserButton&);
  FileChooserButton& operator=(const FileChooserButton&);
protected:
  explicit FileChooserButton(const Glib::ConstructParams& construct_params);
  explicit FileChooserButton(GtkFileChooserButton* castitem);
public:
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkFileChooserButton* gobj() { return reinterpret_cast<GtkFileChooserButton*>(gobject_); }
  const GtkFileChooserButton* gobj() const { return reinterpret_cast<GtkFileChooserButton*>(gobject_); }
public:
protected:
private:
public:
  explicit FileChooserButton(FileChooserAction action = FILE_CHOOSER_ACTION_OPEN);
  explicit FileChooserButton(const Glib::ustring& title, FileChooserAction action = FILE_CHOOSER_ACTION_OPEN);
  explicit FileChooserButton(const Glib::ustring& title, FileChooserAction action, const Glib::ustring& backend);
  explicit FileChooserButton(FileChooserDialog& dialog);
  Glib::ustring get_title() const;
  void set_title(const Glib::ustring& title);
  int get_width_chars() const;
  void set_width_chars(int n_chars);
  bool get_focus_on_click() const;
  void set_focus_on_click(gboolean focus_on_click = true);
  Glib::PropertyProxy_ReadOnly<FileChooserDialog*> property_dialog() const;
  Glib::PropertyProxy<bool> property_focus_on_click() ;
  Glib::PropertyProxy_ReadOnly<bool> property_focus_on_click() const;
  Glib::PropertyProxy<Glib::ustring> property_title() ;
  Glib::PropertyProxy_ReadOnly<Glib::ustring> property_title() const;
  Glib::PropertyProxy<int> property_width_chars() ;
  Glib::PropertyProxy_ReadOnly<int> property_width_chars() const;
};
}
namespace Glib
{
  Gtk::FileChooserButton* wrap(GtkFileChooserButton* object, bool take_copy = false);
}
typedef struct _GtkFileChooserWidget GtkFileChooserWidget;
typedef struct _GtkFileChooserWidgetClass GtkFileChooserWidgetClass;
namespace Gtk
{ class FileChooserWidget_Class; }
namespace Gtk
{
class FileChooserWidget
: public VBox,
  public FileChooser
{
  public:
  typedef FileChooserWidget CppObjectType;
  typedef FileChooserWidget_Class CppClassType;
  typedef GtkFileChooserWidget BaseObjectType;
  typedef GtkFileChooserWidgetClass BaseClassType;
  virtual ~FileChooserWidget();
private:
  friend class FileChooserWidget_Class;
  static CppClassType filechooserwidget_class_;
  FileChooserWidget(const FileChooserWidget&);
  FileChooserWidget& operator=(const FileChooserWidget&);
protected:
  explicit FileChooserWidget(const Glib::ConstructParams& construct_params);
  explicit FileChooserWidget(GtkFileChooserWidget* castitem);
public:
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkFileChooserWidget* gobj() { return reinterpret_cast<GtkFileChooserWidget*>(gobject_); }
  const GtkFileChooserWidget* gobj() const { return reinterpret_cast<GtkFileChooserWidget*>(gobject_); }
public:
protected:
private:
public:
  FileChooserWidget();
  explicit FileChooserWidget(FileChooserAction action);
  explicit FileChooserWidget(FileChooserAction action, const Glib::ustring& backend);
};
}
namespace Glib
{
  Gtk::FileChooserWidget* wrap(GtkFileChooserWidget* object, bool take_copy = false);
}
typedef struct _GtkOptionMenu GtkOptionMenu;
typedef struct _GtkOptionMenuClass GtkOptionMenuClass;
namespace Gtk
{ class OptionMenu_Class; }
namespace Gtk
{
class Menu;
class OptionMenu : public Button
{
  public:
  typedef OptionMenu CppObjectType;
  typedef OptionMenu_Class CppClassType;
  typedef GtkOptionMenu BaseObjectType;
  typedef GtkOptionMenuClass BaseClassType;
  virtual ~OptionMenu();
private:
  friend class OptionMenu_Class;
  static CppClassType optionmenu_class_;
  OptionMenu(const OptionMenu&);
  OptionMenu& operator=(const OptionMenu&);
protected:
  explicit OptionMenu(const Glib::ConstructParams& construct_params);
  explicit OptionMenu(GtkOptionMenu* castitem);
public:
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkOptionMenu* gobj() { return reinterpret_cast<GtkOptionMenu*>(gobject_); }
  const GtkOptionMenu* gobj() const { return reinterpret_cast<GtkOptionMenu*>(gobject_); }
public:
protected:
  virtual void on_changed();
private:
public:
  OptionMenu();
  void set_menu(Menu& menu);
  Menu* get_menu();
  const Menu* get_menu() const;
  void remove_menu();
  int get_history() const;
  void set_history(guint index);
  Glib::SignalProxy0< void > signal_changed();
private:
  void init_accels_handler_();
};
}
namespace Glib
{
  Gtk::OptionMenu* wrap(GtkOptionMenu* object, bool take_copy = false);
}
typedef struct _GtkFileSelection GtkFileSelection;
typedef struct _GtkFileSelectionClass GtkFileSelectionClass;
namespace Gtk
{ class FileSelection_Class; }
namespace Gtk
{
class FileSelection : public Dialog
{
  public:
  typedef FileSelection CppObjectType;
  typedef FileSelection_Class CppClassType;
  typedef GtkFileSelection BaseObjectType;
  typedef GtkFileSelectionClass BaseClassType;
  virtual ~FileSelection();
private:
  friend class FileSelection_Class;
  static CppClassType fileselection_class_;
  FileSelection(const FileSelection&);
  FileSelection& operator=(const FileSelection&);
protected:
  explicit FileSelection(const Glib::ConstructParams& construct_params);
  explicit FileSelection(GtkFileSelection* castitem);
public:
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkFileSelection* gobj() { return reinterpret_cast<GtkFileSelection*>(gobject_); }
  const GtkFileSelection* gobj() const { return reinterpret_cast<GtkFileSelection*>(gobject_); }
public:
protected:
private:
public:
  FileSelection();
  explicit FileSelection(const Glib::ustring& title);
  void set_filename(const std::string& filename);
  std::string get_filename() const;
  void complete(const Glib::ustring& pattern);
  void show_fileop_buttons();
  void hide_fileop_buttons();
  Glib::ArrayHandle<std::string> get_selections() const;
  void set_select_multiple(bool select_multiple = true);
  bool get_select_multiple() const;
   TreeView* get_dir_list();
  const TreeView* get_dir_list() const;
    TreeView* get_file_list();
  const TreeView* get_file_list() const;
    OptionMenu* get_history_pulldown();
  const OptionMenu* get_history_pulldown() const;
    Entry* get_selection_entry();
  const Entry* get_selection_entry() const;
    Label* get_selection_text();
  const Label* get_selection_text() const;
    VBox* get_main_vbox();
  const VBox* get_main_vbox() const;
    Button* get_ok_button();
  const Button* get_ok_button() const;
    Button* get_cancel_button();
  const Button* get_cancel_button() const;
    Button* get_help_button();
  const Button* get_help_button() const;
    HButtonBox* get_button_area();
  const HButtonBox* get_button_area() const;
    HBox* get_action_area();
  const HBox* get_action_area() const;
  Glib::PropertyProxy<bool> property_show_fileops() ;
  Glib::PropertyProxy_ReadOnly<bool> property_show_fileops() const;
  Glib::PropertyProxy<std::string> property_filename() ;
  Glib::PropertyProxy_ReadOnly<std::string> property_filename() const;
  Glib::PropertyProxy<bool> property_select_multiple() ;
  Glib::PropertyProxy_ReadOnly<bool> property_select_multiple() const;
};
}
namespace Glib
{
  Gtk::FileSelection* wrap(GtkFileSelection* object, bool take_copy = false);
}
typedef struct _GtkFixed GtkFixed;
typedef struct _GtkFixedClass GtkFixedClass;
namespace Gtk
{ class Fixed_Class; }
namespace Gtk
{
class Fixed : public Container
{
  public:
  typedef Fixed CppObjectType;
  typedef Fixed_Class CppClassType;
  typedef GtkFixed BaseObjectType;
  typedef GtkFixedClass BaseClassType;
  virtual ~Fixed();
private:
  friend class Fixed_Class;
  static CppClassType fixed_class_;
  Fixed(const Fixed&);
  Fixed& operator=(const Fixed&);
protected:
  explicit Fixed(const Glib::ConstructParams& construct_params);
  explicit Fixed(GtkFixed* castitem);
public:
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkFixed* gobj() { return reinterpret_cast<GtkFixed*>(gobject_); }
  const GtkFixed* gobj() const { return reinterpret_cast<GtkFixed*>(gobject_); }
public:
protected:
private:
public:
  Fixed();
  void put(Widget& widget, int x, int y);
  void move(Widget& widget, int x, int y);
  void set_has_window(bool has_window = true);
  bool get_has_window() const;
};
}
namespace Glib
{
  Gtk::Fixed* wrap(GtkFixed* object, bool take_copy = false);
}
typedef struct _GtkFontButton GtkFontButton;
typedef struct _GtkFontButtonClass GtkFontButtonClass;
namespace Gtk
{ class FontButton_Class; }
namespace Gtk
{
class FontButton : public Button
{
  public:
  typedef FontButton CppObjectType;
  typedef FontButton_Class CppClassType;
  typedef GtkFontButton BaseObjectType;
  typedef GtkFontButtonClass BaseClassType;
  virtual ~FontButton();
private:
  friend class FontButton_Class;
  static CppClassType fontbutton_class_;
  FontButton(const FontButton&);
  FontButton& operator=(const FontButton&);
protected:
  explicit FontButton(const Glib::ConstructParams& construct_params);
  explicit FontButton(GtkFontButton* castitem);
public:
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkFontButton* gobj() { return reinterpret_cast<GtkFontButton*>(gobject_); }
  const GtkFontButton* gobj() const { return reinterpret_cast<GtkFontButton*>(gobject_); }
public:
protected:
  virtual void on_font_set();
private:
public:
  FontButton();
  explicit FontButton(const Glib::ustring& font_name);
  Glib::ustring get_title() const;
  void set_title(const Glib::ustring& title);
  bool get_use_font() const;
  void set_use_font(bool use_font = true);
  bool get_use_size() const;
  void set_use_size(bool use_size = true);
  Glib::ustring get_font_name() const;
  bool set_font_name(const Glib::ustring& fontname);
  bool get_show_style() const;
  void set_show_style(bool show_style = true);
  bool get_show_size() const;
  void set_show_size(bool show_size = true);
  Glib::PropertyProxy<Glib::ustring> property_title() ;
  Glib::PropertyProxy_ReadOnly<Glib::ustring> property_title() const;
  Glib::PropertyProxy<Glib::ustring> property_font_name() ;
  Glib::PropertyProxy_ReadOnly<Glib::ustring> property_font_name() const;
  Glib::PropertyProxy<bool> property_use_font() ;
  Glib::PropertyProxy_ReadOnly<bool> property_use_font() const;
  Glib::PropertyProxy<bool> property_use_size() ;
  Glib::PropertyProxy_ReadOnly<bool> property_use_size() const;
  Glib::PropertyProxy<bool> property_show_style() ;
  Glib::PropertyProxy_ReadOnly<bool> property_show_style() const;
  Glib::PropertyProxy<bool> property_show_size() ;
  Glib::PropertyProxy_ReadOnly<bool> property_show_size() const;
  Glib::SignalProxy0< void > signal_font_set();
};
}
namespace Glib
{
  Gtk::FontButton* wrap(GtkFontButton* object, bool take_copy = false);
}
typedef struct _GtkFontSelection GtkFontSelection;
typedef struct _GtkFontSelectionClass GtkFontSelectionClass;
namespace Gtk
{ class FontSelection_Class; }
typedef struct _GtkFontSelectionDialog GtkFontSelectionDialog;
typedef struct _GtkFontSelectionDialogClass GtkFontSelectionDialogClass;
namespace Gtk
{ class FontSelectionDialog_Class; }
namespace Gtk
{
class Button;
class Entry;
class RadioButton;
class FontSelection : public VBox
{
  public:
  typedef FontSelection CppObjectType;
  typedef FontSelection_Class CppClassType;
  typedef GtkFontSelection BaseObjectType;
  typedef GtkFontSelectionClass BaseClassType;
  virtual ~FontSelection();
private:
  friend class FontSelection_Class;
  static CppClassType fontselection_class_;
  FontSelection(const FontSelection&);
  FontSelection& operator=(const FontSelection&);
protected:
  explicit FontSelection(const Glib::ConstructParams& construct_params);
  explicit FontSelection(GtkFontSelection* castitem);
public:
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkFontSelection* gobj() { return reinterpret_cast<GtkFontSelection*>(gobject_); }
  const GtkFontSelection* gobj() const { return reinterpret_cast<GtkFontSelection*>(gobject_); }
public:
protected:
private:
public:
  FontSelection();
  Glib::ustring get_font_name() const;
  bool set_font_name(const Glib::ustring& fontname);
  Glib::ustring get_preview_text() const;
  void set_preview_text(const Glib::ustring& fontname);
   Entry* get_font_entry();
  const Entry* get_font_entry() const;
    Entry* get_font_style_entry();
  const Entry* get_font_style_entry() const;
    Entry* get_size_entry();
  const Entry* get_size_entry() const;
   RadioButton* get_pixels_button();
  const RadioButton* get_pixels_button() const;
    RadioButton* get_points_button();
  const RadioButton* get_points_button() const;
    Button* get_filter_button();
  const Button* get_filter_button() const;
   Entry* get_preview_entry();
  const Entry* get_preview_entry() const;
  Glib::PropertyProxy<Glib::ustring> property_font_name() ;
  Glib::PropertyProxy_ReadOnly<Glib::ustring> property_font_name() const;
  Glib::PropertyProxy<Glib::ustring> property_preview_text() ;
  Glib::PropertyProxy_ReadOnly<Glib::ustring> property_preview_text() const;
};
class FontSelectionDialog : public Dialog
{
  public:
  typedef FontSelectionDialog CppObjectType;
  typedef FontSelectionDialog_Class CppClassType;
  typedef GtkFontSelectionDialog BaseObjectType;
  typedef GtkFontSelectionDialogClass BaseClassType;
  virtual ~FontSelectionDialog();
private:
  friend class FontSelectionDialog_Class;
  static CppClassType fontselectiondialog_class_;
  FontSelectionDialog(const FontSelectionDialog&);
  FontSelectionDialog& operator=(const FontSelectionDialog&);
protected:
  explicit FontSelectionDialog(const Glib::ConstructParams& construct_params);
  explicit FontSelectionDialog(GtkFontSelectionDialog* castitem);
public:
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkFontSelectionDialog* gobj() { return reinterpret_cast<GtkFontSelectionDialog*>(gobject_); }
  const GtkFontSelectionDialog* gobj() const { return reinterpret_cast<GtkFontSelectionDialog*>(gobject_); }
public:
protected:
private:
public:
  FontSelectionDialog();
  explicit FontSelectionDialog(const Glib::ustring& title);
  bool set_font_name(const Glib::ustring& fontname);
  Glib::ustring get_font_name() const;
  Glib::ustring get_preview_text() const;
  void set_preview_text(const Glib::ustring& fontname);
   FontSelection* get_font_selection();
  const FontSelection* get_font_selection() const;
    Button* get_ok_button();
  const Button* get_ok_button() const;
    Button* get_apply_button();
  const Button* get_apply_button() const;
    Button* get_cancel_button();
  const Button* get_cancel_button() const;
};
}
namespace Glib
{
  Gtk::FontSelection* wrap(GtkFontSelection* object, bool take_copy = false);
}
namespace Glib
{
  Gtk::FontSelectionDialog* wrap(GtkFontSelectionDialog* object, bool take_copy = false);
}
typedef struct _GtkHandleBox GtkHandleBox;
typedef struct _GtkHandleBoxClass GtkHandleBoxClass;
namespace Gtk
{ class HandleBox_Class; }
namespace Gtk
{
class HandleBox : public Bin
{
  public:
  typedef HandleBox CppObjectType;
  typedef HandleBox_Class CppClassType;
  typedef GtkHandleBox BaseObjectType;
  typedef GtkHandleBoxClass BaseClassType;
  virtual ~HandleBox();
private:
  friend class HandleBox_Class;
  static CppClassType handlebox_class_;
  HandleBox(const HandleBox&);
  HandleBox& operator=(const HandleBox&);
protected:
  explicit HandleBox(const Glib::ConstructParams& construct_params);
  explicit HandleBox(GtkHandleBox* castitem);
public:
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkHandleBox* gobj() { return reinterpret_cast<GtkHandleBox*>(gobject_); }
  const GtkHandleBox* gobj() const { return reinterpret_cast<GtkHandleBox*>(gobject_); }
public:
protected:
  virtual void on_child_attached(Widget* child);
  virtual void on_child_detached(Widget* child);
private:
public:
  HandleBox();
  void set_shadow_type(ShadowType type);
  ShadowType get_shadow_type() const;
  void set_handle_position(PositionType position);
  PositionType get_handle_position() const;
  void set_snap_edge(PositionType edge);
  PositionType get_snap_edge() const;
  Glib::SignalProxy1< void,Widget* > signal_child_attached();
  Glib::SignalProxy1< void,Widget* > signal_child_detached();
   Glib::RefPtr<Gdk::Window> get_bin_window();
  Glib::RefPtr<const Gdk::Window> get_bin_window() const;
    Glib::RefPtr<Gdk::Window> get_float_window();
  Glib::RefPtr<const Gdk::Window> get_float_window() const;
  bool is_child_detached() const;
  bool is_float_window_mapped() const;
  bool is_in_drag() const;
  bool shrinks_on_detach() const;
  Glib::PropertyProxy<ShadowType> property_shadow_type() ;
  Glib::PropertyProxy_ReadOnly<ShadowType> property_shadow_type() const;
  Glib::PropertyProxy<PositionType> property_handle_position() ;
  Glib::PropertyProxy_ReadOnly<PositionType> property_handle_position() const;
  Glib::PropertyProxy<PositionType> property_snap_edge() ;
  Glib::PropertyProxy_ReadOnly<PositionType> property_snap_edge() const;
};
}
namespace Glib
{
  Gtk::HandleBox* wrap(GtkHandleBox* object, bool take_copy = false);
}
typedef struct _GtkIconFactory GtkIconFactory;
typedef struct _GtkIconFactoryClass GtkIconFactoryClass;
namespace Gtk
{ class IconFactory_Class; }
namespace Gtk
{
class IconFactory : public Glib::Object
{
public:
  typedef IconFactory CppObjectType;
  typedef IconFactory_Class CppClassType;
  typedef GtkIconFactory BaseObjectType;
  typedef GtkIconFactoryClass BaseClassType;
private: friend class IconFactory_Class;
  static CppClassType iconfactory_class_;
private:
  IconFactory(const IconFactory&);
  IconFactory& operator=(const IconFactory&);
protected:
  explicit IconFactory(const Glib::ConstructParams& construct_params);
  explicit IconFactory(GtkIconFactory* castitem);
public:
  virtual ~IconFactory();
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkIconFactory* gobj() { return reinterpret_cast<GtkIconFactory*>(gobject_); }
  const GtkIconFactory* gobj() const { return reinterpret_cast<GtkIconFactory*>(gobject_); }
  GtkIconFactory* gobj_copy();
private:
protected:
  IconFactory();
public:
  static Glib::RefPtr<IconFactory> create();
  void add(const Gtk::StockID& stock_id, const IconSet& icon_set);
  void add_default();
  void remove_default();
public:
public:
protected:
};
}
namespace Glib
{
  Glib::RefPtr<Gtk::IconFactory> wrap(GtkIconFactory* object, bool take_copy = false);
}
extern "C" { typedef struct _GtkIconInfo GtkIconInfo; }
namespace Gtk
{
class IconInfo
{
  public:
  typedef IconInfo CppObjectType;
  typedef GtkIconInfo BaseObjectType;
  static GType get_type() __attribute__((__const__));
  IconInfo();
  explicit IconInfo(GtkIconInfo* gobject, bool make_a_copy = true);
  IconInfo(const IconInfo& other);
  IconInfo& operator=(const IconInfo& other);
  ~IconInfo();
  void swap(IconInfo& other);
  GtkIconInfo* gobj() { return gobject_; }
  const GtkIconInfo* gobj() const { return gobject_; }
  GtkIconInfo* gobj_copy() const;
protected:
  GtkIconInfo* gobject_;
private:
public:
  operator bool();
  int get_base_size() const;
  Glib::ustring get_filename() const;
  Glib::RefPtr<Gdk::Pixbuf> get_builtin_pixbuf();
  Glib::RefPtr<const Gdk::Pixbuf> get_builtin_pixbuf() const;
  Glib::RefPtr<Gdk::Pixbuf> load_icon() const;
  void set_raw_coordinates(bool raw_coordinates = true);
  bool get_embedded_rect(Gdk::Rectangle& rectangle) const;
  bool get_attach_points(Glib::ArrayHandle<Gdk::Point>& points) const;
  Glib::ustring get_display_name() const;
};
}
namespace Gtk
{
inline void swap(IconInfo& lhs, IconInfo& rhs)
  { lhs.swap(rhs); }
}
namespace Glib
{
Gtk::IconInfo wrap(GtkIconInfo* object, bool take_copy = false);
template <>
class Value<Gtk::IconInfo> : public Glib::Value_Boxed<Gtk::IconInfo>
{};
}
typedef struct _GtkIconTheme GtkIconTheme;
typedef struct _GtkIconThemeClass GtkIconThemeClass;
namespace Gtk
{ class IconTheme_Class; }
namespace Gtk
{
enum IconLookupFlags
{
  ICON_LOOKUP_NO_SVG = 1 << 0,
  ICON_LOOKUP_FORCE_SVG = 1 << 1,
  ICON_LOOKUP_USE_BUILTIN = 1 << 2,
  ICON_LOOKUP_GENERIC_FALLBACK = 1 << 3
};
inline IconLookupFlags operator|(IconLookupFlags lhs, IconLookupFlags rhs)
  { return static_cast<IconLookupFlags>(static_cast<unsigned>(lhs) | static_cast<unsigned>(rhs)); }
inline IconLookupFlags operator&(IconLookupFlags lhs, IconLookupFlags rhs)
  { return static_cast<IconLookupFlags>(static_cast<unsigned>(lhs) & static_cast<unsigned>(rhs)); }
inline IconLookupFlags operator^(IconLookupFlags lhs, IconLookupFlags rhs)
  { return static_cast<IconLookupFlags>(static_cast<unsigned>(lhs) ^ static_cast<unsigned>(rhs)); }
inline IconLookupFlags operator~(IconLookupFlags flags)
  { return static_cast<IconLookupFlags>(~static_cast<unsigned>(flags)); }
inline IconLookupFlags& operator|=(IconLookupFlags& lhs, IconLookupFlags rhs)
  { return (lhs = static_cast<IconLookupFlags>(static_cast<unsigned>(lhs) | static_cast<unsigned>(rhs))); }
inline IconLookupFlags& operator&=(IconLookupFlags& lhs, IconLookupFlags rhs)
  { return (lhs = static_cast<IconLookupFlags>(static_cast<unsigned>(lhs) & static_cast<unsigned>(rhs))); }
inline IconLookupFlags& operator^=(IconLookupFlags& lhs, IconLookupFlags rhs)
  { return (lhs = static_cast<IconLookupFlags>(static_cast<unsigned>(lhs) ^ static_cast<unsigned>(rhs))); }
class IconThemeError : public Glib::Error
{
public:
  enum Code
  {
    ICON_THEME_NOT_FOUND,
    ICON_THEME_FAILED
  };
  IconThemeError(Code error_code, const Glib::ustring& error_message);
  explicit IconThemeError(GError* gobject);
  Code code() const;
private:
  static void throw_func(GError* gobject);
  friend void wrap_init();
};
}
namespace Glib
{
template <>
class Value<Gtk::IconThemeError::Code> : public Glib::Value_Enum<Gtk::IconThemeError::Code>
{
public:
  static GType value_type() __attribute__((__const__));
};
}
namespace Gtk
{
class IconTheme : public Glib::Object
{
public:
  typedef IconTheme CppObjectType;
  typedef IconTheme_Class CppClassType;
  typedef GtkIconTheme BaseObjectType;
  typedef GtkIconThemeClass BaseClassType;
private: friend class IconTheme_Class;
  static CppClassType icontheme_class_;
private:
  IconTheme(const IconTheme&);
  IconTheme& operator=(const IconTheme&);
protected:
  explicit IconTheme(const Glib::ConstructParams& construct_params);
  explicit IconTheme(GtkIconTheme* castitem);
public:
  virtual ~IconTheme();
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkIconTheme* gobj() { return reinterpret_cast<GtkIconTheme*>(gobject_); }
  const GtkIconTheme* gobj() const { return reinterpret_cast<GtkIconTheme*>(gobject_); }
  GtkIconTheme* gobj_copy();
private:
protected:
  IconTheme();
public:
  static Glib::RefPtr<IconTheme> create();
  static Glib::RefPtr<IconTheme> get_default();
  static Glib::RefPtr<IconTheme> get_for_screen(const Glib::RefPtr<Gdk::Screen>& screen);
  void set_screen(const Glib::RefPtr<Gdk::Screen>& screen);
  void set_search_path(const Glib::ArrayHandle<Glib::ustring>& path);
  Glib::ArrayHandle<Glib::ustring> get_search_path() const;
  void append_search_path(const Glib::ustring& path);
  void prepend_search_path(const Glib::ustring& path);
  void set_custom_theme(const Glib::ustring& theme_name);
  bool has_icon(const Glib::ustring& icon_name) const;
  Glib::ArrayHandle<int> get_icon_sizes(const Glib::ustring& icon_name) const;
  IconInfo lookup_icon(const Glib::ustring& icon_name, int size, IconLookupFlags flags) const;
  IconInfo choose_icon(const Glib::StringArrayHandle& icon_names, int size, IconLookupFlags flags);
  Glib::RefPtr<Gdk::Pixbuf> load_icon(const Glib::ustring& icon_name, int size, IconLookupFlags flags) const;
  Glib::ListHandle<Glib::ustring> list_icons(const Glib::ustring& context) const;
   Glib::ListHandle<Glib::ustring> list_icons() const;
  Glib::ListHandle<Glib::ustring> list_contexts() const;
  Glib::ustring get_example_icon_name() const;
  bool rescan_if_needed();
  static void add_builtin_icon(const Glib::ustring& icon_name, int size, const Glib::RefPtr<Gdk::Pixbuf>& pixbuf);
  Glib::SignalProxy0< void > signal_changed();
public:
public:
protected:
  virtual void on_changed();
};
}
namespace Glib
{
  Glib::RefPtr<Gtk::IconTheme> wrap(GtkIconTheme* object, bool take_copy = false);
}
typedef struct _GtkIconView GtkIconView;
typedef struct _GtkIconViewClass GtkIconViewClass;
namespace Gtk
{ class IconView_Class; }
namespace Gtk
{
enum IconViewDropPosition
{
  ICON_VIEW_NO_DROP,
  ICON_VIEW_DROP_INTO,
  ICON_VIEW_DROP_LEFT,
  ICON_VIEW_DROP_RIGHT,
  ICON_VIEW_DROP_ABOVE,
  ICON_VIEW_DROP_BELOW
};
}
namespace Glib
{
template <>
class Value<Gtk::IconViewDropPosition> : public Glib::Value_Enum<Gtk::IconViewDropPosition>
{
public:
  static GType value_type() __attribute__((__const__));
};
}
namespace Gtk
{
class IconView : public Container
{
  public:
  typedef IconView CppObjectType;
  typedef IconView_Class CppClassType;
  typedef GtkIconView BaseObjectType;
  typedef GtkIconViewClass BaseClassType;
  virtual ~IconView();
private:
  friend class IconView_Class;
  static CppClassType iconview_class_;
  IconView(const IconView&);
  IconView& operator=(const IconView&);
protected:
  explicit IconView(const Glib::ConstructParams& construct_params);
  explicit IconView(GtkIconView* castitem);
public:
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkIconView* gobj() { return reinterpret_cast<GtkIconView*>(gobject_); }
  const GtkIconView* gobj() const { return reinterpret_cast<GtkIconView*>(gobject_); }
public:
protected:
  virtual void on_set_scroll_adjustments(Adjustment* hadjustment, Adjustment* vadjustment);
  virtual void on_item_activated(const TreeModel::Path& path);
  virtual void on_selection_changed();
private:
public:
  IconView();
  explicit IconView(const Glib::RefPtr<TreeModel>& model);
  void set_model(const Glib::RefPtr<TreeModel>& model);
  Glib::RefPtr<TreeModel> get_model();
  Glib::RefPtr<const TreeModel> get_model() const;
  void set_text_column(int column);
  void set_text_column(const TreeModelColumnBase& model_column);
  int get_text_column() const;
  void set_markup_column(int column);
  void set_markup_column(const TreeModelColumnBase& column);
  int get_markup_column() const;
  void set_pixbuf_column(int column);
  void set_pixbuf_column(const TreeModelColumnBase& column);
  int get_pixbuf_column() const;
  void set_orientation(Orientation orientation);
  Orientation get_orientation() const;
  void set_columns(int columns);
  int get_columns() const;
  void set_item_width(int item_width);
  int get_icon_width() const;
  void set_spacing(int spacing);
  int get_spacing() const;
  void set_row_spacing(int row_spacing);
  gint get_row_spacing() const;
  void set_column_spacing(int column_spacing);
  int get_column_spacing() const;
  void set_margin(int margin);
  int get_margin() const;
  TreeModel::Path get_path_at_pos(int x, int y) const;
  bool get_item_at_pos(int x, int y, TreeModel::Path& path, CellRenderer*& cell) const;
  bool get_item_at_pos(int x, int y, TreeModel::Path& path) const;
  bool get_item_at_pos(int x, int y, CellRenderer*& cell) const;
  bool get_visible_range(TreeModel::Path& start_path, TreeModel::Path& end_path) const;
  typedef sigc::slot<void, const TreeModel::Path&> SlotForeach;
  void selected_foreach(const SlotForeach& slot);
  void set_selection_mode(SelectionMode mode);
  SelectionMode get_selection_mode() const;
  void select_path(const TreeModel::Path& path);
  void unselect_path(const TreeModel::Path& path);
  bool path_is_selected(const TreeModel::Path& path) const;
  struct TreePathTraits
  {
    typedef TreePath CppType;
    typedef const GtkTreePath* CType;
    typedef GtkTreePath* CTypeNonConst;
    static CType to_c_type (const CppType& obj) { return obj.gobj(); }
    static CType to_c_type (const CType& obj) { return obj; }
    static CppType to_cpp_type (const CType& obj) { return CppType(const_cast<CTypeNonConst>(obj), true); }
    static void release_c_type (const CType&) {}
  };
  typedef Glib::ListHandle<TreePath, TreePathTraits> ArrayHandle_TreePaths;
  ArrayHandle_TreePaths get_selected_items() const;
  void select_all();
  void unselect_all();
  void item_activated(const TreeModel::Path& path);
  void set_cursor(const TreeModel::Path& path, CellRenderer& cell, bool start_editing);
  bool get_cursor(TreeModel::Path& path, CellRenderer*& cell) const;
  bool get_cursor(TreeModel::Path& path) const;
  bool get_cursor(CellRenderer*& cell) const;
  void scroll_to_path(const TreeModel::Path& path, bool use_align, gfloat row_align, gfloat col_align);
  void enable_model_drag_source(const ArrayHandle_TargetEntry& targets,
                                Gdk::ModifierType start_button_mask = Gdk::MODIFIER_MASK,
                                Gdk::DragAction actions = Gdk::ACTION_COPY | Gdk::ACTION_MOVE);
  void enable_model_drag_dest(const ArrayHandle_TargetEntry& targets, Gdk::DragAction actions = Gdk::ACTION_COPY | Gdk::ACTION_MOVE);
  void unset_model_drag_source();
  void unset_model_drag_dest();
  void set_reorderable(bool reorderable = true);
  bool get_reorderable() const;
  void set_drag_dest_item(const TreeModel::Path& path, IconViewDropPosition pos);
  void get_drag_dest_item(TreeModel::Path& path, IconViewDropPosition& pos) const;
  void get_drag_dest_item(TreeModel::Path& path) const;
  void get_drag_dest_item(IconViewDropPosition& pos) const;
  bool get_dest_item_at_pos(int drag_x, int drag_y, TreeModel::Path& path, IconViewDropPosition& pos) const;
  bool get_dest_item_at_pos(int drag_x, int drag_y, TreeModel::Path& path) const;
  bool get_dest_item_at_pos(int drag_x, int drag_y, IconViewDropPosition& pos) const;
  Glib::RefPtr<Gdk::Pixmap> create_drag_icon( const TreeModel::Path& path);
  void convert_widget_to_bin_window_coords(int wx, int wy, int& bx, int& by) const;
  void set_tooltip_item(const Glib::RefPtr<Tooltip>& tooltip, const TreeModel::Path& path);
  void set_tooltip_cell(const Glib::RefPtr<Tooltip>& tooltip, const TreeModel::Path& path, CellRenderer& cell);
  void set_tooltip_cell(const Glib::RefPtr<Tooltip>& tooltip, const TreeModel::Path& path);
  bool get_tooltip_context_path(int& x, int& y,
                                bool keyboard_tip,
                                TreeModel::Path& path);
  bool get_tooltip_context_iter(int& x, int& y,
                                bool keyboard_tip,
                                Gtk::TreeModel::iterator& iter);
  void set_tooltip_column(int column);
  int get_tooltip_column() const;
  Glib::SignalProxy2< void,Adjustment*,Adjustment* > signal_set_scroll_adjustments();
  Glib::SignalProxy1< void,const TreeModel::Path& > signal_item_activated();
  Glib::SignalProxy0< void > signal_selection_changed();
  Glib::PropertyProxy<int> property_pixbuf_column() ;
  Glib::PropertyProxy_ReadOnly<int> property_pixbuf_column() const;
  Glib::PropertyProxy<int> property_text_column() ;
  Glib::PropertyProxy_ReadOnly<int> property_text_column() const;
  Glib::PropertyProxy<int> property_markup_column() ;
  Glib::PropertyProxy_ReadOnly<int> property_markup_column() const;
  Glib::PropertyProxy<SelectionMode> property_selection_mode() ;
  Glib::PropertyProxy_ReadOnly<SelectionMode> property_selection_mode() const;
  Glib::PropertyProxy<Orientation> property_orientation() ;
  Glib::PropertyProxy_ReadOnly<Orientation> property_orientation() const;
  Glib::PropertyProxy< Glib::RefPtr<TreeModel> > property_model() ;
  Glib::PropertyProxy_ReadOnly< Glib::RefPtr<TreeModel> > property_model() const;
  Glib::PropertyProxy<int> property_columns() ;
  Glib::PropertyProxy_ReadOnly<int> property_columns() const;
  Glib::PropertyProxy<int> property_item_width() ;
  Glib::PropertyProxy_ReadOnly<int> property_item_width() const;
  Glib::PropertyProxy<int> property_spacing() ;
  Glib::PropertyProxy_ReadOnly<int> property_spacing() const;
  Glib::PropertyProxy<int> property_row_spacing() ;
  Glib::PropertyProxy_ReadOnly<int> property_row_spacing() const;
  Glib::PropertyProxy<int> property_column_spacing() ;
  Glib::PropertyProxy_ReadOnly<int> property_column_spacing() const;
  Glib::PropertyProxy<int> property_margin() ;
  Glib::PropertyProxy_ReadOnly<int> property_margin() const;
};
}
namespace Glib
{
  Gtk::IconView* wrap(GtkIconView* object, bool take_copy = false);
}
typedef struct _GtkImage GtkImage;
typedef struct _GtkImageClass GtkImageClass;
namespace Gtk
{ class Image_Class; }
namespace Gtk
{
enum ImageType
{
  IMAGE_EMPTY,
  IMAGE_PIXMAP,
  IMAGE_IMAGE,
  IMAGE_PIXBUF,
  IMAGE_STOCK,
  IMAGE_ICON_SET,
  IMAGE_ANIMATION,
  IMAGE_ICON_NAME
};
}
namespace Glib
{
template <>
class Value<Gtk::ImageType> : public Glib::Value_Enum<Gtk::ImageType>
{
public:
  static GType value_type() __attribute__((__const__));
};
}
namespace Gtk
{
class Image : public Misc
{
  public:
  typedef Image CppObjectType;
  typedef Image_Class CppClassType;
  typedef GtkImage BaseObjectType;
  typedef GtkImageClass BaseClassType;
  virtual ~Image();
private:
  friend class Image_Class;
  static CppClassType image_class_;
  Image(const Image&);
  Image& operator=(const Image&);
protected:
  explicit Image(const Glib::ConstructParams& construct_params);
  explicit Image(GtkImage* castitem);
public:
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkImage* gobj() { return reinterpret_cast<GtkImage*>(gobject_); }
  const GtkImage* gobj() const { return reinterpret_cast<GtkImage*>(gobject_); }
public:
protected:
private:
public:
  Image();
  explicit Image(const Glib::RefPtr<Gdk::Pixmap>& pixmap, const Glib::RefPtr<Gdk::Bitmap>& mask);
  explicit Image(const Glib::RefPtr<Gdk::Image>& image, const Glib::RefPtr<Gdk::Bitmap>& mask);
  explicit Image(const std::string& file);
  explicit Image(const Glib::RefPtr<Gdk::Pixbuf>& pixbuf);
  Image(const Gtk::StockID& stock_id, IconSize size);
  Image(IconSet& icon_set, IconSize size);
  Image(const Glib::RefPtr<Gdk::PixbufAnimation>& animation);
  void set(const Glib::RefPtr<Gdk::Pixmap>& pixmap, const Glib::RefPtr<Gdk::Bitmap>& mask);
  void set(const Glib::RefPtr<Gdk::Image>& gdk_image, const Glib::RefPtr<Gdk::Bitmap>& mask);
  void set(const std::string& filename);
  void set(const Glib::RefPtr<Gdk::Pixbuf>& pixbuf);
  void set(const Gtk::StockID& stock_id, IconSize size);
  void set(IconSet& icon_set, IconSize size);
  void set(const Glib::RefPtr<Gdk::PixbufAnimation>& animation);
  void set_from_icon_name(const Glib::ustring& icon_name, IconSize size);
  void clear();
  ImageType get_storage_type() const;
  void get_pixmap(Glib::RefPtr<Gdk::Pixmap>& pixmap, Glib::RefPtr<Gdk::Bitmap>& mask) const;
  void get_image(Glib::RefPtr<Gdk::Image>& gdk_image, Glib::RefPtr<Gdk::Bitmap>& mask) const;
  Glib::RefPtr<Gdk::Pixbuf> get_pixbuf();
  Glib::RefPtr<const Gdk::Pixbuf> get_pixbuf() const;
  void get_stock(Gtk::StockID& stock_id, IconSize& size) const;
  void get_icon_set(IconSet& icon_set, IconSize& size) const;
  Glib::RefPtr<Gdk::PixbufAnimation> get_animation();
  Glib::RefPtr<const Gdk::PixbufAnimation> get_animation() const;
  Glib::ustring get_icon_name() const;
  Glib::ustring get_icon_name(IconSize& size);
  int get_pixel_size() const;
  void set_pixel_size(int pixel_size);
  Glib::PropertyProxy< Glib::RefPtr<Gdk::Pixbuf> > property_pixbuf() ;
  Glib::PropertyProxy_ReadOnly< Glib::RefPtr<Gdk::Pixbuf> > property_pixbuf() const;
  Glib::PropertyProxy< Glib::RefPtr<Gdk::Pixmap> > property_pixmap() ;
  Glib::PropertyProxy_ReadOnly< Glib::RefPtr<Gdk::Pixmap> > property_pixmap() const;
  Glib::PropertyProxy< Glib::RefPtr<Gdk::Image> > property_image() ;
  Glib::PropertyProxy_ReadOnly< Glib::RefPtr<Gdk::Image> > property_image() const;
  Glib::PropertyProxy< Glib::RefPtr<Gdk::Pixmap> > property_mask() ;
  Glib::PropertyProxy_ReadOnly< Glib::RefPtr<Gdk::Pixmap> > property_mask() const;
  Glib::PropertyProxy<Glib::ustring> property_file() ;
  Glib::PropertyProxy_ReadOnly<Glib::ustring> property_file() const;
  Glib::PropertyProxy<Glib::ustring> property_stock() ;
  Glib::PropertyProxy_ReadOnly<Glib::ustring> property_stock() const;
  Glib::PropertyProxy<Gtk::IconSet> property_icon_set() ;
  Glib::PropertyProxy_ReadOnly<Gtk::IconSet> property_icon_set() const;
  Glib::PropertyProxy<int> property_icon_size() ;
  Glib::PropertyProxy_ReadOnly<int> property_icon_size() const;
  Glib::PropertyProxy< Glib::RefPtr<Gdk::PixbufAnimation> > property_pixbuf_animation() ;
  Glib::PropertyProxy_ReadOnly< Glib::RefPtr<Gdk::PixbufAnimation> > property_pixbuf_animation() const;
  Glib::PropertyProxy_ReadOnly<ImageType> property_storage_type() const;
};
}
namespace Glib
{
  Gtk::Image* wrap(GtkImage* object, bool take_copy = false);
}
typedef struct _GtkInputDialog GtkInputDialog;
typedef struct _GtkInputDialogClass GtkInputDialogClass;
namespace Gtk
{ class InputDialog_Class; }
namespace Gtk
{
class Button;
class Table;
class OptionMenu;
class ScrolledWindow;
class InputDialog : public Dialog
{
  public:
  typedef InputDialog CppObjectType;
  typedef InputDialog_Class CppClassType;
  typedef GtkInputDialog BaseObjectType;
  typedef GtkInputDialogClass BaseClassType;
  virtual ~InputDialog();
private:
  friend class InputDialog_Class;
  static CppClassType inputdialog_class_;
  InputDialog(const InputDialog&);
  InputDialog& operator=(const InputDialog&);
protected:
  explicit InputDialog(const Glib::ConstructParams& construct_params);
  explicit InputDialog(GtkInputDialog* castitem);
public:
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkInputDialog* gobj() { return reinterpret_cast<GtkInputDialog*>(gobject_); }
  const GtkInputDialog* gobj() const { return reinterpret_cast<GtkInputDialog*>(gobject_); }
public:
protected:
  virtual void on_enable_device(const Glib::RefPtr<Gdk::Device>& device);
  virtual void on_disable_device(const Glib::RefPtr<Gdk::Device>& device);
private:
public:
  InputDialog();
   Table* get_axis_list();
  const Table* get_axis_list() const;
    ScrolledWindow* get_axis_box();
  const ScrolledWindow* get_axis_box() const;
   OptionMenu* get_mode_optionmenu();
  const OptionMenu* get_mode_optionmenu() const;
   Button* get_close_button();
  const Button* get_close_button() const;
    Button* get_save_button();
  const Button* get_save_button() const;
   Glib::RefPtr<Gdk::Device> get_current_device();
  Glib::RefPtr<const Gdk::Device> get_current_device() const;
   Table* get_keys_list();
  const Table* get_keys_list() const;
    ScrolledWindow* get_keys_box();
  const ScrolledWindow* get_keys_box() const;
  Glib::SignalProxy1< void,const Glib::RefPtr<Gdk::Device>& > signal_enable_device();
  Glib::SignalProxy1< void,const Glib::RefPtr<Gdk::Device>& > signal_disable_device();
};
}
namespace Glib
{
  Gtk::InputDialog* wrap(GtkInputDialog* object, bool take_copy = false);
}
typedef struct _GtkCalendar GtkCalendar;
typedef struct _GtkCalendarClass GtkCalendarClass;
namespace Gtk
{ class Calendar_Class; }
namespace Gtk
{
enum CalendarDisplayOptions
{
  CALENDAR_SHOW_HEADING = 1 << 0,
  CALENDAR_SHOW_DAY_NAMES = 1 << 1,
  CALENDAR_NO_MONTH_CHANGE = 1 << 2,
  CALENDAR_SHOW_WEEK_NUMBERS = 1 << 3,
  CALENDAR_WEEK_START_MONDAY = 1 << 4
};
inline CalendarDisplayOptions operator|(CalendarDisplayOptions lhs, CalendarDisplayOptions rhs)
  { return static_cast<CalendarDisplayOptions>(static_cast<unsigned>(lhs) | static_cast<unsigned>(rhs)); }
inline CalendarDisplayOptions operator&(CalendarDisplayOptions lhs, CalendarDisplayOptions rhs)
  { return static_cast<CalendarDisplayOptions>(static_cast<unsigned>(lhs) & static_cast<unsigned>(rhs)); }
inline CalendarDisplayOptions operator^(CalendarDisplayOptions lhs, CalendarDisplayOptions rhs)
  { return static_cast<CalendarDisplayOptions>(static_cast<unsigned>(lhs) ^ static_cast<unsigned>(rhs)); }
inline CalendarDisplayOptions operator~(CalendarDisplayOptions flags)
  { return static_cast<CalendarDisplayOptions>(~static_cast<unsigned>(flags)); }
inline CalendarDisplayOptions& operator|=(CalendarDisplayOptions& lhs, CalendarDisplayOptions rhs)
  { return (lhs = static_cast<CalendarDisplayOptions>(static_cast<unsigned>(lhs) | static_cast<unsigned>(rhs))); }
inline CalendarDisplayOptions& operator&=(CalendarDisplayOptions& lhs, CalendarDisplayOptions rhs)
  { return (lhs = static_cast<CalendarDisplayOptions>(static_cast<unsigned>(lhs) & static_cast<unsigned>(rhs))); }
inline CalendarDisplayOptions& operator^=(CalendarDisplayOptions& lhs, CalendarDisplayOptions rhs)
  { return (lhs = static_cast<CalendarDisplayOptions>(static_cast<unsigned>(lhs) ^ static_cast<unsigned>(rhs))); }
}
namespace Glib
{
template <>
class Value<Gtk::CalendarDisplayOptions> : public Glib::Value_Flags<Gtk::CalendarDisplayOptions>
{
public:
  static GType value_type() __attribute__((__const__));
};
}
namespace Gtk
{
class Calendar : public Widget
{
  public:
  typedef Calendar CppObjectType;
  typedef Calendar_Class CppClassType;
  typedef GtkCalendar BaseObjectType;
  typedef GtkCalendarClass BaseClassType;
  virtual ~Calendar();
private:
  friend class Calendar_Class;
  static CppClassType calendar_class_;
  Calendar(const Calendar&);
  Calendar& operator=(const Calendar&);
protected:
  explicit Calendar(const Glib::ConstructParams& construct_params);
  explicit Calendar(GtkCalendar* castitem);
public:
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkCalendar* gobj() { return reinterpret_cast<GtkCalendar*>(gobject_); }
  const GtkCalendar* gobj() const { return reinterpret_cast<GtkCalendar*>(gobject_); }
public:
protected:
  virtual void on_month_changed();
  virtual void on_day_selected();
  virtual void on_day_selected_double_click();
  virtual void on_prev_month();
  virtual void on_next_month();
  virtual void on_prev_year();
  virtual void on_next_year();
private:
public:
  Calendar();
  int select_month(guint month, guint year);
  void select_day(guint day);
  int mark_day(guint day);
  int unmark_day(guint day);
  void clear_marks();
  void display_options(CalendarDisplayOptions flags);
  void set_display_options(CalendarDisplayOptions flags);
  CalendarDisplayOptions get_display_options() const;
  void get_date(guint& year, guint& month, guint& day) const;
  void get_date(Glib::Date& date) const;
  void freeze();
  void thaw();
  Glib::SignalProxy0< void > signal_month_changed();
  Glib::SignalProxy0< void > signal_day_selected();
  Glib::SignalProxy0< void > signal_day_selected_double_click();
  Glib::SignalProxy0< void > signal_prev_month();
  Glib::SignalProxy0< void > signal_next_month();
  Glib::SignalProxy0< void > signal_prev_year();
  Glib::SignalProxy0< void > signal_next_year();
};
}
namespace Glib
{
  Gtk::Calendar* wrap(GtkCalendar* object, bool take_copy = false);
}
typedef struct _GtkInvisible GtkInvisible;
typedef struct _GtkInvisibleClass GtkInvisibleClass;
namespace Gtk
{ class Invisible_Class; }
namespace Gtk
{
class Invisible : public Widget
{
  public:
  typedef Invisible CppObjectType;
  typedef Invisible_Class CppClassType;
  typedef GtkInvisible BaseObjectType;
  typedef GtkInvisibleClass BaseClassType;
  virtual ~Invisible();
private:
  friend class Invisible_Class;
  static CppClassType invisible_class_;
  Invisible(const Invisible&);
  Invisible& operator=(const Invisible&);
protected:
  explicit Invisible(const Glib::ConstructParams& construct_params);
  explicit Invisible(GtkInvisible* castitem);
public:
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkInvisible* gobj() { return reinterpret_cast<GtkInvisible*>(gobject_); }
  const GtkInvisible* gobj() const { return reinterpret_cast<GtkInvisible*>(gobject_); }
public:
protected:
private:
public:
  Invisible();
  explicit Invisible(const Glib::RefPtr<Gdk::Screen>& screen);
  Glib::RefPtr<Gdk::Screen> get_screen();
  Glib::RefPtr<const Gdk::Screen> get_screen() const;
  void set_screen(const Glib::RefPtr<Gdk::Screen>& screen);
};
}
namespace Glib
{
  Gtk::Invisible* wrap(GtkInvisible* object, bool take_copy = false);
}
typedef struct _GtkLayout GtkLayout;
typedef struct _GtkLayoutClass GtkLayoutClass;
namespace Gtk
{ class Layout_Class; }
namespace Gtk
{
class Layout : public Container
{
  public:
  typedef Layout CppObjectType;
  typedef Layout_Class CppClassType;
  typedef GtkLayout BaseObjectType;
  typedef GtkLayoutClass BaseClassType;
  virtual ~Layout();
private:
  friend class Layout_Class;
  static CppClassType layout_class_;
  Layout(const Layout&);
  Layout& operator=(const Layout&);
protected:
  explicit Layout(const Glib::ConstructParams& construct_params);
  explicit Layout(GtkLayout* castitem);
public:
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkLayout* gobj() { return reinterpret_cast<GtkLayout*>(gobject_); }
  const GtkLayout* gobj() const { return reinterpret_cast<GtkLayout*>(gobject_); }
public:
protected:
  virtual void on_set_scroll_adjustments(Adjustment* hadj, Adjustment* vadj);
private:
public:
  Layout();
  Layout(Adjustment& hadjustment, Adjustment& vadjustment);
  void put(Widget& child_widget, int x, int y);
  void move(Widget& child_widget, int x, int y);
  void set_size(guint width, guint height);
  void get_size(guint& width, guint& height) const;
  void set_hadjustment(Adjustment& adjustment);
  void set_hadjustment();
  Adjustment* get_hadjustment();
  const Adjustment* get_hadjustment() const;
  void set_vadjustment(Adjustment& adjustment);
  void set_vadjustment();
  Adjustment* get_vadjustment();
  const Adjustment* get_vadjustment() const;
   Glib::RefPtr<Gdk::Window> get_bin_window();
  Glib::RefPtr<const Gdk::Window> get_bin_window() const;
  Glib::SignalProxy2< void,Adjustment*,Adjustment* > signal_set_scroll_adjustments();
  Glib::PropertyProxy<Adjustment*> property_hadjustment() ;
  Glib::PropertyProxy_ReadOnly<Adjustment*> property_hadjustment() const;
  Glib::PropertyProxy<Adjustment*> property_vadjustment() ;
  Glib::PropertyProxy_ReadOnly<Adjustment*> property_vadjustment() const;
  Glib::PropertyProxy<guint> property_width() ;
  Glib::PropertyProxy_ReadOnly<guint> property_width() const;
  Glib::PropertyProxy<guint> property_height() ;
  Glib::PropertyProxy_ReadOnly<guint> property_height() const;
};
}
namespace Glib
{
  Gtk::Layout* wrap(GtkLayout* object, bool take_copy = false);
}
extern "C" {
enum {
  GTK_TREE_SORTABLE_DEFAULT_SORT_COLUMN_ID = -1,
  GTK_TREE_SORTABLE_UNSORTED_SORT_COLUMN_ID = -2
};
typedef struct _GtkTreeSortable GtkTreeSortable;
typedef struct _GtkTreeSortableIface GtkTreeSortableIface;
typedef gint (* GtkTreeIterCompareFunc) (GtkTreeModel *model,
      GtkTreeIter *a,
      GtkTreeIter *b,
      gpointer user_data);
struct _GtkTreeSortableIface
{
  GTypeInterface g_iface;
  void (* sort_column_changed) (GtkTreeSortable *sortable);
  gboolean (* get_sort_column_id) (GtkTreeSortable *sortable,
          gint *sort_column_id,
          GtkSortType *order);
  void (* set_sort_column_id) (GtkTreeSortable *sortable,
          gint sort_column_id,
          GtkSortType order);
  void (* set_sort_func) (GtkTreeSortable *sortable,
          gint sort_column_id,
          GtkTreeIterCompareFunc func,
          gpointer data,
          GtkDestroyNotify destroy);
  void (* set_default_sort_func) (GtkTreeSortable *sortable,
          GtkTreeIterCompareFunc func,
          gpointer data,
          GtkDestroyNotify destroy);
  gboolean (* has_default_sort_func) (GtkTreeSortable *sortable);
};
GType gtk_tree_sortable_get_type (void) __attribute__((__const__));
void gtk_tree_sortable_sort_column_changed (GtkTreeSortable *sortable);
gboolean gtk_tree_sortable_get_sort_column_id (GtkTreeSortable *sortable,
        gint *sort_column_id,
        GtkSortType *order);
void gtk_tree_sortable_set_sort_column_id (GtkTreeSortable *sortable,
        gint sort_column_id,
        GtkSortType order);
void gtk_tree_sortable_set_sort_func (GtkTreeSortable *sortable,
        gint sort_column_id,
        GtkTreeIterCompareFunc sort_func,
        gpointer user_data,
        GtkDestroyNotify destroy);
void gtk_tree_sortable_set_default_sort_func (GtkTreeSortable *sortable,
        GtkTreeIterCompareFunc sort_func,
        gpointer user_data,
        GtkDestroyNotify destroy);
gboolean gtk_tree_sortable_has_default_sort_func (GtkTreeSortable *sortable);
}
typedef struct _GtkTreeSortable GtkTreeSortable;
typedef struct _GtkTreeSortableClass GtkTreeSortableClass;
namespace Gtk
{ class TreeSortable_Class; }
namespace Gtk
{
class TreeSortable : public Glib::Interface
{
public:
  typedef TreeSortable CppObjectType;
  typedef TreeSortable_Class CppClassType;
  typedef GtkTreeSortable BaseObjectType;
  typedef GtkTreeSortableIface BaseClassType;
private:
  friend class TreeSortable_Class;
  static CppClassType treesortable_class_;
  TreeSortable(const TreeSortable&);
  TreeSortable& operator=(const TreeSortable&);
protected:
  TreeSortable();
public:
  explicit TreeSortable(GtkTreeSortable* castitem);
protected:
public:
  virtual ~TreeSortable();
  static void add_interface(GType gtype_implementer);
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkTreeSortable* gobj() { return reinterpret_cast<GtkTreeSortable*>(gobject_); }
  const GtkTreeSortable* gobj() const { return reinterpret_cast<GtkTreeSortable*>(gobject_); }
private:
public:
  enum
  {
    DEFAULT_SORT_COLUMN_ID = -1,
    DEFAULT_UNSORTED_COLUMN_ID = -2
  };
  bool get_sort_column_id(int& sort_column_id, SortType& order) const;
  void set_sort_column(const TreeModelColumnBase& sort_column_id, SortType order);
  void set_sort_column(int sort_column_id, SortType order);
  void set_sort_column_id(const TreeModelColumnBase& sort_column_id, SortType order);
  void set_sort_column_id(int sort_column_id, SortType order);
  typedef sigc::slot<int, const Gtk::TreeModel::iterator&, const Gtk::TreeModel::iterator&> SlotCompare;
  void set_sort_func(const TreeModelColumnBase& sort_column, const SlotCompare& slot);
  void set_sort_func(int sort_column_id, const SlotCompare& slot);
  void set_default_sort_func(const SlotCompare& slot);
  void unset_default_sort_func();
  bool has_default_sort_func() const;
  void sort_column_changed();
  Glib::SignalProxy0< void > signal_sort_column_changed();
protected:
  virtual bool get_sort_column_id_vfunc(int* sort_column_id, SortType* order) const;
  virtual void set_sort_column_id_vfunc(int sort_column_id, SortType order);
  virtual void set_sort_func_vfunc(int sort_column_id, GtkTreeIterCompareFunc func, void* data, GtkDestroyNotify destroy);
  virtual void set_default_sort_func_vfunc(GtkTreeIterCompareFunc func, void* data, GtkDestroyNotify destroy);
  virtual bool has_default_sort_func_vfunc() const;
  virtual void sort_column_changed_vfunc() const;
public:
public:
protected:
  virtual void on_sort_column_changed();
};
}
namespace Glib
{
  Glib::RefPtr<Gtk::TreeSortable> wrap(GtkTreeSortable* object, bool take_copy = false);
}
extern "C"
{
typedef struct _GtkTreeDragDestIface GtkTreeDragDestIface;
typedef struct _GtkSelectionData GtkSelectionData;
}
typedef struct _GtkTreeDragDest GtkTreeDragDest;
typedef struct _GtkTreeDragDestClass GtkTreeDragDestClass;
namespace Gtk
{ class TreeDragDest_Class; }
namespace Gtk
{
class TreeDragDest : public Glib::Interface
{
public:
  typedef TreeDragDest CppObjectType;
  typedef TreeDragDest_Class CppClassType;
  typedef GtkTreeDragDest BaseObjectType;
  typedef GtkTreeDragDestIface BaseClassType;
private:
  friend class TreeDragDest_Class;
  static CppClassType treedragdest_class_;
  TreeDragDest(const TreeDragDest&);
  TreeDragDest& operator=(const TreeDragDest&);
protected:
  TreeDragDest();
public:
  explicit TreeDragDest(GtkTreeDragDest* castitem);
protected:
public:
  virtual ~TreeDragDest();
  static void add_interface(GType gtype_implementer);
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkTreeDragDest* gobj() { return reinterpret_cast<GtkTreeDragDest*>(gobject_); }
  const GtkTreeDragDest* gobj() const { return reinterpret_cast<GtkTreeDragDest*>(gobject_); }
private:
public:
  bool drag_data_received(const TreeModel::Path& dest, const SelectionData& selection_data);
  bool row_drop_possible(const TreeModel::Path& dest_path, const SelectionData& selection_data) const;
protected:
  virtual bool drag_data_received_vfunc(const TreeModel::Path& dest, const SelectionData& selection_data);
  virtual bool row_drop_possible_vfunc(const TreeModel::Path& dest, const SelectionData& selection_data) const;
public:
public:
protected:
};
}
namespace Glib
{
  Glib::RefPtr<Gtk::TreeDragDest> wrap(GtkTreeDragDest* object, bool take_copy = false);
}
extern "C"
{
typedef struct _GtkTreeDragSourceIface GtkTreeDragSourceIface;
typedef struct _GtkSelectionData GtkSelectionData;
}
typedef struct _GtkTreeDragSource GtkTreeDragSource;
typedef struct _GtkTreeDragSourceClass GtkTreeDragSourceClass;
namespace Gtk
{ class TreeDragSource_Class; }
namespace Gtk
{
class TreeDragSource : public Glib::Interface
{
public:
  typedef TreeDragSource CppObjectType;
  typedef TreeDragSource_Class CppClassType;
  typedef GtkTreeDragSource BaseObjectType;
  typedef GtkTreeDragSourceIface BaseClassType;
private:
  friend class TreeDragSource_Class;
  static CppClassType treedragsource_class_;
  TreeDragSource(const TreeDragSource&);
  TreeDragSource& operator=(const TreeDragSource&);
protected:
  TreeDragSource();
public:
  explicit TreeDragSource(GtkTreeDragSource* castitem);
protected:
public:
  virtual ~TreeDragSource();
  static void add_interface(GType gtype_implementer);
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkTreeDragSource* gobj() { return reinterpret_cast<GtkTreeDragSource*>(gobject_); }
  const GtkTreeDragSource* gobj() const { return reinterpret_cast<GtkTreeDragSource*>(gobject_); }
private:
public:
  bool row_draggable(const TreeModel::Path& path) const;
  bool drag_data_get(const TreeModel::Path& path, SelectionData& selection_data);
  bool drag_data_delete(const TreeModel::Path& path);
protected:
  virtual bool row_draggable_vfunc(const TreeModel::Path& path) const;
  virtual bool drag_data_get_vfunc(const TreeModel::Path& path, SelectionData& selection_data) const;
  virtual bool drag_data_delete_vfunc(const TreeModel::Path& path);
public:
public:
protected:
};
}
namespace Glib
{
  Glib::RefPtr<Gtk::TreeDragSource> wrap(GtkTreeDragSource* object, bool take_copy = false);
}
typedef struct _GtkListStore GtkListStore;
typedef struct _GtkListStoreClass GtkListStoreClass;
namespace Gtk
{ class ListStore_Class; }
namespace Gtk
{
class ListStore :
  public Glib::Object,
  public TreeModel,
  public TreeSortable,
  public TreeDragSource,
  public TreeDragDest
{
public:
  typedef ListStore CppObjectType;
  typedef ListStore_Class CppClassType;
  typedef GtkListStore BaseObjectType;
  typedef GtkListStoreClass BaseClassType;
private: friend class ListStore_Class;
  static CppClassType liststore_class_;
private:
  ListStore(const ListStore&);
  ListStore& operator=(const ListStore&);
protected:
  explicit ListStore(const Glib::ConstructParams& construct_params);
  explicit ListStore(GtkListStore* castitem);
public:
  virtual ~ListStore();
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkListStore* gobj() { return reinterpret_cast<GtkListStore*>(gobject_); }
  const GtkListStore* gobj() const { return reinterpret_cast<GtkListStore*>(gobject_); }
  GtkListStore* gobj_copy();
private:
protected:
  ListStore();
  explicit ListStore(const TreeModelColumnRecord& columns);
public:
  static Glib::RefPtr<ListStore> create(const TreeModelColumnRecord& columns);
  void set_column_types(const TreeModelColumnRecord& columns);
  iterator erase(const iterator& iter);
  iterator insert(const iterator& iter);
  iterator insert_after(const iterator& iter);
  iterator prepend();
  iterator append();
  void iter_swap(const iterator& a, const iterator& b);
  void move(const iterator& source, const iterator& destination);
  void reorder(const Glib::ArrayHandle<int>& new_order);
  void clear();
  bool iter_is_valid(const iterator& iter) const;
protected:
  virtual void set_value_impl(const iterator& row, int column, const Glib::ValueBase& value);
public:
public:
protected:
};
}
namespace Glib
{
  Glib::RefPtr<Gtk::ListStore> wrap(GtkListStore* object, bool take_copy = false);
}
namespace Gtk
{
class ListViewText : public Gtk::TreeView
{
public:
  ListViewText(guint columns_count, bool editable = false, Gtk::SelectionMode mode = Gtk::SELECTION_SINGLE);
  virtual ~ListViewText();
  void set_column_title(guint column, const Glib::ustring& title);
  Glib::ustring get_column_title(guint column) const;
  guint append_text(const Glib::ustring& column_one_value = Glib::ustring());
  void prepend_text(const Glib::ustring& column_one_value = Glib::ustring());
  void insert_text(guint row, const Glib::ustring& column_one_value = Glib::ustring());
  void clear_items();
  Glib::ustring get_text(guint row, guint column = 0) const;
  void set_text(guint row, guint column, const Glib::ustring& value);
  void set_text(guint row, const Glib::ustring& value);
  guint size() const;
  guint get_num_columns() const;
  typedef std::vector<int> SelectionList;
  SelectionList get_selected();
protected:
 class TextModelColumns : public Gtk::TreeModel::ColumnRecord
  {
  public:
    TextModelColumns(guint columns_count);
    ~TextModelColumns();
    guint get_num_columns() const;
    Gtk::TreeModelColumn<Glib::ustring>* m_columns;
  protected:
    guint m_columns_count;
  };
  Glib::RefPtr<Gtk::ListStore> m_model;
  TextModelColumns m_model_columns;
};
}
typedef struct _GtkLinkButton GtkLinkButton;
typedef struct _GtkLinkButtonClass GtkLinkButtonClass;
namespace Gtk
{ class LinkButton_Class; }
namespace Gtk
{
class LinkButton : public Button
{
  public:
  typedef LinkButton CppObjectType;
  typedef LinkButton_Class CppClassType;
  typedef GtkLinkButton BaseObjectType;
  typedef GtkLinkButtonClass BaseClassType;
  virtual ~LinkButton();
private:
  friend class LinkButton_Class;
  static CppClassType linkbutton_class_;
  LinkButton(const LinkButton&);
  LinkButton& operator=(const LinkButton&);
protected:
  explicit LinkButton(const Glib::ConstructParams& construct_params);
  explicit LinkButton(GtkLinkButton* castitem);
public:
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkLinkButton* gobj() { return reinterpret_cast<GtkLinkButton*>(gobject_); }
  const GtkLinkButton* gobj() const { return reinterpret_cast<GtkLinkButton*>(gobject_); }
public:
protected:
private:
public:
  LinkButton();
  explicit LinkButton(const Glib::ustring& uri);
  explicit LinkButton(const Glib::ustring& uri, const Glib::ustring& label);
  Glib::ustring get_uri() const;
  void set_uri(const Glib::ustring& uri);
  typedef sigc::slot<void, Gtk::LinkButton*, const Glib::ustring&> SlotUri;
  static void set_uri_hook(const SlotUri& slot);
  static void unset_uri_hook();
  Glib::PropertyProxy<Glib::ustring> property_uri() ;
  Glib::PropertyProxy_ReadOnly<Glib::ustring> property_uri() const;
};
}
namespace Glib
{
  Gtk::LinkButton* wrap(GtkLinkButton* object, bool take_copy = false);
}
extern "C" {
typedef gint (*GtkKeySnoopFunc) (GtkWidget *grab_widget,
          GdkEventKey *event,
          gpointer func_data);
extern const guint gtk_major_version;
extern const guint gtk_minor_version;
extern const guint gtk_micro_version;
extern const guint gtk_binary_age;
extern const guint gtk_interface_age;
gchar* gtk_check_version (guint required_major,
     guint required_minor,
     guint required_micro);
gboolean gtk_parse_args (int *argc,
       char ***argv);
void gtk_init (int *argc,
                                   char ***argv);
gboolean gtk_init_check (int *argc,
                                   char ***argv);
gboolean gtk_init_with_args (int *argc,
       char ***argv,
       char *parameter_string,
       GOptionEntry *entries,
       char *translation_domain,
       GError **error);
GOptionGroup *gtk_get_option_group (gboolean open_default_display);
void gtk_exit (gint error_code);
void gtk_disable_setlocale (void);
gchar * gtk_set_locale (void);
PangoLanguage *gtk_get_default_language (void);
gboolean gtk_events_pending (void);
void gtk_main_do_event (GdkEvent *event);
void gtk_main (void);
guint gtk_main_level (void);
void gtk_main_quit (void);
gboolean gtk_main_iteration (void);
gboolean gtk_main_iteration_do (gboolean blocking);
gboolean gtk_true (void) __attribute__((__const__));
gboolean gtk_false (void) __attribute__((__const__));
void gtk_grab_add (GtkWidget *widget);
GtkWidget* gtk_grab_get_current (void);
void gtk_grab_remove (GtkWidget *widget);
void gtk_init_add (GtkFunction function,
        gpointer data);
void gtk_quit_add_destroy (guint main_level,
        GtkObject *object);
guint gtk_quit_add (guint main_level,
        GtkFunction function,
        gpointer data);
guint gtk_quit_add_full (guint main_level,
        GtkFunction function,
        GtkCallbackMarshal marshal,
        gpointer data,
        GtkDestroyNotify destroy);
void gtk_quit_remove (guint quit_handler_id);
void gtk_quit_remove_by_data (gpointer data);
guint gtk_timeout_add (guint32 interval,
        GtkFunction function,
        gpointer data);
guint gtk_timeout_add_full (guint32 interval,
        GtkFunction function,
        GtkCallbackMarshal marshal,
        gpointer data,
        GtkDestroyNotify destroy);
void gtk_timeout_remove (guint timeout_handler_id);
guint gtk_idle_add (GtkFunction function,
        gpointer data);
guint gtk_idle_add_priority (gint priority,
        GtkFunction function,
        gpointer data);
guint gtk_idle_add_full (gint priority,
        GtkFunction function,
        GtkCallbackMarshal marshal,
        gpointer data,
        GtkDestroyNotify destroy);
void gtk_idle_remove (guint idle_handler_id);
void gtk_idle_remove_by_data (gpointer data);
guint gtk_input_add_full (gint source,
        GdkInputCondition condition,
        GdkInputFunction function,
        GtkCallbackMarshal marshal,
        gpointer data,
        GtkDestroyNotify destroy);
void gtk_input_remove (guint input_handler_id);
guint gtk_key_snooper_install (GtkKeySnoopFunc snooper,
        gpointer func_data);
void gtk_key_snooper_remove (guint snooper_handler_id);
GdkEvent* gtk_get_current_event (void);
guint32 gtk_get_current_event_time (void);
gboolean gtk_get_current_event_state (GdkModifierType *state);
GtkWidget* gtk_get_event_widget (GdkEvent *event);
void gtk_propagate_event (GtkWidget *widget,
        GdkEvent *event);
gboolean _gtk_boolean_handled_accumulator (GSignalInvocationHint *ihint,
                                   GValue *return_accu,
                                   const GValue *handler_return,
                                   gpointer dummy);
gchar *_gtk_get_lc_ctype (void);
}
namespace Gtk
{
class Widget;
class Window;
class RunSig
{
public:
  typedef sigc::slot<void> SlotType;
  sigc::connection connect(const SlotType& slot);
protected:
  static gboolean gtk_callback(gpointer data);
};
class QuitSig
{
public:
  typedef sigc::slot<bool> SlotType;
  sigc::connection connect(const SlotType& slot, guint main_level = 0);
protected:
  static gboolean gtk_callback(gpointer data);
};
class KeySnooperSig
{
public:
  typedef sigc::slot<int, Widget*, GdkEventKey*> SlotType;
  sigc::connection connect(const SlotType& slot);
protected:
  static int gtk_callback(GtkWidget* widget, GdkEventKey* event, gpointer data);
};
class Main : public sigc::trackable
{
public:
  Main(int& argc, char**& argv, Glib::OptionContext& option_context);
  Main(int* argc, char*** argv, bool set_locale = true);
  Main(int& argc, char**& argv, bool set_locale = true);
  virtual ~Main();
  static Gtk::Main* instance();
  static void run();
  static void run(Window& window);
  static void quit();
  static guint level();
  static void add_gtk_option_group(Glib::OptionContext& option_context, bool open_default_display = true);
  static bool iteration(bool blocking = true);
  static bool events_pending();
  static RunSig& signal_run();
  static QuitSig& signal_quit();
  static KeySnooperSig& signal_key_snooper();
  static void init_gtkmm_internals();
protected:
  Main();
  void init(int* argc, char*** argv, bool set_locale);
  virtual void run_impl();
  virtual void quit_impl();
  virtual guint level_impl();
  virtual bool iteration_impl(bool blocking);
  virtual bool events_pending_impl();
  virtual void on_window_hide();
  static RunSig signal_run_;
  static QuitSig signal_quit_;
  static KeySnooperSig signal_key_snooper_;
private:
  static Main* instance_;
};
}
typedef struct _GtkMenuBar GtkMenuBar;
typedef struct _GtkMenuBarClass GtkMenuBarClass;
namespace Gtk
{ class MenuBar_Class; }
namespace Gtk
{
class MenuBar : public MenuShell
{
  public:
  typedef MenuBar CppObjectType;
  typedef MenuBar_Class CppClassType;
  typedef GtkMenuBar BaseObjectType;
  typedef GtkMenuBarClass BaseClassType;
  virtual ~MenuBar();
private:
  friend class MenuBar_Class;
  static CppClassType menubar_class_;
  MenuBar(const MenuBar&);
  MenuBar& operator=(const MenuBar&);
protected:
  explicit MenuBar(const Glib::ConstructParams& construct_params);
  explicit MenuBar(GtkMenuBar* castitem);
public:
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkMenuBar* gobj() { return reinterpret_cast<GtkMenuBar*>(gobject_); }
  const GtkMenuBar* gobj() const { return reinterpret_cast<GtkMenuBar*>(gobject_); }
public:
protected:
private:
public:
  MenuBar();
private:
  void init_accels_handler_(void);
};
}
namespace Glib
{
  Gtk::MenuBar* wrap(GtkMenuBar* object, bool take_copy = false);
}
typedef struct _GtkMessageDialog GtkMessageDialog;
typedef struct _GtkMessageDialogClass GtkMessageDialogClass;
namespace Gtk
{ class MessageDialog_Class; }
namespace Gtk
{
enum MessageType
{
  MESSAGE_INFO,
  MESSAGE_WARNING,
  MESSAGE_QUESTION,
  MESSAGE_ERROR,
  MESSAGE_OTHER
};
}
namespace Glib
{
template <>
class Value<Gtk::MessageType> : public Glib::Value_Enum<Gtk::MessageType>
{
public:
  static GType value_type() __attribute__((__const__));
};
}
namespace Gtk
{
enum ButtonsType
{
  BUTTONS_NONE,
  BUTTONS_OK,
  BUTTONS_CLOSE,
  BUTTONS_CANCEL,
  BUTTONS_YES_NO,
  BUTTONS_OK_CANCEL
};
}
namespace Glib
{
template <>
class Value<Gtk::ButtonsType> : public Glib::Value_Enum<Gtk::ButtonsType>
{
public:
  static GType value_type() __attribute__((__const__));
};
}
namespace Gtk
{
class MessageDialog : public Dialog
{
  public:
  typedef MessageDialog CppObjectType;
  typedef MessageDialog_Class CppClassType;
  typedef GtkMessageDialog BaseObjectType;
  typedef GtkMessageDialogClass BaseClassType;
  virtual ~MessageDialog();
private:
  friend class MessageDialog_Class;
  static CppClassType messagedialog_class_;
  MessageDialog(const MessageDialog&);
  MessageDialog& operator=(const MessageDialog&);
protected:
  explicit MessageDialog(const Glib::ConstructParams& construct_params);
  explicit MessageDialog(GtkMessageDialog* castitem);
public:
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkMessageDialog* gobj() { return reinterpret_cast<GtkMessageDialog*>(gobject_); }
  const GtkMessageDialog* gobj() const { return reinterpret_cast<GtkMessageDialog*>(gobject_); }
public:
protected:
private:
public:
  explicit MessageDialog(const Glib::ustring& message, bool use_markup = false, MessageType type = MESSAGE_INFO, ButtonsType buttons = BUTTONS_OK, bool modal = false);
  MessageDialog(Gtk::Window& parent, const Glib::ustring& message, bool use_markup = false, MessageType type = MESSAGE_INFO, ButtonsType buttons = BUTTONS_OK, bool modal = false);
  void set_image(Widget& image);
  void set_markup(const Glib::ustring& str);
  void set_message(const Glib::ustring& message, bool use_markup = false);
  void set_secondary_text(const Glib::ustring& text, bool use_markup = false);
  Glib::PropertyProxy<MessageType> property_message_type() ;
  Glib::PropertyProxy_ReadOnly<MessageType> property_message_type() const;
  Glib::PropertyProxy_ReadOnly<ButtonsType> property_buttons() const;
  Glib::PropertyProxy<Glib::ustring> property_text() ;
  Glib::PropertyProxy_ReadOnly<Glib::ustring> property_text() const;
  Glib::PropertyProxy<bool> property_use_markup() ;
  Glib::PropertyProxy_ReadOnly<bool> property_use_markup() const;
  Glib::PropertyProxy<Glib::ustring> property_secondary_text() ;
  Glib::PropertyProxy_ReadOnly<Glib::ustring> property_secondary_text() const;
  Glib::PropertyProxy<bool> property_secondary_use_markup() ;
  Glib::PropertyProxy_ReadOnly<bool> property_secondary_use_markup() const;
  Glib::PropertyProxy<Widget*> property_image() ;
  Glib::PropertyProxy_ReadOnly<Widget*> property_image() const;
};
}
namespace Glib
{
  Gtk::MessageDialog* wrap(GtkMessageDialog* object, bool take_copy = false);
}
extern "C"
{
  typedef struct _GtkNotebookPage GtkNotebookPage;
}
typedef struct _GtkNotebook GtkNotebook;
typedef struct _GtkNotebookClass GtkNotebookClass;
namespace Gtk
{ class Notebook_Class; }
namespace Gtk
{
enum NotebookTab
{
  NOTEBOOK_TAB_FIRST,
  NOTEBOOK_TAB_LAST
};
}
namespace Glib
{
template <>
class Value<Gtk::NotebookTab> : public Glib::Value_Enum<Gtk::NotebookTab>
{
public:
  static GType value_type() __attribute__((__const__));
};
}
namespace Gtk
{
class Notebook;
namespace Notebook_Helpers
{
class Page;
class PageIterator
{
public:
  typedef std::bidirectional_iterator_tag iterator_category;
  typedef size_t size_type;
  typedef ptrdiff_t difference_type;
  typedef Page value_type;
  typedef const Page* pointer;
  typedef const Page& reference;
  PageIterator(Gtk::Notebook* parent, GList* node) : node_(node), parent_(parent) {}
  PageIterator() : node_(0), parent_(0) {}
  bool equal(const PageIterator& other) const;
  operator bool() const;
  PageIterator& operator++();
  const PageIterator operator++(int);
  PageIterator& operator--();
  const PageIterator operator--(int);
  inline reference operator*() const;
  inline pointer operator->() const;
protected:
  GList* node_;
  Gtk::Notebook* parent_;
  friend class Gtk::Notebook_Helpers::Page;
};
inline bool operator==(const PageIterator& lhs, const PageIterator& rhs)
  { return lhs.equal(rhs); }
inline bool operator!=(const PageIterator& lhs, const PageIterator& rhs)
  { return !lhs.equal(rhs); }
class Page : public PageIterator
{
protected:
  Page();
private:
  Page& operator=(const Page&);
public:
  int get_page_num() const;
  Widget* get_child() const;
  Widget* get_tab_label() const;
  void set_tab_label(Widget& tab_label);
  void set_tab_label_text(const Glib::ustring& tab_text);
  Glib::ustring get_tab_label_text() const;
  Widget* get_menu_label() const;
  void set_menu_label(Widget& menu_label);
  void set_menu_label_text(const Glib::ustring& menu_text);
  Glib::ustring get_menu_label_text() const;
  void query_tab_label_packing(bool& expand, bool& fill, PackType& pack_type);
  void set_tab_label_packing(bool expand, bool fill, PackType pack_type);
};
class PageList;
class Element
{
public:
  Element(Widget* child, Widget* tab, Widget* menu);
  Element(Widget& child, Widget& tab, Widget& menu);
  explicit Element(Widget& child);
protected:
  friend class PageList;
  Widget* child_;
  Widget* tab_;
  Widget* menu_;
};
typedef Element WidgetElem;
struct TabElem : public Element
{
  TabElem(Widget& child, Widget& tab);
  TabElem(Widget& child, const Glib::ustring& label, bool mnemonic = false);
};
struct MenuElem : public Element
{
  MenuElem(Widget& child, Widget& menu);
};
class PageList
{
public:
  PageList();
  explicit PageList(GtkNotebook* gparent);
  PageList(const PageList& src);
  PageList& operator=(const PageList& src);
  typedef Page value_type;
  typedef Page& reference;
  typedef const Page& const_reference;
  typedef PageIterator iterator;
  typedef Glib::List_ConstIterator<iterator> const_iterator;
  typedef Glib::List_ReverseIterator<iterator> reverse_iterator;
  typedef Glib::List_ConstIterator<reverse_iterator> const_reverse_iterator;
  typedef const Element element_type;
  typedef size_t difference_type;
  typedef size_t size_type;
  inline GtkNotebook* gparent()
    { return gparent_; }
  inline const GtkNotebook* gparent() const
    { return gparent_; }
  size_type size() const;
  size_type max_size() const;
  bool empty() const;
  inline iterator begin()
    { return begin_(); }
  inline iterator end()
    { return end_(); }
  inline const_iterator begin() const
    { return const_iterator(begin_()); }
  inline const_iterator end() const
    { return const_iterator(end_()); }
  inline reverse_iterator rbegin()
    { return reverse_iterator(end_()); }
  inline reverse_iterator rend()
    { return reverse_iterator(begin_()); }
  inline const_reverse_iterator rbegin() const
    { return const_reverse_iterator(reverse_iterator(end_())); }
  inline const_reverse_iterator rend() const
    { return const_reverse_iterator(reverse_iterator(begin_())); }
  value_type front() const;
  value_type back() const;
  value_type operator[](size_type l) const;
  iterator insert(iterator position, element_type& e);
  template <class InputIterator>
  inline void insert(iterator position, InputIterator first, InputIterator last)
  {
    for(;first != last; ++first)
      position = insert(position, *first);
  }
  inline void push_front(element_type& e)
    { insert(begin(), e); }
  inline void push_back(element_type& e)
    { insert(end(), e); }
  void erase(iterator start, iterator stop);
  iterator erase(iterator);
  void remove(const_reference child);
  void remove(Widget& w);
  void reorder(iterator loc, iterator page);
  iterator find(int num);
  iterator find(const_reference c);
  iterator find(Widget& w);
  iterator find(GtkNotebookPage* t);
  inline void pop_front()
    { erase(begin()); }
  inline void pop_back()
    { erase(--end()); }
  void clear();
protected:
  iterator begin_() const;
  iterator end_() const;
  GtkNotebook* gparent_;
};
}
class Notebook : public Container
{
  public:
  typedef Notebook CppObjectType;
  typedef Notebook_Class CppClassType;
  typedef GtkNotebook BaseObjectType;
  typedef GtkNotebookClass BaseClassType;
  virtual ~Notebook();
private:
  friend class Notebook_Class;
  static CppClassType notebook_class_;
  Notebook(const Notebook&);
  Notebook& operator=(const Notebook&);
protected:
  explicit Notebook(const Glib::ConstructParams& construct_params);
  explicit Notebook(GtkNotebook* castitem);
public:
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkNotebook* gobj() { return reinterpret_cast<GtkNotebook*>(gobject_); }
  const GtkNotebook* gobj() const { return reinterpret_cast<GtkNotebook*>(gobject_); }
public:
protected:
  virtual void on_switch_page(GtkNotebookPage* page, guint page_num);
private:
public:
  typedef Notebook_Helpers::PageList PageList;
  Notebook();
  int prepend_page(Widget& child, Widget& tab_label);
  int prepend_page(Widget& child);
  int prepend_page(Widget& child, const Glib::ustring& tab_label, bool use_mnemonic = false);
  int prepend_page(Widget& child, Widget& tab_label, Widget& menu_label);
  int prepend_page(Widget& child, const Glib::ustring& tab_label, const Glib::ustring& menu_label, bool use_mnemonic);
  int append_page(Widget& child, Widget& tab_label);
  int append_page(Widget& child);
  int append_page(Widget& child, const Glib::ustring& tab_label, bool use_mnemonic = false);
  int append_page(Widget& child, Widget& tab_label, Widget& menu_label);
  int append_page(Widget& child, const Glib::ustring& tab_label, const Glib::ustring& menu_label, bool use_mnemonic = false);
  int insert_page(Widget& child, Widget& tab_label, int position);
  int insert_page(Widget& child, int position);
  int insert_page(Widget& child, const Glib::ustring& tab_label, int position, bool use_mnemonic = false);
  int insert_page(Widget& child, Widget& tab_label, Widget& menu_label, int position);
  int insert_page(Widget& child, const Glib::ustring& tab_label, const Glib::ustring& menu_label, int position, bool use_mnemonic = false);
  void remove_page(int page_num = 0);
  void remove_page(Widget& child);
  typedef sigc::slot<Notebook*, Widget*, int, int> SlotWindowCreation;
  static void set_window_creation_hook(const SlotWindowCreation& slot);
  void set_group_id(int group_id);
  int get_group_id() const;
  void set_group(void* group);
  void* get_group();
  const void* get_group() const;
  int get_current_page() const;
  Widget* get_nth_page(int page_num);
  const Widget* get_nth_page(int page_num) const;
  int get_n_pages();
  int get_n_pages() const;
  int page_num(const Widget& child);
  int page_num(const Widget& child) const;
  void set_current_page(int page_num);
  void next_page();
  void prev_page();
  void set_show_border(bool show_border = true);
  bool get_show_border() const;
  void set_show_tabs(bool show_tabs = true);
  bool get_show_tabs() const;
  void set_tab_pos(PositionType pos);
  PositionType get_tab_pos() const;
  void set_scrollable(bool scrollable = true);
  bool get_scrollable() const;
  void popup_enable();
  void popup_disable();
  Widget* get_tab_label(Widget& child);
  const Widget* get_tab_label(Widget& child) const;
  void set_tab_label(Widget& child, Widget& tab_label);
  void set_tab_label_text(Widget& child, const Glib::ustring& tab_text);
  Glib::ustring get_tab_label_text(Widget& child) const;
  Widget* get_menu_label(Widget& child);
  const Widget* get_menu_label(Widget& child) const;
  void set_menu_label(Widget& child, Widget& menu_label);
  void set_menu_label_text(Widget& child, const Glib::ustring& menu_text);
  Glib::ustring get_menu_label_text(Widget& child) const;
  void query_tab_label_packing(Widget& child, bool& expand, bool& fill, PackType& pack_type);
  void set_tab_label_packing(Widget& child, bool expand, bool fill, PackType pack_type);
  void reorder_child(Widget& child, int position);
  bool get_tab_reorderable(Widget& child) const;
  void set_tab_reorderable(Widget& child, bool reorderable = true);
  bool get_tab_detachable(Widget& child) const;
  void set_tab_detachable(Widget& child, bool detachable = true);
  PageList::iterator get_current();
  PageList& pages();
  const PageList& pages() const;
  Glib::SignalProxy2< void,GtkNotebookPage*,guint > signal_switch_page();
  Glib::SignalProxy2< void,Widget*,guint > signal_page_reordered();
  Glib::SignalProxy2< void,Widget*,guint > signal_page_removed();
  Glib::SignalProxy2< void,Widget*,guint > signal_page_added();
  Glib::PropertyProxy<PositionType> property_tab_pos() ;
  Glib::PropertyProxy_ReadOnly<PositionType> property_tab_pos() const;
  Glib::PropertyProxy<bool> property_show_tabs() ;
  Glib::PropertyProxy_ReadOnly<bool> property_show_tabs() const;
  Glib::PropertyProxy<bool> property_show_border() ;
  Glib::PropertyProxy_ReadOnly<bool> property_show_border() const;
  Glib::PropertyProxy<bool> property_scrollable() ;
  Glib::PropertyProxy_ReadOnly<bool> property_scrollable() const;
  Glib::PropertyProxy_WriteOnly<guint> property_tab_border() ;
  Glib::PropertyProxy<guint> property_tab_hborder() ;
  Glib::PropertyProxy_ReadOnly<guint> property_tab_hborder() const;
  Glib::PropertyProxy<guint> property_tab_vborder() ;
  Glib::PropertyProxy_ReadOnly<guint> property_tab_vborder() const;
  Glib::PropertyProxy<int> property_page() ;
  Glib::PropertyProxy_ReadOnly<int> property_page() const;
  Glib::PropertyProxy<bool> property_enable_popup() ;
  Glib::PropertyProxy_ReadOnly<bool> property_enable_popup() const;
  Glib::PropertyProxy<bool> property_homogeneous() ;
  Glib::PropertyProxy_ReadOnly<bool> property_homogeneous() const;
protected:
  mutable PageList pages_proxy_;
};
namespace Notebook_Helpers
{
inline
PageIterator::reference PageIterator::operator*() const
{
  return static_cast<const Page&>(*this);
}
inline
PageIterator::pointer PageIterator::operator->() const
{
  return static_cast<const Page*>(this);
}
}
}
namespace Glib
{
  Gtk::Notebook* wrap(GtkNotebook* object, bool take_copy = false);
}
typedef struct _GtkPaned GtkPaned;
typedef struct _GtkPanedClass GtkPanedClass;
namespace Gtk
{ class Paned_Class; }
typedef struct _GtkHPaned GtkHPaned;
typedef struct _GtkHPanedClass GtkHPanedClass;
namespace Gtk
{ class HPaned_Class; }
typedef struct _GtkVPaned GtkVPaned;
typedef struct _GtkVPanedClass GtkVPanedClass;
namespace Gtk
{ class VPaned_Class; }
namespace Gtk
{
class Paned : public Container
{
  public:
  typedef Paned CppObjectType;
  typedef Paned_Class CppClassType;
  typedef GtkPaned BaseObjectType;
  typedef GtkPanedClass BaseClassType;
  virtual ~Paned();
private:
  friend class Paned_Class;
  static CppClassType paned_class_;
  Paned(const Paned&);
  Paned& operator=(const Paned&);
protected:
  explicit Paned(const Glib::ConstructParams& construct_params);
  explicit Paned(GtkPaned* castitem);
public:
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkPaned* gobj() { return reinterpret_cast<GtkPaned*>(gobject_); }
  const GtkPaned* gobj() const { return reinterpret_cast<GtkPaned*>(gobject_); }
public:
protected:
private:
public:
  Paned();
  void add1(Widget& child);
  void add2(Widget& child);
  void pack1(Widget& child, bool resize, bool shrink);
  void pack1(Widget& child, AttachOptions options = Gtk::EXPAND);
  void pack2(Widget& child, bool resize, bool shrink);
  void pack2(Widget& child, AttachOptions options = Gtk::EXPAND);
  int get_position() const;
  void set_position(int position);
  Widget* get_child1();
  const Widget* get_child1() const;
  Widget* get_child2();
  const Widget* get_child2() const;
  Glib::PropertyProxy<int> property_position() ;
  Glib::PropertyProxy_ReadOnly<int> property_position() const;
  Glib::PropertyProxy<bool> property_position_set() ;
  Glib::PropertyProxy_ReadOnly<bool> property_position_set() const;
  Glib::PropertyProxy_ReadOnly<int> property_min_position() const;
  Glib::PropertyProxy_ReadOnly<int> property_max_position() const;
};
class HPaned : public Paned
{
  public:
  typedef HPaned CppObjectType;
  typedef HPaned_Class CppClassType;
  typedef GtkHPaned BaseObjectType;
  typedef GtkHPanedClass BaseClassType;
  virtual ~HPaned();
private:
  friend class HPaned_Class;
  static CppClassType hpaned_class_;
  HPaned(const HPaned&);
  HPaned& operator=(const HPaned&);
protected:
  explicit HPaned(const Glib::ConstructParams& construct_params);
  explicit HPaned(GtkHPaned* castitem);
public:
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkHPaned* gobj() { return reinterpret_cast<GtkHPaned*>(gobject_); }
  const GtkHPaned* gobj() const { return reinterpret_cast<GtkHPaned*>(gobject_); }
public:
protected:
private:
public:
  HPaned();
};
class VPaned : public Paned
{
  public:
  typedef VPaned CppObjectType;
  typedef VPaned_Class CppClassType;
  typedef GtkVPaned BaseObjectType;
  typedef GtkVPanedClass BaseClassType;
  virtual ~VPaned();
private:
  friend class VPaned_Class;
  static CppClassType vpaned_class_;
  VPaned(const VPaned&);
  VPaned& operator=(const VPaned&);
protected:
  explicit VPaned(const Glib::ConstructParams& construct_params);
  explicit VPaned(GtkVPaned* castitem);
public:
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkVPaned* gobj() { return reinterpret_cast<GtkVPaned*>(gobject_); }
  const GtkVPaned* gobj() const { return reinterpret_cast<GtkVPaned*>(gobject_); }
public:
protected:
private:
public:
  VPaned();
};
}
namespace Glib
{
  Gtk::Paned* wrap(GtkPaned* object, bool take_copy = false);
}
namespace Glib
{
  Gtk::HPaned* wrap(GtkHPaned* object, bool take_copy = false);
}
namespace Glib
{
  Gtk::VPaned* wrap(GtkVPaned* object, bool take_copy = false);
}
extern "C" { typedef struct _GtkPaperSize GtkPaperSize; }
namespace Gtk
{
const Glib::ustring PAPER_NAME_A3 = "iso_a3";
const Glib::ustring PAPER_NAME_A4 = "iso_a4";
const Glib::ustring PAPER_NAME_A5 = "iso_a5";
const Glib::ustring PAPER_NAME_B5 = "iso_b5";
const Glib::ustring PAPER_NAME_LETTER = "na_letter";
const Glib::ustring PAPER_NAME_EXECUTIVE = "na_executive";
const Glib::ustring PAPER_NAME_LEGAL = "na_legal";
enum Unit
{
  UNIT_PIXEL,
  UNIT_POINTS,
  UNIT_INCH,
  UNIT_MM
};
}
namespace Glib
{
template <>
class Value<Gtk::Unit> : public Glib::Value_Enum<Gtk::Unit>
{
public:
  static GType value_type() __attribute__((__const__));
};
}
namespace Gtk
{
class PaperSize
{
  public:
  typedef PaperSize CppObjectType;
  typedef GtkPaperSize BaseObjectType;
  static GType get_type() __attribute__((__const__));
  PaperSize();
  explicit PaperSize(GtkPaperSize* gobject, bool make_a_copy = true);
  PaperSize(const PaperSize& other);
  PaperSize& operator=(const PaperSize& other);
  ~PaperSize();
  void swap(PaperSize& other);
  GtkPaperSize* gobj() { return gobject_; }
  const GtkPaperSize* gobj() const { return gobject_; }
  GtkPaperSize* gobj_copy() const;
protected:
  GtkPaperSize* gobject_;
private:
public:
  explicit PaperSize(const Glib::ustring& name = "");
  explicit PaperSize(const Glib::ustring& ppd_name, const Glib::ustring& ppd_display_name, double width, double height);
  explicit PaperSize(const Glib::ustring& name, const Glib::ustring& display_name, double width, double height, Unit unit);
  explicit PaperSize(const Glib::KeyFile& key_file, const Glib::ustring& group_name = Glib::ustring());
  bool equal(const PaperSize& other) const;
  operator bool() const;
  Glib::ustring get_name() const;
  Glib::ustring get_display_name() const;
  Glib::ustring get_ppd_name() const;
  double get_width(Unit unit) const;
  double get_height(Unit unit) const;
  bool is_custom() const;
  void set_size(double width, double height, Unit unit);
  double get_default_top_margin(Unit unit) const;
  double get_default_bottom_margin(Unit unit) const;
  double get_default_left_margin(Unit unit) const;
  double get_default_right_margin(Unit unit) const;
  static Glib::ustring get_default();
  void save_to_key_file(Glib::KeyFile& key_file, const Glib::ustring& group_name);
  void save_to_key_file(Glib::KeyFile& key_file);
};
inline bool operator==(const PaperSize& lhs, const PaperSize& rhs)
  { return lhs.equal(rhs); }
inline bool operator!=(const PaperSize& lhs, const PaperSize& rhs)
  { return !lhs.equal(rhs); }
}
namespace Gtk
{
inline void swap(PaperSize& lhs, PaperSize& rhs)
  { lhs.swap(rhs); }
}
namespace Glib
{
Gtk::PaperSize wrap(GtkPaperSize* object, bool take_copy = false);
template <>
class Value<Gtk::PaperSize> : public Glib::Value_Boxed<Gtk::PaperSize>
{};
}
typedef struct _GtkPageSetup GtkPageSetup;
typedef struct _GtkPageSetupClass GtkPageSetupClass;
namespace Gtk
{ class PageSetup_Class; }
namespace Gtk
{
class PageSetup : public Glib::Object
{
public:
  typedef PageSetup CppObjectType;
  typedef PageSetup_Class CppClassType;
  typedef GtkPageSetup BaseObjectType;
  typedef GtkPageSetupClass BaseClassType;
private: friend class PageSetup_Class;
  static CppClassType pagesetup_class_;
private:
  PageSetup(const PageSetup&);
  PageSetup& operator=(const PageSetup&);
protected:
  explicit PageSetup(const Glib::ConstructParams& construct_params);
  explicit PageSetup(GtkPageSetup* castitem);
public:
  virtual ~PageSetup();
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkPageSetup* gobj() { return reinterpret_cast<GtkPageSetup*>(gobject_); }
  const GtkPageSetup* gobj() const { return reinterpret_cast<GtkPageSetup*>(gobject_); }
  GtkPageSetup* gobj_copy();
private:
protected:
  PageSetup();
public:
  static Glib::RefPtr<PageSetup> create();
  PageOrientation get_orientation() const;
  void set_orientation(PageOrientation orientation);
  PaperSize get_paper_size();
  const PaperSize get_paper_size() const;
  void set_paper_size(const PaperSize& paper_size);
  double get_top_margin(Unit unit) const;
  void set_top_margin(double margin, Unit unit);
  double get_bottom_margin(Unit unit) const;
  void set_bottom_margin(double margin, Unit unit);
  double get_left_margin(Unit unit) const;
  void set_left_margin(double margin, Unit unit);
  double get_right_margin(Unit unit) const;
  void set_right_margin(double margin, Unit unit);
  void set_paper_size_and_default_margins(const PaperSize& paper_size);
  double get_paper_width(Unit unit) const;
  double get_paper_height(Unit unit) const;
  double get_page_width(Unit unit) const;
  double get_page_height(Unit unit) const;
  bool save_to_file(const std::string& file_name) const;
  void save_to_key_file(Glib::KeyFile& key_file, const Glib::ustring& group_name);
  void save_to_key_file(Glib::KeyFile& key_file);
public:
public:
protected:
};
}
namespace Glib
{
  Glib::RefPtr<Gtk::PageSetup> wrap(GtkPageSetup* object, bool take_copy = false);
}
typedef struct _GtkPrintSettings GtkPrintSettings;
typedef struct _GtkPrintSettingsClass GtkPrintSettingsClass;
namespace Gtk
{ class PrintSettings_Class; }
namespace Gtk
{
enum PrintDuplex
{
  PRINT_DUPLEX_SIMPLEX,
  PRINT_DUPLEX_HORIZONTAL,
  PRINT_DUPLEX_VERTICAL
};
}
namespace Glib
{
template <>
class Value<Gtk::PrintDuplex> : public Glib::Value_Enum<Gtk::PrintDuplex>
{
public:
  static GType value_type() __attribute__((__const__));
};
}
namespace Gtk
{
enum PrintQuality
{
  PRINT_QUALITY_LOW,
  PRINT_QUALITY_NORMAL,
  PRINT_QUALITY_HIGH,
  PRINT_QUALITY_DRAFT
};
}
namespace Glib
{
template <>
class Value<Gtk::PrintQuality> : public Glib::Value_Enum<Gtk::PrintQuality>
{
public:
  static GType value_type() __attribute__((__const__));
};
}
namespace Gtk
{
enum PrintPages
{
  PRINT_PAGES_ALL,
  PRINT_PAGES_CURRENT,
  PRINT_PAGES_RANGES
};
}
namespace Glib
{
template <>
class Value<Gtk::PrintPages> : public Glib::Value_Enum<Gtk::PrintPages>
{
public:
  static GType value_type() __attribute__((__const__));
};
}
namespace Gtk
{
enum PageSet
{
  PAGE_SET_ALL,
  PAGE_SET_EVEN,
  PAGE_SET_ODD
};
}
namespace Glib
{
template <>
class Value<Gtk::PageSet> : public Glib::Value_Enum<Gtk::PageSet>
{
public:
  static GType value_type() __attribute__((__const__));
};
}
namespace Gtk
{
class PrintSettings : public Glib::Object
{
public:
  typedef PrintSettings CppObjectType;
  typedef PrintSettings_Class CppClassType;
  typedef GtkPrintSettings BaseObjectType;
  typedef GtkPrintSettingsClass BaseClassType;
private: friend class PrintSettings_Class;
  static CppClassType printsettings_class_;
private:
  PrintSettings(const PrintSettings&);
  PrintSettings& operator=(const PrintSettings&);
protected:
  explicit PrintSettings(const Glib::ConstructParams& construct_params);
  explicit PrintSettings(GtkPrintSettings* castitem);
public:
  virtual ~PrintSettings();
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkPrintSettings* gobj() { return reinterpret_cast<GtkPrintSettings*>(gobject_); }
  const GtkPrintSettings* gobj() const { return reinterpret_cast<GtkPrintSettings*>(gobject_); }
  GtkPrintSettings* gobj_copy();
private:
protected:
  PrintSettings();
public:
  static Glib::RefPtr<PrintSettings> create();
  class Keys
  {
  public:
    static const Glib::ustring PRINTER;
    static const Glib::ustring ORIENTATION;
    static const Glib::ustring PAPER_FORMAT;
    static const Glib::ustring PAPER_WIDTH;
    static const Glib::ustring PAPER_HEIGHT;
    static const Glib::ustring NUM_COPIES;
    static const Glib::ustring DEFAULT_SOURCE;
    static const Glib::ustring QUALITY;
    static const Glib::ustring RESOLUTION;
    static const Glib::ustring USE_COLOR;
    static const Glib::ustring DUPLEX;
    static const Glib::ustring COLLATE;
    static const Glib::ustring REVERSE;
    static const Glib::ustring MEDIA_TYPE;
    static const Glib::ustring DITHER;
    static const Glib::ustring SCALE;
    static const Glib::ustring PRINT_PAGES;
    static const Glib::ustring PAGE_RANGES;
    static const Glib::ustring PAGE_SET;
    static const Glib::ustring FINISHINGS;
    static const Glib::ustring NUMBER_UP;
    static const Glib::ustring OUTPUT_BIN;
    static const Glib::ustring OUTPUT_FILE_FORMAT;
    static const Glib::ustring OUTPUT_URI;
    static const Glib::ustring WIN32_DRIVER_VERSION;
    static const Glib::ustring WIN32_DRIVER_EXTRA;
  };
  bool save_to_file(const std::string& file_name) const;
  void save_to_key_file(Glib::KeyFile& key_file, const Glib::ustring& group_name) const;
  void save_to_key_file(Glib::KeyFile& key_file);
  bool has_key(const Glib::ustring& key) const;
  Glib::ustring get(const Glib::ustring& key) const;
  void set(const Glib::ustring& key, const Glib::ustring& value);
  void unset(const Glib::ustring& key);
  typedef sigc::slot<void, const Glib::ustring&, const Glib::ustring&> SlotForeach;
  void setting_foreach(const SlotForeach& slot);
  bool get_bool(const Glib::ustring& key) const;
  void set_bool(const Glib::ustring& key, bool value = true);
  double get_double(const Glib::ustring& key) const;
  double get_double_with_default(const Glib::ustring& key, double def) const;
  void set_double(const Glib::ustring& key, double value);
  double get_length(const Glib::ustring& key, Unit unit) const;
  void set_length(const Glib::ustring& key, double value, Unit unit);
  int get_int(const Glib::ustring& key) const;
  int get_int_with_default(const Glib::ustring& key, int def) const;
  void set_int(const Glib::ustring& key, int value);
  Glib::ustring get_printer() const;
  void set_printer(const Glib::ustring& name);
  PageOrientation get_orientation() const;
  void set_orientation(PageOrientation orientation);
  PaperSize get_paper_size();
  const PaperSize get_paper_size() const;
  void set_paper_size(const PaperSize& paper_size);
  double get_paper_width(Unit unit) const;
  void set_paper_width(double width, Unit unit);
  double get_paper_height(Unit unit) const;
  void set_paper_height(double height, Unit unit);
  bool get_use_color() const;
  void set_use_color(bool use_color = true);
  bool get_collate() const;
  void set_collate(bool collate = true);
  bool get_reverse() const;
  void set_reverse(bool reverse = true);
  PrintDuplex get_duplex() const;
  void set_duplex(PrintDuplex duplex);
  PrintQuality get_quality() const;
  void set_quality(PrintQuality quality);
  int get_n_copies() const;
  void set_n_copies(int num_copies);
  int get_number_up() const;
  void set_number_up(int number_up);
  int get_resolution() const;
  void set_resolution(int resolution);
  double get_scale() const;
  void set_scale(double scale);
  PrintPages get_print_pages() const;
  void set_print_pages(PrintPages print_pages);
  class PageRange
  {
  public:
    PageRange();
    PageRange(int start, int end);
    int start;
    int end;
  };
  Glib::ArrayHandle<PageRange> get_page_ranges() const;
  void set_page_ranges(const Glib::ArrayHandle<PageRange>& page_ranges);
  PageSet get_page_set() const;
  void set_page_set(PageSet page_set);
  Glib::ustring get_default_source() const;
  void set_default_source(const Glib::ustring& default_source);
  Glib::ustring get_media_type() const;
  void set_media_type(const Glib::ustring& media_type);
  Glib::ustring get_dither() const;
  void set_dither(const Glib::ustring& dither);
  Glib::ustring get_finishings() const;
  void set_finishings(const Glib::ustring& finishings);
  Glib::ustring get_output_bin() const;
  void set_output_bin(const Glib::ustring& output_bin);
public:
public:
protected:
};
}
namespace Glib
{
  Glib::RefPtr<Gtk::PrintSettings> wrap(GtkPrintSettings* object, bool take_copy = false);
}
typedef struct _GtkPageSetupUnixDialog GtkPageSetupUnixDialog;
typedef struct _GtkPageSetupUnixDialogClass GtkPageSetupUnixDialogClass;
namespace Gtk
{ class PageSetupUnixDialog_Class; }
namespace Gtk
{
class PageSetupUnixDialog : public Dialog
{
  public:
  typedef PageSetupUnixDialog CppObjectType;
  typedef PageSetupUnixDialog_Class CppClassType;
  typedef GtkPageSetupUnixDialog BaseObjectType;
  typedef GtkPageSetupUnixDialogClass BaseClassType;
  virtual ~PageSetupUnixDialog();
private:
  friend class PageSetupUnixDialog_Class;
  static CppClassType pagesetupunixdialog_class_;
  PageSetupUnixDialog(const PageSetupUnixDialog&);
  PageSetupUnixDialog& operator=(const PageSetupUnixDialog&);
protected:
  explicit PageSetupUnixDialog(const Glib::ConstructParams& construct_params);
  explicit PageSetupUnixDialog(GtkPageSetupUnixDialog* castitem);
public:
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkPageSetupUnixDialog* gobj() { return reinterpret_cast<GtkPageSetupUnixDialog*>(gobject_); }
  const GtkPageSetupUnixDialog* gobj() const { return reinterpret_cast<GtkPageSetupUnixDialog*>(gobject_); }
public:
protected:
private:
public:
  explicit PageSetupUnixDialog(Gtk::Window& parent, const Glib::ustring& title);
  explicit PageSetupUnixDialog(const Glib::ustring& title);
  void set_page_setup(const Glib::RefPtr<PageSetup>& page_setup);
  Glib::RefPtr<PageSetup> get_page_setup();
  Glib::RefPtr<const PageSetup> get_page_setup() const;
  void set_print_settings(const Glib::RefPtr<PrintSettings>& print_settings);
  Glib::RefPtr<PrintSettings> get_print_settings();
  Glib::RefPtr<const PrintSettings> get_print_settings() const;
};
}
namespace Glib
{
  Gtk::PageSetupUnixDialog* wrap(GtkPageSetupUnixDialog* object, bool take_copy = false);
}
typedef struct _GtkPrintContext GtkPrintContext;
typedef struct _GtkPrintContextClass GtkPrintContextClass;
namespace Gtk
{ class PrintContext_Class; }
namespace Gtk
{
class PrintContext : public Glib::Object
{
public:
  typedef PrintContext CppObjectType;
  typedef PrintContext_Class CppClassType;
  typedef GtkPrintContext BaseObjectType;
  typedef GtkPrintContextClass BaseClassType;
private: friend class PrintContext_Class;
  static CppClassType printcontext_class_;
private:
  PrintContext(const PrintContext&);
  PrintContext& operator=(const PrintContext&);
protected:
  explicit PrintContext(const Glib::ConstructParams& construct_params);
  explicit PrintContext(GtkPrintContext* castitem);
public:
  virtual ~PrintContext();
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkPrintContext* gobj() { return reinterpret_cast<GtkPrintContext*>(gobject_); }
  const GtkPrintContext* gobj() const { return reinterpret_cast<GtkPrintContext*>(gobject_); }
  GtkPrintContext* gobj_copy();
private:
public:
  Cairo::RefPtr<Cairo::Context> get_cairo_context();
  Cairo::RefPtr<const Cairo::Context> get_cairo_context() const;
  Glib::RefPtr<PageSetup> get_page_setup();
  Glib::RefPtr<const PageSetup> get_page_setup() const;
  double get_width() const;
  double get_height() const;
  double get_dpi_x() const;
  double get_dpi_y() const;
  Glib::RefPtr<Pango::FontMap> get_pango_fontmap();
  Glib::RefPtr<const Pango::FontMap> get_pango_fontmap() const;
  Glib::RefPtr<Pango::Context> create_pango_context();
  Glib::RefPtr<Pango::Layout> create_pango_layout();
  void set_cairo_context(const Cairo::RefPtr<Cairo::Context>& cr, double dpi_x, double dpi_y);
public:
public:
protected:
};
}
namespace Glib
{
  Glib::RefPtr<Gtk::PrintContext> wrap(GtkPrintContext* object, bool take_copy = false);
}
typedef struct _GtkPrinter GtkPrinter;
typedef struct _GtkPrinterClass GtkPrinterClass;
namespace Gtk
{ class Printer_Class; }
namespace Gtk
{
enum PrintCapabilities
{
  PRINT_CAPABILITY_PAGE_SET = 1 << 0,
  PRINT_CAPABILITY_COPIES = 1 << 1,
  PRINT_CAPABILITY_COLLATE = 1 << 2,
  PRINT_CAPABILITY_REVERSE = 1 << 3,
  PRINT_CAPABILITY_SCALE = 1 << 4,
  PRINT_CAPABILITY_GENERATE_PDF = 1 << 5,
  PRINT_CAPABILITY_GENERATE_PS = 1 << 6,
  PRINT_CAPABILITY_PREVIEW = 1 << 7,
  PRINT_CAPABILITY_NUMBER_UP = 1 << 8
};
inline PrintCapabilities operator|(PrintCapabilities lhs, PrintCapabilities rhs)
  { return static_cast<PrintCapabilities>(static_cast<unsigned>(lhs) | static_cast<unsigned>(rhs)); }
inline PrintCapabilities operator&(PrintCapabilities lhs, PrintCapabilities rhs)
  { return static_cast<PrintCapabilities>(static_cast<unsigned>(lhs) & static_cast<unsigned>(rhs)); }
inline PrintCapabilities operator^(PrintCapabilities lhs, PrintCapabilities rhs)
  { return static_cast<PrintCapabilities>(static_cast<unsigned>(lhs) ^ static_cast<unsigned>(rhs)); }
inline PrintCapabilities operator~(PrintCapabilities flags)
  { return static_cast<PrintCapabilities>(~static_cast<unsigned>(flags)); }
inline PrintCapabilities& operator|=(PrintCapabilities& lhs, PrintCapabilities rhs)
  { return (lhs = static_cast<PrintCapabilities>(static_cast<unsigned>(lhs) | static_cast<unsigned>(rhs))); }
inline PrintCapabilities& operator&=(PrintCapabilities& lhs, PrintCapabilities rhs)
  { return (lhs = static_cast<PrintCapabilities>(static_cast<unsigned>(lhs) & static_cast<unsigned>(rhs))); }
inline PrintCapabilities& operator^=(PrintCapabilities& lhs, PrintCapabilities rhs)
  { return (lhs = static_cast<PrintCapabilities>(static_cast<unsigned>(lhs) ^ static_cast<unsigned>(rhs))); }
}
namespace Glib
{
template <>
class Value<Gtk::PrintCapabilities> : public Glib::Value_Flags<Gtk::PrintCapabilities>
{
public:
  static GType value_type() __attribute__((__const__));
};
}
namespace Gtk
{
class Printer : public Glib::Object
{
public:
  typedef Printer CppObjectType;
  typedef Printer_Class CppClassType;
  typedef GtkPrinter BaseObjectType;
  typedef GtkPrinterClass BaseClassType;
private: friend class Printer_Class;
  static CppClassType printer_class_;
private:
  Printer(const Printer&);
  Printer& operator=(const Printer&);
protected:
  explicit Printer(const Glib::ConstructParams& construct_params);
  explicit Printer(GtkPrinter* castitem);
public:
  virtual ~Printer();
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkPrinter* gobj() { return reinterpret_cast<GtkPrinter*>(gobject_); }
  const GtkPrinter* gobj() const { return reinterpret_cast<GtkPrinter*>(gobject_); }
  GtkPrinter* gobj_copy();
private:
public:
  bool equal(const Glib::RefPtr<Printer>& other) const;
  Glib::ustring get_name() const;
  Glib::ustring get_state_message() const;
  Glib::ustring get_description() const;
  Glib::ustring get_location() const;
  Glib::ustring get_icon_name() const;
  int get_job_count() const;
  bool is_active() const;
  bool is_virtual() const;
  bool is_default() const;
  bool accepts_pdf() const;
  bool accepts_ps() const;
  Glib::ListHandle< Glib::RefPtr<PageSetup> > list_papers();
  Glib::ListHandle< Glib::RefPtr<const PageSetup> > list_papers() const;
  bool has_details() const;
  void request_details();
  PrintCapabilities get_capabilities() const;
  Glib::SignalProxy1< void,bool > signal_details_acquired();
  Glib::PropertyProxy_ReadOnly<Glib::ustring> property_name() const;
  Glib::PropertyProxy_ReadOnly<bool> property_is_virtual() const;
  Glib::PropertyProxy_ReadOnly<Glib::ustring> property_state_message() const;
  Glib::PropertyProxy_ReadOnly<Glib::ustring> property_location() const;
  Glib::PropertyProxy_ReadOnly<Glib::ustring> property_icon_name() const;
  Glib::PropertyProxy_ReadOnly<int> property_job_count() const;
  Glib::PropertyProxy_ReadOnly<bool> property_accepts_pdf() const;
  Glib::PropertyProxy_ReadOnly<bool> property_accepts_ps() const;
public:
public:
protected:
  virtual void on_details_acquired(bool success);
};
inline bool operator==(const Glib::RefPtr<Printer>& lhs, const Glib::RefPtr<Printer>& rhs)
  { return lhs->equal(rhs); }
inline bool operator!=(const Glib::RefPtr<Printer>& lhs, const Glib::RefPtr<Printer>& rhs)
  { return !lhs->equal(rhs); }
typedef sigc::slot< bool, const Glib::RefPtr<Printer>& > SlotPrinterEnumerator;
void enumerate_printers(const SlotPrinterEnumerator& slot, bool wait = true);
}
namespace Glib
{
  Glib::RefPtr<Gtk::Printer> wrap(GtkPrinter* object, bool take_copy = false);
}
extern "C" {
typedef struct _GtkPaperSize GtkPaperSize;
GType gtk_paper_size_get_type (void) __attribute__((__const__));
GtkPaperSize *gtk_paper_size_new (const gchar *name);
GtkPaperSize *gtk_paper_size_new_from_ppd (const gchar *ppd_name,
        const gchar *ppd_display_name,
        gdouble width,
        gdouble height);
GtkPaperSize *gtk_paper_size_new_custom (const gchar *name,
        const gchar *display_name,
        gdouble width,
        gdouble height,
        GtkUnit unit);
GtkPaperSize *gtk_paper_size_copy (GtkPaperSize *other);
void gtk_paper_size_free (GtkPaperSize *size);
gboolean gtk_paper_size_is_equal (GtkPaperSize *size1,
        GtkPaperSize *size2);
GList *gtk_paper_size_get_paper_sizes (gboolean include_custom);
const gchar *gtk_paper_size_get_name (GtkPaperSize *size);
const gchar *gtk_paper_size_get_display_name (GtkPaperSize *size);
const gchar *gtk_paper_size_get_ppd_name (GtkPaperSize *size);
gdouble gtk_paper_size_get_width (GtkPaperSize *size, GtkUnit unit);
gdouble gtk_paper_size_get_height (GtkPaperSize *size, GtkUnit unit);
gboolean gtk_paper_size_is_custom (GtkPaperSize *size);
void gtk_paper_size_set_size (GtkPaperSize *size,
                                                  gdouble width,
                                                  gdouble height,
                                                  GtkUnit unit);
gdouble gtk_paper_size_get_default_top_margin (GtkPaperSize *size,
        GtkUnit unit);
gdouble gtk_paper_size_get_default_bottom_margin (GtkPaperSize *size,
        GtkUnit unit);
gdouble gtk_paper_size_get_default_left_margin (GtkPaperSize *size,
        GtkUnit unit);
gdouble gtk_paper_size_get_default_right_margin (GtkPaperSize *size,
        GtkUnit unit);
const gchar *gtk_paper_size_get_default (void);
GtkPaperSize *gtk_paper_size_new_from_key_file (GKeyFile *key_file,
             const gchar *group_name,
             GError **error);
void gtk_paper_size_to_key_file (GtkPaperSize *size,
             GKeyFile *key_file,
             const gchar *group_name);
}
extern "C" {
typedef struct _GtkPageSetup GtkPageSetup;
GType gtk_page_setup_get_type (void) __attribute__((__const__));
GtkPageSetup * gtk_page_setup_new (void);
GtkPageSetup * gtk_page_setup_copy (GtkPageSetup *other);
GtkPageOrientation gtk_page_setup_get_orientation (GtkPageSetup *setup);
void gtk_page_setup_set_orientation (GtkPageSetup *setup,
           GtkPageOrientation orientation);
GtkPaperSize * gtk_page_setup_get_paper_size (GtkPageSetup *setup);
void gtk_page_setup_set_paper_size (GtkPageSetup *setup,
           GtkPaperSize *size);
gdouble gtk_page_setup_get_top_margin (GtkPageSetup *setup,
           GtkUnit unit);
void gtk_page_setup_set_top_margin (GtkPageSetup *setup,
           gdouble margin,
           GtkUnit unit);
gdouble gtk_page_setup_get_bottom_margin (GtkPageSetup *setup,
           GtkUnit unit);
void gtk_page_setup_set_bottom_margin (GtkPageSetup *setup,
           gdouble margin,
           GtkUnit unit);
gdouble gtk_page_setup_get_left_margin (GtkPageSetup *setup,
           GtkUnit unit);
void gtk_page_setup_set_left_margin (GtkPageSetup *setup,
           gdouble margin,
           GtkUnit unit);
gdouble gtk_page_setup_get_right_margin (GtkPageSetup *setup,
           GtkUnit unit);
void gtk_page_setup_set_right_margin (GtkPageSetup *setup,
           gdouble margin,
           GtkUnit unit);
void gtk_page_setup_set_paper_size_and_default_margins (GtkPageSetup *setup,
       GtkPaperSize *size);
gdouble gtk_page_setup_get_paper_width (GtkPageSetup *setup,
           GtkUnit unit);
gdouble gtk_page_setup_get_paper_height (GtkPageSetup *setup,
           GtkUnit unit);
gdouble gtk_page_setup_get_page_width (GtkPageSetup *setup,
           GtkUnit unit);
gdouble gtk_page_setup_get_page_height (GtkPageSetup *setup,
           GtkUnit unit);
GtkPageSetup *gtk_page_setup_new_from_file (const gchar *file_name,
           GError **error);
gboolean gtk_page_setup_to_file (GtkPageSetup *setup,
           const char *file_name,
           GError **error);
GtkPageSetup *gtk_page_setup_new_from_key_file (GKeyFile *key_file,
           const gchar *group_name,
           GError **error);
void gtk_page_setup_to_key_file (GtkPageSetup *setup,
           GKeyFile *key_file,
           const gchar *group_name);
}
extern "C" {
typedef struct _GtkPrintContext GtkPrintContext;
GType gtk_print_context_get_type (void) __attribute__((__const__));
cairo_t *gtk_print_context_get_cairo_context (GtkPrintContext *context);
GtkPageSetup *gtk_print_context_get_page_setup (GtkPrintContext *context);
gdouble gtk_print_context_get_width (GtkPrintContext *context);
gdouble gtk_print_context_get_height (GtkPrintContext *context);
gdouble gtk_print_context_get_dpi_x (GtkPrintContext *context);
gdouble gtk_print_context_get_dpi_y (GtkPrintContext *context);
PangoFontMap *gtk_print_context_get_pango_fontmap (GtkPrintContext *context);
PangoContext *gtk_print_context_create_pango_context (GtkPrintContext *context);
PangoLayout *gtk_print_context_create_pango_layout (GtkPrintContext *context);
void gtk_print_context_set_cairo_context (GtkPrintContext *context,
            cairo_t *cr,
            double dpi_x,
            double dpi_y);
}
extern "C" {
typedef struct _GtkPrintOperationPreview GtkPrintOperationPreview;
typedef struct _GtkPrintOperationPreviewIface GtkPrintOperationPreviewIface;
struct _GtkPrintOperationPreviewIface
{
  GTypeInterface g_iface;
  void (*ready) (GtkPrintOperationPreview *preview,
           GtkPrintContext *context);
  void (*got_page_size) (GtkPrintOperationPreview *preview,
           GtkPrintContext *context,
           GtkPageSetup *page_setup);
  void (*render_page) (GtkPrintOperationPreview *preview,
           gint page_nr);
  gboolean (*is_selected) (GtkPrintOperationPreview *preview,
           gint page_nr);
  void (*end_preview) (GtkPrintOperationPreview *preview);
  void (*_gtk_reserved1) (void);
  void (*_gtk_reserved2) (void);
  void (*_gtk_reserved3) (void);
  void (*_gtk_reserved4) (void);
  void (*_gtk_reserved5) (void);
  void (*_gtk_reserved6) (void);
  void (*_gtk_reserved7) (void);
};
GType gtk_print_operation_preview_get_type (void) __attribute__((__const__));
void gtk_print_operation_preview_render_page (GtkPrintOperationPreview *preview,
        gint page_nr);
void gtk_print_operation_preview_end_preview (GtkPrintOperationPreview *preview);
gboolean gtk_print_operation_preview_is_selected (GtkPrintOperationPreview *preview,
        gint page_nr);
}
typedef struct _GtkPrintOperationPreview GtkPrintOperationPreview;
typedef struct _GtkPrintOperationPreviewClass GtkPrintOperationPreviewClass;
namespace Gtk
{ class PrintOperationPreview_Class; }
namespace Gtk
{
class PrintOperationPreview : public Glib::Interface
{
public:
  typedef PrintOperationPreview CppObjectType;
  typedef PrintOperationPreview_Class CppClassType;
  typedef GtkPrintOperationPreview BaseObjectType;
  typedef GtkPrintOperationPreviewIface BaseClassType;
private:
  friend class PrintOperationPreview_Class;
  static CppClassType printoperationpreview_class_;
  PrintOperationPreview(const PrintOperationPreview&);
  PrintOperationPreview& operator=(const PrintOperationPreview&);
protected:
  PrintOperationPreview();
public:
  explicit PrintOperationPreview(GtkPrintOperationPreview* castitem);
protected:
public:
  virtual ~PrintOperationPreview();
  static void add_interface(GType gtype_implementer);
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkPrintOperationPreview* gobj() { return reinterpret_cast<GtkPrintOperationPreview*>(gobject_); }
  const GtkPrintOperationPreview* gobj() const { return reinterpret_cast<GtkPrintOperationPreview*>(gobject_); }
private:
public:
  void render_page(int page_nr);
  void end_preview();
  bool is_selected(int page_nr) const;
  virtual void render_page_vfunc(int page_nr);
  virtual void end_preview_vfunc();
  virtual bool is_selected_vfunc(int page_nr) const;
  Glib::SignalProxy1< void,const Glib::RefPtr<PrintContext>& > signal_ready();
  Glib::SignalProxy2< void,const Glib::RefPtr<PrintContext>&,const Glib::RefPtr<PageSetup>& > signal_got_page_size();
public:
public:
protected:
  virtual void on_ready(const Glib::RefPtr<PrintContext>& context);
  virtual void on_got_page_size(const Glib::RefPtr<PrintContext>& context, const Glib::RefPtr<PageSetup>& page_setup);
};
}
namespace Glib
{
  Glib::RefPtr<Gtk::PrintOperationPreview> wrap(GtkPrintOperationPreview* object, bool take_copy = false);
}
typedef struct _GtkPrintOperation GtkPrintOperation;
typedef struct _GtkPrintOperationClass GtkPrintOperationClass;
namespace Gtk
{ class PrintOperation_Class; }
namespace Gtk
{
enum PrintStatus
{
  PRINT_STATUS_INITIAL,
  PRINT_STATUS_PREPARING,
  PRINT_STATUS_GENERATING_DATA,
  PRINT_STATUS_SENDING_DATA,
  PRINT_STATUS_PENDING,
  PRINT_STATUS_PENDING_ISSUE,
  PRINT_STATUS_PRINTING,
  PRINT_STATUS_FINISHED,
  PRINT_STATUS_FINISHED_ABORTED
};
}
namespace Glib
{
template <>
class Value<Gtk::PrintStatus> : public Glib::Value_Enum<Gtk::PrintStatus>
{
public:
  static GType value_type() __attribute__((__const__));
};
}
namespace Gtk
{
enum PrintOperationResult
{
  PRINT_OPERATION_RESULT_ERROR,
  PRINT_OPERATION_RESULT_APPLY,
  PRINT_OPERATION_RESULT_CANCEL,
  PRINT_OPERATION_RESULT_IN_PROGRESS
};
}
namespace Glib
{
template <>
class Value<Gtk::PrintOperationResult> : public Glib::Value_Enum<Gtk::PrintOperationResult>
{
public:
  static GType value_type() __attribute__((__const__));
};
}
namespace Gtk
{
enum PrintOperationAction
{
  PRINT_OPERATION_ACTION_PRINT_DIALOG,
  PRINT_OPERATION_ACTION_PRINT,
  PRINT_OPERATION_ACTION_PREVIEW,
  PRINT_OPERATION_ACTION_EXPORT
};
}
namespace Glib
{
template <>
class Value<Gtk::PrintOperationAction> : public Glib::Value_Enum<Gtk::PrintOperationAction>
{
public:
  static GType value_type() __attribute__((__const__));
};
}
namespace Gtk
{
class PrintError : public Glib::Error
{
public:
  enum Code
  {
    GENERAL,
    INTERNAL_ERROR,
    NOMEM,
    INVALID_FILE
  };
  PrintError(Code error_code, const Glib::ustring& error_message);
  explicit PrintError(GError* gobject);
  Code code() const;
private:
  static void throw_func(GError* gobject);
  friend void wrap_init();
};
}
namespace Glib
{
template <>
class Value<Gtk::PrintError::Code> : public Glib::Value_Enum<Gtk::PrintError::Code>
{
public:
  static GType value_type() __attribute__((__const__));
};
}
namespace Gtk
{
class PrintOperation :
  public Glib::Object,
  public PrintOperationPreview
{
public:
  typedef PrintOperation CppObjectType;
  typedef PrintOperation_Class CppClassType;
  typedef GtkPrintOperation BaseObjectType;
  typedef GtkPrintOperationClass BaseClassType;
private: friend class PrintOperation_Class;
  static CppClassType printoperation_class_;
private:
  PrintOperation(const PrintOperation&);
  PrintOperation& operator=(const PrintOperation&);
protected:
  explicit PrintOperation(const Glib::ConstructParams& construct_params);
  explicit PrintOperation(GtkPrintOperation* castitem);
public:
  virtual ~PrintOperation();
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkPrintOperation* gobj() { return reinterpret_cast<GtkPrintOperation*>(gobject_); }
  const GtkPrintOperation* gobj() const { return reinterpret_cast<GtkPrintOperation*>(gobject_); }
  GtkPrintOperation* gobj_copy();
private:
protected:
  PrintOperation();
public:
  static Glib::RefPtr<PrintOperation> create();
  void set_default_page_setup(const Glib::RefPtr<PageSetup>& default_page_setup);
  Glib::RefPtr<PageSetup> get_default_page_setup() const;
  void set_print_settings(const Glib::RefPtr<PrintSettings>& print_settings);
  Glib::RefPtr<PrintSettings> get_print_settings() const;
  void set_job_name(const Glib::ustring& job_name);
  void set_n_pages(int n_pages);
  void set_current_page(int current_page);
  void set_use_full_page(bool use_full_page = true);
  void set_unit(Unit unit);
  void set_export_filename(const std::string& filename);
  void set_track_print_status(bool track_status = true);
  void set_show_progress (bool show_progress = true);
  void set_allow_async(bool allow_async = true);
  void set_custom_tab_label(const Glib::ustring& label);
  PrintOperationResult run(PrintOperationAction action = PRINT_OPERATION_ACTION_PRINT_DIALOG);
  PrintOperationResult run(PrintOperationAction action, Window& parent);
  PrintStatus get_status() const;
  Glib::ustring get_status_string() const;
  void cancel();
  bool is_finished() const;
  Glib::SignalProxy1< void,PrintOperationResult > signal_done();
  Glib::SignalProxy1< void,const Glib::RefPtr<PrintContext>& > signal_begin_print();
  Glib::SignalProxy1< bool,const Glib::RefPtr<PrintContext>& > signal_paginate();
  Glib::SignalProxy3< void,const Glib::RefPtr<PrintContext>&,int,const Glib::RefPtr<PageSetup>& > signal_request_page_setup();
  Glib::SignalProxy2< void,const Glib::RefPtr<PrintContext>&,int > signal_draw_page();
  Glib::SignalProxy1< void,const Glib::RefPtr<PrintContext>& > signal_end_print();
  Glib::SignalProxy0< void > signal_status_changed();
  Glib::SignalProxy0< Widget* > signal_create_custom_widget();
  Glib::SignalProxy1< void,Widget* > signal_custom_widget_apply();
  Glib::SignalProxy3< bool,const Glib::RefPtr<PrintOperationPreview>&,const Glib::RefPtr<PrintContext>&,Window* > signal_preview();
  Glib::PropertyProxy< Glib::RefPtr<PageSetup> > property_default_page_setup() ;
  Glib::PropertyProxy_ReadOnly< Glib::RefPtr<PageSetup> > property_default_page_setup() const;
  Glib::PropertyProxy< Glib::RefPtr<PrintSettings> > property_print_settings() ;
  Glib::PropertyProxy_ReadOnly< Glib::RefPtr<PrintSettings> > property_print_settings() const;
  Glib::PropertyProxy<Glib::ustring> property_job_name() ;
  Glib::PropertyProxy_ReadOnly<Glib::ustring> property_job_name() const;
  Glib::PropertyProxy<int> property_n_pages() ;
  Glib::PropertyProxy_ReadOnly<int> property_n_pages() const;
  Glib::PropertyProxy<int> property_current_page() ;
  Glib::PropertyProxy_ReadOnly<int> property_current_page() const;
  Glib::PropertyProxy<bool> property_use_full_page() ;
  Glib::PropertyProxy_ReadOnly<bool> property_use_full_page() const;
  Glib::PropertyProxy<Unit> property_unit() ;
  Glib::PropertyProxy_ReadOnly<Unit> property_unit() const;
  Glib::PropertyProxy<bool> property_show_progress() ;
  Glib::PropertyProxy_ReadOnly<bool> property_show_progress() const;
  Glib::PropertyProxy<bool> property_allow_async() ;
  Glib::PropertyProxy_ReadOnly<bool> property_allow_async() const;
  Glib::PropertyProxy<std::string> property_export_filename() ;
  Glib::PropertyProxy_ReadOnly<std::string> property_export_filename() const;
  Glib::PropertyProxy_ReadOnly<PrintStatus> property_status() const;
  Glib::PropertyProxy_ReadOnly<Glib::ustring> property_status_string() const;
  Glib::PropertyProxy<Glib::ustring> property_custom_tab_label() ;
  Glib::PropertyProxy_ReadOnly<Glib::ustring> property_custom_tab_label() const;
public:
public:
protected:
  virtual void on_done(PrintOperationResult result);
  virtual void on_begin_print(const Glib::RefPtr<PrintContext>& context);
  virtual bool on_paginate(const Glib::RefPtr<PrintContext>& context);
  virtual void on_request_page_setup(const Glib::RefPtr<PrintContext>& context, int page_no, const Glib::RefPtr<PageSetup>& setup);
  virtual void on_draw_page(const Glib::RefPtr<PrintContext>& context, int page_nr);
  virtual void on_end_print(const Glib::RefPtr<PrintContext>& context);
  virtual void on_status_changed();
  virtual Widget* on_create_custom_widget();
  virtual void on_custom_widget_apply(Widget* widget);
  virtual bool on_preview(const Glib::RefPtr<PrintOperationPreview>& preview, const Glib::RefPtr<PrintContext>& context, Window* parent);
};
  Glib::RefPtr<PageSetup> run_page_setup_dialog(Window& parent,
                                                const Glib::RefPtr<const PageSetup>& page_setup,
                                                const Glib::RefPtr<const PrintSettings>& print_settings);
  typedef sigc::slot< void, const Glib::RefPtr<PageSetup>& > SlotPrintSetupDone;
  void run_page_setup_dialog_async(Window& parent,
                                   const Glib::RefPtr<const PageSetup>& page_setup,
                                   const Glib::RefPtr<const PrintSettings>& print_settings,
                                   const SlotPrintSetupDone& slot);
}
namespace Glib
{
  Glib::RefPtr<Gtk::PrintOperation> wrap(GtkPrintOperation* object, bool take_copy = false);
}
typedef struct _GtkPrintJob GtkPrintJob;
typedef struct _GtkPrintJobClass GtkPrintJobClass;
namespace Gtk
{ class PrintJob_Class; }
namespace Gtk
{
class PrintJob : public Glib::Object
{
public:
  typedef PrintJob CppObjectType;
  typedef PrintJob_Class CppClassType;
  typedef GtkPrintJob BaseObjectType;
  typedef GtkPrintJobClass BaseClassType;
private: friend class PrintJob_Class;
  static CppClassType printjob_class_;
private:
  PrintJob(const PrintJob&);
  PrintJob& operator=(const PrintJob&);
protected:
  explicit PrintJob(const Glib::ConstructParams& construct_params);
  explicit PrintJob(GtkPrintJob* castitem);
public:
  virtual ~PrintJob();
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkPrintJob* gobj() { return reinterpret_cast<GtkPrintJob*>(gobject_); }
  const GtkPrintJob* gobj() const { return reinterpret_cast<GtkPrintJob*>(gobject_); }
  GtkPrintJob* gobj_copy();
private:
protected:
  explicit PrintJob(const Glib::ustring& title, const Glib::RefPtr<Printer>& printer, const Glib::RefPtr<PrintSettings>& settings, const Glib::RefPtr<PageSetup>& page_setup);
public:
  static Glib::RefPtr<PrintJob> create(const Glib::ustring& title, const Glib::RefPtr<Printer>& printer, const Glib::RefPtr<PrintSettings>& settings, const Glib::RefPtr<PageSetup>& page_setup);
  Glib::RefPtr<PrintSettings> get_settings();
  Glib::RefPtr<const PrintSettings> get_settings() const;
  Glib::RefPtr<Printer> get_printer();
  Glib::RefPtr<const Printer> get_printer() const;
  Glib::ustring get_title() const;
  PrintStatus get_status() const;
  void set_source_file(const std::string& filename);
  Cairo::RefPtr<Cairo::Surface> get_surface();
  Cairo::RefPtr<const Cairo::Surface> get_surface() const;
  void set_track_print_status(bool track_status = true);
  bool get_track_print_status() const;
  typedef sigc::slot< void, const Glib::RefPtr<PrintJob>& > SlotPrintJobComplete;
  void send(const SlotPrintJobComplete& slot);
  Glib::SignalProxy0< void > signal_status_changed();
  Glib::PropertyProxy_ReadOnly<Glib::ustring> property_title() const;
  Glib::PropertyProxy_ReadOnly< Glib::RefPtr<Printer> > property_printer() const;
  Glib::PropertyProxy_ReadOnly< Glib::RefPtr<PrintSettings> > property_settings() const;
  Glib::PropertyProxy_ReadOnly< Glib::RefPtr<PageSetup> > property_page_setup() const;
public:
public:
protected:
  virtual void on_status_changed();
};
}
namespace Glib
{
  Glib::RefPtr<Gtk::PrintJob> wrap(GtkPrintJob* object, bool take_copy = false);
}
typedef struct _GtkPrintUnixDialog GtkPrintUnixDialog;
typedef struct _GtkPrintUnixDialogClass GtkPrintUnixDialogClass;
namespace Gtk
{ class PrintUnixDialog_Class; }
namespace Gtk
{
class PrintUnixDialog : public Dialog
{
  public:
  typedef PrintUnixDialog CppObjectType;
  typedef PrintUnixDialog_Class CppClassType;
  typedef GtkPrintUnixDialog BaseObjectType;
  typedef GtkPrintUnixDialogClass BaseClassType;
  virtual ~PrintUnixDialog();
private:
  friend class PrintUnixDialog_Class;
  static CppClassType printunixdialog_class_;
  PrintUnixDialog(const PrintUnixDialog&);
  PrintUnixDialog& operator=(const PrintUnixDialog&);
protected:
  explicit PrintUnixDialog(const Glib::ConstructParams& construct_params);
  explicit PrintUnixDialog(GtkPrintUnixDialog* castitem);
public:
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkPrintUnixDialog* gobj() { return reinterpret_cast<GtkPrintUnixDialog*>(gobject_); }
  const GtkPrintUnixDialog* gobj() const { return reinterpret_cast<GtkPrintUnixDialog*>(gobject_); }
public:
protected:
private:
public:
  explicit PrintUnixDialog(Gtk::Window& parent, const Glib::ustring& title);
  explicit PrintUnixDialog(const Glib::ustring& title);
  void set_page_setup(const Glib::RefPtr<PageSetup>& page_setup);
  Glib::RefPtr<PageSetup> get_page_setup();
  Glib::RefPtr<const PageSetup> get_page_setup() const;
  void set_current_page(int current_page);
  int get_current_page() const;
  void set_settings(const Glib::RefPtr<PrintSettings>& print_settings);
  Glib::RefPtr<PrintSettings> get_settings();
  Glib::RefPtr<const PrintSettings> get_settings() const;
  Glib::RefPtr<Printer> get_selected_printer();
  Glib::RefPtr<const Printer> get_selected_printer() const;
  void add_custom_tab(const Widget& child, const Glib::ustring& tab_label);
  void add_custom_tab(const Widget& child, const Widget& tab_label);
  void set_manual_capabilities(PrintCapabilities capabilities);
  Glib::PropertyProxy< Glib::RefPtr<PageSetup> > property_page_setup() ;
  Glib::PropertyProxy_ReadOnly< Glib::RefPtr<PageSetup> > property_page_setup() const;
  Glib::PropertyProxy<int> property_current_page() ;
  Glib::PropertyProxy_ReadOnly<int> property_current_page() const;
  Glib::PropertyProxy< Glib::RefPtr<PrintSettings> > property_print_settings() ;
  Glib::PropertyProxy_ReadOnly< Glib::RefPtr<PrintSettings> > property_print_settings() const;
  Glib::PropertyProxy_ReadOnly< Glib::RefPtr<Printer> > property_selected_printer() const;
};
}
namespace Glib
{
  Gtk::PrintUnixDialog* wrap(GtkPrintUnixDialog* object, bool take_copy = false);
}
typedef struct _GtkProgressBar GtkProgressBar;
typedef struct _GtkProgressBarClass GtkProgressBarClass;
namespace Gtk
{ class ProgressBar_Class; }
namespace Gtk
{
enum ProgressBarStyle
{
  PROGRESS_CONTINUOUS,
  PROGRESS_DISCRETE
};
}
namespace Glib
{
template <>
class Value<Gtk::ProgressBarStyle> : public Glib::Value_Enum<Gtk::ProgressBarStyle>
{
public:
  static GType value_type() __attribute__((__const__));
};
}
namespace Gtk
{
enum ProgressBarOrientation
{
  PROGRESS_LEFT_TO_RIGHT,
  PROGRESS_RIGHT_TO_LEFT,
  PROGRESS_BOTTOM_TO_TOP,
  PROGRESS_TOP_TO_BOTTOM
};
}
namespace Glib
{
template <>
class Value<Gtk::ProgressBarOrientation> : public Glib::Value_Enum<Gtk::ProgressBarOrientation>
{
public:
  static GType value_type() __attribute__((__const__));
};
}
namespace Gtk
{
class ProgressBar : public Widget
{
  public:
  typedef ProgressBar CppObjectType;
  typedef ProgressBar_Class CppClassType;
  typedef GtkProgressBar BaseObjectType;
  typedef GtkProgressBarClass BaseClassType;
  virtual ~ProgressBar();
private:
  friend class ProgressBar_Class;
  static CppClassType progressbar_class_;
  ProgressBar(const ProgressBar&);
  ProgressBar& operator=(const ProgressBar&);
protected:
  explicit ProgressBar(const Glib::ConstructParams& construct_params);
  explicit ProgressBar(GtkProgressBar* castitem);
public:
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkProgressBar* gobj() { return reinterpret_cast<GtkProgressBar*>(gobject_); }
  const GtkProgressBar* gobj() const { return reinterpret_cast<GtkProgressBar*>(gobject_); }
public:
protected:
private:
public:
  ProgressBar();
  void pulse();
  Glib::ustring get_text() const;
  void set_text(const Glib::ustring& text);
  double get_fraction() const;
  void set_fraction(double fraction);
  double get_pulse_step() const;
  void set_pulse_step(double fraction);
  void set_orientation(ProgressBarOrientation orientation = PROGRESS_LEFT_TO_RIGHT);
  ProgressBarOrientation get_orientation() const;
  void set_ellipsize(Pango::EllipsizeMode mode);
  Pango::EllipsizeMode get_ellipsize() const;
  Glib::PropertyProxy<double> property_fraction() ;
  Glib::PropertyProxy_ReadOnly<double> property_fraction() const;
  Glib::PropertyProxy<double> property_pulse_step() ;
  Glib::PropertyProxy_ReadOnly<double> property_pulse_step() const;
  Glib::PropertyProxy<ProgressBarOrientation> property_orientation() ;
  Glib::PropertyProxy_ReadOnly<ProgressBarOrientation> property_orientation() const;
  Glib::PropertyProxy<Glib::ustring> property_text() ;
  Glib::PropertyProxy_ReadOnly<Glib::ustring> property_text() const;
  Glib::PropertyProxy<bool> property_ellipsize() ;
  Glib::PropertyProxy_ReadOnly<bool> property_ellipsize() const;
};
}
namespace Glib
{
  Gtk::ProgressBar* wrap(GtkProgressBar* object, bool take_copy = false);
}
typedef struct _GtkAction GtkAction;
typedef struct _GtkActionClass GtkActionClass;
namespace Gtk
{ class Action_Class; }
namespace Gtk
{
class Menu;
class MenuItem;
class ToolItem;
class Image;
class Action : public Glib::Object
{
public:
  typedef Action CppObjectType;
  typedef Action_Class CppClassType;
  typedef GtkAction BaseObjectType;
  typedef GtkActionClass BaseClassType;
private: friend class Action_Class;
  static CppClassType action_class_;
private:
  Action(const Action&);
  Action& operator=(const Action&);
protected:
  explicit Action(const Glib::ConstructParams& construct_params);
  explicit Action(GtkAction* castitem);
public:
  virtual ~Action();
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkAction* gobj() { return reinterpret_cast<GtkAction*>(gobject_); }
  const GtkAction* gobj() const { return reinterpret_cast<GtkAction*>(gobject_); }
  GtkAction* gobj_copy();
private:
protected:
 Action();
  explicit Action(const Glib::ustring& name, const StockID& stock_id = StockID(), const Glib::ustring& label = Glib::ustring(), const Glib::ustring& tooltip = Glib::ustring());
public:
  static Glib::RefPtr<Action> create();
  static Glib::RefPtr<Action> create(const Glib::ustring& name, const Glib::ustring& label = Glib::ustring(), const Glib::ustring& tooltip = Glib::ustring());
  static Glib::RefPtr<Action> create(const Glib::ustring& name, const Gtk::StockID& stock_id, const Glib::ustring& label = Glib::ustring(), const Glib::ustring& tooltip = Glib::ustring());
  Glib::ustring get_name() const;
  bool is_sensitive() const;
  bool get_sensitive() const;
   void set_tooltip(const Glib::ustring& tooltip);
  void set_sensitive(bool sensitive = true);
  bool is_visible() const;
  bool get_visible() const;
  void set_visible(bool visible = true);
  void activate();
  Image* create_icon(IconSize icon_size);
  MenuItem* create_menu_item();
  ToolItem* create_tool_item();
  Menu* create_menu();
  void connect_proxy(Widget& proxy);
  void disconnect_proxy(Widget& proxy);
  Glib::SListHandle<Widget*> get_proxies();
  Glib::SListHandle<const Widget*> get_proxies() const;
  void connect_accelerator();
  void disconnect_accelerator();
  Glib::ustring get_accel_path() const;
  typedef sigc::slot<void> SlotActivate;
  Glib::SignalProxy0< void > signal_activate();
  void set_accel_path(const Glib::ustring& accel_path);
  void set_accel_group(const Glib::RefPtr<AccelGroup>& accel_group);
  Glib::PropertyProxy_ReadOnly<Glib::ustring> property_name() const;
  Glib::PropertyProxy<Glib::ustring> property_label() ;
  Glib::PropertyProxy_ReadOnly<Glib::ustring> property_label() const;
  Glib::PropertyProxy<Glib::ustring> property_short_label() ;
  Glib::PropertyProxy_ReadOnly<Glib::ustring> property_short_label() const;
  Glib::PropertyProxy<Glib::ustring> property_tooltip() ;
  Glib::PropertyProxy_ReadOnly<Glib::ustring> property_tooltip() const;
  Glib::PropertyProxy<StockID> property_stock_id() ;
  Glib::PropertyProxy_ReadOnly<StockID> property_stock_id() const;
  Glib::PropertyProxy<bool> property_visible_horizontal() ;
  Glib::PropertyProxy_ReadOnly<bool> property_visible_horizontal() const;
  Glib::PropertyProxy<bool> property_visible_vertical() ;
  Glib::PropertyProxy_ReadOnly<bool> property_visible_vertical() const;
  Glib::PropertyProxy<bool> property_is_important() ;
  Glib::PropertyProxy_ReadOnly<bool> property_is_important() const;
  Glib::PropertyProxy<bool> property_hide_if_empty() ;
  Glib::PropertyProxy_ReadOnly<bool> property_hide_if_empty() const;
  Glib::PropertyProxy<bool> property_sensitive() ;
  Glib::PropertyProxy_ReadOnly<bool> property_sensitive() const;
  Glib::PropertyProxy<bool> property_visible() ;
  Glib::PropertyProxy_ReadOnly<bool> property_visible() const;
protected:
  void block_activate_from(Widget& proxy);
  void unblock_activate_from(Widget& proxy);
protected:
  virtual Widget* create_menu_item_vfunc();
  virtual Widget* create_tool_item_vfunc();
  virtual void connect_proxy_vfunc(Widget* proxy);
  virtual void disconnect_proxy_vfunc(Widget* proxy);
public:
public:
protected:
  virtual void on_activate();
};
}
namespace Glib
{
  Glib::RefPtr<Gtk::Action> wrap(GtkAction* object, bool take_copy = false);
}
typedef struct _GtkToggleAction GtkToggleAction;
typedef struct _GtkToggleActionClass GtkToggleActionClass;
namespace Gtk
{ class ToggleAction_Class; }
namespace Gtk
{
class ToggleAction : public Gtk::Action
{
public:
  typedef ToggleAction CppObjectType;
  typedef ToggleAction_Class CppClassType;
  typedef GtkToggleAction BaseObjectType;
  typedef GtkToggleActionClass BaseClassType;
private: friend class ToggleAction_Class;
  static CppClassType toggleaction_class_;
private:
  ToggleAction(const ToggleAction&);
  ToggleAction& operator=(const ToggleAction&);
protected:
  explicit ToggleAction(const Glib::ConstructParams& construct_params);
  explicit ToggleAction(GtkToggleAction* castitem);
public:
  virtual ~ToggleAction();
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkToggleAction* gobj() { return reinterpret_cast<GtkToggleAction*>(gobject_); }
  const GtkToggleAction* gobj() const { return reinterpret_cast<GtkToggleAction*>(gobject_); }
  GtkToggleAction* gobj_copy();
private:
protected:
  ToggleAction();
   explicit ToggleAction(const Glib::ustring& name, const StockID& stock_id = StockID(), const Glib::ustring& label = Glib::ustring(), const Glib::ustring& tooltip = Glib::ustring(), bool is_active = false);
public:
  static Glib::RefPtr<ToggleAction> create();
   static Glib::RefPtr<ToggleAction> create(const Glib::ustring& name, const Glib::ustring& label = Glib::ustring(), const Glib::ustring& tooltip = Glib::ustring(), bool is_active = false);
   static Glib::RefPtr<ToggleAction> create(const Glib::ustring& name, const Gtk::StockID& stock_id, const Glib::ustring& label = Glib::ustring(), const Glib::ustring& tooltip = Glib::ustring(), bool is_active = false);
  void toggled();
  void set_active(bool is_active = true);
  bool get_active() const;
  void set_draw_as_radio(bool draw_as_radio = true);
  bool get_draw_as_radio() const;
  Glib::SignalProxy0< void > signal_toggled();
  Glib::PropertyProxy<bool> property_draw_as_radio() ;
  Glib::PropertyProxy_ReadOnly<bool> property_draw_as_radio() const;
public:
public:
protected:
  virtual void on_toggled();
};
}
namespace Glib
{
  Glib::RefPtr<Gtk::ToggleAction> wrap(GtkToggleAction* object, bool take_copy = false);
}
typedef struct _GtkRadioAction GtkRadioAction;
typedef struct _GtkRadioActionClass GtkRadioActionClass;
namespace Gtk
{ class RadioAction_Class; }
namespace Gtk
{
class RadioAction : public Gtk::ToggleAction
{
public:
  typedef RadioAction CppObjectType;
  typedef RadioAction_Class CppClassType;
  typedef GtkRadioAction BaseObjectType;
  typedef GtkRadioActionClass BaseClassType;
private: friend class RadioAction_Class;
  static CppClassType radioaction_class_;
private:
  RadioAction(const RadioAction&);
  RadioAction& operator=(const RadioAction&);
protected:
  explicit RadioAction(const Glib::ConstructParams& construct_params);
  explicit RadioAction(GtkRadioAction* castitem);
public:
  virtual ~RadioAction();
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkRadioAction* gobj() { return reinterpret_cast<GtkRadioAction*>(gobject_); }
  const GtkRadioAction* gobj() const { return reinterpret_cast<GtkRadioAction*>(gobject_); }
  GtkRadioAction* gobj_copy();
private:
public:
  typedef RadioButtonGroup Group;
protected:
  RadioAction();
  explicit RadioAction(Group& group, const Glib::ustring& name, const StockID& stock_id = StockID(), const Glib::ustring& label = Glib::ustring(), const Glib::ustring& tooltip = Glib::ustring());
public:
  static Glib::RefPtr<RadioAction> create();
  static Glib::RefPtr<RadioAction> create(Group& group, const Glib::ustring& name, const Glib::ustring& label = Glib::ustring(), const Glib::ustring& tooltip = Glib::ustring());
  static Glib::RefPtr<RadioAction> create(Group& group, const Glib::ustring& name, const Gtk::StockID& stock_id, const Glib::ustring& label = Glib::ustring(), const Glib::ustring& tooltip = Glib::ustring());
  Group get_group();
   void set_group(Group& group);
  int get_current_value() const;
  void set_current_value(int current_value);
  Glib::SignalProxy1< void,const Glib::RefPtr<RadioAction>& > signal_changed();
  Glib::PropertyProxy<int> property_value() ;
  Glib::PropertyProxy_ReadOnly<int> property_value() const;
  Glib::PropertyProxy<int> property_current_value() ;
  Glib::PropertyProxy_ReadOnly<int> property_current_value() const;
public:
public:
protected:
  virtual void on_changed(const Glib::RefPtr<RadioAction>& current);
};
}
namespace Glib
{
  Glib::RefPtr<Gtk::RadioAction> wrap(GtkRadioAction* object, bool take_copy = false);
}
typedef struct _GtkTooltipsData GtkTooltipsData;
typedef struct _GtkTooltips GtkTooltips;
typedef struct _GtkTooltipsClass GtkTooltipsClass;
namespace Gtk
{ class Tooltips_Class; }
namespace Gtk
{
class Widget;
class Tooltips : public Object
{
  public:
  typedef Tooltips CppObjectType;
  typedef Tooltips_Class CppClassType;
  typedef GtkTooltips BaseObjectType;
  typedef GtkTooltipsClass BaseClassType;
  virtual ~Tooltips();
private:
  friend class Tooltips_Class;
  static CppClassType tooltips_class_;
  Tooltips(const Tooltips&);
  Tooltips& operator=(const Tooltips&);
protected:
  explicit Tooltips(const Glib::ConstructParams& construct_params);
  explicit Tooltips(GtkTooltips* castitem);
public:
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkTooltips* gobj() { return reinterpret_cast<GtkTooltips*>(gobject_); }
  const GtkTooltips* gobj() const { return reinterpret_cast<GtkTooltips*>(gobject_); }
public:
protected:
private:
public:
  Tooltips();
  void enable();
  void disable();
  void set_tip(Widget& widget, const Glib::ustring& tip_text, const Glib::ustring& tip_private);
  void set_tip(Widget& widget, const Glib::ustring& tip_text);
  void unset_tip(Widget& widget);
protected:
  static GtkTooltipsData* data_get(Widget& widget);
public:
  void force_window();
};
}
namespace Glib
{
  Gtk::Tooltips* wrap(GtkTooltips* object, bool take_copy = false);
}
typedef struct _GtkToolItem GtkToolItem;
typedef struct _GtkToolItemClass GtkToolItemClass;
namespace Gtk
{ class ToolItem_Class; }
namespace Gtk
{
class ToolItem : public Bin
{
  public:
  typedef ToolItem CppObjectType;
  typedef ToolItem_Class CppClassType;
  typedef GtkToolItem BaseObjectType;
  typedef GtkToolItemClass BaseClassType;
  virtual ~ToolItem();
private:
  friend class ToolItem_Class;
  static CppClassType toolitem_class_;
  ToolItem(const ToolItem&);
  ToolItem& operator=(const ToolItem&);
protected:
  explicit ToolItem(const Glib::ConstructParams& construct_params);
  explicit ToolItem(GtkToolItem* castitem);
public:
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkToolItem* gobj() { return reinterpret_cast<GtkToolItem*>(gobject_); }
  const GtkToolItem* gobj() const { return reinterpret_cast<GtkToolItem*>(gobject_); }
public:
protected:
  virtual bool on_create_menu_proxy();
  virtual void on_toolbar_reconfigured();
private:
public:
  ToolItem();
  void set_homogeneous(bool homogeneous = true);
  bool get_homogeneous() const;
  void set_expand(bool expand = true);
  bool get_expand() const;
  void set_tooltip(Tooltips& tooltips, const Glib::ustring& tip_text, const Glib::ustring& tip_private = Glib::ustring());
  void set_tooltip_text(const Glib::ustring& text);
  void set_tooltip_markup(const Glib::ustring& markup);
  void set_use_drag_window(bool use_drag_window = true);
  bool get_use_drag_window() const;
  void set_visible_horizontal(bool visible_horizontal = true);
  bool get_visible_horizontal() const;
  void set_visible_vertical(bool visible_vertical = true);
  bool get_visible_vertical() const;
  bool get_is_important() const;
  void set_is_important(bool is_important = true);
  IconSize get_icon_size () const;
  Orientation get_orientation() const;
  ToolbarStyle get_toolbar_style() const;
  ReliefStyle get_relief_style() const;
  Widget* retrieve_proxy_menu_item();
  const Widget* retrieve_proxy_menu_item() const;
  Widget* get_proxy_menu_item(const Glib::ustring& menu_item_id);
  const Widget* get_proxy_menu_item(const Glib::ustring& menu_item_id) const;
  void set_proxy_menu_item(const Glib::ustring& menu_item_id, Widget& menu_item);
  void rebuild_menu();
  Glib::SignalProxy0< bool > signal_create_menu_proxy();
  Glib::SignalProxy0< void > signal_toolbar_reconfigured();
  Glib::SignalProxy3< bool,Tooltips*,const Glib::ustring&,const Glib::ustring& > signal_set_tooltip();
  Glib::PropertyProxy<bool> property_visible_horizontal() ;
  Glib::PropertyProxy_ReadOnly<bool> property_visible_horizontal() const;
  Glib::PropertyProxy<bool> property_visible_vertical() ;
  Glib::PropertyProxy_ReadOnly<bool> property_visible_vertical() const;
  Glib::PropertyProxy<bool> property_is_important() ;
  Glib::PropertyProxy_ReadOnly<bool> property_is_important() const;
};
}
namespace Glib
{
  Gtk::ToolItem* wrap(GtkToolItem* object, bool take_copy = false);
}
typedef struct _GtkToolButton GtkToolButton;
typedef struct _GtkToolButtonClass GtkToolButtonClass;
namespace Gtk
{ class ToolButton_Class; }
namespace Gtk
{
class ToolButton : public ToolItem
{
  public:
  typedef ToolButton CppObjectType;
  typedef ToolButton_Class CppClassType;
  typedef GtkToolButton BaseObjectType;
  typedef GtkToolButtonClass BaseClassType;
  virtual ~ToolButton();
private:
  friend class ToolButton_Class;
  static CppClassType toolbutton_class_;
  ToolButton(const ToolButton&);
  ToolButton& operator=(const ToolButton&);
protected:
  explicit ToolButton(const Glib::ConstructParams& construct_params);
  explicit ToolButton(GtkToolButton* castitem);
public:
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkToolButton* gobj() { return reinterpret_cast<GtkToolButton*>(gobject_); }
  const GtkToolButton* gobj() const { return reinterpret_cast<GtkToolButton*>(gobject_); }
public:
protected:
  virtual void on_clicked();
private:
public:
  ToolButton();
  explicit ToolButton(const Gtk::StockID& stock_id);
  explicit ToolButton(const Glib::ustring& label);
  explicit ToolButton(Widget& icon_widget, const Glib::ustring& label = Glib::ustring());
  void set_label(const Glib::ustring& label);
  Glib::ustring get_label() const;
  void set_use_underline(bool use_underline = true);
  bool get_use_underline() const;
  void set_stock_id(const Gtk::StockID& stock_id);
  Glib::ustring get_stock_id() const;
  void set_icon_name(const Glib::ustring& icon_name);
  Glib::ustring get_icon_name() const;
  void set_icon_widget(Widget& icon_widget);
  Widget* get_icon_widget();
  const Widget* get_icon_widget() const;
  void set_label_widget(Widget& label_widget);
  Widget* get_label_widget();
  const Widget* get_label_widget() const;
  Glib::SignalProxy0< void > signal_clicked();
  Glib::PropertyProxy<Glib::ustring> property_label() ;
  Glib::PropertyProxy_ReadOnly<Glib::ustring> property_label() const;
  Glib::PropertyProxy<bool> property_use_underline() ;
  Glib::PropertyProxy_ReadOnly<bool> property_use_underline() const;
  Glib::PropertyProxy<Gtk::Widget*> property_label_widget() ;
  Glib::PropertyProxy_ReadOnly<Gtk::Widget*> property_label_widget() const;
  Glib::PropertyProxy<Glib::ustring> property_stock_id() ;
  Glib::PropertyProxy_ReadOnly<Glib::ustring> property_stock_id() const;
  Glib::PropertyProxy<Gtk::Widget> property_icon_widget() ;
  Glib::PropertyProxy_ReadOnly<Gtk::Widget> property_icon_widget() const;
};
}
namespace Glib
{
  Gtk::ToolButton* wrap(GtkToolButton* object, bool take_copy = false);
}
typedef struct _GtkToggleToolButton GtkToggleToolButton;
typedef struct _GtkToggleToolButtonClass GtkToggleToolButtonClass;
namespace Gtk
{ class ToggleToolButton_Class; }
namespace Gtk
{
class ToggleToolButton : public ToolButton
{
  public:
  typedef ToggleToolButton CppObjectType;
  typedef ToggleToolButton_Class CppClassType;
  typedef GtkToggleToolButton BaseObjectType;
  typedef GtkToggleToolButtonClass BaseClassType;
  virtual ~ToggleToolButton();
private:
  friend class ToggleToolButton_Class;
  static CppClassType toggletoolbutton_class_;
  ToggleToolButton(const ToggleToolButton&);
  ToggleToolButton& operator=(const ToggleToolButton&);
protected:
  explicit ToggleToolButton(const Glib::ConstructParams& construct_params);
  explicit ToggleToolButton(GtkToggleToolButton* castitem);
public:
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkToggleToolButton* gobj() { return reinterpret_cast<GtkToggleToolButton*>(gobject_); }
  const GtkToggleToolButton* gobj() const { return reinterpret_cast<GtkToggleToolButton*>(gobject_); }
public:
protected:
  virtual void on_toggled();
private:
public:
  ToggleToolButton();
  explicit ToggleToolButton(const Gtk::StockID& stock_id);
  explicit ToggleToolButton(const Glib::ustring& label);
  explicit ToggleToolButton(Widget& icon_widget, const Glib::ustring& label = Glib::ustring());
  void set_active(bool is_active = true);
  bool get_active() const;
  Glib::SignalProxy0< void > signal_toggled();
};
}
namespace Glib
{
  Gtk::ToggleToolButton* wrap(GtkToggleToolButton* object, bool take_copy = false);
}
typedef struct _GtkRadioToolButton GtkRadioToolButton;
typedef struct _GtkRadioToolButtonClass GtkRadioToolButtonClass;
namespace Gtk
{ class RadioToolButton_Class; }
namespace Gtk
{
class RadioToolButton : public ToggleToolButton
{
  public:
  typedef RadioToolButton CppObjectType;
  typedef RadioToolButton_Class CppClassType;
  typedef GtkRadioToolButton BaseObjectType;
  typedef GtkRadioToolButtonClass BaseClassType;
  virtual ~RadioToolButton();
private:
  friend class RadioToolButton_Class;
  static CppClassType radiotoolbutton_class_;
  RadioToolButton(const RadioToolButton&);
  RadioToolButton& operator=(const RadioToolButton&);
protected:
  explicit RadioToolButton(const Glib::ConstructParams& construct_params);
  explicit RadioToolButton(GtkRadioToolButton* castitem);
public:
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkRadioToolButton* gobj() { return reinterpret_cast<GtkRadioToolButton*>(gobject_); }
  const GtkRadioToolButton* gobj() const { return reinterpret_cast<GtkRadioToolButton*>(gobject_); }
public:
protected:
private:
public:
  typedef RadioButtonGroup Group;
  RadioToolButton();
  explicit RadioToolButton(Group& group, const Glib::ustring& label = Glib::ustring());
  RadioToolButton(Group& group, const Gtk::StockID& stock_id);
  explicit RadioToolButton(Widget& icon_widget, const Glib::ustring& label = Glib::ustring());
  Group get_group();
  void set_group(Group& group);
};
}
namespace Glib
{
  Gtk::RadioToolButton* wrap(GtkRadioToolButton* object, bool take_copy = false);
}
typedef struct _GtkRange GtkRange;
typedef struct _GtkRangeClass GtkRangeClass;
namespace Gtk
{ class Range_Class; }
namespace Gtk
{
enum SensitivityType
{
  SENSITIVITY_AUTO,
  SENSITIVITY_ON,
  SENSITIVITY_OFF
};
}
namespace Glib
{
template <>
class Value<Gtk::SensitivityType> : public Glib::Value_Enum<Gtk::SensitivityType>
{
public:
  static GType value_type() __attribute__((__const__));
};
}
namespace Gtk
{
class Adjustment;
class Range : public Widget
{
  public:
  typedef Range CppObjectType;
  typedef Range_Class CppClassType;
  typedef GtkRange BaseObjectType;
  typedef GtkRangeClass BaseClassType;
  virtual ~Range();
private:
  friend class Range_Class;
  static CppClassType range_class_;
  Range(const Range&);
  Range& operator=(const Range&);
protected:
  explicit Range(const Glib::ConstructParams& construct_params);
  explicit Range(GtkRange* castitem);
public:
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkRange* gobj() { return reinterpret_cast<GtkRange*>(gobject_); }
  const GtkRange* gobj() const { return reinterpret_cast<GtkRange*>(gobject_); }
public:
protected:
  virtual void on_value_changed();
  virtual void on_adjust_bounds(double new_value);
  virtual void on_move_slider(ScrollType scroll);
private:
protected:
  Range();
public:
  void set_update_policy(UpdateType policy);
  UpdateType get_update_policy() const;
  void set_adjustment(Gtk::Adjustment& adjustment);
  void unset_adjustment();
  Gtk::Adjustment* get_adjustment();
  const Gtk::Adjustment* get_adjustment() const;
  void set_inverted(bool setting = true);
  bool get_inverted() const;
  void set_lower_stepper_sensitivity(SensitivityType sensitivity);
  SensitivityType get_lower_stepper_sensitivity() const;
  void set_upper_stepper_sensitivity(SensitivityType sensitivity);
  SensitivityType get_upper_stepper_sensitivity() const;
  void set_increments(double step, double page);
  void set_range(double min, double max);
  void set_value(double value);
  double get_value() const;
  void set_show_fill_level(bool show_fill_level = true);
  bool get_show_fill_level() const;
  void set_restrict_to_fill_level(bool restrict_to_fill_level = true);
  bool get_restrict_to_fill_level() const;
  void set_fill_level(double fill_level);
  double get_fill_level() const;
  Glib::SignalProxy0< void > signal_value_changed();
  Glib::SignalProxy1< void,double > signal_adjust_bounds();
  Glib::SignalProxy1< void,ScrollType > signal_move_slider();
  Glib::SignalProxy2< bool,ScrollType,double > signal_change_value();
  Glib::PropertyProxy<UpdateType> property_update_policy() ;
  Glib::PropertyProxy_ReadOnly<UpdateType> property_update_policy() const;
  Glib::PropertyProxy<Adjustment*> property_adjustment() ;
  Glib::PropertyProxy_ReadOnly<Adjustment*> property_adjustment() const;
  Glib::PropertyProxy<bool> property_inverted() ;
  Glib::PropertyProxy_ReadOnly<bool> property_inverted() const;
  Glib::PropertyProxy<SensitivityType> property_lower_stepper_sensitivity() ;
  Glib::PropertyProxy_ReadOnly<SensitivityType> property_lower_stepper_sensitivity() const;
  Glib::PropertyProxy<SensitivityType> property_upper_stepper_sensitivity() ;
  Glib::PropertyProxy_ReadOnly<SensitivityType> property_upper_stepper_sensitivity() const;
  Glib::PropertyProxy<bool> property_show_fill_level() ;
  Glib::PropertyProxy_ReadOnly<bool> property_show_fill_level() const;
  Glib::PropertyProxy<bool> property_restrict_to_fill_level() ;
  Glib::PropertyProxy_ReadOnly<bool> property_restrict_to_fill_level() const;
  Glib::PropertyProxy<double> property_fill_level() ;
  Glib::PropertyProxy_ReadOnly<double> property_fill_level() const;
protected:
  virtual void get_range_border_vfunc(GtkBorder* border) const;
};
}
namespace Glib
{
  Gtk::Range* wrap(GtkRange* object, bool take_copy = false);
}
typedef struct _GtkRecentInfo GtkRecentInfo;
namespace Gtk
{
class RecentInfo
{
  public:
  typedef RecentInfo CppObjectType;
  typedef GtkRecentInfo BaseObjectType;
  void reference() const;
  void unreference() const;
  GtkRecentInfo* gobj();
  const GtkRecentInfo* gobj() const;
  GtkRecentInfo* gobj_copy() const;
protected:
  RecentInfo();
  void operator delete(void*, size_t);
private:
  RecentInfo(const RecentInfo&);
  RecentInfo& operator=(const RecentInfo&);
public:
  bool equal(const RecentInfo& other) const;
  operator bool() const;
  Glib::ustring get_uri() const;
  Glib::ustring get_display_name() const;
  Glib::ustring get_description() const;
  Glib::ustring get_mime_type() const;
  time_t get_added() const;
  time_t get_modified() const;
  time_t get_visited() const;
  bool get_private_hint() const;
  bool get_application_info(const Glib::ustring& app_name, Glib::StringArrayHandle& app_exec, guint& count, time_t& time) const;
  Glib::StringArrayHandle get_applications() const;
  Glib::ustring last_application() const;
  bool has_application(const Glib::ustring& app_name) const;
  Glib::StringArrayHandle get_groups() const;
  bool has_group(const Glib::ustring& group) const;
  Glib::RefPtr<Gdk::Pixbuf> get_icon(int size);
  Glib::RefPtr<const Gdk::Pixbuf> get_icon(int size) const;
  Glib::ustring get_short_name() const;
  Glib::ustring get_uri_display() const;
  int get_age() const;
  bool is_local() const;
  bool exists() const;
};
struct RecentInfoTraits
{
  typedef Glib::RefPtr<RecentInfo> CppType;
  typedef const GtkRecentInfo* CType;
  typedef GtkRecentInfo* CTypeNonConst;
  static CType to_c_type(const CppType& obj) { return Glib::unwrap(obj); }
  static CType to_c_type(const CType& obj) { return obj; }
  static CppType to_cpp_type(const CType& obj);
  static void release_c_type(const CType& ) { }
};
inline bool operator==(const RecentInfo& lhs, const RecentInfo& rhs)
  { return lhs.equal(rhs); }
inline bool operator!=(const RecentInfo& lhs, const RecentInfo& rhs)
  { return !lhs.equal(rhs); }
}
namespace Glib
{
  Glib::RefPtr<Gtk::RecentInfo> wrap(GtkRecentInfo* object, bool take_copy = false);
}
typedef struct _GtkRecentManager GtkRecentManager;
typedef struct _GtkRecentManagerClass GtkRecentManagerClass;
namespace Gtk
{ class RecentManager_Class; }
namespace Gtk
{
class RecentManagerError : public Glib::Error
{
public:
  enum Code
  {
    NOT_FOUND,
    INVALID_URI,
    INVALID_ENCODING,
    NOT_REGISTERED,
    READ,
    WRITE,
    UNKNOWN
  };
  RecentManagerError(Code error_code, const Glib::ustring& error_message);
  explicit RecentManagerError(GError* gobject);
  Code code() const;
private:
  static void throw_func(GError* gobject);
  friend void wrap_init();
};
}
namespace Glib
{
template <>
class Value<Gtk::RecentManagerError::Code> : public Glib::Value_Enum<Gtk::RecentManagerError::Code>
{
public:
  static GType value_type() __attribute__((__const__));
};
}
namespace Gtk
{
class RecentManager : public Glib::Object
{
public:
  typedef RecentManager CppObjectType;
  typedef RecentManager_Class CppClassType;
  typedef GtkRecentManager BaseObjectType;
  typedef GtkRecentManagerClass BaseClassType;
private: friend class RecentManager_Class;
  static CppClassType recentmanager_class_;
private:
  RecentManager(const RecentManager&);
  RecentManager& operator=(const RecentManager&);
protected:
  explicit RecentManager(const Glib::ConstructParams& construct_params);
  explicit RecentManager(GtkRecentManager* castitem);
public:
  virtual ~RecentManager();
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkRecentManager* gobj() { return reinterpret_cast<GtkRecentManager*>(gobject_); }
  const GtkRecentManager* gobj() const { return reinterpret_cast<GtkRecentManager*>(gobject_); }
  GtkRecentManager* gobj_copy();
private:
protected:
  RecentManager();
public:
  static Glib::RefPtr<RecentManager> create();
  static Glib::RefPtr<RecentManager> get_default();
  static Glib::RefPtr<RecentManager> get_for_screen(const Glib::RefPtr<Gdk::Screen>& screen);
  class Data
  {
  public:
    Glib::ustring display_name;
    Glib::ustring description;
    Glib::ustring mime_type;
    Glib::ustring app_name;
    Glib::ustring app_exec;
    std::vector<Glib::ustring> groups;
    bool is_private;
  };
  void set_screen(const Glib::RefPtr<Gdk::Screen>& screen);
  bool add_item(const Glib::ustring& uri);
  bool add_item(const Glib::ustring& uri, const Data& recent_data);
  bool remove_item(const Glib::ustring& uri);
  Glib::RefPtr<RecentInfo> lookup_item(const Glib::ustring& uri);
  Glib::RefPtr<const RecentInfo> lookup_item(const Glib::ustring& uri) const;
  bool has_item(const Glib::ustring& uri) const;
  bool move_item(const Glib::ustring& uri, const Glib::ustring& new_uri);
  void set_limit(int limit);
  int get_limit() const;
  typedef Glib::ListHandle<RecentInfo, RecentInfoTraits> ListHandle_RecentInfos;
  ListHandle_RecentInfos get_items() const;
  int purge_items();
  typedef sigc::slot<void> SlotChanged;
  Glib::SignalProxy0< void > signal_changed();
  Glib::PropertyProxy_ReadOnly<Glib::ustring> property_filename() const;
  Glib::PropertyProxy<int> property_limit() ;
  Glib::PropertyProxy_ReadOnly<int> property_limit() const;
  Glib::PropertyProxy_ReadOnly<int> property_size() const;
public:
public:
protected:
  virtual void on_changed();
};
}
namespace Glib
{
  Glib::RefPtr<Gtk::RecentManager> wrap(GtkRecentManager* object, bool take_copy = false);
}
typedef struct _GtkRecentAction GtkRecentAction;
typedef struct _GtkRecentActionClass GtkRecentActionClass;
namespace Gtk
{ class RecentAction_Class; }
namespace Gtk
{
class RecentAction : public Gtk::Action
{
public:
  typedef RecentAction CppObjectType;
  typedef RecentAction_Class CppClassType;
  typedef GtkRecentAction BaseObjectType;
  typedef GtkRecentActionClass BaseClassType;
private: friend class RecentAction_Class;
  static CppClassType recentaction_class_;
private:
  RecentAction(const RecentAction&);
  RecentAction& operator=(const RecentAction&);
protected:
  explicit RecentAction(const Glib::ConstructParams& construct_params);
  explicit RecentAction(GtkRecentAction* castitem);
public:
  virtual ~RecentAction();
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkRecentAction* gobj() { return reinterpret_cast<GtkRecentAction*>(gobject_); }
  const GtkRecentAction* gobj() const { return reinterpret_cast<GtkRecentAction*>(gobject_); }
  GtkRecentAction* gobj_copy();
private:
protected:
  RecentAction();
  explicit RecentAction(const Glib::ustring& name, const StockID& stock_id = StockID(), const Glib::ustring& label = Glib::ustring(), const Glib::ustring& tooltip = Glib::ustring());
  explicit RecentAction(const Glib::ustring& name, const StockID& stock_id, const Glib::ustring& label, const Glib::ustring& tooltip, const Glib::RefPtr<RecentManager>& manager);
public:
  static Glib::RefPtr<RecentAction> create();
  static Glib::RefPtr<RecentAction> create(const Glib::ustring& name, const Glib::ustring& label = Glib::ustring(), const Glib::ustring& tooltip = Glib::ustring());
  static Glib::RefPtr<RecentAction> create(const Glib::ustring& name, const Gtk::StockID& stock_id, const Glib::ustring& label = Glib::ustring(), const Glib::ustring& tooltip = Glib::ustring());
  static Glib::RefPtr<RecentAction> create(const Glib::ustring& name, const Gtk::StockID& stock_id, const Glib::ustring& label, const Glib::ustring& tooltip, const Glib::RefPtr<RecentManager>& manager);
  bool get_show_numbers();
  void set_show_numbers(bool show_numbers = true);
  Glib::PropertyProxy<bool> property_show_numbers() ;
  Glib::PropertyProxy_ReadOnly<bool> property_show_numbers() const;
public:
public:
protected:
};
}
namespace Glib
{
  Glib::RefPtr<Gtk::RecentAction> wrap(GtkRecentAction* object, bool take_copy = false);
}
extern "C" {
typedef struct _GtkRecentInfo GtkRecentInfo;
typedef struct _GtkRecentData GtkRecentData;
typedef struct _GtkRecentManager GtkRecentManager;
typedef struct _GtkRecentManagerClass GtkRecentManagerClass;
typedef struct _GtkRecentManagerPrivate GtkRecentManagerPrivate;
struct _GtkRecentData
{
  gchar *display_name;
  gchar *description;
  gchar *mime_type;
  gchar *app_name;
  gchar *app_exec;
  gchar **groups;
  gboolean is_private;
};
struct _GtkRecentManager
{
  GObject parent_instance;
  GtkRecentManagerPrivate *priv;
};
struct _GtkRecentManagerClass
{
  GObjectClass parent_class;
  void (*changed) (GtkRecentManager *manager);
  void (*_gtk_recent1) (void);
  void (*_gtk_recent2) (void);
  void (*_gtk_recent3) (void);
  void (*_gtk_recent4) (void);
};
typedef enum
{
  GTK_RECENT_MANAGER_ERROR_NOT_FOUND,
  GTK_RECENT_MANAGER_ERROR_INVALID_URI,
  GTK_RECENT_MANAGER_ERROR_INVALID_ENCODING,
  GTK_RECENT_MANAGER_ERROR_NOT_REGISTERED,
  GTK_RECENT_MANAGER_ERROR_READ,
  GTK_RECENT_MANAGER_ERROR_WRITE,
  GTK_RECENT_MANAGER_ERROR_UNKNOWN
} GtkRecentManagerError;
GQuark gtk_recent_manager_error_quark (void);
GType gtk_recent_manager_get_type (void) __attribute__((__const__));
GtkRecentManager *gtk_recent_manager_new (void);
GtkRecentManager *gtk_recent_manager_get_default (void);
GtkRecentManager *gtk_recent_manager_get_for_screen (GdkScreen *screen);
void gtk_recent_manager_set_screen (GtkRecentManager *manager,
           GdkScreen *screen);
gboolean gtk_recent_manager_add_item (GtkRecentManager *manager,
           const gchar *uri);
gboolean gtk_recent_manager_add_full (GtkRecentManager *manager,
           const gchar *uri,
           const GtkRecentData *recent_data);
gboolean gtk_recent_manager_remove_item (GtkRecentManager *manager,
           const gchar *uri,
           GError **error);
GtkRecentInfo * gtk_recent_manager_lookup_item (GtkRecentManager *manager,
           const gchar *uri,
           GError **error);
gboolean gtk_recent_manager_has_item (GtkRecentManager *manager,
           const gchar *uri);
gboolean gtk_recent_manager_move_item (GtkRecentManager *manager,
           const gchar *uri,
           const gchar *new_uri,
           GError **error);
void gtk_recent_manager_set_limit (GtkRecentManager *manager,
           gint limit);
gint gtk_recent_manager_get_limit (GtkRecentManager *manager);
GList * gtk_recent_manager_get_items (GtkRecentManager *manager);
gint gtk_recent_manager_purge_items (GtkRecentManager *manager,
           GError **error);
GType gtk_recent_info_get_type (void) __attribute__((__const__));
GtkRecentInfo * gtk_recent_info_ref (GtkRecentInfo *info);
void gtk_recent_info_unref (GtkRecentInfo *info);
const gchar *gtk_recent_info_get_uri (GtkRecentInfo *info);
const gchar *gtk_recent_info_get_display_name (GtkRecentInfo *info);
const gchar *gtk_recent_info_get_description (GtkRecentInfo *info);
const gchar *gtk_recent_info_get_mime_type (GtkRecentInfo *info);
time_t gtk_recent_info_get_added (GtkRecentInfo *info);
time_t gtk_recent_info_get_modified (GtkRecentInfo *info);
time_t gtk_recent_info_get_visited (GtkRecentInfo *info);
gboolean gtk_recent_info_get_private_hint (GtkRecentInfo *info);
gboolean gtk_recent_info_get_application_info (GtkRecentInfo *info,
           const gchar *app_name,
           gchar **app_exec,
           guint *count,
           time_t *time_);
gchar ** gtk_recent_info_get_applications (GtkRecentInfo *info,
           gsize *length) __attribute__((__malloc__));
gchar * gtk_recent_info_last_application (GtkRecentInfo *info) __attribute__((__malloc__));
gboolean gtk_recent_info_has_application (GtkRecentInfo *info,
           const gchar *app_name);
gchar ** gtk_recent_info_get_groups (GtkRecentInfo *info,
           gsize *length) __attribute__((__malloc__));
gboolean gtk_recent_info_has_group (GtkRecentInfo *info,
           const gchar *group_name);
GdkPixbuf * gtk_recent_info_get_icon (GtkRecentInfo *info,
           gint size);
gchar * gtk_recent_info_get_short_name (GtkRecentInfo *info) __attribute__((__malloc__));
gchar * gtk_recent_info_get_uri_display (GtkRecentInfo *info) __attribute__((__malloc__));
gint gtk_recent_info_get_age (GtkRecentInfo *info);
gboolean gtk_recent_info_is_local (GtkRecentInfo *info);
gboolean gtk_recent_info_exists (GtkRecentInfo *info);
gboolean gtk_recent_info_match (GtkRecentInfo *info_a,
           GtkRecentInfo *info_b);
void _gtk_recent_manager_sync (void);
}
extern "C" {
typedef struct _GtkRecentFilter GtkRecentFilter;
typedef struct _GtkRecentFilterInfo GtkRecentFilterInfo;
typedef enum {
  GTK_RECENT_FILTER_URI = 1 << 0,
  GTK_RECENT_FILTER_DISPLAY_NAME = 1 << 1,
  GTK_RECENT_FILTER_MIME_TYPE = 1 << 2,
  GTK_RECENT_FILTER_APPLICATION = 1 << 3,
  GTK_RECENT_FILTER_GROUP = 1 << 4,
  GTK_RECENT_FILTER_AGE = 1 << 5
} GtkRecentFilterFlags;
typedef gboolean (*GtkRecentFilterFunc) (const GtkRecentFilterInfo *filter_info,
      gpointer user_data);
struct _GtkRecentFilterInfo
{
  GtkRecentFilterFlags contains;
  const gchar *uri;
  const gchar *display_name;
  const gchar *mime_type;
  const gchar **applications;
  const gchar **groups;
  gint age;
};
GType gtk_recent_filter_get_type (void) __attribute__((__const__));
GtkRecentFilter * gtk_recent_filter_new (void);
void gtk_recent_filter_set_name (GtkRecentFilter *filter,
        const gchar *name);
const gchar *gtk_recent_filter_get_name (GtkRecentFilter *filter);
void gtk_recent_filter_add_mime_type (GtkRecentFilter *filter,
        const gchar *mime_type);
void gtk_recent_filter_add_pattern (GtkRecentFilter *filter,
        const gchar *pattern);
void gtk_recent_filter_add_pixbuf_formats (GtkRecentFilter *filter);
void gtk_recent_filter_add_application (GtkRecentFilter *filter,
        const gchar *application);
void gtk_recent_filter_add_group (GtkRecentFilter *filter,
        const gchar *group);
void gtk_recent_filter_add_age (GtkRecentFilter *filter,
        gint days);
void gtk_recent_filter_add_custom (GtkRecentFilter *filter,
        GtkRecentFilterFlags needed,
        GtkRecentFilterFunc func,
        gpointer data,
        GDestroyNotify data_destroy);
GtkRecentFilterFlags gtk_recent_filter_get_needed (GtkRecentFilter *filter);
gboolean gtk_recent_filter_filter (GtkRecentFilter *filter,
         const GtkRecentFilterInfo *filter_info);
}
extern "C" {
typedef enum
{
  GTK_RECENT_SORT_NONE = 0,
  GTK_RECENT_SORT_MRU,
  GTK_RECENT_SORT_LRU,
  GTK_RECENT_SORT_CUSTOM
} GtkRecentSortType;
typedef gint (*GtkRecentSortFunc) (GtkRecentInfo *a,
       GtkRecentInfo *b,
       gpointer user_data);
typedef struct _GtkRecentChooser GtkRecentChooser;
typedef struct _GtkRecentChooserIface GtkRecentChooserIface;
typedef enum
{
  GTK_RECENT_CHOOSER_ERROR_NOT_FOUND,
  GTK_RECENT_CHOOSER_ERROR_INVALID_URI
} GtkRecentChooserError;
GQuark gtk_recent_chooser_error_quark (void);
struct _GtkRecentChooserIface
{
  GTypeInterface base_iface;
  gboolean (* set_current_uri) (GtkRecentChooser *chooser,
           const gchar *uri,
           GError **error);
  gchar * (* get_current_uri) (GtkRecentChooser *chooser);
  gboolean (* select_uri) (GtkRecentChooser *chooser,
           const gchar *uri,
           GError **error);
  void (* unselect_uri) (GtkRecentChooser *chooser,
                                            const gchar *uri);
  void (* select_all) (GtkRecentChooser *chooser);
  void (* unselect_all) (GtkRecentChooser *chooser);
  GList * (* get_items) (GtkRecentChooser *chooser);
  GtkRecentManager *(* get_recent_manager) (GtkRecentChooser *chooser);
  void (* add_filter) (GtkRecentChooser *chooser,
           GtkRecentFilter *filter);
  void (* remove_filter) (GtkRecentChooser *chooser,
           GtkRecentFilter *filter);
  GSList * (* list_filters) (GtkRecentChooser *chooser);
  void (* set_sort_func) (GtkRecentChooser *chooser,
           GtkRecentSortFunc sort_func,
           gpointer data,
           GDestroyNotify destroy);
  void (* item_activated) (GtkRecentChooser *chooser);
  void (* selection_changed) (GtkRecentChooser *chooser);
};
GType gtk_recent_chooser_get_type (void) __attribute__((__const__));
void gtk_recent_chooser_set_show_private (GtkRecentChooser *chooser,
         gboolean show_private);
gboolean gtk_recent_chooser_get_show_private (GtkRecentChooser *chooser);
void gtk_recent_chooser_set_show_not_found (GtkRecentChooser *chooser,
         gboolean show_not_found);
gboolean gtk_recent_chooser_get_show_not_found (GtkRecentChooser *chooser);
void gtk_recent_chooser_set_select_multiple (GtkRecentChooser *chooser,
         gboolean select_multiple);
gboolean gtk_recent_chooser_get_select_multiple (GtkRecentChooser *chooser);
void gtk_recent_chooser_set_limit (GtkRecentChooser *chooser,
         gint limit);
gint gtk_recent_chooser_get_limit (GtkRecentChooser *chooser);
void gtk_recent_chooser_set_local_only (GtkRecentChooser *chooser,
         gboolean local_only);
gboolean gtk_recent_chooser_get_local_only (GtkRecentChooser *chooser);
void gtk_recent_chooser_set_show_tips (GtkRecentChooser *chooser,
         gboolean show_tips);
gboolean gtk_recent_chooser_get_show_tips (GtkRecentChooser *chooser);
void gtk_recent_chooser_set_show_numbers (GtkRecentChooser *chooser,
         gboolean show_numbers);
gboolean gtk_recent_chooser_get_show_numbers (GtkRecentChooser *chooser);
void gtk_recent_chooser_set_show_icons (GtkRecentChooser *chooser,
         gboolean show_icons);
gboolean gtk_recent_chooser_get_show_icons (GtkRecentChooser *chooser);
void gtk_recent_chooser_set_sort_type (GtkRecentChooser *chooser,
         GtkRecentSortType sort_type);
GtkRecentSortType gtk_recent_chooser_get_sort_type (GtkRecentChooser *chooser);
void gtk_recent_chooser_set_sort_func (GtkRecentChooser *chooser,
         GtkRecentSortFunc sort_func,
         gpointer sort_data,
         GDestroyNotify data_destroy);
gboolean gtk_recent_chooser_set_current_uri (GtkRecentChooser *chooser,
          const gchar *uri,
          GError **error);
gchar * gtk_recent_chooser_get_current_uri (GtkRecentChooser *chooser);
GtkRecentInfo *gtk_recent_chooser_get_current_item (GtkRecentChooser *chooser);
gboolean gtk_recent_chooser_select_uri (GtkRecentChooser *chooser,
          const gchar *uri,
          GError **error);
void gtk_recent_chooser_unselect_uri (GtkRecentChooser *chooser,
                 const gchar *uri);
void gtk_recent_chooser_select_all (GtkRecentChooser *chooser);
void gtk_recent_chooser_unselect_all (GtkRecentChooser *chooser);
GList * gtk_recent_chooser_get_items (GtkRecentChooser *chooser);
gchar ** gtk_recent_chooser_get_uris (GtkRecentChooser *chooser,
          gsize *length);
void gtk_recent_chooser_add_filter (GtkRecentChooser *chooser,
          GtkRecentFilter *filter);
void gtk_recent_chooser_remove_filter (GtkRecentChooser *chooser,
         GtkRecentFilter *filter);
GSList * gtk_recent_chooser_list_filters (GtkRecentChooser *chooser);
void gtk_recent_chooser_set_filter (GtkRecentChooser *chooser,
         GtkRecentFilter *filter);
GtkRecentFilter *gtk_recent_chooser_get_filter (GtkRecentChooser *chooser);
}
typedef struct _GtkRecentFilter GtkRecentFilter;
typedef struct _GtkRecentFilterClass GtkRecentFilterClass;
namespace Gtk
{ class RecentFilter_Class; }
namespace Gtk
{
enum RecentFilterFlags
{
  RECENT_FILTER_URI = 1 << 0,
  RECENT_FILTER_DISPLAY_NAME = 1 << 1,
  RECENT_FILTER_MIME_TYPE = 1 << 2,
  RECENT_FILTER_APPLICATION = 1 << 3,
  RECENT_FILTER_GROUP = 1 << 4,
  RECENT_FILTER_AGE = 1 << 5
};
inline RecentFilterFlags operator|(RecentFilterFlags lhs, RecentFilterFlags rhs)
  { return static_cast<RecentFilterFlags>(static_cast<unsigned>(lhs) | static_cast<unsigned>(rhs)); }
inline RecentFilterFlags operator&(RecentFilterFlags lhs, RecentFilterFlags rhs)
  { return static_cast<RecentFilterFlags>(static_cast<unsigned>(lhs) & static_cast<unsigned>(rhs)); }
inline RecentFilterFlags operator^(RecentFilterFlags lhs, RecentFilterFlags rhs)
  { return static_cast<RecentFilterFlags>(static_cast<unsigned>(lhs) ^ static_cast<unsigned>(rhs)); }
inline RecentFilterFlags operator~(RecentFilterFlags flags)
  { return static_cast<RecentFilterFlags>(~static_cast<unsigned>(flags)); }
inline RecentFilterFlags& operator|=(RecentFilterFlags& lhs, RecentFilterFlags rhs)
  { return (lhs = static_cast<RecentFilterFlags>(static_cast<unsigned>(lhs) | static_cast<unsigned>(rhs))); }
inline RecentFilterFlags& operator&=(RecentFilterFlags& lhs, RecentFilterFlags rhs)
  { return (lhs = static_cast<RecentFilterFlags>(static_cast<unsigned>(lhs) & static_cast<unsigned>(rhs))); }
inline RecentFilterFlags& operator^=(RecentFilterFlags& lhs, RecentFilterFlags rhs)
  { return (lhs = static_cast<RecentFilterFlags>(static_cast<unsigned>(lhs) ^ static_cast<unsigned>(rhs))); }
}
namespace Glib
{
template <>
class Value<Gtk::RecentFilterFlags> : public Glib::Value_Flags<Gtk::RecentFilterFlags>
{
public:
  static GType value_type() __attribute__((__const__));
};
}
namespace Gtk
{
class RecentFilter : public Gtk::Object
{
  public:
  typedef RecentFilter CppObjectType;
  typedef RecentFilter_Class CppClassType;
  typedef GtkRecentFilter BaseObjectType;
  typedef GtkRecentFilterClass BaseClassType;
  virtual ~RecentFilter();
private:
  friend class RecentFilter_Class;
  static CppClassType recentfilter_class_;
  RecentFilter(const RecentFilter&);
  RecentFilter& operator=(const RecentFilter&);
protected:
  explicit RecentFilter(const Glib::ConstructParams& construct_params);
  explicit RecentFilter(GtkRecentFilter* castitem);
public:
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkRecentFilter* gobj() { return reinterpret_cast<GtkRecentFilter*>(gobject_); }
  const GtkRecentFilter* gobj() const { return reinterpret_cast<GtkRecentFilter*>(gobject_); }
public:
protected:
private:
public:
  RecentFilter();
  void set_name(const Glib::ustring& name);
  Glib::ustring get_name() const;
  void add_mime_type(const Glib::ustring& mime_type);
  void add_pattern(const Glib::ustring& pattern);
  void add_pixbuf_formats();
  void add_application(const Glib::ustring& application);
  void add_group(const Glib::ustring& group);
  void add_age(int days);
  class Info
  {
  public:
    Info();
    RecentFilterFlags contains;
    Glib::ustring uri;
    Glib::ustring display_name;
    Glib::ustring mime_type;
    std::list<Glib::ustring> applications;
    std::list<Glib::ustring> groups;
    int age;
  };
  typedef sigc::slot<bool, const Info&> SlotCustom;
  void add_custom(RecentFilterFlags needed, const SlotCustom& slot);
  RecentFilterFlags get_needed() const;
};
}
namespace Glib
{
  Gtk::RecentFilter* wrap(GtkRecentFilter* object, bool take_copy = false);
}
typedef struct _GtkRecentChooser GtkRecentChooser;
typedef struct _GtkRecentChooserClass GtkRecentChooserClass;
namespace Gtk
{ class RecentChooser_Class; }
namespace Gtk
{
enum RecentSortType
{
  RECENT_SORT_NONE,
  RECENT_SORT_MRU,
  RECENT_SORT_LRU,
  RECENT_SORT_CUSTOM
};
}
namespace Glib
{
template <>
class Value<Gtk::RecentSortType> : public Glib::Value_Enum<Gtk::RecentSortType>
{
public:
  static GType value_type() __attribute__((__const__));
};
}
namespace Gtk
{
class RecentChooserError : public Glib::Error
{
public:
  enum Code
  {
    NOT_FOUND,
    INVALID_URI
  };
  RecentChooserError(Code error_code, const Glib::ustring& error_message);
  explicit RecentChooserError(GError* gobject);
  Code code() const;
private:
  static void throw_func(GError* gobject);
  friend void wrap_init();
};
}
namespace Glib
{
template <>
class Value<Gtk::RecentChooserError::Code> : public Glib::Value_Enum<Gtk::RecentChooserError::Code>
{
public:
  static GType value_type() __attribute__((__const__));
};
}
namespace Gtk
{
class RecentChooser : public Glib::Interface
{
public:
  typedef RecentChooser CppObjectType;
  typedef RecentChooser_Class CppClassType;
  typedef GtkRecentChooser BaseObjectType;
  typedef GtkRecentChooserIface BaseClassType;
private:
  friend class RecentChooser_Class;
  static CppClassType recentchooser_class_;
  RecentChooser(const RecentChooser&);
  RecentChooser& operator=(const RecentChooser&);
protected:
  RecentChooser();
public:
  explicit RecentChooser(GtkRecentChooser* castitem);
protected:
public:
  virtual ~RecentChooser();
  static void add_interface(GType gtype_implementer);
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkRecentChooser* gobj() { return reinterpret_cast<GtkRecentChooser*>(gobject_); }
  const GtkRecentChooser* gobj() const { return reinterpret_cast<GtkRecentChooser*>(gobject_); }
private:
public:
  void set_show_private(bool show_private = true);
  bool get_show_private() const;
  void set_show_not_found(bool show_not_found = true);
  bool get_show_not_found() const;
  void set_select_multiple(bool select_multiple = true);
  bool get_select_multiple() const;
  void set_limit(int limit);
  void unset_limit();
  int get_limit() const;
  void set_local_only(bool local_only = true);
  bool get_local_only() const;
  void set_show_tips(bool show_tips = true);
  bool get_show_tips() const;
  void set_show_icons(bool show_icons = true);
  bool get_show_icons() const;
  void set_sort_type(RecentSortType sort_type);
  RecentSortType get_sort_type() const;
  typedef sigc::slot<int, const Glib::RefPtr<RecentInfo>&, const Glib::RefPtr<RecentInfo>&> SlotCompare;
  void set_sort_func(const SlotCompare& slot);
  bool set_current_uri(const Glib::ustring& uri);
  Glib::ustring get_current_uri() const;
  Glib::RefPtr<RecentInfo> get_current_item();
  Glib::RefPtr<const RecentInfo> get_current_item() const;
  bool select_uri(const Glib::ustring& uri);
  void unselect_uri(const Glib::ustring& uri);
  void select_all();
  void unselect_all();
  typedef Glib::ListHandle<RecentInfo, RecentInfoTraits> ListHandle_RecentInfos;
  ListHandle_RecentInfos get_items() const;
  Glib::StringArrayHandle get_uris() const;
  void add_filter(const RecentFilter& filter);
  void remove_filter(const RecentFilter& filter);
  Glib::SListHandle<RecentFilter*> list_filters();
  Glib::SListHandle<const RecentFilter*> list_filters() const;
  void set_filter(const RecentFilter& filter);
  RecentFilter* get_filter();
  const RecentFilter* get_filter() const;
  Glib::SignalProxy0< void > signal_selection_changed();
  Glib::SignalProxy0< void > signal_item_activated();
  Glib::PropertyProxy_ReadOnly< Glib::RefPtr<RecentManager> > property_recent_manager() const;
  Glib::PropertyProxy<bool> property_show_private() ;
  Glib::PropertyProxy_ReadOnly<bool> property_show_private() const;
  Glib::PropertyProxy<bool> property_show_tips() ;
  Glib::PropertyProxy_ReadOnly<bool> property_show_tips() const;
  Glib::PropertyProxy<bool> property_show_icons() ;
  Glib::PropertyProxy_ReadOnly<bool> property_show_icons() const;
  Glib::PropertyProxy<bool> property_show_not_found() ;
  Glib::PropertyProxy_ReadOnly<bool> property_show_not_found() const;
  Glib::PropertyProxy<bool> property_select_multiple() ;
  Glib::PropertyProxy_ReadOnly<bool> property_select_multiple() const;
  Glib::PropertyProxy<bool> property_local_only() ;
  Glib::PropertyProxy_ReadOnly<bool> property_local_only() const;
  Glib::PropertyProxy<int> property_limit() ;
  Glib::PropertyProxy_ReadOnly<int> property_limit() const;
  Glib::PropertyProxy<RecentSortType> property_sort_type() ;
  Glib::PropertyProxy_ReadOnly<RecentSortType> property_sort_type() const;
  Glib::PropertyProxy<RecentFilter*> property_filter() ;
  Glib::PropertyProxy_ReadOnly<RecentFilter*> property_filter() const;
protected:
  virtual Glib::ustring get_current_uri_vfunc() const;
  virtual void unselect_uri_vfunc(const Glib::ustring& uri);
  virtual void select_all_vfunc();
  virtual void unselect_all_vfunc();
  virtual Glib::RefPtr<RecentManager> get_recent_manager_vfunc();
  virtual void add_filter_vfunc(const RecentFilter& filter);
  virtual void remove_filter_vfunc(const RecentFilter& filter);
public:
public:
protected:
};
}
namespace Glib
{
  Glib::RefPtr<Gtk::RecentChooser> wrap(GtkRecentChooser* object, bool take_copy = false);
}
typedef struct _GtkRecentChooserDialog GtkRecentChooserDialog;
typedef struct _GtkRecentChooserDialogClass GtkRecentChooserDialogClass;
namespace Gtk
{ class RecentChooserDialog_Class; }
namespace Gtk
{
class RecentChooserDialog
  : public Dialog,
    public RecentChooser
{
  public:
  typedef RecentChooserDialog CppObjectType;
  typedef RecentChooserDialog_Class CppClassType;
  typedef GtkRecentChooserDialog BaseObjectType;
  typedef GtkRecentChooserDialogClass BaseClassType;
  virtual ~RecentChooserDialog();
private:
  friend class RecentChooserDialog_Class;
  static CppClassType recentchooserdialog_class_;
  RecentChooserDialog(const RecentChooserDialog&);
  RecentChooserDialog& operator=(const RecentChooserDialog&);
protected:
  explicit RecentChooserDialog(const Glib::ConstructParams& construct_params);
  explicit RecentChooserDialog(GtkRecentChooserDialog* castitem);
public:
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkRecentChooserDialog* gobj() { return reinterpret_cast<GtkRecentChooserDialog*>(gobject_); }
  const GtkRecentChooserDialog* gobj() const { return reinterpret_cast<GtkRecentChooserDialog*>(gobject_); }
public:
protected:
private:
public:
  explicit RecentChooserDialog(Gtk::Window& parent, const Glib::ustring& title);
  explicit RecentChooserDialog(const Glib::ustring& title);
  explicit RecentChooserDialog(Gtk::Window& parent, const Glib::ustring& title, const Glib::RefPtr<RecentManager>& recent_manager);
  explicit RecentChooserDialog(const Glib::ustring& title, const Glib::RefPtr<RecentManager>& recent_manager);
};
}
namespace Glib
{
  Gtk::RecentChooserDialog* wrap(GtkRecentChooserDialog* object, bool take_copy = false);
}
typedef struct _GtkRecentChooserMenu GtkRecentChooserMenu;
typedef struct _GtkRecentChooserMenuClass GtkRecentChooserMenuClass;
namespace Gtk
{ class RecentChooserMenu_Class; }
namespace Gtk
{
class RecentChooserMenu
  : public Menu,
    public RecentChooser
{
  public:
  typedef RecentChooserMenu CppObjectType;
  typedef RecentChooserMenu_Class CppClassType;
  typedef GtkRecentChooserMenu BaseObjectType;
  typedef GtkRecentChooserMenuClass BaseClassType;
  virtual ~RecentChooserMenu();
private:
  friend class RecentChooserMenu_Class;
  static CppClassType recentchoosermenu_class_;
  RecentChooserMenu(const RecentChooserMenu&);
  RecentChooserMenu& operator=(const RecentChooserMenu&);
protected:
  explicit RecentChooserMenu(const Glib::ConstructParams& construct_params);
  explicit RecentChooserMenu(GtkRecentChooserMenu* castitem);
public:
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkRecentChooserMenu* gobj() { return reinterpret_cast<GtkRecentChooserMenu*>(gobject_); }
  const GtkRecentChooserMenu* gobj() const { return reinterpret_cast<GtkRecentChooserMenu*>(gobject_); }
public:
protected:
private:
public:
  RecentChooserMenu();
  explicit RecentChooserMenu(const Glib::RefPtr<RecentManager>& recent_manager);
  void set_show_numbers(bool show_numbers = true);
  bool get_show_numbers() const;
};
}
namespace Glib
{
  Gtk::RecentChooserMenu* wrap(GtkRecentChooserMenu* object, bool take_copy = false);
}
typedef struct _GtkRecentChooserWidget GtkRecentChooserWidget;
typedef struct _GtkRecentChooserWidgetClass GtkRecentChooserWidgetClass;
namespace Gtk
{ class RecentChooserWidget_Class; }
namespace Gtk
{
class RecentChooserWidget
: public VBox,
  public RecentChooser
{
  public:
  typedef RecentChooserWidget CppObjectType;
  typedef RecentChooserWidget_Class CppClassType;
  typedef GtkRecentChooserWidget BaseObjectType;
  typedef GtkRecentChooserWidgetClass BaseClassType;
  virtual ~RecentChooserWidget();
private:
  friend class RecentChooserWidget_Class;
  static CppClassType recentchooserwidget_class_;
  RecentChooserWidget(const RecentChooserWidget&);
  RecentChooserWidget& operator=(const RecentChooserWidget&);
protected:
  explicit RecentChooserWidget(const Glib::ConstructParams& construct_params);
  explicit RecentChooserWidget(GtkRecentChooserWidget* castitem);
public:
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkRecentChooserWidget* gobj() { return reinterpret_cast<GtkRecentChooserWidget*>(gobject_); }
  const GtkRecentChooserWidget* gobj() const { return reinterpret_cast<GtkRecentChooserWidget*>(gobject_); }
public:
protected:
private:
public:
  RecentChooserWidget();
  explicit RecentChooserWidget(const Glib::RefPtr<RecentManager>& recent_manager);
};
}
namespace Glib
{
  Gtk::RecentChooserWidget* wrap(GtkRecentChooserWidget* object, bool take_copy = false);
}
typedef struct _GtkRuler GtkRuler;
typedef struct _GtkRulerClass GtkRulerClass;
namespace Gtk
{ class Ruler_Class; }
typedef struct _GtkVRuler GtkVRuler;
typedef struct _GtkVRulerClass GtkVRulerClass;
namespace Gtk
{ class VRuler_Class; }
typedef struct _GtkHRuler GtkHRuler;
typedef struct _GtkHRulerClass GtkHRulerClass;
namespace Gtk
{ class HRuler_Class; }
namespace Gtk
{
class Ruler : public Widget
{
  public:
  typedef Ruler CppObjectType;
  typedef Ruler_Class CppClassType;
  typedef GtkRuler BaseObjectType;
  typedef GtkRulerClass BaseClassType;
  virtual ~Ruler();
private:
  friend class Ruler_Class;
  static CppClassType ruler_class_;
  Ruler(const Ruler&);
  Ruler& operator=(const Ruler&);
protected:
  explicit Ruler(const Glib::ConstructParams& construct_params);
  explicit Ruler(GtkRuler* castitem);
public:
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkRuler* gobj() { return reinterpret_cast<GtkRuler*>(gobject_); }
  const GtkRuler* gobj() const { return reinterpret_cast<GtkRuler*>(gobject_); }
public:
protected:
private:
protected:
  Ruler();
public:
  MetricType get_metric() const;
  void set_metric(MetricType metric = PIXELS);
  MetricType get_metric();
   double get_range_lower() const;
    double get_range_upper() const;
  void set_range(double lower, double upper, double position, double max_size);
  void get_range(double& lower, double& upper, double& position, double& max_size);
  void draw_ticks();
  void draw_pos();
  virtual void draw_ticks_vfunc();
  virtual void draw_pos_vfunc();
  Glib::PropertyProxy<double> property_lower() ;
  Glib::PropertyProxy_ReadOnly<double> property_lower() const;
  Glib::PropertyProxy<double> property_upper() ;
  Glib::PropertyProxy_ReadOnly<double> property_upper() const;
  Glib::PropertyProxy<double> property_position() ;
  Glib::PropertyProxy_ReadOnly<double> property_position() const;
  Glib::PropertyProxy<double> property_max_size() ;
  Glib::PropertyProxy_ReadOnly<double> property_max_size() const;
};
class VRuler : public Ruler
{
  public:
  typedef VRuler CppObjectType;
  typedef VRuler_Class CppClassType;
  typedef GtkVRuler BaseObjectType;
  typedef GtkVRulerClass BaseClassType;
  virtual ~VRuler();
private:
  friend class VRuler_Class;
  static CppClassType vruler_class_;
  VRuler(const VRuler&);
  VRuler& operator=(const VRuler&);
protected:
  explicit VRuler(const Glib::ConstructParams& construct_params);
  explicit VRuler(GtkVRuler* castitem);
public:
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkVRuler* gobj() { return reinterpret_cast<GtkVRuler*>(gobject_); }
  const GtkVRuler* gobj() const { return reinterpret_cast<GtkVRuler*>(gobject_); }
public:
protected:
private:
public:
  VRuler();
};
class HRuler : public Ruler
{
  public:
  typedef HRuler CppObjectType;
  typedef HRuler_Class CppClassType;
  typedef GtkHRuler BaseObjectType;
  typedef GtkHRulerClass BaseClassType;
  virtual ~HRuler();
private:
  friend class HRuler_Class;
  static CppClassType hruler_class_;
  HRuler(const HRuler&);
  HRuler& operator=(const HRuler&);
protected:
  explicit HRuler(const Glib::ConstructParams& construct_params);
  explicit HRuler(GtkHRuler* castitem);
public:
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkHRuler* gobj() { return reinterpret_cast<GtkHRuler*>(gobject_); }
  const GtkHRuler* gobj() const { return reinterpret_cast<GtkHRuler*>(gobject_); }
public:
protected:
private:
public:
  HRuler();
};
}
namespace Glib
{
  Gtk::Ruler* wrap(GtkRuler* object, bool take_copy = false);
}
namespace Glib
{
  Gtk::VRuler* wrap(GtkVRuler* object, bool take_copy = false);
}
namespace Glib
{
  Gtk::HRuler* wrap(GtkHRuler* object, bool take_copy = false);
}
typedef struct _GtkScale GtkScale;
typedef struct _GtkScaleClass GtkScaleClass;
namespace Gtk
{ class Scale_Class; }
typedef struct _GtkVScale GtkVScale;
typedef struct _GtkVScaleClass GtkVScaleClass;
namespace Gtk
{ class VScale_Class; }
typedef struct _GtkHScale GtkHScale;
typedef struct _GtkHScaleClass GtkHScaleClass;
namespace Gtk
{ class HScale_Class; }
namespace Gtk
{
class Scale : public Range
{
  public:
  typedef Scale CppObjectType;
  typedef Scale_Class CppClassType;
  typedef GtkScale BaseObjectType;
  typedef GtkScaleClass BaseClassType;
  virtual ~Scale();
private:
  friend class Scale_Class;
  static CppClassType scale_class_;
  Scale(const Scale&);
  Scale& operator=(const Scale&);
protected:
  explicit Scale(const Glib::ConstructParams& construct_params);
  explicit Scale(GtkScale* castitem);
public:
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkScale* gobj() { return reinterpret_cast<GtkScale*>(gobject_); }
  const GtkScale* gobj() const { return reinterpret_cast<GtkScale*>(gobject_); }
public:
protected:
  virtual Glib::ustring on_format_value(double value);
private:
protected:
  Scale();
public:
  void set_digits(int digits);
  int get_digits() const;
  void set_draw_value(bool draw_value = true);
  bool get_draw_value() const;
  void set_value_pos(PositionType pos);
  PositionType get_value_pos() const;
  Glib::RefPtr<Pango::Layout> get_layout();
  Glib::RefPtr<const Pango::Layout> get_layout() const;
  void get_layout_offsets(int& x, int& y) const;
  Glib::SignalProxy1< Glib::ustring,double > signal_format_value();
  Glib::PropertyProxy<int> property_digits() ;
  Glib::PropertyProxy_ReadOnly<int> property_digits() const;
  Glib::PropertyProxy<bool> property_draw_value() ;
  Glib::PropertyProxy_ReadOnly<bool> property_draw_value() const;
  Glib::PropertyProxy<PositionType> property_value_pos() ;
  Glib::PropertyProxy_ReadOnly<PositionType> property_value_pos() const;
protected:
  virtual void draw_value_vfunc();
  virtual int calc_digits_(double step) const;
};
class VScale : public Scale
{
  public:
  typedef VScale CppObjectType;
  typedef VScale_Class CppClassType;
  typedef GtkVScale BaseObjectType;
  typedef GtkVScaleClass BaseClassType;
  virtual ~VScale();
private:
  friend class VScale_Class;
  static CppClassType vscale_class_;
  VScale(const VScale&);
  VScale& operator=(const VScale&);
protected:
  explicit VScale(const Glib::ConstructParams& construct_params);
  explicit VScale(GtkVScale* castitem);
public:
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkVScale* gobj() { return reinterpret_cast<GtkVScale*>(gobject_); }
  const GtkVScale* gobj() const { return reinterpret_cast<GtkVScale*>(gobject_); }
public:
protected:
private:
public:
  VScale();
  VScale(double min, double max, double step);
  explicit VScale(Adjustment& adjustment);
};
class HScale : public Scale
{
  public:
  typedef HScale CppObjectType;
  typedef HScale_Class CppClassType;
  typedef GtkHScale BaseObjectType;
  typedef GtkHScaleClass BaseClassType;
  virtual ~HScale();
private:
  friend class HScale_Class;
  static CppClassType hscale_class_;
  HScale(const HScale&);
  HScale& operator=(const HScale&);
protected:
  explicit HScale(const Glib::ConstructParams& construct_params);
  explicit HScale(GtkHScale* castitem);
public:
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkHScale* gobj() { return reinterpret_cast<GtkHScale*>(gobject_); }
  const GtkHScale* gobj() const { return reinterpret_cast<GtkHScale*>(gobject_); }
public:
protected:
private:
public:
  HScale();
  HScale(double min, double max, double step);
  explicit HScale(Adjustment& adjustment);
};
}
namespace Glib
{
  Gtk::Scale* wrap(GtkScale* object, bool take_copy = false);
}
namespace Glib
{
  Gtk::VScale* wrap(GtkVScale* object, bool take_copy = false);
}
namespace Glib
{
  Gtk::HScale* wrap(GtkHScale* object, bool take_copy = false);
}
typedef struct _GtkScrollbar GtkScrollbar;
typedef struct _GtkScrollbarClass GtkScrollbarClass;
namespace Gtk
{ class Scrollbar_Class; }
typedef struct _GtkVScrollbar GtkVScrollbar;
typedef struct _GtkVScrollbarClass GtkVScrollbarClass;
namespace Gtk
{ class VScrollbar_Class; }
typedef struct _GtkHScrollbar GtkHScrollbar;
typedef struct _GtkHScrollbarClass GtkHScrollbarClass;
namespace Gtk
{ class HScrollbar_Class; }
namespace Gtk
{
class Scrollbar : public Range
{
  public:
  typedef Scrollbar CppObjectType;
  typedef Scrollbar_Class CppClassType;
  typedef GtkScrollbar BaseObjectType;
  typedef GtkScrollbarClass BaseClassType;
  virtual ~Scrollbar();
private:
  friend class Scrollbar_Class;
  static CppClassType scrollbar_class_;
  Scrollbar(const Scrollbar&);
  Scrollbar& operator=(const Scrollbar&);
protected:
  explicit Scrollbar(const Glib::ConstructParams& construct_params);
  explicit Scrollbar(GtkScrollbar* castitem);
public:
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkScrollbar* gobj() { return reinterpret_cast<GtkScrollbar*>(gobject_); }
  const GtkScrollbar* gobj() const { return reinterpret_cast<GtkScrollbar*>(gobject_); }
public:
protected:
private:
protected:
};
class VScrollbar : public Scrollbar
{
  public:
  typedef VScrollbar CppObjectType;
  typedef VScrollbar_Class CppClassType;
  typedef GtkVScrollbar BaseObjectType;
  typedef GtkVScrollbarClass BaseClassType;
  virtual ~VScrollbar();
private:
  friend class VScrollbar_Class;
  static CppClassType vscrollbar_class_;
  VScrollbar(const VScrollbar&);
  VScrollbar& operator=(const VScrollbar&);
protected:
  explicit VScrollbar(const Glib::ConstructParams& construct_params);
  explicit VScrollbar(GtkVScrollbar* castitem);
public:
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkVScrollbar* gobj() { return reinterpret_cast<GtkVScrollbar*>(gobject_); }
  const GtkVScrollbar* gobj() const { return reinterpret_cast<GtkVScrollbar*>(gobject_); }
public:
protected:
private:
public:
  VScrollbar();
  explicit VScrollbar(Adjustment& gtkadjustment);
};
class HScrollbar : public Scrollbar
{
  public:
  typedef HScrollbar CppObjectType;
  typedef HScrollbar_Class CppClassType;
  typedef GtkHScrollbar BaseObjectType;
  typedef GtkHScrollbarClass BaseClassType;
  virtual ~HScrollbar();
private:
  friend class HScrollbar_Class;
  static CppClassType hscrollbar_class_;
  HScrollbar(const HScrollbar&);
  HScrollbar& operator=(const HScrollbar&);
protected:
  explicit HScrollbar(const Glib::ConstructParams& construct_params);
  explicit HScrollbar(GtkHScrollbar* castitem);
public:
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkHScrollbar* gobj() { return reinterpret_cast<GtkHScrollbar*>(gobject_); }
  const GtkHScrollbar* gobj() const { return reinterpret_cast<GtkHScrollbar*>(gobject_); }
public:
protected:
private:
public:
  HScrollbar();
  explicit HScrollbar(Adjustment& gtkadjustment);
};
}
namespace Glib
{
  Gtk::Scrollbar* wrap(GtkScrollbar* object, bool take_copy = false);
}
namespace Glib
{
  Gtk::VScrollbar* wrap(GtkVScrollbar* object, bool take_copy = false);
}
namespace Glib
{
  Gtk::HScrollbar* wrap(GtkHScrollbar* object, bool take_copy = false);
}
typedef struct _GtkScrolledWindow GtkScrolledWindow;
typedef struct _GtkScrolledWindowClass GtkScrolledWindowClass;
namespace Gtk
{ class ScrolledWindow_Class; }
namespace Gtk
{
class Adjustment;
class HScrollbar;
class VScrollbar;
class ScrolledWindow : public Bin
{
  public:
  typedef ScrolledWindow CppObjectType;
  typedef ScrolledWindow_Class CppClassType;
  typedef GtkScrolledWindow BaseObjectType;
  typedef GtkScrolledWindowClass BaseClassType;
  virtual ~ScrolledWindow();
private:
  friend class ScrolledWindow_Class;
  static CppClassType scrolledwindow_class_;
  ScrolledWindow(const ScrolledWindow&);
  ScrolledWindow& operator=(const ScrolledWindow&);
protected:
  explicit ScrolledWindow(const Glib::ConstructParams& construct_params);
  explicit ScrolledWindow(GtkScrolledWindow* castitem);
public:
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkScrolledWindow* gobj() { return reinterpret_cast<GtkScrolledWindow*>(gobject_); }
  const GtkScrolledWindow* gobj() const { return reinterpret_cast<GtkScrolledWindow*>(gobject_); }
public:
protected:
private:
public:
  ScrolledWindow();
  explicit ScrolledWindow(Adjustment& hadjustment, Adjustment& vadjustment);
  void set_hadjustment(Gtk::Adjustment* hadjustment = 0);
  void set_vadjustment(Gtk::Adjustment* vadjustment = 0);
  void set_hadjustment(Gtk::Adjustment& hadjustment);
  void set_vadjustment(Gtk::Adjustment& vadjustment);
  Gtk::Adjustment* get_hadjustment();
  const Gtk::Adjustment* get_hadjustment() const;
  Gtk::Adjustment* get_vadjustment();
  const Gtk::Adjustment* get_vadjustment() const;
  void set_policy(PolicyType hscrollbar_policy, PolicyType vscrollbar_policy);
  void get_policy(PolicyType& hscrollbar_policy, PolicyType& vscrollbar_policy) const;
  void set_placement(CornerType window_placement);
  void unset_placement();
  CornerType get_placement() const;
  void set_shadow_type(ShadowType type);
  ShadowType get_shadow_type() const;
  virtual void add(Gtk::Widget& widget);
  VScrollbar* get_vscrollbar();
  const VScrollbar* get_vscrollbar() const;
  HScrollbar* get_hscrollbar();
  const HScrollbar* get_hscrollbar() const;
   bool get_vscrollbar_visible() const;
    bool get_hscrollbar_visible() const;
  Glib::PropertyProxy<Gtk::Adjustment*> property_hadjustment() ;
  Glib::PropertyProxy_ReadOnly<Gtk::Adjustment*> property_hadjustment() const;
  Glib::PropertyProxy<Gtk::Adjustment*> property_vadjustment() ;
  Glib::PropertyProxy_ReadOnly<Gtk::Adjustment*> property_vadjustment() const;
  Glib::PropertyProxy<PolicyType> property_hscrollbar_policy() ;
  Glib::PropertyProxy_ReadOnly<PolicyType> property_hscrollbar_policy() const;
  Glib::PropertyProxy<PolicyType> property_vscrollbar_policy() ;
  Glib::PropertyProxy_ReadOnly<PolicyType> property_vscrollbar_policy() const;
  Glib::PropertyProxy<CornerType> property_window_placement() ;
  Glib::PropertyProxy_ReadOnly<CornerType> property_window_placement() const;
  Glib::PropertyProxy<ShadowType> property_shadow_type() ;
  Glib::PropertyProxy_ReadOnly<ShadowType> property_shadow_type() const;
};
}
namespace Glib
{
  Gtk::ScrolledWindow* wrap(GtkScrolledWindow* object, bool take_copy = false);
}
typedef struct _GtkSeparator GtkSeparator;
typedef struct _GtkSeparatorClass GtkSeparatorClass;
namespace Gtk
{ class Separator_Class; }
typedef struct _GtkVSeparator GtkVSeparator;
typedef struct _GtkVSeparatorClass GtkVSeparatorClass;
namespace Gtk
{ class VSeparator_Class; }
typedef struct _GtkHSeparator GtkHSeparator;
typedef struct _GtkHSeparatorClass GtkHSeparatorClass;
namespace Gtk
{ class HSeparator_Class; }
namespace Gtk
{
class Separator : public Widget
{
  public:
  typedef Separator CppObjectType;
  typedef Separator_Class CppClassType;
  typedef GtkSeparator BaseObjectType;
  typedef GtkSeparatorClass BaseClassType;
  virtual ~Separator();
private:
  friend class Separator_Class;
  static CppClassType separator_class_;
  Separator(const Separator&);
  Separator& operator=(const Separator&);
protected:
  explicit Separator(const Glib::ConstructParams& construct_params);
  explicit Separator(GtkSeparator* castitem);
public:
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkSeparator* gobj() { return reinterpret_cast<GtkSeparator*>(gobject_); }
  const GtkSeparator* gobj() const { return reinterpret_cast<GtkSeparator*>(gobject_); }
public:
protected:
private:
public:
protected:
  Separator();
};
class VSeparator : public Separator
{
  public:
  typedef VSeparator CppObjectType;
  typedef VSeparator_Class CppClassType;
  typedef GtkVSeparator BaseObjectType;
  typedef GtkVSeparatorClass BaseClassType;
  virtual ~VSeparator();
private:
  friend class VSeparator_Class;
  static CppClassType vseparator_class_;
  VSeparator(const VSeparator&);
  VSeparator& operator=(const VSeparator&);
protected:
  explicit VSeparator(const Glib::ConstructParams& construct_params);
  explicit VSeparator(GtkVSeparator* castitem);
public:
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkVSeparator* gobj() { return reinterpret_cast<GtkVSeparator*>(gobject_); }
  const GtkVSeparator* gobj() const { return reinterpret_cast<GtkVSeparator*>(gobject_); }
public:
protected:
private:
public:
  VSeparator();
};
class HSeparator : public Separator
{
  public:
  typedef HSeparator CppObjectType;
  typedef HSeparator_Class CppClassType;
  typedef GtkHSeparator BaseObjectType;
  typedef GtkHSeparatorClass BaseClassType;
  virtual ~HSeparator();
private:
  friend class HSeparator_Class;
  static CppClassType hseparator_class_;
  HSeparator(const HSeparator&);
  HSeparator& operator=(const HSeparator&);
protected:
  explicit HSeparator(const Glib::ConstructParams& construct_params);
  explicit HSeparator(GtkHSeparator* castitem);
public:
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkHSeparator* gobj() { return reinterpret_cast<GtkHSeparator*>(gobject_); }
  const GtkHSeparator* gobj() const { return reinterpret_cast<GtkHSeparator*>(gobject_); }
public:
protected:
private:
public:
  HSeparator();
};
}
namespace Glib
{
  Gtk::Separator* wrap(GtkSeparator* object, bool take_copy = false);
}
namespace Glib
{
  Gtk::VSeparator* wrap(GtkVSeparator* object, bool take_copy = false);
}
namespace Glib
{
  Gtk::HSeparator* wrap(GtkHSeparator* object, bool take_copy = false);
}
typedef struct _GtkSeparatorToolItem GtkSeparatorToolItem;
typedef struct _GtkSeparatorToolItemClass GtkSeparatorToolItemClass;
namespace Gtk
{ class SeparatorToolItem_Class; }
namespace Gtk
{
class SeparatorToolItem : public ToolItem
{
  public:
  typedef SeparatorToolItem CppObjectType;
  typedef SeparatorToolItem_Class CppClassType;
  typedef GtkSeparatorToolItem BaseObjectType;
  typedef GtkSeparatorToolItemClass BaseClassType;
  virtual ~SeparatorToolItem();
private:
  friend class SeparatorToolItem_Class;
  static CppClassType separatortoolitem_class_;
  SeparatorToolItem(const SeparatorToolItem&);
  SeparatorToolItem& operator=(const SeparatorToolItem&);
protected:
  explicit SeparatorToolItem(const Glib::ConstructParams& construct_params);
  explicit SeparatorToolItem(GtkSeparatorToolItem* castitem);
public:
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkSeparatorToolItem* gobj() { return reinterpret_cast<GtkSeparatorToolItem*>(gobject_); }
  const GtkSeparatorToolItem* gobj() const { return reinterpret_cast<GtkSeparatorToolItem*>(gobject_); }
public:
protected:
private:
public:
  SeparatorToolItem();
};
}
namespace Glib
{
  Gtk::SeparatorToolItem* wrap(GtkSeparatorToolItem* object, bool take_copy = false);
}
typedef struct _GtkToolbar GtkToolbar;
typedef struct _GtkToolbarClass GtkToolbarClass;
namespace Gtk
{ class Toolbar_Class; }
namespace Gtk
{
class Toolbar : public Container
{
  public:
  typedef Toolbar CppObjectType;
  typedef Toolbar_Class CppClassType;
  typedef GtkToolbar BaseObjectType;
  typedef GtkToolbarClass BaseClassType;
  virtual ~Toolbar();
private:
  friend class Toolbar_Class;
  static CppClassType toolbar_class_;
  Toolbar(const Toolbar&);
  Toolbar& operator=(const Toolbar&);
protected:
  explicit Toolbar(const Glib::ConstructParams& construct_params);
  explicit Toolbar(GtkToolbar* castitem);
public:
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkToolbar* gobj() { return reinterpret_cast<GtkToolbar*>(gobject_); }
  const GtkToolbar* gobj() const { return reinterpret_cast<GtkToolbar*>(gobject_); }
public:
protected:
  virtual void on_orientation_changed(Orientation orientation);
  virtual void on_toolbar_style_changed(ToolbarStyle style);
  virtual bool on_popup_context_menu(int x, int y, int button_number);
private:
public:
  Toolbar();
  void insert(ToolItem& item, int pos);
  void insert(ToolButton& item, int pos, const sigc::slot<void>& clicked_slot);
  void insert(ToggleToolButton& item, int pos, const sigc::slot<void>& toggled_slot);
  void append(ToolItem& item);
  void append(ToolButton& item, const sigc::slot<void>& clicked_slot);
  void append(ToggleToolButton& item, const sigc::slot<void>& toggled_slot);
  void prepend(ToolItem& item);
  void prepend(ToolButton& item, const sigc::slot<void>& clicked_slot);
  void prepend(ToggleToolButton& item, const sigc::slot<void>& toggled_slot);
  int get_item_index(const ToolItem& item) const;
  int get_n_items() const;
  ToolItem* get_nth_item(int n);
  const ToolItem* get_nth_item(int n) const;
  bool get_show_arrow() const;
  void set_show_arrow(bool show_arrow = true);
  void set_orientation(Orientation orientation);
  Orientation get_orientation() const;
  void set_toolbar_style(ToolbarStyle style);
  ToolbarStyle get_toolbar_style() const;
  void set_tooltips(bool enable = true);
  bool get_tooltips() const;
  void unset_toolbar_style();
  void set_icon_size(IconSize icon_size);
  void unset_icon_size();
  IconSize get_icon_size() const;
  ReliefStyle get_relief_style() const;
  int get_drop_index(int x, int y) const;
  void set_drop_highlight_item(ToolItem& tool_item, int index);
  void unset_drop_highlight_item();
  Glib::SignalProxy1< void,Orientation > signal_orientation_changed();
  Glib::SignalProxy1< void,ToolbarStyle > signal_toolbar_style_changed();
  Glib::SignalProxy3< bool,int,int,int > signal_popup_context_menu();
  Tooltips* get_tooltips_object() const;
  Glib::PropertyProxy<Orientation> property_orientation() ;
  Glib::PropertyProxy_ReadOnly<Orientation> property_orientation() const;
  Glib::PropertyProxy<ToolbarStyle> property_toolbar_style() ;
  Glib::PropertyProxy_ReadOnly<ToolbarStyle> property_toolbar_style() const;
  Glib::PropertyProxy<bool> property_show_arrow() ;
  Glib::PropertyProxy_ReadOnly<bool> property_show_arrow() const;
};
}
namespace Glib
{
  Gtk::Toolbar* wrap(GtkToolbar* object, bool take_copy = false);
}
typedef struct _GtkSettings GtkSettings;
typedef struct _GtkSettingsClass GtkSettingsClass;
namespace Gtk
{ class Settings_Class; }
namespace Gtk
{
class Settings : public Glib::Object
{
public:
  typedef Settings CppObjectType;
  typedef Settings_Class CppClassType;
  typedef GtkSettings BaseObjectType;
  typedef GtkSettingsClass BaseClassType;
private: friend class Settings_Class;
  static CppClassType settings_class_;
private:
  Settings(const Settings&);
  Settings& operator=(const Settings&);
protected:
  explicit Settings(const Glib::ConstructParams& construct_params);
  explicit Settings(GtkSettings* castitem);
public:
  virtual ~Settings();
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkSettings* gobj() { return reinterpret_cast<GtkSettings*>(gobject_); }
  const GtkSettings* gobj() const { return reinterpret_cast<GtkSettings*>(gobject_); }
  GtkSettings* gobj_copy();
private:
protected:
public:
  static Glib::RefPtr<Settings> get_default();
  static Glib::RefPtr<Settings> get_for_screen(const Glib::RefPtr<Gdk::Screen>& screen);
  Glib::PropertyProxy<int> property_gtk_double_click_time() ;
  Glib::PropertyProxy_ReadOnly<int> property_gtk_double_click_time() const;
  Glib::PropertyProxy<int> property_gtk_double_click_distance() ;
  Glib::PropertyProxy_ReadOnly<int> property_gtk_double_click_distance() const;
  Glib::PropertyProxy<bool> property_gtk_cursor_blink() ;
  Glib::PropertyProxy_ReadOnly<bool> property_gtk_cursor_blink() const;
  Glib::PropertyProxy<int> property_gtk_cursor_blink_time() ;
  Glib::PropertyProxy_ReadOnly<int> property_gtk_cursor_blink_time() const;
  Glib::PropertyProxy<bool> property_gtk_split_cursor() ;
  Glib::PropertyProxy_ReadOnly<bool> property_gtk_split_cursor() const;
  Glib::PropertyProxy<Glib::ustring> property_gtk_theme_name() ;
  Glib::PropertyProxy_ReadOnly<Glib::ustring> property_gtk_theme_name() const;
  Glib::PropertyProxy<Glib::ustring> property_gtk_key_theme_name() ;
  Glib::PropertyProxy_ReadOnly<Glib::ustring> property_gtk_key_theme_name() const;
  Glib::PropertyProxy<Glib::ustring> property_gtk_menu_bar_accel() ;
  Glib::PropertyProxy_ReadOnly<Glib::ustring> property_gtk_menu_bar_accel() const;
  Glib::PropertyProxy<int> property_gtk_dnd_drag_threshold() ;
  Glib::PropertyProxy_ReadOnly<int> property_gtk_dnd_drag_threshold() const;
  Glib::PropertyProxy<Glib::ustring> property_gtk_font_name() ;
  Glib::PropertyProxy_ReadOnly<Glib::ustring> property_gtk_font_name() const;
  Glib::PropertyProxy<Glib::ustring> property_gtk_modules() ;
  Glib::PropertyProxy_ReadOnly<Glib::ustring> property_gtk_modules() const;
  Glib::PropertyProxy<int> property_gtk_xft_antialias() ;
  Glib::PropertyProxy_ReadOnly<int> property_gtk_xft_antialias() const;
  Glib::PropertyProxy<int> property_gtk_xft_hinting() ;
  Glib::PropertyProxy_ReadOnly<int> property_gtk_xft_hinting() const;
  Glib::PropertyProxy<Glib::ustring> property_gtk_xft_hintstyle() ;
  Glib::PropertyProxy_ReadOnly<Glib::ustring> property_gtk_xft_hintstyle() const;
  Glib::PropertyProxy<Glib::ustring> property_gtk_xft_rgba() ;
  Glib::PropertyProxy_ReadOnly<Glib::ustring> property_gtk_xft_rgba() const;
  Glib::PropertyProxy<int> property_gtk_xft_dpi() ;
  Glib::PropertyProxy_ReadOnly<int> property_gtk_xft_dpi() const;
  Glib::PropertyProxy<Glib::ustring> property_gtk_cursor_theme_name() ;
  Glib::PropertyProxy_ReadOnly<Glib::ustring> property_gtk_cursor_theme_name() const;
  Glib::PropertyProxy<int> property_gtk_cursor_theme_size() ;
  Glib::PropertyProxy_ReadOnly<int> property_gtk_cursor_theme_size() const;
  Glib::PropertyProxy<bool> property_gtk_alternative_button_order() ;
  Glib::PropertyProxy_ReadOnly<bool> property_gtk_alternative_button_order() const;
  Glib::PropertyProxy<bool> property_gtk_alternative_sort_arrows() ;
  Glib::PropertyProxy_ReadOnly<bool> property_gtk_alternative_sort_arrows() const;
  Glib::PropertyProxy<bool> property_gtk_show_input_method_menu() ;
  Glib::PropertyProxy_ReadOnly<bool> property_gtk_show_input_method_menu() const;
  Glib::PropertyProxy<bool> property_gtk_show_unicode_menu() ;
  Glib::PropertyProxy_ReadOnly<bool> property_gtk_show_unicode_menu() const;
  Glib::PropertyProxy<int> property_gtk_timeout_initial() ;
  Glib::PropertyProxy_ReadOnly<int> property_gtk_timeout_initial() const;
  Glib::PropertyProxy<int> property_gtk_timeout_repeat() ;
  Glib::PropertyProxy_ReadOnly<int> property_gtk_timeout_repeat() const;
  Glib::PropertyProxy<int> property_gtk_timeout_expand() ;
  Glib::PropertyProxy_ReadOnly<int> property_gtk_timeout_expand() const;
  Glib::PropertyProxy<Glib::ustring> property_gtk_color_scheme() ;
  Glib::PropertyProxy_ReadOnly<Glib::ustring> property_gtk_color_scheme() const;
  Glib::PropertyProxy<bool> property_gtk_enable_animations() ;
  Glib::PropertyProxy_ReadOnly<bool> property_gtk_enable_animations() const;
  Glib::PropertyProxy<bool> property_gtk_touchscreen_mode() ;
  Glib::PropertyProxy_ReadOnly<bool> property_gtk_touchscreen_mode() const;
  Glib::PropertyProxy<int> property_gtk_tooltip_timeout() ;
  Glib::PropertyProxy_ReadOnly<int> property_gtk_tooltip_timeout() const;
  Glib::PropertyProxy<int> property_gtk_tooltip_browse_timeout() ;
  Glib::PropertyProxy_ReadOnly<int> property_gtk_tooltip_browse_timeout() const;
  Glib::PropertyProxy<int> property_gtk_tooltip_browse_mode_timeout() ;
  Glib::PropertyProxy_ReadOnly<int> property_gtk_tooltip_browse_mode_timeout() const;
  Glib::PropertyProxy<bool> property_gtk_keynav_cursor_only() ;
  Glib::PropertyProxy_ReadOnly<bool> property_gtk_keynav_cursor_only() const;
  Glib::PropertyProxy<bool> property_gtk_keynav_wrap_around() ;
  Glib::PropertyProxy_ReadOnly<bool> property_gtk_keynav_wrap_around() const;
  Glib::PropertyProxy<bool> property_gtk_error_bell() ;
  Glib::PropertyProxy_ReadOnly<bool> property_gtk_error_bell() const;
  Glib::PropertyProxy<Glib::ustring> property_gtk_file_chooser_backend() ;
  Glib::PropertyProxy_ReadOnly<Glib::ustring> property_gtk_file_chooser_backend() const;
  Glib::PropertyProxy<Glib::ustring> property_gtk_print_backends() ;
  Glib::PropertyProxy_ReadOnly<Glib::ustring> property_gtk_print_backends() const;
  Glib::PropertyProxy<Glib::ustring> property_gtk_print_preview_command() ;
  Glib::PropertyProxy_ReadOnly<Glib::ustring> property_gtk_print_preview_command() const;
  Glib::PropertyProxy<bool> property_gtk_enable_mnemonics() ;
  Glib::PropertyProxy_ReadOnly<bool> property_gtk_enable_mnemonics() const;
  Glib::PropertyProxy<bool> property_gtk_enable_accels() ;
  Glib::PropertyProxy_ReadOnly<bool> property_gtk_enable_accels() const;
  Glib::PropertyProxy<ToolbarStyle> property_gtk_toolbar_style() ;
  Glib::PropertyProxy_ReadOnly<ToolbarStyle> property_gtk_toolbar_style() const;
  Glib::PropertyProxy<IconSize> property_gtk_toolbar_icon_size() ;
  Glib::PropertyProxy_ReadOnly<IconSize> property_gtk_toolbar_icon_size() const;
  Glib::PropertyProxy<bool> property_gtk_can_change_accels() ;
  Glib::PropertyProxy_ReadOnly<bool> property_gtk_can_change_accels() const;
  Glib::PropertyProxy<bool> property_gtk_entry_select_on_focus() ;
  Glib::PropertyProxy_ReadOnly<bool> property_gtk_entry_select_on_focus() const;
  Glib::PropertyProxy<Glib::ustring> property_gtk_color_palette() ;
  Glib::PropertyProxy_ReadOnly<Glib::ustring> property_gtk_color_palette() const;
  Glib::PropertyProxy<bool> property_gtk_button_images() ;
  Glib::PropertyProxy_ReadOnly<bool> property_gtk_button_images() const;
  Glib::PropertyProxy<Glib::ustring> property_gtk_icon_theme_name() ;
  Glib::PropertyProxy_ReadOnly<Glib::ustring> property_gtk_icon_theme_name() const;
  Glib::PropertyProxy<Glib::ustring> property_gtk_icon_sizes() ;
  Glib::PropertyProxy_ReadOnly<Glib::ustring> property_gtk_icon_sizes() const;
public:
public:
protected:
};
}
namespace Glib
{
  Glib::RefPtr<Gtk::Settings> wrap(GtkSettings* object, bool take_copy = false);
}
typedef struct _GtkSizeGroup GtkSizeGroup;
typedef struct _GtkSizeGroupClass GtkSizeGroupClass;
namespace Gtk
{ class SizeGroup_Class; }
namespace Gtk
{
enum SizeGroupMode
{
  SIZE_GROUP_NONE,
  SIZE_GROUP_HORIZONTAL,
  SIZE_GROUP_VERTICAL,
  SIZE_GROUP_BOTH
};
}
namespace Glib
{
template <>
class Value<Gtk::SizeGroupMode> : public Glib::Value_Enum<Gtk::SizeGroupMode>
{
public:
  static GType value_type() __attribute__((__const__));
};
}
namespace Gtk
{
class SizeGroup : public Glib::Object
{
public:
  typedef SizeGroup CppObjectType;
  typedef SizeGroup_Class CppClassType;
  typedef GtkSizeGroup BaseObjectType;
  typedef GtkSizeGroupClass BaseClassType;
private: friend class SizeGroup_Class;
  static CppClassType sizegroup_class_;
private:
  SizeGroup(const SizeGroup&);
  SizeGroup& operator=(const SizeGroup&);
protected:
  explicit SizeGroup(const Glib::ConstructParams& construct_params);
  explicit SizeGroup(GtkSizeGroup* castitem);
public:
  virtual ~SizeGroup();
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkSizeGroup* gobj() { return reinterpret_cast<GtkSizeGroup*>(gobject_); }
  const GtkSizeGroup* gobj() const { return reinterpret_cast<GtkSizeGroup*>(gobject_); }
  GtkSizeGroup* gobj_copy();
private:
protected:
  explicit SizeGroup(SizeGroupMode mode);
public:
  static Glib::RefPtr<SizeGroup> create(SizeGroupMode mode);
  void set_mode(SizeGroupMode mode);
  SizeGroupMode get_mode() const;
  void set_ignore_hidden(bool ignore_hidden = true);
  bool get_ignore_hidden() const;
  void add_widget(Widget& widget);
  void remove_widget(Widget& widget);
  Glib::SListHandle<Widget*> get_widgets();
  Glib::SListHandle<const Widget*> get_widgets() const;
  Glib::PropertyProxy<SizeGroupMode> property_mode() ;
  Glib::PropertyProxy_ReadOnly<SizeGroupMode> property_mode() const;
  Glib::PropertyProxy<bool> property_ignore_hidden() ;
  Glib::PropertyProxy_ReadOnly<bool> property_ignore_hidden() const;
public:
public:
protected:
};
}
namespace Glib
{
  Glib::RefPtr<Gtk::SizeGroup> wrap(GtkSizeGroup* object, bool take_copy = false);
}
typedef struct _GtkSpinButton GtkSpinButton;
typedef struct _GtkSpinButtonClass GtkSpinButtonClass;
namespace Gtk
{ class SpinButton_Class; }
namespace Gtk
{
enum SpinButtonUpdatePolicy
{
  UPDATE_ALWAYS,
  UPDATE_IF_VALID
};
}
namespace Glib
{
template <>
class Value<Gtk::SpinButtonUpdatePolicy> : public Glib::Value_Enum<Gtk::SpinButtonUpdatePolicy>
{
public:
  static GType value_type() __attribute__((__const__));
};
}
namespace Gtk
{
enum SpinType
{
  SPIN_STEP_FORWARD,
  SPIN_STEP_BACKWARD,
  SPIN_PAGE_FORWARD,
  SPIN_PAGE_BACKWARD,
  SPIN_HOME,
  SPIN_END,
  SPIN_USER_DEFINED
};
}
namespace Glib
{
template <>
class Value<Gtk::SpinType> : public Glib::Value_Enum<Gtk::SpinType>
{
public:
  static GType value_type() __attribute__((__const__));
};
}
namespace Gtk
{
enum { INPUT_ERROR = -1 };
class Adjustment;
class SpinButton : public Entry
{
  public:
  typedef SpinButton CppObjectType;
  typedef SpinButton_Class CppClassType;
  typedef GtkSpinButton BaseObjectType;
  typedef GtkSpinButtonClass BaseClassType;
  virtual ~SpinButton();
private:
  friend class SpinButton_Class;
  static CppClassType spinbutton_class_;
  SpinButton(const SpinButton&);
  SpinButton& operator=(const SpinButton&);
protected:
  explicit SpinButton(const Glib::ConstructParams& construct_params);
  explicit SpinButton(GtkSpinButton* castitem);
public:
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkSpinButton* gobj() { return reinterpret_cast<GtkSpinButton*>(gobject_); }
  const GtkSpinButton* gobj() const { return reinterpret_cast<GtkSpinButton*>(gobject_); }
public:
protected:
  virtual int on_input(double* new_value);
  virtual bool on_output();
  virtual void on_value_changed();
private:
public:
  SpinButton(double climb_rate = 0.0, guint digits = 0);
  explicit SpinButton(Adjustment& adjustment, double climb_rate = 0.0, guint digits = 0);
  void configure(Adjustment& adjustment, double climb_rate, guint digits);
  void set_adjustment(Adjustment& adjustment);
  void unset_adjustment();
  Gtk::Adjustment* get_adjustment();
  const Gtk::Adjustment* get_adjustment() const;
  void set_digits(guint digits);
  guint get_digits() const;
  void set_increments(double step, double page);
  void get_increments(double& step, double& page) const;
  void set_range(double min, double max);
  void get_range(double& min, double& max) const;
  double get_value() const;
  int get_value_as_int() const;
  void set_value(double value);
  void set_update_policy(SpinButtonUpdatePolicy policy);
  SpinButtonUpdatePolicy get_update_policy() const;
  void set_numeric(bool numeric = true);
  bool get_numeric() const;
  void spin(SpinType direction, double increment);
  void set_wrap(bool wrap = true);
  bool get_wrap() const;
  void set_snap_to_ticks(bool snap_to_ticks = true);
  bool get_snap_to_ticks() const;
  void update();
  Glib::SignalProxy1< int,double* > signal_input();
  Glib::SignalProxy0< bool > signal_output();
  Glib::SignalProxy0< bool > signal_wrapped();
  Glib::SignalProxy0< void > signal_value_changed();
  Glib::PropertyProxy<Gtk::Adjustment*> property_adjustment() ;
  Glib::PropertyProxy_ReadOnly<Gtk::Adjustment*> property_adjustment() const;
  Glib::PropertyProxy<double> property_climb_rate() ;
  Glib::PropertyProxy_ReadOnly<double> property_climb_rate() const;
  Glib::PropertyProxy<guint> property_digits() ;
  Glib::PropertyProxy_ReadOnly<guint> property_digits() const;
  Glib::PropertyProxy<bool> property_snap_to_ticks() ;
  Glib::PropertyProxy_ReadOnly<bool> property_snap_to_ticks() const;
  Glib::PropertyProxy<bool> property_numeric() ;
  Glib::PropertyProxy_ReadOnly<bool> property_numeric() const;
  Glib::PropertyProxy<bool> property_wrap() ;
  Glib::PropertyProxy_ReadOnly<bool> property_wrap() const;
  Glib::PropertyProxy<SpinButtonUpdatePolicy> property_update_policy() ;
  Glib::PropertyProxy_ReadOnly<SpinButtonUpdatePolicy> property_update_policy() const;
  Glib::PropertyProxy<double> property_value() ;
  Glib::PropertyProxy_ReadOnly<double> property_value() const;
};
}
namespace Glib
{
  Gtk::SpinButton* wrap(GtkSpinButton* object, bool take_copy = false);
}
typedef struct _GtkStatusbar GtkStatusbar;
typedef struct _GtkStatusbarClass GtkStatusbarClass;
namespace Gtk
{ class Statusbar_Class; }
namespace Gtk
{
class Statusbar : public HBox
{
  public:
  typedef Statusbar CppObjectType;
  typedef Statusbar_Class CppClassType;
  typedef GtkStatusbar BaseObjectType;
  typedef GtkStatusbarClass BaseClassType;
  virtual ~Statusbar();
private:
  friend class Statusbar_Class;
  static CppClassType statusbar_class_;
  Statusbar(const Statusbar&);
  Statusbar& operator=(const Statusbar&);
protected:
  explicit Statusbar(const Glib::ConstructParams& construct_params);
  explicit Statusbar(GtkStatusbar* castitem);
public:
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkStatusbar* gobj() { return reinterpret_cast<GtkStatusbar*>(gobject_); }
  const GtkStatusbar* gobj() const { return reinterpret_cast<GtkStatusbar*>(gobject_); }
public:
protected:
  virtual void on_text_pushed(guint context_id, const Glib::ustring& text);
  virtual void on_text_popped(guint context_id, const Glib::ustring& text);
private:
public:
  Statusbar();
  guint get_context_id(const Glib::ustring& context_description);
  guint push(const Glib::ustring& text, guint context_id = 0);
  void pop(guint context_id = 0);
  void remove_message(guint message_id, guint context_id = 0);
  void set_has_resize_grip(bool setting = true);
  bool get_has_resize_grip() const;
  Glib::SignalProxy2< void,guint,const Glib::ustring& > signal_text_pushed();
  Glib::SignalProxy2< void,guint,const Glib::ustring& > signal_text_popped();
  Glib::PropertyProxy<bool> property_has_resize_grip() ;
  Glib::PropertyProxy_ReadOnly<bool> property_has_resize_grip() const;
};
}
namespace Glib
{
  Gtk::Statusbar* wrap(GtkStatusbar* object, bool take_copy = false);
}
typedef struct _GtkStatusIcon GtkStatusIcon;
typedef struct _GtkStatusIconClass GtkStatusIconClass;
namespace Gtk
{ class StatusIcon_Class; }
namespace Gtk
{
class StatusIcon : public Glib::Object
{
public:
  typedef StatusIcon CppObjectType;
  typedef StatusIcon_Class CppClassType;
  typedef GtkStatusIcon BaseObjectType;
  typedef GtkStatusIconClass BaseClassType;
private: friend class StatusIcon_Class;
  static CppClassType statusicon_class_;
private:
  StatusIcon(const StatusIcon&);
  StatusIcon& operator=(const StatusIcon&);
protected:
  explicit StatusIcon(const Glib::ConstructParams& construct_params);
  explicit StatusIcon(GtkStatusIcon* castitem);
public:
  virtual ~StatusIcon();
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkStatusIcon* gobj() { return reinterpret_cast<GtkStatusIcon*>(gobject_); }
  const GtkStatusIcon* gobj() const { return reinterpret_cast<GtkStatusIcon*>(gobject_); }
  GtkStatusIcon* gobj_copy();
private:
protected:
  StatusIcon();
  explicit StatusIcon(const Glib::RefPtr<Gdk::Pixbuf>& pixbuf);
  explicit StatusIcon(const StockID& stock);
  explicit StatusIcon(const Glib::ustring& icon_name);
public:
  static Glib::RefPtr<StatusIcon> create(const Glib::RefPtr<Gdk::Pixbuf>& pixbuf);
  static Glib::RefPtr<StatusIcon> create(const StockID& stock_id);
  static Glib::RefPtr<StatusIcon> create(const Glib::ustring& icon_name);
  static Glib::RefPtr<StatusIcon> create_from_file(const std::string& filename);
  void set(const Glib::RefPtr<Gdk::Pixbuf>& pixbuf);
  void set_from_file(const Glib::ustring& filename);
  void set(const StockID& stock_id);
  void set(const Glib::ustring& icon_name);
  ImageType get_storage_type() const;
  Glib::RefPtr<Gdk::Pixbuf> get_pixbuf();
  Glib::RefPtr<const Gdk::Pixbuf> get_pixbuf() const;
  StockID get_stock() const;
  Glib::ustring get_icon_name() const;
  int get_size() const;
  void set_screen(const Glib::RefPtr<Gdk::Screen>& screen);
  Glib::RefPtr<Gdk::Screen> get_screen();
  Glib::RefPtr<const Gdk::Screen> get_screen() const;
  void set_tooltip(const Glib::ustring& tooltip_text);
  void set_visible(bool visible = true);
  bool get_visible() const;
  void set_blinking(bool blinking = true);
  bool get_blinking() const;
  bool is_embedded() const;
  void popup_menu_at_position(Menu& menu, guint button, guint32 activate_time);
  bool get_geometry(Glib::RefPtr<Gdk::Screen>& screen, Gdk::Rectangle& area, Orientation& orientation);
  Glib::PropertyProxy< Glib::RefPtr<Gdk::Pixbuf> > property_pixbuf() ;
  Glib::PropertyProxy_ReadOnly< Glib::RefPtr<Gdk::Pixbuf> > property_pixbuf() const;
  Glib::PropertyProxy_WriteOnly<std::string> property_file() ;
  Glib::PropertyProxy<StockID> property_stock() ;
  Glib::PropertyProxy_ReadOnly<StockID> property_stock() const;
  Glib::PropertyProxy<Glib::ustring> property_icon_name() ;
  Glib::PropertyProxy_ReadOnly<Glib::ustring> property_icon_name() const;
  Glib::PropertyProxy_ReadOnly<ImageType> property_storage_type() const;
  Glib::PropertyProxy_ReadOnly<int> property_size() const;
  Glib::PropertyProxy<bool> property_blinking() ;
  Glib::PropertyProxy_ReadOnly<bool> property_blinking() const;
  Glib::SignalProxy1< bool,int > signal_size_changed();
  Glib::SignalProxy0< void > signal_activate();
  Glib::SignalProxy2< void,guint,guint32 > signal_popup_menu();
public:
public:
protected:
  virtual bool on_size_changed(int size);
};
}
namespace Glib
{
  Glib::RefPtr<Gtk::StatusIcon> wrap(GtkStatusIcon* object, bool take_copy = false);
}
extern "C"
{
  typedef struct _GtkStockItem GtkStockItem;
}
namespace Gtk
{
class StockItem
{
  public:
  typedef StockItem CppObjectType;
  typedef GtkStockItem BaseObjectType;
  StockItem();
  explicit StockItem(GtkStockItem* castitem, bool make_a_copy = false);
  StockItem(const StockItem& src);
  StockItem& operator=(const StockItem& src);
  ~StockItem();
  GtkStockItem* gobj() { return gobject_; }
  const GtkStockItem* gobj() const { return gobject_; }
  GtkStockItem* gobj_copy() const;
protected:
  GtkStockItem* gobject_;
private:
public:
  StockItem(const Gtk::StockID& stock_id, const Glib::ustring& label,
            Gdk::ModifierType modifier = Gdk::ModifierType(0), unsigned int keyval = 0,
            const Glib::ustring& translation_domain = Glib::ustring());
   StockID get_stock_id() const;
    Glib::ustring get_label() const;
    Gdk::ModifierType get_modifier() const;
    guint get_keyval() const;
    Glib::ustring get_translation_domain() const;
  static bool lookup(const Gtk::StockID& stock_id, Gtk::StockItem& item);
};
}
namespace Glib
{
Gtk::StockItem wrap(GtkStockItem* object, bool take_copy = false);
}
namespace Gtk
{
struct BuiltinStockID
{
  const char* id;
};
namespace Stock
{
extern const Gtk::BuiltinStockID DIALOG_AUTHENTICATION;
extern const Gtk::BuiltinStockID DIALOG_INFO;
extern const Gtk::BuiltinStockID DIALOG_WARNING;
extern const Gtk::BuiltinStockID DIALOG_ERROR;
extern const Gtk::BuiltinStockID DIALOG_QUESTION;
extern const Gtk::BuiltinStockID DND;
extern const Gtk::BuiltinStockID DND_MULTIPLE;
extern const Gtk::BuiltinStockID ABOUT;
extern const Gtk::BuiltinStockID ADD;
extern const Gtk::BuiltinStockID APPLY;
extern const Gtk::BuiltinStockID BOLD;
extern const Gtk::BuiltinStockID CANCEL;
extern const Gtk::BuiltinStockID CDROM;
extern const Gtk::BuiltinStockID CLEAR;
extern const Gtk::BuiltinStockID CLOSE;
extern const Gtk::BuiltinStockID COLOR_PICKER;
extern const Gtk::BuiltinStockID CONVERT;
extern const Gtk::BuiltinStockID CONNECT;
extern const Gtk::BuiltinStockID COPY;
extern const Gtk::BuiltinStockID CUT;
extern const Gtk::BuiltinStockID DELETE;
extern const Gtk::BuiltinStockID DIRECTORY;
extern const Gtk::BuiltinStockID DISCARD;
extern const Gtk::BuiltinStockID DISCONNECT;
extern const Gtk::BuiltinStockID EDIT;
extern const Gtk::BuiltinStockID EXECUTE;
extern const Gtk::BuiltinStockID FILE;
extern const Gtk::BuiltinStockID FIND;
extern const Gtk::BuiltinStockID FIND_AND_REPLACE;
extern const Gtk::BuiltinStockID FLOPPY;
extern const Gtk::BuiltinStockID FULLSCREEN;
extern const Gtk::BuiltinStockID LEAVE_FULLSCREEN;
extern const Gtk::BuiltinStockID GOTO_BOTTOM;
extern const Gtk::BuiltinStockID GOTO_FIRST;
extern const Gtk::BuiltinStockID GOTO_LAST;
extern const Gtk::BuiltinStockID GOTO_TOP;
extern const Gtk::BuiltinStockID GO_BACK;
extern const Gtk::BuiltinStockID GO_DOWN;
extern const Gtk::BuiltinStockID GO_FORWARD;
extern const Gtk::BuiltinStockID GO_UP;
extern const Gtk::BuiltinStockID HARDDISK;
extern const Gtk::BuiltinStockID HELP;
extern const Gtk::BuiltinStockID HOME;
extern const Gtk::BuiltinStockID INDEX;
extern const Gtk::BuiltinStockID INFO;
extern const Gtk::BuiltinStockID INDENT;
extern const Gtk::BuiltinStockID UNINDENT;
extern const Gtk::BuiltinStockID ITALIC;
extern const Gtk::BuiltinStockID JUMP_TO;
extern const Gtk::BuiltinStockID JUSTIFY_CENTER;
extern const Gtk::BuiltinStockID JUSTIFY_FILL;
extern const Gtk::BuiltinStockID JUSTIFY_LEFT;
extern const Gtk::BuiltinStockID JUSTIFY_RIGHT;
extern const Gtk::BuiltinStockID MISSING_IMAGE;
extern const Gtk::BuiltinStockID MEDIA_FORWARD;
extern const Gtk::BuiltinStockID MEDIA_NEXT;
extern const Gtk::BuiltinStockID MEDIA_PAUSE;
extern const Gtk::BuiltinStockID MEDIA_PLAY;
extern const Gtk::BuiltinStockID MEDIA_PREVIOUS;
extern const Gtk::BuiltinStockID MEDIA_RECORD;
extern const Gtk::BuiltinStockID MEDIA_REWIND;
extern const Gtk::BuiltinStockID MEDIA_STOP;
extern const Gtk::BuiltinStockID NETWORK;
extern const Gtk::BuiltinStockID NEW;
extern const Gtk::BuiltinStockID NO;
extern const Gtk::BuiltinStockID OK;
extern const Gtk::BuiltinStockID OPEN;
extern const Gtk::BuiltinStockID ORIENTATION_PORTRAIT;
extern const Gtk::BuiltinStockID ORIENTATION_LANDSCAPE;
extern const Gtk::BuiltinStockID ORIENTATION_REVERSE_LANDSCAPE;
extern const Gtk::BuiltinStockID ORIENTATION_REVERSE_PORTRAIT;
extern const Gtk::BuiltinStockID PASTE;
extern const Gtk::BuiltinStockID PREFERENCES;
extern const Gtk::BuiltinStockID PRINT;
extern const Gtk::BuiltinStockID PRINT_PREVIEW;
extern const Gtk::BuiltinStockID PROPERTIES;
extern const Gtk::BuiltinStockID QUIT;
extern const Gtk::BuiltinStockID REDO;
extern const Gtk::BuiltinStockID REFRESH;
extern const Gtk::BuiltinStockID REMOVE;
extern const Gtk::BuiltinStockID REVERT_TO_SAVED;
extern const Gtk::BuiltinStockID SAVE;
extern const Gtk::BuiltinStockID SAVE_AS;
extern const Gtk::BuiltinStockID SELECT_ALL;
extern const Gtk::BuiltinStockID SELECT_COLOR;
extern const Gtk::BuiltinStockID SELECT_FONT;
extern const Gtk::BuiltinStockID SORT_ASCENDING;
extern const Gtk::BuiltinStockID SORT_DESCENDING;
extern const Gtk::BuiltinStockID SPELL_CHECK;
extern const Gtk::BuiltinStockID STOP;
extern const Gtk::BuiltinStockID STRIKETHROUGH;
extern const Gtk::BuiltinStockID UNDELETE;
extern const Gtk::BuiltinStockID UNDERLINE;
extern const Gtk::BuiltinStockID UNDO;
extern const Gtk::BuiltinStockID YES;
extern const Gtk::BuiltinStockID ZOOM_100;
extern const Gtk::BuiltinStockID ZOOM_FIT;
extern const Gtk::BuiltinStockID ZOOM_IN;
extern const Gtk::BuiltinStockID ZOOM_OUT;
void add(const Gtk::StockItem& item);
bool lookup(const Gtk::StockID& stock_id, Gtk::StockItem& item);
bool lookup(const Gtk::StockID& stock_id, Gtk::IconSet& iconset);
bool lookup(const Gtk::StockID& stock_id, Gtk::IconSize size, Gtk::Image& image);
Glib::SListHandle<Gtk::StockID,Gtk::StockID_Traits> get_ids();
}
}
extern "C" {
typedef struct _GtkTable GtkTable;
typedef struct _GtkTableClass GtkTableClass;
typedef struct _GtkTableChild GtkTableChild;
typedef struct _GtkTableRowCol GtkTableRowCol;
struct _GtkTable
{
  GtkContainer container;
  GList *children;
  GtkTableRowCol *rows;
  GtkTableRowCol *cols;
  guint16 nrows;
  guint16 ncols;
  guint16 column_spacing;
  guint16 row_spacing;
  guint homogeneous : 1;
};
struct _GtkTableClass
{
  GtkContainerClass parent_class;
};
struct _GtkTableChild
{
  GtkWidget *widget;
  guint16 left_attach;
  guint16 right_attach;
  guint16 top_attach;
  guint16 bottom_attach;
  guint16 xpadding;
  guint16 ypadding;
  guint xexpand : 1;
  guint yexpand : 1;
  guint xshrink : 1;
  guint yshrink : 1;
  guint xfill : 1;
  guint yfill : 1;
};
struct _GtkTableRowCol
{
  guint16 requisition;
  guint16 allocation;
  guint16 spacing;
  guint need_expand : 1;
  guint need_shrink : 1;
  guint expand : 1;
  guint shrink : 1;
  guint empty : 1;
};
GType gtk_table_get_type (void) __attribute__((__const__));
GtkWidget* gtk_table_new (guint rows,
           guint columns,
           gboolean homogeneous);
void gtk_table_resize (GtkTable *table,
           guint rows,
           guint columns);
void gtk_table_attach (GtkTable *table,
           GtkWidget *child,
           guint left_attach,
           guint right_attach,
           guint top_attach,
           guint bottom_attach,
           GtkAttachOptions xoptions,
           GtkAttachOptions yoptions,
           guint xpadding,
           guint ypadding);
void gtk_table_attach_defaults (GtkTable *table,
           GtkWidget *widget,
           guint left_attach,
           guint right_attach,
           guint top_attach,
           guint bottom_attach);
void gtk_table_set_row_spacing (GtkTable *table,
           guint row,
           guint spacing);
guint gtk_table_get_row_spacing (GtkTable *table,
           guint row);
void gtk_table_set_col_spacing (GtkTable *table,
           guint column,
           guint spacing);
guint gtk_table_get_col_spacing (GtkTable *table,
           guint column);
void gtk_table_set_row_spacings (GtkTable *table,
           guint spacing);
guint gtk_table_get_default_row_spacing (GtkTable *table);
void gtk_table_set_col_spacings (GtkTable *table,
           guint spacing);
guint gtk_table_get_default_col_spacing (GtkTable *table);
void gtk_table_set_homogeneous (GtkTable *table,
           gboolean homogeneous);
gboolean gtk_table_get_homogeneous (GtkTable *table);
}
typedef struct _GtkTable GtkTable;
typedef struct _GtkTableClass GtkTableClass;
namespace Gtk
{ class Table_Class; }
namespace Gtk
{
class Table;
namespace Table_Helpers
{
class Child : protected _GtkTableChild
{
private:
  Child& operator=(const Child&);
  Child(const Child&);
public:
  inline _GtkTableChild* gobj() {return (this);}
  inline const _GtkTableChild* gobj() const {return (this);}
  Widget* get_widget() const;
  guint16 get_left_attach() const;
  guint16 get_right_attach() const;
  guint16 get_top_attach() const;
  guint16 get_bottom_attach() const;
  guint16 get_xpadding() const;
  guint16 get_ypadding() const;
  bool get_xexpand() const;
  bool get_yexpand() const;
  bool get_xshrink() const;
  bool get_yshrink() const;
  bool get_xfill() const;
  bool get_yfill() const;
protected:
  inline GtkTable* parent()
    { return (GtkTable*) (gobj()->widget->parent); }
  friend class Dummy_;
};
class TableList : public Glib::HelperList< Child, Widget, Glib::List_Iterator< Child > >
{
public:
  TableList();
  explicit TableList(GtkTable* gparent);
  TableList(const TableList& src);
  virtual ~TableList() {}
  TableList& operator=(const TableList& src);
  typedef Glib::HelperList< Child, Widget, Glib::List_Iterator< Child > > type_base;
  GtkTable* gparent();
  const GtkTable* gparent() const;
  virtual GList*& glist() const;
  virtual void erase(iterator start, iterator stop);
  virtual iterator erase(iterator);
  virtual void remove(const_reference);
  reference operator[](size_type l) const;
protected:
  iterator insert(iterator position, element_type& e);
  inline void pop_front();
  inline void pop_back();
virtual void remove(Widget& w);
  };
}
class Table : public Container
{
  public:
  typedef Table CppObjectType;
  typedef Table_Class CppClassType;
  typedef GtkTable BaseObjectType;
  typedef GtkTableClass BaseClassType;
  virtual ~Table();
private:
  friend class Table_Class;
  static CppClassType table_class_;
  Table(const Table&);
  Table& operator=(const Table&);
protected:
  explicit Table(const Glib::ConstructParams& construct_params);
  explicit Table(GtkTable* castitem);
public:
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkTable* gobj() { return reinterpret_cast<GtkTable*>(gobject_); }
  const GtkTable* gobj() const { return reinterpret_cast<GtkTable*>(gobject_); }
public:
protected:
private:
public:
  explicit Table(guint n_rows = 1, guint n_columns = 1, bool homogeneous = false);
        void attach(Widget& child,
                    guint left_attach, guint right_attach,
                    guint top_attach, guint bottom_attach,
                    AttachOptions xoptions = FILL | EXPAND, AttachOptions yoptions = FILL | EXPAND,
                    guint xpadding = 0, guint ypadding = 0);
  void resize(guint rows, guint columns);
  void set_row_spacing(guint row, guint spacing);
  guint get_row_spacing(guint row) const;
  void set_col_spacing(guint column, guint spacing);
  guint get_col_spacing(guint column) const;
  void set_row_spacings(guint spacing);
  void set_col_spacings(guint spacing);
  void set_spacings(guint spacing);
  guint get_default_row_spacing();
  guint get_default_col_spacing();
  void set_homogeneous(bool homogeneous = true);
  bool get_homogeneous() const;
  typedef Table_Helpers::TableList TableList;
  TableList& children();
  const TableList& children() const;
  Glib::PropertyProxy<guint> property_n_rows() ;
  Glib::PropertyProxy_ReadOnly<guint> property_n_rows() const;
  Glib::PropertyProxy<guint> property_n_columns() ;
  Glib::PropertyProxy_ReadOnly<guint> property_n_columns() const;
  Glib::PropertyProxy<guint> property_column_spacing() ;
  Glib::PropertyProxy_ReadOnly<guint> property_column_spacing() const;
  Glib::PropertyProxy<guint> property_row_spacing() ;
  Glib::PropertyProxy_ReadOnly<guint> property_row_spacing() const;
protected:
  mutable TableList children_proxy_;
};
}
namespace Glib
{
  Gtk::Table* wrap(GtkTable* object, bool take_copy = false);
}
typedef struct _GtkTextTag GtkTextTag;
typedef struct _GtkTextTagClass GtkTextTagClass;
namespace Gtk
{ class TextTag_Class; }
namespace Gtk
{
class TextIter;
class TextTag : public Glib::Object
{
public:
  typedef TextTag CppObjectType;
  typedef TextTag_Class CppClassType;
  typedef GtkTextTag BaseObjectType;
  typedef GtkTextTagClass BaseClassType;
private: friend class TextTag_Class;
  static CppClassType texttag_class_;
private:
  TextTag(const TextTag&);
  TextTag& operator=(const TextTag&);
protected:
  explicit TextTag(const Glib::ConstructParams& construct_params);
  explicit TextTag(GtkTextTag* castitem);
public:
  virtual ~TextTag();
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkTextTag* gobj() { return reinterpret_cast<GtkTextTag*>(gobject_); }
  const GtkTextTag* gobj() const { return reinterpret_cast<GtkTextTag*>(gobject_); }
  GtkTextTag* gobj_copy();
private:
protected:
  TextTag();
  explicit TextTag(const Glib::ustring& name);
public:
  static Glib::RefPtr<TextTag> create();
  static Glib::RefPtr<TextTag> create(const Glib::ustring& name);
  int get_priority() const;
  void set_priority(int priority);
  bool event(const Glib::RefPtr<Glib::Object>& event_object, GdkEvent* event, const TextIter& iter);
  Glib::SignalProxy3< bool,const Glib::RefPtr<Glib::Object>&,GdkEvent*,const TextIter& > signal_event();
  Glib::PropertyProxy_ReadOnly<Glib::ustring> property_name() const;
  Glib::PropertyProxy_WriteOnly<Glib::ustring> property_background() ;
  Glib::PropertyProxy_WriteOnly<Glib::ustring> property_foreground() ;
  Glib::PropertyProxy<Gdk::Color> property_background_gdk() ;
  Glib::PropertyProxy_ReadOnly<Gdk::Color> property_background_gdk() const;
  Glib::PropertyProxy<Gdk::Color> property_foreground_gdk() ;
  Glib::PropertyProxy_ReadOnly<Gdk::Color> property_foreground_gdk() const;
  Glib::PropertyProxy< Glib::RefPtr<Gdk::Bitmap> > property_background_stipple() ;
  Glib::PropertyProxy_ReadOnly< Glib::RefPtr<Gdk::Bitmap> > property_background_stipple() const;
  Glib::PropertyProxy< Glib::RefPtr<Gdk::Bitmap> > property_foreground_stipple() ;
  Glib::PropertyProxy_ReadOnly< Glib::RefPtr<Gdk::Bitmap> > property_foreground_stipple() const;
  Glib::PropertyProxy<Glib::ustring> property_font() ;
  Glib::PropertyProxy_ReadOnly<Glib::ustring> property_font() const;
  Glib::PropertyProxy<Pango::FontDescription> property_font_desc() ;
  Glib::PropertyProxy_ReadOnly<Pango::FontDescription> property_font_desc() const;
  Glib::PropertyProxy<Glib::ustring> property_family() ;
  Glib::PropertyProxy_ReadOnly<Glib::ustring> property_family() const;
  Glib::PropertyProxy<Pango::Style> property_style() ;
  Glib::PropertyProxy_ReadOnly<Pango::Style> property_style() const;
  Glib::PropertyProxy<Pango::Variant> property_variant() ;
  Glib::PropertyProxy_ReadOnly<Pango::Variant> property_variant() const;
  Glib::PropertyProxy<int> property_weight() ;
  Glib::PropertyProxy_ReadOnly<int> property_weight() const;
  Glib::PropertyProxy<Pango::Stretch> property_stretch() ;
  Glib::PropertyProxy_ReadOnly<Pango::Stretch> property_stretch() const;
  Glib::PropertyProxy<int> property_size() ;
  Glib::PropertyProxy_ReadOnly<int> property_size() const;
  Glib::PropertyProxy<double> property_size_points() ;
  Glib::PropertyProxy_ReadOnly<double> property_size_points() const;
  Glib::PropertyProxy<double> property_scale() ;
  Glib::PropertyProxy_ReadOnly<double> property_scale() const;
  Glib::PropertyProxy<int> property_pixels_above_lines() ;
  Glib::PropertyProxy_ReadOnly<int> property_pixels_above_lines() const;
  Glib::PropertyProxy<int> property_pixels_below_lines() ;
  Glib::PropertyProxy_ReadOnly<int> property_pixels_below_lines() const;
  Glib::PropertyProxy<int> property_pixels_inside_wrap() ;
  Glib::PropertyProxy_ReadOnly<int> property_pixels_inside_wrap() const;
  Glib::PropertyProxy<bool> property_editable() ;
  Glib::PropertyProxy_ReadOnly<bool> property_editable() const;
  Glib::PropertyProxy<WrapMode> property_wrap_mode() ;
  Glib::PropertyProxy_ReadOnly<WrapMode> property_wrap_mode() const;
  Glib::PropertyProxy<Justification> property_justification() ;
  Glib::PropertyProxy_ReadOnly<Justification> property_justification() const;
  Glib::PropertyProxy<TextDirection> property_direction() ;
  Glib::PropertyProxy_ReadOnly<TextDirection> property_direction() const;
  Glib::PropertyProxy<int> property_left_margin() ;
  Glib::PropertyProxy_ReadOnly<int> property_left_margin() const;
  Glib::PropertyProxy<int> property_indent() ;
  Glib::PropertyProxy_ReadOnly<int> property_indent() const;
  Glib::PropertyProxy<bool> property_strikethrough() ;
  Glib::PropertyProxy_ReadOnly<bool> property_strikethrough() const;
  Glib::PropertyProxy<int> property_right_margin() ;
  Glib::PropertyProxy_ReadOnly<int> property_right_margin() const;
  Glib::PropertyProxy<Pango::Underline> property_underline() ;
  Glib::PropertyProxy_ReadOnly<Pango::Underline> property_underline() const;
  Glib::PropertyProxy<int> property_rise() ;
  Glib::PropertyProxy_ReadOnly<int> property_rise() const;
  Glib::PropertyProxy<bool> property_background_full_height() ;
  Glib::PropertyProxy_ReadOnly<bool> property_background_full_height() const;
  Glib::PropertyProxy<Glib::ustring> property_language() ;
  Glib::PropertyProxy_ReadOnly<Glib::ustring> property_language() const;
  Glib::PropertyProxy<Pango::TabArray> property_tabs() ;
  Glib::PropertyProxy_ReadOnly<Pango::TabArray> property_tabs() const;
  Glib::PropertyProxy<bool> property_invisible() ;
  Glib::PropertyProxy_ReadOnly<bool> property_invisible() const;
  Glib::PropertyProxy_WriteOnly<Glib::ustring> property_paragraph_background() ;
  Glib::PropertyProxy<Gdk::Color> property_paragraph_background_gdk() ;
  Glib::PropertyProxy_ReadOnly<Gdk::Color> property_paragraph_background_gdk() const;
  Glib::PropertyProxy<bool> property_accumulative_margin() ;
  Glib::PropertyProxy_ReadOnly<bool> property_accumulative_margin() const;
  Glib::PropertyProxy<bool> property_background_set() ;
  Glib::PropertyProxy_ReadOnly<bool> property_background_set() const;
  Glib::PropertyProxy<bool> property_foreground_set() ;
  Glib::PropertyProxy_ReadOnly<bool> property_foreground_set() const;
  Glib::PropertyProxy<bool> property_background_stipple_set() ;
  Glib::PropertyProxy_ReadOnly<bool> property_background_stipple_set() const;
  Glib::PropertyProxy<bool> property_foreground_stipple_set() ;
  Glib::PropertyProxy_ReadOnly<bool> property_foreground_stipple_set() const;
  Glib::PropertyProxy<bool> property_family_set() ;
  Glib::PropertyProxy_ReadOnly<bool> property_family_set() const;
  Glib::PropertyProxy<bool> property_style_set() ;
  Glib::PropertyProxy_ReadOnly<bool> property_style_set() const;
  Glib::PropertyProxy<bool> property_variant_set() ;
  Glib::PropertyProxy_ReadOnly<bool> property_variant_set() const;
  Glib::PropertyProxy<bool> property_weight_set() ;
  Glib::PropertyProxy_ReadOnly<bool> property_weight_set() const;
  Glib::PropertyProxy<bool> property_stretch_set() ;
  Glib::PropertyProxy_ReadOnly<bool> property_stretch_set() const;
  Glib::PropertyProxy<bool> property_size_set() ;
  Glib::PropertyProxy_ReadOnly<bool> property_size_set() const;
  Glib::PropertyProxy<bool> property_scale_set() ;
  Glib::PropertyProxy_ReadOnly<bool> property_scale_set() const;
  Glib::PropertyProxy<bool> property_pixels_above_lines_set() ;
  Glib::PropertyProxy_ReadOnly<bool> property_pixels_above_lines_set() const;
  Glib::PropertyProxy<bool> property_pixels_below_lines_set() ;
  Glib::PropertyProxy_ReadOnly<bool> property_pixels_below_lines_set() const;
  Glib::PropertyProxy<bool> property_pixels_inside_wrap_set() ;
  Glib::PropertyProxy_ReadOnly<bool> property_pixels_inside_wrap_set() const;
  Glib::PropertyProxy<bool> property_editable_set() ;
  Glib::PropertyProxy_ReadOnly<bool> property_editable_set() const;
  Glib::PropertyProxy<bool> property_wrap_mode_set() ;
  Glib::PropertyProxy_ReadOnly<bool> property_wrap_mode_set() const;
  Glib::PropertyProxy<bool> property_justification_set() ;
  Glib::PropertyProxy_ReadOnly<bool> property_justification_set() const;
  Glib::PropertyProxy<bool> property_left_margin_set() ;
  Glib::PropertyProxy_ReadOnly<bool> property_left_margin_set() const;
  Glib::PropertyProxy<bool> property_indent_set() ;
  Glib::PropertyProxy_ReadOnly<bool> property_indent_set() const;
  Glib::PropertyProxy<bool> property_strikethrough_set() ;
  Glib::PropertyProxy_ReadOnly<bool> property_strikethrough_set() const;
  Glib::PropertyProxy<bool> property_right_margin_set() ;
  Glib::PropertyProxy_ReadOnly<bool> property_right_margin_set() const;
  Glib::PropertyProxy<bool> property_underline_set() ;
  Glib::PropertyProxy_ReadOnly<bool> property_underline_set() const;
  Glib::PropertyProxy<bool> property_rise_set() ;
  Glib::PropertyProxy_ReadOnly<bool> property_rise_set() const;
  Glib::PropertyProxy<bool> property_background_full_height_set() ;
  Glib::PropertyProxy_ReadOnly<bool> property_background_full_height_set() const;
  Glib::PropertyProxy<bool> property_language_set() ;
  Glib::PropertyProxy_ReadOnly<bool> property_language_set() const;
  Glib::PropertyProxy<bool> property_tabs_set() ;
  Glib::PropertyProxy_ReadOnly<bool> property_tabs_set() const;
  Glib::PropertyProxy<bool> property_invisible_set() ;
  Glib::PropertyProxy_ReadOnly<bool> property_invisible_set() const;
  Glib::PropertyProxy<bool> property_paragraph_background_set() ;
  Glib::PropertyProxy_ReadOnly<bool> property_paragraph_background_set() const;
public:
public:
protected:
  virtual bool on_event(const Glib::RefPtr<Glib::Object>& event_object, GdkEvent* event, const TextIter& iter);
};
}
namespace Glib
{
  Glib::RefPtr<Gtk::TextTag> wrap(GtkTextTag* object, bool take_copy = false);
}
typedef struct _GtkTextTagTable GtkTextTagTable;
typedef struct _GtkTextTagTableClass GtkTextTagTableClass;
namespace Gtk
{ class TextTagTable_Class; }
namespace Gtk
{
class TextTag;
class TextTagTable : public Glib::Object
{
public:
  typedef TextTagTable CppObjectType;
  typedef TextTagTable_Class CppClassType;
  typedef GtkTextTagTable BaseObjectType;
  typedef GtkTextTagTableClass BaseClassType;
private: friend class TextTagTable_Class;
  static CppClassType texttagtable_class_;
private:
  TextTagTable(const TextTagTable&);
  TextTagTable& operator=(const TextTagTable&);
protected:
  explicit TextTagTable(const Glib::ConstructParams& construct_params);
  explicit TextTagTable(GtkTextTagTable* castitem);
public:
  virtual ~TextTagTable();
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkTextTagTable* gobj() { return reinterpret_cast<GtkTextTagTable*>(gobject_); }
  const GtkTextTagTable* gobj() const { return reinterpret_cast<GtkTextTagTable*>(gobject_); }
  GtkTextTagTable* gobj_copy();
private:
protected:
  TextTagTable();
public:
  static Glib::RefPtr<TextTagTable> create();
  void add(const Glib::RefPtr<TextTag>& tag);
  void remove(const Glib::RefPtr<TextTag>& tag);
  Glib::RefPtr<TextTag> lookup(const Glib::ustring& name);
  Glib::RefPtr<const TextTag> lookup(const Glib::ustring& name) const;
  typedef sigc::slot<void, const Glib::RefPtr<TextTag>&> SlotForEach;
  void foreach(const SlotForEach& slot);
  int get_size() const;
  Glib::SignalProxy2< void,const Glib::RefPtr<TextTag>&,bool > signal_tag_changed();
  Glib::SignalProxy1< void,const Glib::RefPtr<TextTag>& > signal_tag_added();
  Glib::SignalProxy1< void,const Glib::RefPtr<TextTag>& > signal_tag_removed();
public:
public:
protected:
  virtual void on_tag_changed(const Glib::RefPtr<TextTag>& tag, bool size_changed);
  virtual void on_tag_added(const Glib::RefPtr<TextTag>& tag);
  virtual void on_tag_removed(const Glib::RefPtr<TextTag>& tag);
};
}
namespace Glib
{
  Glib::RefPtr<Gtk::TextTagTable> wrap(GtkTextTagTable* object, bool take_copy = false);
}
typedef struct _GtkTextChildAnchor GtkTextChildAnchor;
typedef struct _GtkTextChildAnchorClass GtkTextChildAnchorClass;
namespace Gtk
{ class TextChildAnchor_Class; }
namespace Gtk
{
class TextChildAnchor : public Glib::Object
{
public:
  typedef TextChildAnchor CppObjectType;
  typedef TextChildAnchor_Class CppClassType;
  typedef GtkTextChildAnchor BaseObjectType;
  typedef GtkTextChildAnchorClass BaseClassType;
private: friend class TextChildAnchor_Class;
  static CppClassType textchildanchor_class_;
private:
  TextChildAnchor(const TextChildAnchor&);
  TextChildAnchor& operator=(const TextChildAnchor&);
protected:
  explicit TextChildAnchor(const Glib::ConstructParams& construct_params);
  explicit TextChildAnchor(GtkTextChildAnchor* castitem);
public:
  virtual ~TextChildAnchor();
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkTextChildAnchor* gobj() { return reinterpret_cast<GtkTextChildAnchor*>(gobject_); }
  const GtkTextChildAnchor* gobj() const { return reinterpret_cast<GtkTextChildAnchor*>(gobject_); }
  GtkTextChildAnchor* gobj_copy();
private:
protected:
  TextChildAnchor();
public:
  static Glib::RefPtr<TextChildAnchor> create();
  Glib::ListHandle<Widget*> get_widgets();
  Glib::ListHandle<const Widget*> get_widgets() const;
  bool get_deleted() const;
public:
public:
protected:
};
}
namespace Glib
{
  Glib::RefPtr<Gtk::TextChildAnchor> wrap(GtkTextChildAnchor* object, bool take_copy = false);
}
typedef struct _GtkTextMark GtkTextMark;
typedef struct _GtkTextMarkClass GtkTextMarkClass;
namespace Gtk
{ class TextMark_Class; }
namespace Gtk
{
class TextBuffer;
class TextIter;
class TextMark : public Glib::Object
{
public:
  typedef TextMark CppObjectType;
  typedef TextMark_Class CppClassType;
  typedef GtkTextMark BaseObjectType;
  typedef GtkTextMarkClass BaseClassType;
private: friend class TextMark_Class;
  static CppClassType textmark_class_;
private:
  TextMark(const TextMark&);
  TextMark& operator=(const TextMark&);
protected:
  explicit TextMark(const Glib::ConstructParams& construct_params);
  explicit TextMark(GtkTextMark* castitem);
public:
  virtual ~TextMark();
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkTextMark* gobj() { return reinterpret_cast<GtkTextMark*>(gobject_); }
  const GtkTextMark* gobj() const { return reinterpret_cast<GtkTextMark*>(gobject_); }
  GtkTextMark* gobj_copy();
private:
protected:
  explicit TextMark(bool left_gravity = true);
  explicit TextMark(const Glib::ustring& name, bool left_gravity = true);
public:
  static Glib::RefPtr<TextMark> create(bool left_gravity = true);
  static Glib::RefPtr<TextMark> create(const Glib::ustring& name, bool left_gravity = true);
  void set_visible(bool setting = true);
  bool get_visible() const;
  Glib::ustring get_name() const;
  bool get_deleted() const;
  Glib::RefPtr<TextBuffer> get_buffer();
  Glib::RefPtr<const TextBuffer> get_buffer() const;
  bool get_left_gravity() const;
  TextIter get_iter();
public:
public:
protected:
};
}
namespace Glib
{
  Glib::RefPtr<Gtk::TextMark> wrap(GtkTextMark* object, bool take_copy = false);
}
extern "C" { typedef struct _GtkTextAttributes GtkTextAttributes; }
namespace Gtk
{
class TextAttributes
{
  public:
  typedef TextAttributes CppObjectType;
  typedef GtkTextAttributes BaseObjectType;
  static GType get_type() __attribute__((__const__));
  TextAttributes();
  explicit TextAttributes(GtkTextAttributes* gobject, bool make_a_copy = true);
  TextAttributes(const TextAttributes& other);
  TextAttributes& operator=(const TextAttributes& other);
  ~TextAttributes();
  void swap(TextAttributes& other);
  GtkTextAttributes* gobj() { return gobject_; }
  const GtkTextAttributes* gobj() const { return gobject_; }
  GtkTextAttributes* gobj_copy() const;
protected:
  GtkTextAttributes* gobject_;
private:
public:
};
}
namespace Gtk
{
inline void swap(TextAttributes& lhs, TextAttributes& rhs)
  { lhs.swap(rhs); }
}
namespace Glib
{
Gtk::TextAttributes wrap(GtkTextAttributes* object, bool take_copy = false);
template <>
class Value<Gtk::TextAttributes> : public Glib::Value_Boxed<Gtk::TextAttributes>
{};
}
namespace Gtk
{
enum TextSearchFlags
{
  TEXT_SEARCH_VISIBLE_ONLY = 1 << 0,
  TEXT_SEARCH_TEXT_ONLY = 1 << 1
};
inline TextSearchFlags operator|(TextSearchFlags lhs, TextSearchFlags rhs)
  { return static_cast<TextSearchFlags>(static_cast<unsigned>(lhs) | static_cast<unsigned>(rhs)); }
inline TextSearchFlags operator&(TextSearchFlags lhs, TextSearchFlags rhs)
  { return static_cast<TextSearchFlags>(static_cast<unsigned>(lhs) & static_cast<unsigned>(rhs)); }
inline TextSearchFlags operator^(TextSearchFlags lhs, TextSearchFlags rhs)
  { return static_cast<TextSearchFlags>(static_cast<unsigned>(lhs) ^ static_cast<unsigned>(rhs)); }
inline TextSearchFlags operator~(TextSearchFlags flags)
  { return static_cast<TextSearchFlags>(~static_cast<unsigned>(flags)); }
inline TextSearchFlags& operator|=(TextSearchFlags& lhs, TextSearchFlags rhs)
  { return (lhs = static_cast<TextSearchFlags>(static_cast<unsigned>(lhs) | static_cast<unsigned>(rhs))); }
inline TextSearchFlags& operator&=(TextSearchFlags& lhs, TextSearchFlags rhs)
  { return (lhs = static_cast<TextSearchFlags>(static_cast<unsigned>(lhs) & static_cast<unsigned>(rhs))); }
inline TextSearchFlags& operator^=(TextSearchFlags& lhs, TextSearchFlags rhs)
  { return (lhs = static_cast<TextSearchFlags>(static_cast<unsigned>(lhs) ^ static_cast<unsigned>(rhs))); }
}
namespace Glib
{
template <>
class Value<Gtk::TextSearchFlags> : public Glib::Value_Flags<Gtk::TextSearchFlags>
{
public:
  static GType value_type() __attribute__((__const__));
};
}
namespace Gtk
{
class TextBuffer;
class TextMark;
class TextIter
{
  public:
  typedef TextIter CppObjectType;
  typedef GtkTextIter BaseObjectType;
  static GType get_type() __attribute__((__const__));
  TextIter();
  explicit TextIter(const GtkTextIter* gobject);
  GtkTextIter* gobj() { return &gobject_; }
  const GtkTextIter* gobj() const { return &gobject_; }
protected:
  GtkTextIter gobject_;
private:
public:
  typedef std::bidirectional_iterator_tag iterator_category;
  typedef gunichar value_type;
  typedef int difference_type;
  typedef value_type reference;
  typedef void pointer;
  inline TextIter& operator++();
  inline const TextIter operator++(int);
  inline TextIter& operator--();
  inline const TextIter operator--(int);
  inline value_type operator*() const;
  inline operator bool() const;
protected:
  template <class Predicate>
  struct PredicateAdapter
  {
    Predicate predicate_;
    inline PredicateAdapter(const Predicate& predicate);
    static gboolean gtk_callback(gunichar uc, void* user_data);
  };
  bool forward_find_char_impl(GtkTextCharPredicate predicate,
                                           void* user_data,
                                           const GtkTextIter* limit);
  bool backward_find_char_impl(GtkTextCharPredicate predicate,
                                            void* user_data,
                                            const GtkTextIter* limit);
public:
  Glib::RefPtr<TextBuffer> get_buffer() const;
  int get_offset() const;
  int get_line() const;
  int get_line_offset() const;
  int get_line_index() const;
  int get_visible_line_offset() const;
  int get_visible_line_index() const;
  gunichar get_char() const;
  Glib::ustring get_slice(const TextIter& end) const;
  Glib::ustring get_text(const TextIter& end) const;
  Glib::ustring get_visible_slice(const TextIter& end) const;
  Glib::ustring get_visible_text(const TextIter& end) const;
  Glib::RefPtr<Gdk::Pixbuf> get_pixbuf() const;
  Glib::SListHandle< Glib::RefPtr<TextMark> > get_marks();
  Glib::SListHandle< Glib::RefPtr<const TextMark> > get_marks() const;
  Glib::RefPtr<TextChildAnchor> get_child_anchor();
  Glib::RefPtr<const TextChildAnchor> get_child_anchor() const;
  Glib::SListHandle< Glib::RefPtr<TextTag> > get_toggled_tags(bool toggled_on = true);
  Glib::SListHandle< Glib::RefPtr<const TextTag> > get_toggled_tags(bool toggled_on = true) const;
  bool begins_tag(const Glib::RefPtr<const TextTag>& tag) const;
  bool begins_tag() const;
  bool ends_tag(const Glib::RefPtr<const TextTag>& tag) const;
  bool ends_tag() const;
  bool toggles_tag(const Glib::RefPtr<const TextTag>& tag) const;
  bool toggles_tag() const;
  bool has_tag(const Glib::RefPtr<const TextTag>& tag) const;
  bool has_tag() const;
  Glib::SListHandle< Glib::RefPtr<TextTag> > get_tags();
  Glib::SListHandle< Glib::RefPtr<const TextTag> > get_tags() const;
  bool editable(bool default_setting = true) const;
  bool can_insert(bool default_editability = true) const;
  bool starts_word() const;
  bool ends_word() const;
  bool inside_word() const;
  bool starts_sentence() const;
  bool ends_sentence() const;
  bool inside_sentence() const;
  bool starts_line() const;
  bool ends_line() const;
  bool is_cursor_position() const;
  int get_chars_in_line() const;
  int get_bytes_in_line() const;
  bool get_attributes(TextAttributes& values) const;
  Pango::Language get_language() const;
  bool is_end() const;
  bool is_start() const;
  bool forward_char();
  bool backward_char();
  bool forward_chars(int count);
  bool backward_chars(int count);
  bool forward_line();
  bool backward_line();
  bool forward_lines(int count);
  bool backward_lines(int count);
  bool forward_word_end();
  bool backward_word_start();
  bool forward_word_ends(int count);
  bool backward_word_starts(int count);
  bool forward_visible_line();
  bool backward_visible_line();
  bool forward_visible_line(int count);
  bool backward_visible_lines(int count);
  bool forward_visible_word_end();
  bool backward_visible_word_start();
  bool forward_visible_word_ends(int count);
  bool backward_visible_word_starts(int count);
  bool forward_sentence_end();
  bool backward_sentence_start();
  bool forward_sentence_ends(int count);
  bool backward_sentence_starts(int count);
  bool forward_cursor_position();
  bool backward_cursor_position();
  bool forward_cursor_positions(int count);
  bool backward_cursor_positions(int count);
  bool forward_visible_cursor_position();
  bool backward_visible_cursor_position();
  bool forward_visible_cursor_positions(int count);
  bool backward_visible_cursor_positions(int count);
  void set_offset(int char_offset);
  void set_line(int line_number);
  void set_line_offset(int char_on_line);
  void set_line_index(int byte_on_line);
  void forward_to_end();
  bool forward_to_line_end();
  void set_visible_line_offset(int char_on_line);
  void set_visible_line_index(int byte_on_line);
  bool forward_to_tag_toggle(const Glib::RefPtr<TextTag>& tag);
  bool backward_to_tag_toggle(const Glib::RefPtr<TextTag>& tag);
  template <class Predicate> bool forward_find_char(const Predicate& predicate, const TextIter& limit);
  template <class Predicate> bool forward_find_char(const Predicate& predicate);
  template <class Predicate> bool backward_find_char(const Predicate& predicate, const TextIter& limit);
  template <class Predicate> bool backward_find_char(const Predicate& predicate);
  bool forward_search(const Glib::ustring& str,
                                   TextSearchFlags flags,
                                   TextIter& match_start,
                                   TextIter& match_end,
                                   const TextIter& limit) const;
   bool forward_search(const Glib::ustring& str, TextSearchFlags flags, TextIter& match_start, TextIter& match_end) const;
  bool backward_search(const Glib::ustring& str,
                                    TextSearchFlags flags,
                                    TextIter& match_start,
                                    TextIter& match_end,
                                    const TextIter& limit) const;
  bool backward_search(const Glib::ustring& str, TextSearchFlags flags, TextIter& match_start, TextIter& match_end) const;
  int compare(const TextIter& rhs) const;
  bool in_range(const TextIter& start, const TextIter& end) const;
  void order(TextIter& second);
};
template <class Predicate> inline
TextIter::PredicateAdapter<Predicate>::PredicateAdapter(const Predicate& predicate)
:
  predicate_ (predicate)
{}
template <class Predicate>
gboolean TextIter::PredicateAdapter<Predicate>::gtk_callback(gunichar uc, void* user_data)
{
  try
  {
    return (static_cast<TextIter::PredicateAdapter<Predicate>*>(user_data)->predicate_(uc)) ? 1 : 0;
  }
  catch(...)
  {
    Glib::exception_handlers_invoke();
    return 0;
  }
}
inline
TextIter& TextIter::operator++()
{
  forward_char();
  return *this;
}
inline
const TextIter TextIter::operator++(int)
{
  const TextIter temp (*this);
  forward_char();
  return temp;
}
inline
TextIter& TextIter::operator--()
{
  backward_char();
  return *this;
}
inline
const TextIter TextIter::operator--(int)
{
  const TextIter temp (*this);
  backward_char();
  return temp;
}
inline
TextIter::value_type TextIter::operator*() const
{
  return get_char();
}
inline
TextIter::operator bool() const
{
  return !is_end();
}
template <class Predicate>
bool TextIter::forward_find_char(const Predicate& predicate, const TextIter& limit)
{
  typedef TextIter::PredicateAdapter<Predicate> PredAdapter;
  PredAdapter adapter (predicate);
  return this->forward_find_char_impl(&PredAdapter::gtk_callback, &adapter, limit.gobj());
}
template <class Predicate>
bool TextIter::forward_find_char(const Predicate& predicate)
{
  typedef TextIter::PredicateAdapter<Predicate> PredAdapter;
  PredAdapter adapter (predicate);
  return this->forward_find_char_impl(&PredAdapter::gtk_callback, &adapter, 0);
}
template <class Predicate>
bool TextIter::backward_find_char(const Predicate& predicate, const TextIter& limit)
{
  typedef TextIter::PredicateAdapter<Predicate> PredAdapter;
  PredAdapter adapter (predicate);
  return this->backward_find_char_impl(&PredAdapter::gtk_callback, &adapter, limit.gobj());
}
template <class Predicate>
bool TextIter::backward_find_char(const Predicate& predicate)
{
  typedef TextIter::PredicateAdapter<Predicate> PredAdapter;
  PredAdapter adapter (predicate);
  return this->backward_find_char_impl(&PredAdapter::gtk_callback, &adapter, 0);
}
}
namespace Gtk
{
bool operator==(const TextIter& lhs, const TextIter& rhs);
bool operator!=(const TextIter& lhs, const TextIter& rhs);
bool operator<(const TextIter& lhs, const TextIter& rhs);
bool operator>(const TextIter& lhs, const TextIter& rhs);
bool operator<=(const TextIter& lhs, const TextIter& rhs);
bool operator>=(const TextIter& lhs, const TextIter& rhs);
}
namespace Glib
{
Gtk::TextIter& wrap(GtkTextIter* object);
const Gtk::TextIter& wrap(const GtkTextIter* object);
template <>
class Value<Gtk::TextIter> : public Glib::Value_Boxed<Gtk::TextIter>
{};
}
typedef struct _GtkTextBuffer GtkTextBuffer;
typedef struct _GtkTextBufferClass GtkTextBufferClass;
namespace Gtk
{ class TextBuffer_Class; }
namespace Gtk
{
class TextMark;
class TextIter;
class TextBuffer : public Glib::Object
{
public:
  typedef TextBuffer CppObjectType;
  typedef TextBuffer_Class CppClassType;
  typedef GtkTextBuffer BaseObjectType;
  typedef GtkTextBufferClass BaseClassType;
private: friend class TextBuffer_Class;
  static CppClassType textbuffer_class_;
private:
  TextBuffer(const TextBuffer&);
  TextBuffer& operator=(const TextBuffer&);
protected:
  explicit TextBuffer(const Glib::ConstructParams& construct_params);
  explicit TextBuffer(GtkTextBuffer* castitem);
public:
  virtual ~TextBuffer();
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkTextBuffer* gobj() { return reinterpret_cast<GtkTextBuffer*>(gobject_); }
  const GtkTextBuffer* gobj() const { return reinterpret_cast<GtkTextBuffer*>(gobject_); }
  GtkTextBuffer* gobj_copy();
private:
public:
  typedef TextIter iterator;
  typedef TextTag Tag;
  typedef TextTagTable TagTable;
  typedef TextMark Mark;
  typedef TextChildAnchor ChildAnchor;
protected:
  TextBuffer();
  explicit TextBuffer(const Glib::RefPtr<TagTable>& tag_table);
public:
  static Glib::RefPtr<TextBuffer> create();
  static Glib::RefPtr<TextBuffer> create(const Glib::RefPtr<TagTable>& tag_table);
  int get_line_count() const;
  int get_char_count() const;
  int size() const;
  Glib::RefPtr<TextBuffer::TagTable> get_tag_table();
  Glib::RefPtr<const TextBuffer::TagTable> get_tag_table() const;
  void set_text(const Glib::ustring& text);
  void set_text(const char* text_begin, const char* text_end);
  void assign(const Glib::ustring& text);
  void assign(const char* text_begin, const char* text_end);
  iterator insert(const iterator& pos, const Glib::ustring& text);
  iterator insert(const iterator& pos, const char* text_begin, const char* text_end);
  void insert_at_cursor(const Glib::ustring& text);
  void insert_at_cursor(const char* text_begin, const char* text_end);
  std::pair<iterator,bool> insert_interactive(
      const iterator& pos, const Glib::ustring& text, bool default_editable = true);
  std::pair<iterator,bool> insert_interactive(
      const iterator& pos, const char* text_begin, const char* text_end, bool default_editable = true);
  bool insert_interactive_at_cursor(const Glib::ustring& text, bool default_editable = true);
  bool insert_interactive_at_cursor(const char* text_begin, const char* text_end,
                                    bool default_editable = true);
  iterator insert(const iterator& pos, const iterator& range_begin, const iterator& range_end);
  std::pair<iterator,bool> insert_interactive(const iterator& pos, const iterator& range_begin, const iterator& range_end, bool default_editable = true);
  iterator insert_with_tag(const iterator& pos, const Glib::ustring& text, const Glib::RefPtr<Tag>& tag);
  iterator insert_with_tag(const iterator& pos, const char* text_begin, const char* text_end, const Glib::RefPtr<Tag>& tag);
  iterator insert_with_tag(const iterator& pos, const Glib::ustring& text, const Glib::ustring& tag_name);
  iterator insert_with_tag(const iterator& pos, const char* text_begin, const char* text_end, const Glib::ustring& tag_name);
  iterator insert_with_tags(const iterator& pos, const Glib::ustring& text,
                            const Glib::ArrayHandle< Glib::RefPtr<Tag> >& tags);
  iterator insert_with_tags(const iterator& pos, const char* text_begin, const char* text_end,
                            const Glib::ArrayHandle< Glib::RefPtr<Tag> >& tags);
  iterator insert_with_tags_by_name(const iterator& pos, const Glib::ustring& text,
                                    const Glib::StringArrayHandle& tag_names);
  iterator insert_with_tags_by_name(const iterator& pos, const char* text_begin, const char* text_end,
                                    const Glib::StringArrayHandle& tag_names);
  iterator erase(const iterator& range_begin, const iterator& range_end);
  std::pair<iterator,bool> erase_interactive(const iterator& range_begin, const iterator& range_end, bool default_editable = true);
  iterator backspace(const iterator& iter, bool interactive = true, bool default_editable = true);
  Glib::ustring get_text(const iterator& start, const iterator& end, bool include_hidden_chars = true);
  Glib::ustring get_text(const iterator& start, const iterator& end, bool include_hidden_chars = true) const;
  Glib::ustring get_text(bool include_hidden_chars = true);
  Glib::ustring get_text(bool include_hidden_chars = true) const;
  Glib::ustring get_slice(const iterator& start, const iterator& end, bool include_hidden_chars = true);
  Glib::ustring get_slice(const iterator& start, const iterator& end, bool include_hidden_chars = true) const;
  iterator insert_pixbuf(const iterator& pos, const Glib::RefPtr<Gdk::Pixbuf>& pixbuf);
  iterator insert_child_anchor(const iterator& pos, const Glib::RefPtr<ChildAnchor>& anchor);
  Glib::RefPtr<ChildAnchor> create_child_anchor(const iterator& pos);
  void add_mark(const Glib::RefPtr<TextBuffer::Mark>& mark, const iterator& where);
  Glib::RefPtr<TextBuffer::Mark> create_mark(const Glib::ustring& mark_name, const iterator& where, bool left_gravity = true);
  Glib::RefPtr<Mark> create_mark(const iterator& where, bool left_gravity = true);
  void move_mark(const Glib::RefPtr<Mark>& mark, const iterator& where);
  void delete_mark(const Glib::RefPtr<Mark>& mark);
  Glib::RefPtr<TextBuffer::Mark> get_mark(const Glib::ustring& name);
  Glib::RefPtr<const TextBuffer::Mark> get_mark(const Glib::ustring& name) const;
  void move_mark_by_name(const Glib::ustring& name, const iterator& where);
  void delete_mark_by_name(const Glib::ustring& name);
  Glib::RefPtr<TextBuffer::Mark> get_insert();
  Glib::RefPtr<TextBuffer::Mark> get_selection_bound();
  void place_cursor(const iterator& where);
  void apply_tag(const Glib::RefPtr<Tag>& tag, const iterator& start, const iterator& end);
  void remove_tag(const Glib::RefPtr<Tag>& tag, const iterator& start, const iterator& end);
  void apply_tag_by_name(const Glib::ustring& name, const iterator& start, const iterator& end);
  void remove_tag_by_name(const Glib::ustring& name, const iterator& start, const iterator& end);
  void remove_all_tags(const iterator& start, const iterator& end);
  Glib::RefPtr<Tag> create_tag(const Glib::ustring& tag_name);
  Glib::RefPtr<Tag> create_tag();
  iterator get_iter_at_line_offset(int line_number, int char_offset);
  iterator get_iter_at_line_index(int line_number, int byte_index);
  iterator get_iter_at_offset(int char_offset);
  iterator get_iter_at_line(int line_number);
  iterator begin();
  iterator end();
  void get_bounds(iterator& range_begin, iterator& range_end);
  iterator get_iter_at_mark(const Glib::RefPtr<Mark>& mark);
  iterator get_iter_at_child_anchor(const Glib::RefPtr<ChildAnchor>& anchor);
  bool get_modified() const;
  void set_modified(bool setting = true);
  bool get_has_selection() const;
  void add_selection_clipboard(const Glib::RefPtr<Clipboard>& clipboard);
  void remove_selection_clipboard(const Glib::RefPtr<Clipboard>& clipboard);
  void cut_clipboard(const Glib::RefPtr<Clipboard>& clipboard, bool default_editable = true);
  void copy_clipboard(const Glib::RefPtr<Clipboard>& clipboard);
  void paste_clipboard(const Glib::RefPtr<Clipboard>& clipboard, const iterator& override_location, bool default_editable = true);
  void paste_clipboard(const Glib::RefPtr<Clipboard>& clipboard, bool default_editable = true);
  bool get_selection_bounds(iterator& start, iterator& end) const;
  bool erase_selection(bool interactive = true, bool default_editable = true);
  void select_range(const iterator& ins, const iterator& bound);
  void begin_user_action();
  void end_user_action();
  Glib::ustring register_serialize_tagset(const Glib::ustring& tagset_name);
  Glib::ustring register_deserialize_tagset(const Glib::ustring& tagset_name);
  void unregister_serialize_format(const Glib::ustring& format);
  void unregister_deserialize_format(const Glib::ustring& format);
  void set_can_create_tags(const Glib::ustring& format, bool can_create_tags = true);
  bool get_can_create_tags(const Glib::ustring& format) const;
  Glib::StringArrayHandle get_serialize_formats() const;
  Glib::StringArrayHandle get_deserialize_formats() const;
  Glib::SignalProxy3< void,const TextBuffer::iterator&,const Glib::ustring&,int > signal_insert();
  Glib::SignalProxy2< void,const TextBuffer::iterator&,const Glib::RefPtr<Gdk::Pixbuf>& > signal_insert_pixbuf();
  Glib::SignalProxy2< void,const TextBuffer::iterator&,const Glib::RefPtr<ChildAnchor>& > signal_insert_child_anchor();
  Glib::SignalProxy2< void,const TextBuffer::iterator&,const TextBuffer::iterator& > signal_erase();
  Glib::SignalProxy0< void > signal_changed();
  Glib::SignalProxy0< void > signal_modified_changed();
  Glib::SignalProxy2< void,const TextBuffer::iterator&,const Glib::RefPtr<TextBuffer::Mark>& > signal_mark_set();
  Glib::SignalProxy1< void,const Glib::RefPtr<TextBuffer::Mark>& > signal_mark_deleted();
  Glib::SignalProxy3< void,const Glib::RefPtr<TextBuffer::Tag>&,const TextBuffer::iterator&,const TextBuffer::iterator& > signal_apply_tag();
  Glib::SignalProxy3< void,const Glib::RefPtr<TextBuffer::Tag>&,const TextBuffer::iterator&,const TextBuffer::iterator& > signal_remove_tag();
  Glib::SignalProxy0< void > signal_begin_user_action();
  Glib::SignalProxy0< void > signal_end_user_action();
  Glib::PropertyProxy<Glib::ustring> property_text() ;
  Glib::PropertyProxy_ReadOnly<Glib::ustring> property_text() const;
  Glib::PropertyProxy_ReadOnly<bool> property_has_selection() const;
  Glib::PropertyProxy_ReadOnly<int> property_cursor_position() const;
public:
public:
protected:
  virtual void on_insert(const TextBuffer::iterator& pos, const Glib::ustring& text, int bytes);
  virtual void on_insert_pixbuf(const TextBuffer::iterator& pos, const Glib::RefPtr<Gdk::Pixbuf>& pixbuf);
  virtual void on_insert_child_anchor(const TextBuffer::iterator& pos, const Glib::RefPtr<ChildAnchor>& anchor);
  virtual void on_erase(const TextBuffer::iterator& start, const TextBuffer::iterator& end);
  virtual void on_changed();
  virtual void on_modified_changed();
  virtual void on_mark_set(const TextBuffer::iterator& location, const Glib::RefPtr<TextBuffer::Mark>& mark);
  virtual void on_mark_deleted(const Glib::RefPtr<TextBuffer::Mark>& mark);
  virtual void on_apply_tag(const Glib::RefPtr<TextBuffer::Tag>& tag, const TextBuffer::iterator& range_begin, const TextBuffer::iterator& range_end);
  virtual void on_remove_tag(const Glib::RefPtr<TextBuffer::Tag>& tag, const TextBuffer::iterator& range_begin, const TextBuffer::iterator& range_end);
  virtual void on_begin_user_action();
  virtual void on_end_user_action();
};
}
namespace Glib
{
  Glib::RefPtr<Gtk::TextBuffer> wrap(GtkTextBuffer* object, bool take_copy = false);
}
typedef struct _GtkTextView GtkTextView;
typedef struct _GtkTextViewClass GtkTextViewClass;
namespace Gtk
{ class TextView_Class; }
namespace Gtk
{
enum TextWindowType
{
  TEXT_WINDOW_PRIVATE,
  TEXT_WINDOW_WIDGET,
  TEXT_WINDOW_TEXT,
  TEXT_WINDOW_LEFT,
  TEXT_WINDOW_RIGHT,
  TEXT_WINDOW_TOP,
  TEXT_WINDOW_BOTTOM
};
}
namespace Glib
{
template <>
class Value<Gtk::TextWindowType> : public Glib::Value_Enum<Gtk::TextWindowType>
{
public:
  static GType value_type() __attribute__((__const__));
};
}
namespace Gtk
{
class TextView : public Container
{
  public:
  typedef TextView CppObjectType;
  typedef TextView_Class CppClassType;
  typedef GtkTextView BaseObjectType;
  typedef GtkTextViewClass BaseClassType;
  virtual ~TextView();
private:
  friend class TextView_Class;
  static CppClassType textview_class_;
  TextView(const TextView&);
  TextView& operator=(const TextView&);
protected:
  explicit TextView(const Glib::ConstructParams& construct_params);
  explicit TextView(GtkTextView* castitem);
public:
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkTextView* gobj() { return reinterpret_cast<GtkTextView*>(gobject_); }
  const GtkTextView* gobj() const { return reinterpret_cast<GtkTextView*>(gobject_); }
public:
protected:
  virtual void on_set_scroll_adjustments(Adjustment* hadjustment, Adjustment* vadjustment);
  virtual void on_populate_popup(Menu* menu);
  virtual void on_set_anchor();
  virtual void on_insert_at_cursor(const Glib::ustring& str);
private:
public:
  TextView();
  explicit TextView(const Glib::RefPtr<TextBuffer>& buffer);
  void set_buffer(const Glib::RefPtr<TextBuffer>& buffer);
  Glib::RefPtr<TextBuffer> get_buffer();
  Glib::RefPtr<const TextBuffer> get_buffer() const;
  bool scroll_to_iter(TextBuffer::iterator& iter, double within_margin);
  void scroll_to_mark(const Glib::RefPtr<TextBuffer::Mark>& mark, double within_margin);
  void scroll_mark_onscreen(const Glib::RefPtr<TextBuffer::Mark>& mark);
  bool scroll_to(TextBuffer::iterator& iter, double within_margin = 0);
  bool scroll_to(TextBuffer::iterator& iter, double within_margin, double xalign, double yalign);
  void scroll_to(const Glib::RefPtr<TextBuffer::Mark>& mark, double within_margin = 0);
  void scroll_to(const Glib::RefPtr<TextBuffer::Mark>& mark, double within_margin, double xalign, double yalign);
  bool move_mark_onscreen(const Glib::RefPtr<TextBuffer::Mark>& mark);
  bool place_cursor_onscreen();
  void get_visible_rect(Gdk::Rectangle& visible_rect) const;
  void set_cursor_visible(bool setting = true);
  bool get_cursor_visible() const;
  void get_iter_location(const TextBuffer::iterator& iter, Gdk::Rectangle& location) const;
  void get_iter_at_location(TextBuffer::iterator& iter, int x, int y) const;
  void get_iter_at_position(TextBuffer::iterator& iter, int& trailing, int x, int y) const;
  void get_line_yrange(const TextBuffer::iterator& iter, int& y, int& height) const;
  void get_line_at_y(TextBuffer::iterator& target_iter, int y, int& line_top) const;
  void buffer_to_window_coords(TextWindowType win,
                                            int buffer_x, int buffer_y,
                                            int& window_x, int& window_y) const;
  void window_to_buffer_coords(TextWindowType win,
                                            int window_x, int window_y,
                                            int& buffer_x, int& buffer_y) const;
  Glib::RefPtr<Gdk::Window> get_window(TextWindowType win);
  Glib::RefPtr<const Gdk::Window> get_window(TextWindowType win) const;
  TextWindowType get_window_type(const Glib::RefPtr<Gdk::Window>& window);
  void set_border_window_size(TextWindowType type, int size);
  int get_border_window_size(TextWindowType type) const;
  bool forward_display_line(TextBuffer::iterator& iter);
  bool backward_display_line(TextBuffer::iterator& iter);
  bool forward_display_line_end(TextBuffer::iterator& iter);
  bool backward_display_line_start(TextBuffer::iterator& iter);
  bool starts_display_line(const TextBuffer::iterator& iter);
  bool move_visually(TextBuffer::iterator& iter, int count);
  void add_child_at_anchor(Widget& child, const Glib::RefPtr<TextBuffer::ChildAnchor>& anchor);
  void add_child_in_window(Widget& child, TextWindowType which_window,
                                        int xpos, int ypos);
  void move_child(Widget& child, int xpos,int ypos);
  void set_wrap_mode(WrapMode wrap_mode);
  WrapMode get_wrap_mode() const;
  void set_editable(bool setting = true);
  bool get_editable() const;
  void set_pixels_above_lines(int pixels_above_lines);
  int get_pixels_above_lines() const;
  void set_pixels_below_lines(int pixels_below_lines);
  int get_pixels_below_lines() const;
  void set_pixels_inside_wrap(int pixels_inside_wrap);
  int get_pixels_inside_wrap() const;
  void set_justification(Justification justification);
  Justification get_justification() const;
  void set_left_margin(int left_margin);
  int get_left_margin() const;
  void set_right_margin(int right_margin);
  int get_right_margin() const;
  void set_indent(int indent);
  int get_indent() const;
  void set_tabs(Pango::TabArray& tabs);
  Pango::TabArray get_tabs() const;
  TextAttributes get_default_attributes() const;
  void set_overwrite(bool overwrite = true);
  bool get_overwrite() const;
  void set_accepts_tab(bool accepts_tab = true);
  bool get_accepts_tab() const;
  Glib::SignalProxy2< void,Adjustment*,Adjustment* > signal_set_scroll_adjustments();
  Glib::SignalProxy1< void,Menu* > signal_populate_popup();
  Glib::SignalProxy0< void > signal_set_anchor();
  Glib::SignalProxy1< void,const Glib::ustring& > signal_insert_at_cursor();
  Glib::PropertyProxy<int> property_pixels_above_lines() ;
  Glib::PropertyProxy_ReadOnly<int> property_pixels_above_lines() const;
  Glib::PropertyProxy<int> property_pixels_below_lines() ;
  Glib::PropertyProxy_ReadOnly<int> property_pixels_below_lines() const;
  Glib::PropertyProxy<int> property_pixels_inside_wrap() ;
  Glib::PropertyProxy_ReadOnly<int> property_pixels_inside_wrap() const;
  Glib::PropertyProxy<bool> property_editable() ;
  Glib::PropertyProxy_ReadOnly<bool> property_editable() const;
  Glib::PropertyProxy<WrapMode> property_wrap_mode() ;
  Glib::PropertyProxy_ReadOnly<WrapMode> property_wrap_mode() const;
  Glib::PropertyProxy<Justification> property_justification() ;
  Glib::PropertyProxy_ReadOnly<Justification> property_justification() const;
  Glib::PropertyProxy<int> property_left_margin() ;
  Glib::PropertyProxy_ReadOnly<int> property_left_margin() const;
  Glib::PropertyProxy<int> property_right_margin() ;
  Glib::PropertyProxy_ReadOnly<int> property_right_margin() const;
  Glib::PropertyProxy<int> property_indent() ;
  Glib::PropertyProxy_ReadOnly<int> property_indent() const;
  Glib::PropertyProxy<Pango::TabArray> property_tabs() ;
  Glib::PropertyProxy_ReadOnly<Pango::TabArray> property_tabs() const;
  Glib::PropertyProxy<bool> property_cursor_visible() ;
  Glib::PropertyProxy_ReadOnly<bool> property_cursor_visible() const;
  Glib::PropertyProxy< Glib::RefPtr<TextBuffer> > property_buffer() ;
  Glib::PropertyProxy_ReadOnly< Glib::RefPtr<TextBuffer> > property_buffer() const;
  Glib::PropertyProxy<bool> property_overwrite() ;
  Glib::PropertyProxy_ReadOnly<bool> property_overwrite() const;
  Glib::PropertyProxy<bool> property_accepts_tab() ;
  Glib::PropertyProxy_ReadOnly<bool> property_accepts_tab() const;
};
}
namespace Glib
{
  Gtk::TextView* wrap(GtkTextView* object, bool take_copy = false);
}
typedef struct _GtkMenuToolButton GtkMenuToolButton;
typedef struct _GtkMenuToolButtonClass GtkMenuToolButtonClass;
namespace Gtk
{ class MenuToolButton_Class; }
namespace Gtk
{
class MenuToolButton : public ToolButton
{
  public:
  typedef MenuToolButton CppObjectType;
  typedef MenuToolButton_Class CppClassType;
  typedef GtkMenuToolButton BaseObjectType;
  typedef GtkMenuToolButtonClass BaseClassType;
  virtual ~MenuToolButton();
private:
  friend class MenuToolButton_Class;
  static CppClassType menutoolbutton_class_;
  MenuToolButton(const MenuToolButton&);
  MenuToolButton& operator=(const MenuToolButton&);
protected:
  explicit MenuToolButton(const Glib::ConstructParams& construct_params);
  explicit MenuToolButton(GtkMenuToolButton* castitem);
public:
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkMenuToolButton* gobj() { return reinterpret_cast<GtkMenuToolButton*>(gobject_); }
  const GtkMenuToolButton* gobj() const { return reinterpret_cast<GtkMenuToolButton*>(gobject_); }
public:
protected:
  virtual void on_show_menu();
private:
public:
  MenuToolButton();
  explicit MenuToolButton(const Gtk::StockID& stock_id);
  explicit MenuToolButton(const Glib::ustring& label);
  explicit MenuToolButton(Widget& icon_widget, const Glib::ustring& label = Glib::ustring());
  void set_menu(Menu& menu);
  Menu* get_menu();
  const Menu* get_menu() const;
  void set_arrow_tooltip(Tooltips& tooltips, const Glib::ustring& tip_text, const Glib::ustring& tip_private);
  void set_arrow_tooltip_text(const Glib::ustring& text);
  void set_arrow_tooltip_markup(const Glib::ustring& markup);
  Glib::SignalProxy0< void > signal_show_menu();
  Glib::PropertyProxy<Menu*> property_menu() ;
  Glib::PropertyProxy_ReadOnly<Menu*> property_menu() const;
};
}
namespace Glib
{
  Gtk::MenuToolButton* wrap(GtkMenuToolButton* object, bool take_copy = false);
}
typedef struct _GtkTreeModelFilter GtkTreeModelFilter;
typedef struct _GtkTreeModelFilterClass GtkTreeModelFilterClass;
namespace Gtk
{ class TreeModelFilter_Class; }
namespace Gtk
{
class TreeModelFilter :
  public Glib::Object,
  public TreeModel
{
public:
  typedef TreeModelFilter CppObjectType;
  typedef TreeModelFilter_Class CppClassType;
  typedef GtkTreeModelFilter BaseObjectType;
  typedef GtkTreeModelFilterClass BaseClassType;
private: friend class TreeModelFilter_Class;
  static CppClassType treemodelfilter_class_;
private:
  TreeModelFilter(const TreeModelFilter&);
  TreeModelFilter& operator=(const TreeModelFilter&);
protected:
  explicit TreeModelFilter(const Glib::ConstructParams& construct_params);
  explicit TreeModelFilter(GtkTreeModelFilter* castitem);
public:
  virtual ~TreeModelFilter();
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkTreeModelFilter* gobj() { return reinterpret_cast<GtkTreeModelFilter*>(gobject_); }
  const GtkTreeModelFilter* gobj() const { return reinterpret_cast<GtkTreeModelFilter*>(gobject_); }
  GtkTreeModelFilter* gobj_copy();
private:
protected:
  explicit TreeModelFilter(const Glib::RefPtr<TreeModel>& child_model);
  explicit TreeModelFilter(const Glib::RefPtr<TreeModel>& child_model, const TreeModel::Path& virtual_root);
public:
  static Glib::RefPtr<TreeModelFilter> create(const Glib::RefPtr<TreeModel>& child_model);
  static Glib::RefPtr<TreeModelFilter> create(const Glib::RefPtr<TreeModel>& child_model, const TreeModel::Path& virtual_root);
  typedef sigc::slot<bool, const TreeModel::const_iterator&> SlotVisible;
  void set_visible_func(const SlotVisible& slot);
  typedef sigc::slot<void, const Gtk::TreeModel::iterator& , Glib::ValueBase& , int > SlotModify;
  void set_modify_func(const TreeModelColumnRecord& columns, const SlotModify& slot);
  void set_visible_column(const TreeModelColumnBase& column);
  void set_visible_column(int column);
  Glib::RefPtr<TreeModel> get_model();
  Glib::RefPtr<const TreeModel> get_model() const;
  iterator convert_child_iter_to_iter(const iterator& child_iter) const;
  iterator convert_iter_to_child_iter(const iterator& filter_iter) const;
  Path convert_child_path_to_path(const Path& child_path);
  Path convert_path_to_child_path(const Path& filter_path);
  Path convert_child_path_to_path(const Path& child_path) const;
  Path convert_path_to_child_path(const Path& filter_path) const;
  void refilter();
  void clear_cache();
protected:
  virtual void set_value_impl(const iterator& row, int column, const Glib::ValueBase& value);
public:
public:
protected:
};
}
namespace Glib
{
  Glib::RefPtr<Gtk::TreeModelFilter> wrap(GtkTreeModelFilter* object, bool take_copy = false);
}
typedef struct _GtkTreeModelSort GtkTreeModelSort;
typedef struct _GtkTreeModelSortClass GtkTreeModelSortClass;
namespace Gtk
{ class TreeModelSort_Class; }
namespace Gtk
{
class TreeModelSort : public Glib::Object, public TreeModel, public TreeSortable
{
public:
  typedef TreeModelSort CppObjectType;
  typedef TreeModelSort_Class CppClassType;
  typedef GtkTreeModelSort BaseObjectType;
  typedef GtkTreeModelSortClass BaseClassType;
private: friend class TreeModelSort_Class;
  static CppClassType treemodelsort_class_;
private:
  TreeModelSort(const TreeModelSort&);
  TreeModelSort& operator=(const TreeModelSort&);
protected:
  explicit TreeModelSort(const Glib::ConstructParams& construct_params);
  explicit TreeModelSort(GtkTreeModelSort* castitem);
public:
  virtual ~TreeModelSort();
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkTreeModelSort* gobj() { return reinterpret_cast<GtkTreeModelSort*>(gobject_); }
  const GtkTreeModelSort* gobj() const { return reinterpret_cast<GtkTreeModelSort*>(gobject_); }
  GtkTreeModelSort* gobj_copy();
private:
protected:
  explicit TreeModelSort(const Glib::RefPtr<TreeModel>& model);
public:
  static Glib::RefPtr<TreeModelSort> create(const Glib::RefPtr<TreeModel>& model);
  Glib::RefPtr<TreeModel> get_model();
  Glib::RefPtr<const TreeModel> get_model() const;
  Path convert_child_path_to_path(const Path& child_path) const;
  iterator convert_child_iter_to_iter(const iterator& child_iter) const;
  Path convert_path_to_child_path(const Path& sorted_path) const;
  iterator convert_iter_to_child_iter(const iterator& sorted_iter) const;
  void reset_default_sort_func();
  void clear_cache();
  bool iter_is_valid(const iterator& iter) const;
protected:
  virtual void set_value_impl(const iterator& row, int column, const Glib::ValueBase& value);
public:
public:
protected:
};
}
namespace Glib
{
  Glib::RefPtr<Gtk::TreeModelSort> wrap(GtkTreeModelSort* object, bool take_copy = false);
}
extern "C" { typedef struct _GtkTreeRowReference GtkTreeRowReference; }
namespace Gtk
{
class TreeRowReference
{
  public:
  typedef TreeRowReference CppObjectType;
  typedef GtkTreeRowReference BaseObjectType;
  static GType get_type() __attribute__((__const__));
  TreeRowReference();
  explicit TreeRowReference(GtkTreeRowReference* gobject, bool make_a_copy = true);
  TreeRowReference(const TreeRowReference& other);
  TreeRowReference& operator=(const TreeRowReference& other);
  ~TreeRowReference();
  void swap(TreeRowReference& other);
  GtkTreeRowReference* gobj() { return gobject_; }
  const GtkTreeRowReference* gobj() const { return gobject_; }
  GtkTreeRowReference* gobj_copy() const;
protected:
  GtkTreeRowReference* gobject_;
private:
public:
  TreeRowReference(const Glib::RefPtr<TreeModel>& model, const TreeModel::Path& path);
  operator bool() const;
  TreeModel::Path get_path() const;
  Glib::RefPtr<TreeModel> get_model();
  Glib::RefPtr<const TreeModel> get_model() const;
  bool is_valid() const;
};
}
namespace Gtk
{
inline void swap(TreeRowReference& lhs, TreeRowReference& rhs)
  { lhs.swap(rhs); }
}
namespace Glib
{
Gtk::TreeRowReference wrap(GtkTreeRowReference* object, bool take_copy = false);
template <>
class Value<Gtk::TreeRowReference> : public Glib::Value_Boxed<Gtk::TreeRowReference>
{};
}
typedef struct _GtkTreeStore GtkTreeStore;
typedef struct _GtkTreeStoreClass GtkTreeStoreClass;
namespace Gtk
{ class TreeStore_Class; }
namespace Gtk
{
class TreeStore :
  public Glib::Object,
  public Gtk::TreeModel,
  public TreeSortable,
  public TreeDragSource,
  public TreeDragDest
{
public:
  typedef TreeStore CppObjectType;
  typedef TreeStore_Class CppClassType;
  typedef GtkTreeStore BaseObjectType;
  typedef GtkTreeStoreClass BaseClassType;
private: friend class TreeStore_Class;
  static CppClassType treestore_class_;
private:
  TreeStore(const TreeStore&);
  TreeStore& operator=(const TreeStore&);
protected:
  explicit TreeStore(const Glib::ConstructParams& construct_params);
  explicit TreeStore(GtkTreeStore* castitem);
public:
  virtual ~TreeStore();
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkTreeStore* gobj() { return reinterpret_cast<GtkTreeStore*>(gobject_); }
  const GtkTreeStore* gobj() const { return reinterpret_cast<GtkTreeStore*>(gobject_); }
  GtkTreeStore* gobj_copy();
private:
protected:
  TreeStore();
  explicit TreeStore(const TreeModelColumnRecord& columns);
public:
  static Glib::RefPtr<TreeStore> create(const TreeModelColumnRecord& columns);
  void set_column_types(const TreeModelColumnRecord& columns);
  iterator erase(const iterator& iter);
  iterator insert(const iterator& iter);
  iterator insert_after(const iterator& iter);
  iterator prepend();
  iterator prepend(const TreeNodeChildren& node);
  iterator append();
  iterator append(const TreeNodeChildren& node);
  void iter_swap(const iterator& a, const iterator& b);
  void move(const iterator& source, const iterator& destination);
  void reorder(const TreeNodeChildren& node, const Glib::ArrayHandle<int>& new_order);
  void clear();
  bool is_ancestor(const iterator& iter, const iterator& descendant) const;
  int iter_depth(const iterator& iter) const;
  bool iter_is_valid(const iterator& iter) const;
protected:
  virtual void set_value_impl(const iterator& row, int column, const Glib::ValueBase& value);
public:
public:
protected:
};
}
namespace Glib
{
  Glib::RefPtr<Gtk::TreeStore> wrap(GtkTreeStore* object, bool take_copy = false);
}
typedef struct _GtkActionGroup GtkActionGroup;
typedef struct _GtkActionGroupClass GtkActionGroupClass;
namespace Gtk
{ class ActionGroup_Class; }
namespace Gtk
{
class ActionGroup : public Glib::Object
{
public:
  typedef ActionGroup CppObjectType;
  typedef ActionGroup_Class CppClassType;
  typedef GtkActionGroup BaseObjectType;
  typedef GtkActionGroupClass BaseClassType;
private: friend class ActionGroup_Class;
  static CppClassType actiongroup_class_;
private:
  ActionGroup(const ActionGroup&);
  ActionGroup& operator=(const ActionGroup&);
protected:
  explicit ActionGroup(const Glib::ConstructParams& construct_params);
  explicit ActionGroup(GtkActionGroup* castitem);
public:
  virtual ~ActionGroup();
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkActionGroup* gobj() { return reinterpret_cast<GtkActionGroup*>(gobject_); }
  const GtkActionGroup* gobj() const { return reinterpret_cast<GtkActionGroup*>(gobject_); }
  GtkActionGroup* gobj_copy();
private:
protected:
  explicit ActionGroup(const Glib::ustring& name = Glib::ustring());
public:
  static Glib::RefPtr<ActionGroup> create(const Glib::ustring& name = Glib::ustring());
  Glib::ustring get_name() const;
  bool get_sensitive() const;
  void set_sensitive(bool sensitive = true);
  bool get_visible() const;
  void set_visible(bool visible = true);
  Glib::RefPtr<Action> get_action(const Glib::ustring& action_name);
  Glib::RefPtr<const Action> get_action(const Glib::ustring& action_name) const;
  Glib::ListHandle< Glib::RefPtr<Action> > get_actions();
  Glib::ListHandle< Glib::RefPtr<const Action> > get_actions() const;
  void add(const Glib::RefPtr<Action>& action);
  void add(const Glib::RefPtr<Action>& action, const AccelKey& accel_key);
  void add(const Glib::RefPtr<Action>& action, const Action::SlotActivate& slot);
  void add(const Glib::RefPtr<Action>& action, const AccelKey& accel_key, const Action::SlotActivate& slot);
  void remove(const Glib::RefPtr<Action>& action);
  Glib::ustring translate_string(const Glib::ustring& str) const;
  Glib::SignalProxy2< void,const Glib::RefPtr<Action>&,Widget* > signal_connect_proxy();
  Glib::SignalProxy2< void,const Glib::RefPtr<Action>&,Widget* > signal_disconnect_proxy();
  Glib::SignalProxy1< void,const Glib::RefPtr<Action>& > signal_pre_activate();
  Glib::SignalProxy1< void,const Glib::RefPtr<Action>& > signal_post_activate();
public:
public:
protected:
};
}
namespace Glib
{
  Glib::RefPtr<Gtk::ActionGroup> wrap(GtkActionGroup* object, bool take_copy = false);
}
typedef struct _GtkUIManager GtkUIManager;
typedef struct _GtkUIManagerClass GtkUIManagerClass;
namespace Gtk
{ class UIManager_Class; }
namespace Gtk
{
enum UIManagerItemType
{
  UI_MANAGER_AUTO = 0,
  UI_MANAGER_MENUBAR = 1 << 0,
  UI_MANAGER_MENU = 1 << 1,
  UI_MANAGER_TOOLBAR = 1 << 2,
  UI_MANAGER_PLACEHOLDER = 1 << 3,
  UI_MANAGER_POPUP = 1 << 4,
  UI_MANAGER_MENUITEM = 1 << 5,
  UI_MANAGER_TOOLITEM = 1 << 6,
  UI_MANAGER_SEPARATOR = 1 << 7,
  UI_MANAGER_ACCELERATOR = 1 << 8
};
inline UIManagerItemType operator|(UIManagerItemType lhs, UIManagerItemType rhs)
  { return static_cast<UIManagerItemType>(static_cast<unsigned>(lhs) | static_cast<unsigned>(rhs)); }
inline UIManagerItemType operator&(UIManagerItemType lhs, UIManagerItemType rhs)
  { return static_cast<UIManagerItemType>(static_cast<unsigned>(lhs) & static_cast<unsigned>(rhs)); }
inline UIManagerItemType operator^(UIManagerItemType lhs, UIManagerItemType rhs)
  { return static_cast<UIManagerItemType>(static_cast<unsigned>(lhs) ^ static_cast<unsigned>(rhs)); }
inline UIManagerItemType operator~(UIManagerItemType flags)
  { return static_cast<UIManagerItemType>(~static_cast<unsigned>(flags)); }
inline UIManagerItemType& operator|=(UIManagerItemType& lhs, UIManagerItemType rhs)
  { return (lhs = static_cast<UIManagerItemType>(static_cast<unsigned>(lhs) | static_cast<unsigned>(rhs))); }
inline UIManagerItemType& operator&=(UIManagerItemType& lhs, UIManagerItemType rhs)
  { return (lhs = static_cast<UIManagerItemType>(static_cast<unsigned>(lhs) & static_cast<unsigned>(rhs))); }
inline UIManagerItemType& operator^=(UIManagerItemType& lhs, UIManagerItemType rhs)
  { return (lhs = static_cast<UIManagerItemType>(static_cast<unsigned>(lhs) ^ static_cast<unsigned>(rhs))); }
}
namespace Glib
{
template <>
class Value<Gtk::UIManagerItemType> : public Glib::Value_Flags<Gtk::UIManagerItemType>
{
public:
  static GType value_type() __attribute__((__const__));
};
}
namespace Gtk
{
class UIManager : public Glib::Object
{
public:
  typedef UIManager CppObjectType;
  typedef UIManager_Class CppClassType;
  typedef GtkUIManager BaseObjectType;
  typedef GtkUIManagerClass BaseClassType;
private: friend class UIManager_Class;
  static CppClassType uimanager_class_;
private:
  UIManager(const UIManager&);
  UIManager& operator=(const UIManager&);
protected:
  explicit UIManager(const Glib::ConstructParams& construct_params);
  explicit UIManager(GtkUIManager* castitem);
public:
  virtual ~UIManager();
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkUIManager* gobj() { return reinterpret_cast<GtkUIManager*>(gobject_); }
  const GtkUIManager* gobj() const { return reinterpret_cast<GtkUIManager*>(gobject_); }
  GtkUIManager* gobj_copy();
private:
protected:
  UIManager();
public:
  static Glib::RefPtr<UIManager> create();
  void set_add_tearoffs(bool add_tearoffs = true);
  bool get_add_tearoffs() const;
  void insert_action_group(const Glib::RefPtr<ActionGroup>& action_group, int pos = 0);
  void remove_action_group(const Glib::RefPtr<ActionGroup>& action_group);
  Glib::ListHandle< Glib::RefPtr<ActionGroup> > get_action_groups();
  Glib::ListHandle< Glib::RefPtr<const ActionGroup> > get_action_groups() const;
  Glib::RefPtr<AccelGroup> get_accel_group();
  Glib::RefPtr<const AccelGroup> get_accel_group() const;
  Widget* get_widget(const Glib::ustring& path);
  const Widget* get_widget(const Glib::ustring& path) const;
  Glib::SListHandle<Widget*> get_toplevels(UIManagerItemType types);
  Glib::SListHandle<const Widget*> get_toplevels(UIManagerItemType types) const;
  Glib::RefPtr<Action> get_action(const Glib::ustring& path);
  Glib::RefPtr<const Action> get_action(const Glib::ustring& path) const;
  typedef guint ui_merge_id;
  ui_merge_id add_ui_from_string(const Glib::ustring& buffer);
  ui_merge_id add_ui_from_file(const Glib::ustring& filename);
  void add_ui(ui_merge_id merge_id, const Glib::ustring& path, const Glib::ustring& name, const Glib::ustring& action, UIManagerItemType type = Gtk::UI_MANAGER_AUTO, bool top = true);
  void add_ui_separator(ui_merge_id merge_id, const Glib::ustring& path, const Glib::ustring& name = "", UIManagerItemType type = Gtk::UI_MANAGER_AUTO, bool top = true);
  void remove_ui(ui_merge_id merge_id);
  Glib::ustring get_ui() const;
  void ensure_update();
  ui_merge_id new_merge_id();
  Glib::SignalProxy1< void,Widget* > signal_add_widget();
  Glib::SignalProxy0< void > signal_actions_changed();
  Glib::SignalProxy2< void,const Glib::RefPtr<Action>&,Widget* > signal_connect_proxy();
  Glib::SignalProxy2< void,const Glib::RefPtr<Action>&,Widget* > signal_disconnect_proxy();
  Glib::SignalProxy1< void,const Glib::RefPtr<Action>& > signal_pre_activate();
  Glib::SignalProxy1< void,const Glib::RefPtr<Action>& > signal_post_activate();
  Glib::PropertyProxy<bool> property_add_tearoffs() ;
  Glib::PropertyProxy_ReadOnly<bool> property_add_tearoffs() const;
  Glib::PropertyProxy_ReadOnly<Glib::ustring> property_ui() const;
public:
public:
protected:
  virtual void on_add_widget(Widget* widget);
  virtual void on_actions_changed();
};
}
namespace Glib
{
  Glib::RefPtr<Gtk::UIManager> wrap(GtkUIManager* object, bool take_copy = false);
}
typedef struct _GtkViewport GtkViewport;
typedef struct _GtkViewportClass GtkViewportClass;
namespace Gtk
{ class Viewport_Class; }
namespace Gtk {
class Adjustment;
class Viewport : public Bin
{
  public:
  typedef Viewport CppObjectType;
  typedef Viewport_Class CppClassType;
  typedef GtkViewport BaseObjectType;
  typedef GtkViewportClass BaseClassType;
  virtual ~Viewport();
private:
  friend class Viewport_Class;
  static CppClassType viewport_class_;
  Viewport(const Viewport&);
  Viewport& operator=(const Viewport&);
protected:
  explicit Viewport(const Glib::ConstructParams& construct_params);
  explicit Viewport(GtkViewport* castitem);
public:
  static GType get_type() __attribute__((__const__));
  static GType get_base_type() __attribute__((__const__));
  GtkViewport* gobj() { return reinterpret_cast<GtkViewport*>(gobject_); }
  const GtkViewport* gobj() const { return reinterpret_cast<GtkViewport*>(gobject_); }
public:
protected:
  virtual void on_set_scroll_adjustments(Gtk::Adjustment* hadjustment, Gtk::Adjustment* vadjustment);
private:
public:
  explicit Viewport(Adjustment& hadjustment, Adjustment& vadjustment);
  Gtk::Adjustment* get_hadjustment();
  const Gtk::Adjustment* get_hadjustment() const;
  Gtk::Adjustment* get_vadjustment();
  const Gtk::Adjustment* get_vadjustment() const;
  void set_hadjustment(Gtk::Adjustment* adjustment=0);
  void set_hadjustment(Gtk::Adjustment& adjustment);
  void set_vadjustment(Gtk::Adjustment* adjustment=0);
  void set_vadjustment(Gtk::Adjustment& adjustment);
  void set_shadow_type(ShadowType type);
  ShadowType get_shadow_type() const;
  Glib::SignalProxy2< void,Gtk::Adjustment*,Gtk::Adjustment* > signal_set_scroll_adjustments();
  Glib::PropertyProxy<Gtk::Adjustment*> property_hadjustment() ;
  Glib::PropertyProxy_ReadOnly<Gtk::Adjustment*> property_hadjustment() const;
  Glib::PropertyProxy<Gtk::Adjustment*> property_vadjustment() ;
  Glib::PropertyProxy_ReadOnly<Gtk::Adjustment*> property_vadjustment() const;
  Glib::PropertyProxy<ShadowType> property_shadow_type() ;
  Glib::PropertyProxy_ReadOnly<ShadowType> property_shadow_type() const;
};
}
namespace Glib
{
  Gtk::Viewport* wrap(GtkViewport* object, bool take_copy = false);
}
