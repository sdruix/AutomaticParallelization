/* This file has been generated by gen-symbols-attrs.py. */
/* Do not modify it or you'll get what you deserve */
#ifndef FORTRAN03_MODULES_BITS_H
#define FORTRAN03_MODULES_BITS_H

static const char * attr_field_names = "is_static, is_register, is_extern, is_mutable, is_export, is_inline, is_virtual, is_pure, is_builtin, is_deleted, is_defaulted, is_conversion, is_trivial, is_constructor, is_default_constructor, is_copy_constructor, is_move_constructor, is_conversor_constructor, is_copy_assignment_operator, is_move_assignment_operator, is_destructor, is_explicit, is_surrogate_function, is_anonymous, is_template_argument, is_user_declared, is_template_parameter, is_parameter, is_member, is_bitfield, is_unnamed_bitfield, any_exception, is_injected_class_name, is_nested_unnamed_struct, after_typedef, is_implicit_basic_type, is_allocatable, is_in_common, is_in_namelist, is_optional, is_target, is_value, is_elemental, is_recursive, is_result, is_stmt_function, is_dummy_arg_stmt_function, is_generic_spec, is_builtin_subroutine, is_module_procedure, is_from_module, bind_c, intent_kind, access, template_parameter_nesting, template_parameter_position, parameter_position, class_type, linkage_spec, bitfield_expr, field_offset, definition_tree";
static char * symbol_get_attribute_values(sqlite3* handle, scope_entry_t* sym)
{
    const char *format = "%d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %lld, %Q, %lld, %lld, %lld";

    insert_type(handle, sym->entity_specs.class_type);
    insert_ast(handle, sym->entity_specs.bitfield_expr);
    insert_ast(handle, sym->entity_specs.definition_tree);

    char * result = sqlite3_mprintf(format, sym->entity_specs.is_static, sym->entity_specs.is_register, sym->entity_specs.is_extern, sym->entity_specs.is_mutable, sym->entity_specs.is_export, sym->entity_specs.is_inline, sym->entity_specs.is_virtual, sym->entity_specs.is_pure, sym->entity_specs.is_builtin, sym->entity_specs.is_deleted, sym->entity_specs.is_defaulted, sym->entity_specs.is_conversion, sym->entity_specs.is_trivial, sym->entity_specs.is_constructor, sym->entity_specs.is_default_constructor, sym->entity_specs.is_copy_constructor, sym->entity_specs.is_move_constructor, sym->entity_specs.is_conversor_constructor, sym->entity_specs.is_copy_assignment_operator, sym->entity_specs.is_move_assignment_operator, sym->entity_specs.is_destructor, sym->entity_specs.is_explicit, sym->entity_specs.is_surrogate_function, sym->entity_specs.is_anonymous, sym->entity_specs.is_template_argument, sym->entity_specs.is_user_declared, sym->entity_specs.is_template_parameter, sym->entity_specs.is_parameter, sym->entity_specs.is_member, sym->entity_specs.is_bitfield, sym->entity_specs.is_unnamed_bitfield, sym->entity_specs.any_exception, sym->entity_specs.is_injected_class_name, sym->entity_specs.is_nested_unnamed_struct, sym->entity_specs.after_typedef, sym->entity_specs.is_implicit_basic_type, sym->entity_specs.is_allocatable, sym->entity_specs.is_in_common, sym->entity_specs.is_in_namelist, sym->entity_specs.is_optional, sym->entity_specs.is_target, sym->entity_specs.is_value, sym->entity_specs.is_elemental, sym->entity_specs.is_recursive, sym->entity_specs.is_result, sym->entity_specs.is_stmt_function, sym->entity_specs.is_dummy_arg_stmt_function, sym->entity_specs.is_generic_spec, sym->entity_specs.is_builtin_subroutine, sym->entity_specs.is_module_procedure, sym->entity_specs.is_from_module, sym->entity_specs.bind_c, sym->entity_specs.intent_kind, sym->entity_specs.access, sym->entity_specs.template_parameter_nesting, sym->entity_specs.template_parameter_position, sym->entity_specs.parameter_position, sym->entity_specs.class_type, sym->entity_specs.linkage_spec, sym->entity_specs.bitfield_expr, sym->entity_specs.field_offset, sym->entity_specs.definition_tree);
    return result;
}
static void insert_extended_attributes(sqlite3* handle, scope_entry_t* sym)
{
{ int i; for (i = 0; i < sym->entity_specs.num_related_symbols; i++) {
insert_extra_attr_symbol(handle, sym, "related_symbols", sym->entity_specs.related_symbols[i]);
} }
{ int i; for (i = 0; i < sym->entity_specs.num_exceptions; i++) {
insert_extra_attr_type(handle, sym, "exceptions", sym->entity_specs.exceptions[i]);
} }
{ int i; for (i = 0; i < sym->entity_specs.num_parameters; i++) {
insert_extra_attr_data(handle, sym, "default_argument_info", sym->entity_specs.default_argument_info[i], insert_default_argument_info_ptr);
} }
{ int i; for (i = 0; i < sym->entity_specs.num_gcc_attributes; i++) {
insert_extra_gcc_attr(handle, sym, "gcc_attributes", &(sym->entity_specs.gcc_attributes[i]));
} }
}

static void get_extra_attributes(sqlite3* handle, int ncols, char **values, char **names, sqlite3_int64 sym_oid, scope_entry_t* sym)
{
{
int i;
if (query_contains_field(ncols, names, "is_static", &i))
{
   sym->entity_specs.is_static = safe_atoll(values[i]);
}
}
{
int i;
if (query_contains_field(ncols, names, "is_register", &i))
{
   sym->entity_specs.is_register = safe_atoll(values[i]);
}
}
{
int i;
if (query_contains_field(ncols, names, "is_extern", &i))
{
   sym->entity_specs.is_extern = safe_atoll(values[i]);
}
}
{
int i;
if (query_contains_field(ncols, names, "is_mutable", &i))
{
   sym->entity_specs.is_mutable = safe_atoll(values[i]);
}
}
{
int i;
if (query_contains_field(ncols, names, "is_export", &i))
{
   sym->entity_specs.is_export = safe_atoll(values[i]);
}
}
{
int i;
if (query_contains_field(ncols, names, "is_inline", &i))
{
   sym->entity_specs.is_inline = safe_atoll(values[i]);
}
}
{
int i;
if (query_contains_field(ncols, names, "is_virtual", &i))
{
   sym->entity_specs.is_virtual = safe_atoll(values[i]);
}
}
{
int i;
if (query_contains_field(ncols, names, "is_pure", &i))
{
   sym->entity_specs.is_pure = safe_atoll(values[i]);
}
}
{
int i;
if (query_contains_field(ncols, names, "is_builtin", &i))
{
   sym->entity_specs.is_builtin = safe_atoll(values[i]);
}
}
{
int i;
if (query_contains_field(ncols, names, "is_deleted", &i))
{
   sym->entity_specs.is_deleted = safe_atoll(values[i]);
}
}
{
int i;
if (query_contains_field(ncols, names, "is_defaulted", &i))
{
   sym->entity_specs.is_defaulted = safe_atoll(values[i]);
}
}
{
int i;
if (query_contains_field(ncols, names, "is_conversion", &i))
{
   sym->entity_specs.is_conversion = safe_atoll(values[i]);
}
}
{
int i;
if (query_contains_field(ncols, names, "is_trivial", &i))
{
   sym->entity_specs.is_trivial = safe_atoll(values[i]);
}
}
{
int i;
if (query_contains_field(ncols, names, "is_constructor", &i))
{
   sym->entity_specs.is_constructor = safe_atoll(values[i]);
}
}
{
int i;
if (query_contains_field(ncols, names, "is_default_constructor", &i))
{
   sym->entity_specs.is_default_constructor = safe_atoll(values[i]);
}
}
{
int i;
if (query_contains_field(ncols, names, "is_copy_constructor", &i))
{
   sym->entity_specs.is_copy_constructor = safe_atoll(values[i]);
}
}
{
int i;
if (query_contains_field(ncols, names, "is_move_constructor", &i))
{
   sym->entity_specs.is_move_constructor = safe_atoll(values[i]);
}
}
{
int i;
if (query_contains_field(ncols, names, "is_conversor_constructor", &i))
{
   sym->entity_specs.is_conversor_constructor = safe_atoll(values[i]);
}
}
{
int i;
if (query_contains_field(ncols, names, "is_copy_assignment_operator", &i))
{
   sym->entity_specs.is_copy_assignment_operator = safe_atoll(values[i]);
}
}
{
int i;
if (query_contains_field(ncols, names, "is_move_assignment_operator", &i))
{
   sym->entity_specs.is_move_assignment_operator = safe_atoll(values[i]);
}
}
{
int i;
if (query_contains_field(ncols, names, "is_destructor", &i))
{
   sym->entity_specs.is_destructor = safe_atoll(values[i]);
}
}
{
int i;
if (query_contains_field(ncols, names, "is_explicit", &i))
{
   sym->entity_specs.is_explicit = safe_atoll(values[i]);
}
}
{
int i;
if (query_contains_field(ncols, names, "is_surrogate_function", &i))
{
   sym->entity_specs.is_surrogate_function = safe_atoll(values[i]);
}
}
{
int i;
if (query_contains_field(ncols, names, "is_anonymous", &i))
{
   sym->entity_specs.is_anonymous = safe_atoll(values[i]);
}
}
{
int i;
if (query_contains_field(ncols, names, "is_template_argument", &i))
{
   sym->entity_specs.is_template_argument = safe_atoll(values[i]);
}
}
{
int i;
if (query_contains_field(ncols, names, "is_user_declared", &i))
{
   sym->entity_specs.is_user_declared = safe_atoll(values[i]);
}
}
{
int i;
if (query_contains_field(ncols, names, "is_template_parameter", &i))
{
   sym->entity_specs.is_template_parameter = safe_atoll(values[i]);
}
}
{
int i;
if (query_contains_field(ncols, names, "is_parameter", &i))
{
   sym->entity_specs.is_parameter = safe_atoll(values[i]);
}
}
{
int i;
if (query_contains_field(ncols, names, "is_member", &i))
{
   sym->entity_specs.is_member = safe_atoll(values[i]);
}
}
{
int i;
if (query_contains_field(ncols, names, "is_bitfield", &i))
{
   sym->entity_specs.is_bitfield = safe_atoll(values[i]);
}
}
{
int i;
if (query_contains_field(ncols, names, "is_unnamed_bitfield", &i))
{
   sym->entity_specs.is_unnamed_bitfield = safe_atoll(values[i]);
}
}
{
int i;
if (query_contains_field(ncols, names, "any_exception", &i))
{
   sym->entity_specs.any_exception = safe_atoll(values[i]);
}
}
{
int i;
if (query_contains_field(ncols, names, "is_injected_class_name", &i))
{
   sym->entity_specs.is_injected_class_name = safe_atoll(values[i]);
}
}
{
int i;
if (query_contains_field(ncols, names, "is_nested_unnamed_struct", &i))
{
   sym->entity_specs.is_nested_unnamed_struct = safe_atoll(values[i]);
}
}
{
int i;
if (query_contains_field(ncols, names, "after_typedef", &i))
{
   sym->entity_specs.after_typedef = safe_atoll(values[i]);
}
}
{
int i;
if (query_contains_field(ncols, names, "is_implicit_basic_type", &i))
{
   sym->entity_specs.is_implicit_basic_type = safe_atoll(values[i]);
}
}
{
int i;
if (query_contains_field(ncols, names, "is_allocatable", &i))
{
   sym->entity_specs.is_allocatable = safe_atoll(values[i]);
}
}
{
int i;
if (query_contains_field(ncols, names, "is_in_common", &i))
{
   sym->entity_specs.is_in_common = safe_atoll(values[i]);
}
}
{
int i;
if (query_contains_field(ncols, names, "is_in_namelist", &i))
{
   sym->entity_specs.is_in_namelist = safe_atoll(values[i]);
}
}
{
int i;
if (query_contains_field(ncols, names, "is_optional", &i))
{
   sym->entity_specs.is_optional = safe_atoll(values[i]);
}
}
{
int i;
if (query_contains_field(ncols, names, "is_target", &i))
{
   sym->entity_specs.is_target = safe_atoll(values[i]);
}
}
{
int i;
if (query_contains_field(ncols, names, "is_value", &i))
{
   sym->entity_specs.is_value = safe_atoll(values[i]);
}
}
{
int i;
if (query_contains_field(ncols, names, "is_elemental", &i))
{
   sym->entity_specs.is_elemental = safe_atoll(values[i]);
}
}
{
int i;
if (query_contains_field(ncols, names, "is_recursive", &i))
{
   sym->entity_specs.is_recursive = safe_atoll(values[i]);
}
}
{
int i;
if (query_contains_field(ncols, names, "is_result", &i))
{
   sym->entity_specs.is_result = safe_atoll(values[i]);
}
}
{
int i;
if (query_contains_field(ncols, names, "is_stmt_function", &i))
{
   sym->entity_specs.is_stmt_function = safe_atoll(values[i]);
}
}
{
int i;
if (query_contains_field(ncols, names, "is_dummy_arg_stmt_function", &i))
{
   sym->entity_specs.is_dummy_arg_stmt_function = safe_atoll(values[i]);
}
}
{
int i;
if (query_contains_field(ncols, names, "is_generic_spec", &i))
{
   sym->entity_specs.is_generic_spec = safe_atoll(values[i]);
}
}
{
int i;
if (query_contains_field(ncols, names, "is_builtin_subroutine", &i))
{
   sym->entity_specs.is_builtin_subroutine = safe_atoll(values[i]);
}
}
{
int i;
if (query_contains_field(ncols, names, "is_module_procedure", &i))
{
   sym->entity_specs.is_module_procedure = safe_atoll(values[i]);
}
}
{
int i;
if (query_contains_field(ncols, names, "is_from_module", &i))
{
   sym->entity_specs.is_from_module = safe_atoll(values[i]);
}
}
{
int i;
if (query_contains_field(ncols, names, "bind_c", &i))
{
   sym->entity_specs.bind_c = safe_atoll(values[i]);
}
}
{
int i;
if (query_contains_field(ncols, names, "intent_kind", &i))
{
   sym->entity_specs.intent_kind = safe_atoll(values[i]);
}
}
{
int i;
if (query_contains_field(ncols, names, "in_common", &i))
{
   sym->entity_specs.in_common = load_symbol(handle, safe_atoll(values[i]));
}
}
{
int i;
if (query_contains_field(ncols, names, "namelist", &i))
{
   sym->entity_specs.namelist = load_symbol(handle, safe_atoll(values[i]));
}
}
{
{
extra_syms_t extra_syms;
memset(&extra_syms, 0, sizeof(extra_syms));
extra_syms.handle = handle;
get_extended_attribute(handle, sym_oid, "related_symbols", &extra_syms, get_extra_syms);
sym->entity_specs.num_related_symbols = extra_syms.num_syms;
sym->entity_specs.related_symbols = extra_syms.syms;
}
}
{
int i;
if (query_contains_field(ncols, names, "specific_intrinsic", &i))
{
   sym->entity_specs.specific_intrinsic = load_symbol(handle, safe_atoll(values[i]));
}
}
{
int i;
if (query_contains_field(ncols, names, "access", &i))
{
   sym->entity_specs.access = safe_atoll(values[i]);
}
}
{
int i;
if (query_contains_field(ncols, names, "template_parameter_nesting", &i))
{
   sym->entity_specs.template_parameter_nesting = safe_atoll(values[i]);
}
}
{
int i;
if (query_contains_field(ncols, names, "template_parameter_position", &i))
{
   sym->entity_specs.template_parameter_position = safe_atoll(values[i]);
}
}
{
int i;
if (query_contains_field(ncols, names, "parameter_position", &i))
{
   sym->entity_specs.parameter_position = safe_atoll(values[i]);
}
}
{
int i;
if (query_contains_field(ncols, names, "class_type", &i))
{
   sym->entity_specs.class_type = load_type(handle, safe_atoll(values[i]));
}
}
{
int i;
if (query_contains_field(ncols, names, "injected_class_referred_symbol", &i))
{
   sym->entity_specs.injected_class_referred_symbol = load_symbol(handle, safe_atoll(values[i]));
}
}
{
int i;
if (query_contains_field(ncols, names, "linkage_spec", &i))
{
   sym->entity_specs.linkage_spec = uniquestr(values[i]);
}
}
{
{
extra_types_t extra_types;
memset(&extra_types, 0, sizeof(extra_types));
extra_types.handle = handle;
get_extended_attribute(handle, sym_oid, "exceptions", &extra_types, get_extra_types);
sym->entity_specs.num_exceptions = extra_types.num_types;
sym->entity_specs.exceptions = extra_types.types;
}
}
{
{
extra_default_argument_info_t extra_default_argument_info;
memset(&extra_default_argument_info, 0, sizeof(extra_default_argument_info_t));
extra_default_argument_info.handle = handle;
get_extended_attribute(handle, sym_oid, "default_argument_info", &extra_default_argument_info,                     get_extra_default_argument_info);
}
}
{
int i;
if (query_contains_field(ncols, names, "bitfield_expr", &i))
{
   sym->entity_specs.bitfield_expr = load_ast(handle, safe_atoll(values[i]));
}
}
{
// Scope is not stored (yet)
sym->entity_specs.bitfield_expr_context = CURRENT_COMPILED_FILE->global_decl_context;
}
{
int i;
if (query_contains_field(ncols, names, "field_offset", &i))
{
   sym->entity_specs.field_offset = safe_atoll(values[i]);
}
}
{
{
extra_gcc_attrs_t extra_gcc_attrs;
memset(&extra_gcc_attrs, 0, sizeof(extra_gcc_attrs));
extra_gcc_attrs.handle = handle;
get_extended_attribute(handle, sym_oid, "gcc_attributes", &extra_gcc_attrs, get_extra_gcc_attrs);
}
}
{
int i;
if (query_contains_field(ncols, names, "definition_tree", &i))
{
   sym->entity_specs.definition_tree = load_ast(handle, safe_atoll(values[i]));
}
}
}
#endif // FORTRAN03_MODULES_BITS_H
